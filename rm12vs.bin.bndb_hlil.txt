/*
Type: Mapped
Platform: thumb2
Architecture: thumb2
Segments:
r-x  0x08020000-0x0803c665 
---  0x0803c670-0x0803c688 
rw-  0x20000000-0x20040000 
rw-  0x40000000-0x40200000 
Sections:
0x0803c670-0x0803c688  .synthetic_builtins  {External}
*/
08020000  int32_t Initial_SP = 0x20002df0
08020004  void* Reset_Handler_P = Reset_Handler
08020008                          13 a9 03 08 15 a9 03 08 17 a9 03 08 19 a9 03 08 1b a9 03 08 00 00 00 00          ........................
08020020  00 00 00 00 00 00 00 00 00 00 00 00 35 69 03 08 1d a9 03 08 00 00 00 00 dd 68 03 08 a7 25 03 08  ............5i...........h...%..
08020040  39 c1 03 08 75 a9 03 08 3d c1 03 08 41 c1 03 08 45 c1 03 08 49 c1 03 08 1f a9 03 08 4d c1 03 08  9...u...=...A...E...I.......M...
08020060  55 00 03 08 51 c1 03 08 55 c1 03 08 67 6e 02 08 59 c1 03 08 b1 ab 02 08 5d c1 03 08 a5 ab 02 08  U...Q...U...gn..Y.......].......
08020080  61 c1 03 08 65 c1 03 08 69 c1 03 08 6d c1 03 08 71 c1 03 08 75 c1 03 08 79 c1 03 08 7d c1 03 08  a...e...i...m...q...u...y...}...
080200a0  a7 39 03 08 21 a9 03 08 81 c1 03 08 85 c1 03 08 8b 38 03 08 1d 39 03 08 89 c1 03 08 8d c1 03 08  .9..!............8...9..........
080200c0  91 c1 03 08 95 c1 03 08 99 c1 03 08 9d c1 03 08 a1 c1 03 08 a5 c1 03 08 a9 c1 03 08 ad c1 03 08  ................................
080200e0  b1 c1 03 08 b5 c1 03 08 b9 c1 03 08 bd c1 03 08 c1 c1 03 08 c5 c1 03 08 c9 c1 03 08 cd c1 03 08  ................................
08020100  d1 c1 03 08 d5 c1 03 08 d9 c1 03 08 dd c1 03 08 e1 c1 03 08 e5 c1 03 08 e9 c1 03 08 ed c1 03 08  ................................
08020120  f1 c1 03 08 3d c3 02 08 8d c0 02 08 f5 c1 03 08 f9 c1 03 08 fd c1 03 08 01 c2 03 08 05 c2 03 08  ....=...........................
08020140  09 c2 03 08 0d c2 03 08 11 c2 03 08 53 a9 03 08 15 c2 03 08 19 c2 03 08 31 c3 02 08 49 c3 02 08  ............S...........1...I...
08020160  1d c2 03 08 21 c2 03 08 25 c2 03 08 29 c2 03 08 2d c2 03 08 31 c2 03 08 35 c2 03 08 00 00 00 00  ....!...%...)...-...1...5.......
08020180  39 c2 03 08 3d c2 03 08                                                                          9...=...
08020188    void memcpy_n(void* dst, void const* src, uint32_t n)
08020188  {
08020192      while (true)
08020192      {
08020192          uint32_t n_1 = n;
08020194          n = n_1 - 1;
08020194          
08020198          if (!n_1)
08020198              break;
08020198          
0802018c          *(uint8_t*)dst = *(uint8_t*)src;
0802018e          src += 1;
08020190          dst += 1;
08020192      }
08020188  }
0802019c    void memset_n(void* dst, uint8_t val, uint32_t n)
0802019c  {
080201a2      while (true)
080201a2      {
080201a2          uint32_t n_1 = n;
080201a4          n = n_1 - 1;
080201a4          
080201a8          if (!n_1)
080201a8              break;
080201a8          
0802019e          *(uint8_t*)dst = val;
080201a0          dst += 1;
080201a2      }
0802019c  }
080201ac    int32_t memcmp_n(void const* s1, void const* s2, uint32_t n)
080201ac  {
080201c4      uint32_t i;
080201c4      
080201c4      for (i = 0; !i; )
080201c4      {
080201b0          uint32_t n_1 = n;
080201b2          n = n_1 - 1;
080201b2          
080201b6          if (!n_1)
080201b6              break;
080201b6          
080201bc          i = (uint32_t)*(uint8_t*)s1 - (uint32_t)*(uint8_t*)s2;
080201be          s2 += 1;
080201c0          s1 += 1;
080201c4      }
080201c4      
080201ca      return i;
080201ac  }
080201cc    char* strchr_local(char const* s, int32_t c)
080201cc  {
080201d4      while ((uint32_t)*(uint8_t*)s)
080201d4      {
080201da          if ((uint32_t)*(uint8_t*)s == c)
080201da              break;
080201da          
080201ce          s = &s[1];
080201d4      }
080201d4      
080201de      return (uint32_t)*(uint8_t*)s;
080201cc  }
080201e0  // // FatFs internal: move the 1-sector window to 'sector', flushing if needed.
080201e0  
080201e0    int32_t ff_move_window(FatFs* fs, uint32_t sector)
080201e0  {
080201e0      int32_t r3;
080201e0      int32_t var_18 = r3;
080201e6      int32_t r6;
080201e6      (uint8_t)r6 = fs->win[0xc];
080201e6      *(uint8_t*)((char*)r6)[1] = fs->win[0xd];
080201e6      *(uint8_t*)((char*)r6)[2] = fs->win[0xe];
080201e6      *(uint8_t*)((char*)r6)[3] = fs->win[0xf];
080201e6      
080201ea      if (r6 != sector)
080201ea      {
080201f0          if ((uint32_t)fs->n_rootdir)
080201f0          {
08020202              if (disk_write(fs->pdrv, &fs->win[0x10], r6, 1))
08020204                  return 1;
08020204              
0802020a              fs->n_rootdir = 0;
0802020c              int32_t r0_4;
0802020c              (uint8_t)r0_4 = fs->win[0];
0802020c              *(uint8_t*)((char*)r0_4)[1] = fs->win[1];
0802020c              *(uint8_t*)((char*)r0_4)[2] = fs->win[2];
0802020c              *(uint8_t*)((char*)r0_4)[3] = fs->win[3];
0802020c              
08020214              if (r6 < fs->database + r0_4)
08020214              {
08020216                  uint8_t csize = fs->csize;
08020216                  
0802022e                  while (true)
0802022e                  {
0802022e                      uint32_t csize_1 = (uint32_t)csize;
0802022e                      
08020232                      if (csize_1 < 2)
08020232                          break;
08020232                      
0802021c                      r6 += fs->database;
08020228                      disk_write(fs->pdrv, &fs->win[0x10], r6, 1);
0802022c                      csize = (uint8_t)csize_1 - 1;
0802022e                  }
08020214              }
080201f0          }
080201f0          
08020236          if (sector)
08020236          {
08020248              if (disk_read(fs->pdrv, &fs->win[0x10], sector, 1))
0802024a                  return 1;
0802024a              
0802024e              fs->win[0xc] = (uint8_t)sector;
0802024e              fs->win[0xd] = *(uint8_t*)((char*)sector)[1];
0802024e              fs->win[0xe] = *(uint8_t*)((char*)sector)[2];
0802024e              fs->win[0xf] = *(uint8_t*)((char*)sector)[3];
08020236          }
080201ea      }
080201ea      
08020250      return 0;
080201e0  }
08020254  // // Flush filesystem state to the device (FSInfo + media sync). 
08020254  // // Returns 0 on success, 1 on error.
08020254  
08020254    uint32_t ff_sync(FatFs* fs)
08020254  {
08020254      int32_t r3;
08020254      int32_t var_10 = r3;
08020262      uint32_t r5_1 = (uint32_t)ff_move_window(fs, 0);
08020262      
08020266      if (!r5_1)
08020266      {
08020272          if ((uint32_t)fs->fs_type == 3 && (uint32_t)*(uint8_t*)((char*)fs->n_rootdir)[1])
08020272          {
08020276              fs->win[0xc] = 0;
08020276              fs->win[0xd] = 0;
08020276              fs->win[0xe] = 0;
08020276              fs->win[0xf] = 0;
08020282              memset_n(&fs->win[0x10], 0, 0x200);
08020288              *((char*)fs + 0x22e) = 0x55;
0802028e              *((char*)fs + 0x22f) = 0xaa;
08020294              __builtin_strncpy(&fs->win[0x10], "RRaA", 4);
080202ac              __builtin_strncpy(&fs->win[0x1f4], "rrAa", 4);
080202c4              fs->win[0x1f8] = (char)fs->fatbase;
080202ce              fs->win[0x1f9] = (char)((uint32_t)(uint16_t)fs->fatbase >> 8);
080202d6              fs->win[0x1fa] = (char)(fs->fatbase >> 0x10);
080202de              fs->win[0x1fb] = (char)(fs->fatbase >> 0x18);
080202e4              fs->win[0x1fc] = (char)fs->n_fatent;
080202ee              fs->win[0x1fd] = (char)((uint32_t)(uint16_t)fs->n_fatent >> 8);
080202f6              fs->win[0x1fe] = (char)(fs->n_fatent >> 0x10);
080202fe              fs->win[0x1ff] = (char)(fs->n_fatent >> 0x18);
0802030c              disk_write(fs->pdrv, &fs->win[0x10], fs->dirbase, 1);
08020312              *(uint8_t*)((char*)fs->n_rootdir)[1] = 0;
08020272          }
08020272          
08020320          if (disk_ioctl(fs->pdrv, 0, nullptr))
08020322              r5_1 = 1;
08020266      }
08020266      
08020328      return (uint32_t)(uint8_t)r5_1;
08020254  }
0802032a  // // Read FAT[clst] (next cluster in the chain).
0802032a  // // Returns 0xFFFFFFFF on I/O error; otherwise the raw entry value
0802032a  // // (masked to 12/16/28 bits depending on FAT type).
0802032a  
0802032a    uint32_t ff_get_fat(FatFs* fs, uint32_t clst)
0802032a  {
0802033a      if (clst < 2 || clst >= fs->winsect)
0802033c          return 1;
0802033c      
08020340      int32_t r8;
08020340      (uint8_t)r8 = fs->win[0];
08020340      *(uint8_t*)((char*)r8)[1] = fs->win[1];
08020340      *(uint8_t*)((char*)r8)[2] = fs->win[2];
08020340      *(uint8_t*)((char*)r8)[3] = fs->win[3];
08020344      uint32_t fs_type = (uint32_t)fs->fs_type;
08020344      
08020348      if (fs_type == 1)
08020348      {
08020356          uint32_t r7_2 = clst + (clst >> 1);
08020356          
08020366          if (!ff_move_window(fs, r8 + (r7_2 >> 9)))
08020366          {
08020376              uint32_t r6_1 = (uint32_t)fs->win[0x10 + (r7_2 << 0x17 >> 0x17)];
08020376              
08020388              if (!ff_move_window(fs, r8 + ((r7_2 + 1) >> 9)))
08020388              {
08020394                  int32_t r6_2 =
08020394                      r6_1 | (uint32_t)fs->win[0x10 + ((r7_2 + 1) << 0x17 >> 0x17)] << 8;
08020394                  
0802039a                  if (clst << 0x1f >= 0)
080203a2                      return r6_2 << 0x14 >> 0x14;
080203a2                  
0802039c                  return r6_2 >> 4;
08020388              }
08020366          }
08020348      }
08020348      else if (fs_type >= 1)
0802034a      {
0802034e          if (fs_type == 3)
0802034e          {
080203e0              if (!ff_move_window(fs, r8 + (clst >> 7)))
080203e0              {
0802040c                  uint32_t r0_31 = (uint32_t)fs->win[0x12 + (clst << 0x19 >> 0x17)] << 0x10
0802040c                      | (uint32_t)fs->win[0x13 + (clst << 0x19 >> 0x17)] << 0x18
0802040c                      | (uint32_t)fs->win[0x11 + (clst << 0x19 >> 0x17)] << 8;
0802041e                  return (r0_31 | (uint32_t)fs->win[0x10 + (clst << 0x19 >> 0x17)])
0802041e                      & 0xfffffff;
080203e0              }
0802034e          }
0802034e          else if (fs_type < 3 && !ff_move_window(fs, r8 + (clst >> 8)))
080203d0              return (uint32_t)fs->win[0x10 + (clst << 0x18 >> 0x17)] | (uint32_t)(
080203d0                  uint16_t)((uint32_t)fs->win[0x11 + (clst << 0x18 >> 0x17)] << 8);
0802034a      }
0802034a      
08020368      return 0xffffffff;
0802032a  }
08020424    uint32_t ff_put_fat(FatFs* fs, uint32_t clst, uint32_t val)
08020424  {
08020436      uint32_t r0_3;
08020436      
08020436      if (clst < 2 || clst >= fs->winsect)
08020438          r0_3 = 2;
08020436      else
08020436      {
0802043c          int32_t r7;
0802043c          (uint8_t)r7 = fs->win[0];
0802043c          *(uint8_t*)((char*)r7)[1] = fs->win[1];
0802043c          *(uint8_t*)((char*)r7)[2] = fs->win[2];
0802043c          *(uint8_t*)((char*)r7)[3] = fs->win[3];
0802043e          uint32_t fs_type = (uint32_t)fs->fs_type;
0802043e          
08020442          if (fs_type == 1)
08020442          {
08020450              uint32_t r8_2 = clst + (clst >> 1);
0802045e              r0_3 = (uint32_t)ff_move_window(fs, r7 + (r8_2 >> 9));
0802045e              
08020462              if (!r0_3)
08020462              {
08020472                  char r0_10;
08020472                  
08020472                  if (clst << 0x1f >= 0)
08020480                      r0_10 = (uint8_t)val;
08020472                  else
0802047a                      r0_10 =
0802047a                          (fs->win[0x10 + (r8_2 << 0x17 >> 0x17)] & 0xf) | (char)(val << 4);
0802047a                  
08020482                  fs->win[0x10 + (r8_2 << 0x17 >> 0x17)] = r0_10;
0802048a                  fs->n_rootdir = 1;
08020496                  r0_3 = (uint32_t)ff_move_window(fs, r7 + ((r8_2 + 1) >> 9));
08020496                  
0802049a                  if (!r0_3)
0802049a                  {
080204a8                      uint8_t r2_1;
080204a8                      
080204a8                      if (clst << 0x1f >= 0)
080204ba                          r2_1 = (fs->win[0x10 + ((r8_2 + 1) << 0x17 >> 0x17)] & 0xf0)
080204ba                              | ((char)(val >> 8) & 0xf);
080204a8                      else
080204aa                          r2_1 = (char)(val >> 4);
080204aa                      
080204bc                      fs->win[0x10 + ((r8_2 + 1) << 0x17 >> 0x17)] = r2_1;
0802049a                  }
08020462              }
08020442          }
08020442          else if (fs_type < 1)
0802053a              r0_3 = 2;
08020444          else if (fs_type == 3)
08020448          {
080204f8              r0_3 = (uint32_t)ff_move_window(fs, r7 + (clst >> 7));
080204f8              
080204fc              if (!r0_3)
080204fc              {
08020506                  fs->win[0x10 + (clst << 0x19 >> 0x17)] = (char)val;
08020518                  fs->win[0x11 + (clst << 0x19 >> 0x17)] =
08020518                      (char)((uint32_t)(uint16_t)val >> 8);
08020526                  fs->win[0x12 + (clst << 0x19 >> 0x17)] = (char)(val >> 0x10);
08020534                  fs->win[0x13 + (clst << 0x19 >> 0x17)] = (char)(val >> 0x18);
080204fc              }
08020448          }
08020448          else if (fs_type < 3)
0802044a          {
080204ca              r0_3 = (uint32_t)ff_move_window(fs, r7 + (clst >> 8));
080204ca              
080204ce              if (!r0_3)
080204ce              {
080204d8                  fs->win[0x10 + (clst << 0x18 >> 0x17)] = (char)val;
080204e8                  fs->win[0x11 + (clst << 0x18 >> 0x17)] =
080204e8                      (char)((uint32_t)(uint16_t)val >> 8);
080204ce              }
0802044a          }
0802044a          else
0802053a              r0_3 = 2;
0802053a          
0802053e          fs->n_rootdir = 1;
08020436      }
08020436      
08020542      return (uint32_t)(uint8_t)r0_3;
08020424  }
08020546  // // Free (unlink) a FAT chain starting at `clst`.
08020546  // // Returns: 0 = OK, 1 = I/O error, 2 = invalid cluster / internal error.
08020546  
08020546    uint32_t ff_remove_chain(FatFs* fs, uint32_t clst)
08020546  {
08020546      int32_t r3;
08020546      int32_t var_18 = r3;
0802054a      uint32_t clst_1 = clst;
08020554      uint32_t r5;
08020554      
08020554      if (clst_1 < 2 || clst_1 >= fs->winsect)
08020556          r5 = 2;
08020554      else
08020554      {
0802055a          r5 = 0;
08020576          uint32_t clst_2;
08020576          
08020576          for (; clst_1 < fs->winsect; clst_1 = clst_2)
08020576          {
0802057c              clst_2 = ff_get_fat(fs, clst_1);
0802057c              
08020584              if (!clst_2)
08020584                  break;
08020584              
08020588              if (clst_2 == 1)
08020588              {
0802058a                  r5 = 2;
0802058c                  break;
08020588              }
08020588              
08020592              if (clst_2 == 0xffffffff)
08020592              {
08020594                  r5 = 1;
08020596                  break;
08020592              }
08020592              
080205a4              r5 = (uint32_t)ff_put_fat(fs, clst_1, 0);
080205a4              
080205a8              if (r5)
080205a8                  break;
080205a8              
08020564              if (fs->fatbase != 0xffffffff)
08020564              {
0802056a                  fs->fatbase += 1;
0802056e                  *(uint8_t*)((char*)fs->n_rootdir)[1] = 1;
08020564              }
08020576          }
08020554      }
08020554      
080205ae      return (uint32_t)(uint8_t)r5;
08020546  }
080205b0    uint32_t ff_create_chain(FatFs* fs, uint32_t clst_prev)
080205b0  {
080205b8      uint32_t winsect = fs->winsect;
080205be      uint32_t n_fatent;
080205be      
080205be      if (!clst_prev)
080205be      {
080205c0          n_fatent = fs->n_fatent;
080205c0          
080205c8          if (!n_fatent || n_fatent >= winsect)
080205ca              n_fatent = 1;
080205ca          
080205c8          goto label_80205e4;
080205be      }
080205be      
080205d2      uint32_t r0_1 = ff_get_fat(fs, clst_prev);
080205d2      
080205d8      if (r0_1 < 2)
080205da          return 1;
080205da      
080205e0      if (r0_1 >= winsect)
080205e0      {
080205e2          n_fatent = clst_prev;
080205e4      label_80205e4:
080205e4          uint32_t n_fatent_1 = n_fatent;
080205e4          
080205e6          while (true)
080205e6          {
080205e6              n_fatent_1 += 1;
080205e6              
080205ea              if (n_fatent_1 >= winsect)
080205ea              {
080205ec                  n_fatent_1 = 2;
080205ec                  
080205f0                  if (n_fatent < 2)
080205f2                      return 0;
080205ea              }
080205ea              
080205fa              r0_1 = ff_get_fat(fs, n_fatent_1);
080205fa              
08020600              if (!r0_1)
08020600              {
08020610                  if (ff_put_fat(fs, n_fatent_1, 0xfffffff))
0802063e                      return 0xffffffff;
0802063e                  
08020614                  if (clst_prev && ff_put_fat(fs, clst_prev, n_fatent_1))
08020624                      return 0xffffffff;
08020624                  
08020644                  fs->n_fatent = n_fatent_1;
08020644                  
0802064c                  if (fs->fatbase != 0xffffffff)
0802064c                  {
08020652                      fs->fatbase -= 1;
08020656                      *(uint8_t*)((char*)fs->n_rootdir)[1] = 1;
0802064c                  }
0802064c                  
08020658                  return n_fatent_1;
08020600              }
08020600              
0802062e              if (r0_1 == 0xffffffff)
0802062e                  break;
0802062e              
08020632              if (r0_1 == 1)
08020632                  break;
08020632              
08020638              if (n_fatent_1 == n_fatent)
0802063a                  return 0;
080205e6          }
080205e0      }
080205e0      
0802065a      return r0_1;
080205b0  }
0802065e    int32_t ff_clust2sect(FatFs const* fs, uint32_t clst)
0802065e  {
08020666      if (clst - 2 >= fs->winsect - 2)
08020668          return 0;
08020668      
0802066e      int32_t r0_1;
0802066e      (uint8_t)r0_1 = fs->win[8];
0802066e      *(uint8_t*)((char*)r0_1)[1] = fs->win[9];
0802066e      *(uint8_t*)((char*)r0_1)[2] = fs->win[0xa];
0802066e      *(uint8_t*)((char*)r0_1)[3] = fs->win[0xb];
08020670      return r0_1 + (uint32_t)fs->n_fats * (clst - 2);
0802065e  }
08020676    int32_t ff_dir_seek(DIR_Compat* dp, uint32_t di)
08020676  {
0802067a      uint32_t di_1 = di;
0802067c      *(uint16_t*)((char*)dp->index)[2] = (int16_t)di_1;
0802067e      uint32_t dir = dp->dir;
0802067e      
0802068a      if (dir == 1 || dir >= dp->fs->winsect)
0802068c          return 2;
0802068c      
0802069a      if (!dir && (uint32_t)dp->fs->fs_type == 3)
0802069a      {
0802069c          FatFs* fs = dp->fs;
0802069e          (uint8_t)dir = fs->win[4];
0802069e          *(uint8_t*)((char*)dir)[1] = fs->win[5];
0802069e          *(uint8_t*)((char*)dir)[2] = fs->win[6];
0802069e          *(uint8_t*)((char*)dir)[3] = fs->win[7];
0802069a      }
0802069a      
080206a2      uint32_t r5;
080206a2      
080206a2      if (dir)
080206a2      {
080206ca          uint32_t r6_1 = (uint32_t)dp->fs->n_fats << 4;
080206ca          
080206da          while ((uint32_t)(uint16_t)di_1 >= (uint32_t)(uint16_t)r6_1)
080206da          {
080206e0              dir = ff_get_fat(dp->fs, dir);
080206e0              
080206e8              if (dir == 0xffffffff)
080206ea                  return 1;
080206ea              
080206f8              if (dir < 2 || dir >= dp->fs->winsect)
080206fa                  return 2;
080206fa              
080206ce              di_1 -= r6_1;
080206da          }
080206da          
080206fe          dp->sclust = dir;
08020708          r5 = (uint32_t)(uint16_t)di_1;
0802070a          int32_t r0_8 = ff_clust2sect(dp->fs, dir) + (r5 >> 4);
0802070e          dp->sfn[0] = (uint8_t)r0_8;
0802070e          dp->sfn[1] = *(uint8_t*)((char*)r0_8)[1];
0802070e          dp->sfn[2] = *(uint8_t*)((char*)r0_8)[2];
0802070e          dp->sfn[3] = *(uint8_t*)((char*)r0_8)[3];
080206a2      }
080206a2      else
080206a2      {
080206a4          dp->sclust = dir;
080206a4          
080206b0          if ((uint32_t)(uint16_t)di_1 >= (uint32_t)dp->fs->fatsz)
080206b2              return 2;
080206b2          
080206b6          FatFs* fs_1 = dp->fs;
080206b8          int32_t r0_3;
080206b8          (uint8_t)r0_3 = fs_1->win[4];
080206b8          *(uint8_t*)((char*)r0_3)[1] = fs_1->win[5];
080206b8          *(uint8_t*)((char*)r0_3)[2] = fs_1->win[6];
080206b8          *(uint8_t*)((char*)r0_3)[3] = fs_1->win[7];
080206ba          r5 = (uint32_t)(uint16_t)di_1;
080206bc          int32_t r0_4 = r0_3 + (r5 >> 4);
080206c0          dp->sfn[0] = (uint8_t)r0_4;
080206c0          dp->sfn[1] = *(uint8_t*)((char*)r0_4)[1];
080206c0          dp->sfn[2] = *(uint8_t*)((char*)r0_4)[2];
080206c0          dp->sfn[3] = *(uint8_t*)((char*)r0_4)[3];
080206a2      }
080206a2      
0802071c      void* r0_11 = &dp->fs->win[0x10 + (((uint32_t)(uint16_t)r5 & 0xf) << 5)];
0802071e      dp->sfn[4] = (uint8_t)r0_11;
0802071e      dp->sfn[5] = *(uint8_t*)((char*)r0_11)[1];
0802071e      dp->sfn[6] = *(uint8_t*)((char*)r0_11)[2];
0802071e      dp->sfn[7] = *(uint8_t*)((char*)r0_11)[3];
08020720      return 0;
08020676  }
08020724  // // Advance directory iterator to the next entry.
08020724  // // If `extend` is nonzero and we hit end-of-chain in a subdir,
08020724  // // allocate/append a new cluster and clear it.
08020724  // //
08020724  // // Returns:
08020724  // //   0 : OK (dp->dir / dp->sect / dp->clust advanced)
08020724  // //   1 : disk/I/O error (move/flush/write/Read FAT failed)
08020724  // //   2 : internal FAT error or invalid cluster number
08020724  // //   4 : end-of-table (no space / out of range); not extended (root overflow
08020724  // or extend==0)
08020724  // //   7 : no free cluster available (extend requested but alloc failed)
08020724  
08020724    int32_t ff_dir_next(DIR_Compat* dp, uint8_t extend)
08020724  {
08020724      int32_t r3;
08020724      int32_t var_18 = r3;
0802072e      uint32_t r6_1 = (uint32_t)(*(uint16_t*)((char*)dp->index)[2] + 1);
0802072e      
08020732      if (r6_1)
08020732      {
08020734          int32_t r0_1;
08020734          (uint8_t)r0_1 = dp->sfn[0];
08020734          *(uint8_t*)((char*)r0_1)[1] = dp->sfn[1];
08020734          *(uint8_t*)((char*)r0_1)[2] = dp->sfn[2];
08020734          *(uint8_t*)((char*)r0_1)[3] = dp->sfn[3];
08020734          
08020738          if (r0_1)
08020738          {
08020742              if (!(r6_1 & 0xf))
08020742              {
08020744                  int32_t r0_2;
08020744                  (uint8_t)r0_2 = dp->sfn[0];
08020744                  *(uint8_t*)((char*)r0_2)[1] = dp->sfn[1];
08020744                  *(uint8_t*)((char*)r0_2)[2] = dp->sfn[2];
08020744                  *(uint8_t*)((char*)r0_2)[3] = dp->sfn[3];
08020748                  dp->sfn[0] = (r0_2 + 1);
08020748                  dp->sfn[1] = *(uint8_t*)((char*)(r0_2 + 1))[1];
08020748                  dp->sfn[2] = *(uint8_t*)((char*)(r0_2 + 1))[2];
08020748                  dp->sfn[3] = *(uint8_t*)((char*)(r0_2 + 1))[3];
08020748                  
0802074e                  if (dp->sclust)
0802074e                  {
08020760                      r6_1 = (uint32_t)(uint16_t)r6_1;
08020760                      
0802076c                      if (!(((uint32_t)dp->fs->n_fats - 1) & r6_1 >> 4))
0802076c                      {
08020776                          uint32_t clst = ff_get_fat(dp->fs, dp->sclust);
08020776                          
0802077a                          if (clst < 2)
0802077c                              return 2;
0802077c                          
08020784                          if (clst == 0xffffffff)
08020786                              return 1;
08020786                          
08020790                          if (clst >= dp->fs->winsect)
08020790                          {
08020796                              if (!(uint32_t)extend)
08020798                                  return 4;
08020798                              
080207a4                              clst = ff_create_chain(dp->fs, dp->sclust);
080207a4                              
080207a8                              if (!clst)
080207aa                                  return 7;
080207aa                              
080207b0                              if (clst == 1)
080207b2                                  return 2;
080207b2                              
080207ba                              if (clst == 0xffffffff)
080207bc                                  return 1;
080207bc                              
080207ca                              if (ff_move_window(dp->fs, 0))
080207cc                                  return 1;
080207cc                              
080207da                              memset_n(&dp->fs->win[0x10], 0, 0x200);
080207e2                              int32_t r0_22 = ff_clust2sect(dp->fs, clst);
080207e6                              FatFs* fs_2 = dp->fs;
080207e8                              fs_2->win[0xc] = (uint8_t)r0_22;
080207e8                              fs_2->win[0xd] = *(uint8_t*)((char*)r0_22)[1];
080207e8                              fs_2->win[0xe] = *(uint8_t*)((char*)r0_22)[2];
080207e8                              fs_2->win[0xf] = *(uint8_t*)((char*)r0_22)[3];
080207ea                              int32_t r5_2 = 0;
080207ea                              
08020804                              while ((uint32_t)(uint8_t)r5_2 < (uint32_t)dp->fs->n_fats)
08020804                              {
0802080a                                  dp->fs->n_rootdir = 1;
0802080a                                  
08020816                                  if (ff_move_window(dp->fs, 0))
08020818                                      return 1;
08020818                                  
080207ee                                  FatFs* fs = dp->fs;
080207f0                                  int32_t r0_23;
080207f0                                  (uint8_t)r0_23 = fs->win[0xc];
080207f0                                  *(uint8_t*)((char*)r0_23)[1] = fs->win[0xd];
080207f0                                  *(uint8_t*)((char*)r0_23)[2] = fs->win[0xe];
080207f0                                  *(uint8_t*)((char*)r0_23)[3] = fs->win[0xf];
080207f4                                  FatFs* fs_3 = dp->fs;
080207f6                                  fs_3->win[0xc] = (r0_23 + 1);
080207f6                                  fs_3->win[0xd] = *(uint8_t*)((char*)(r0_23 + 1))[1];
080207f6                                  fs_3->win[0xe] = *(uint8_t*)((char*)(r0_23 + 1))[2];
080207f6                                  fs_3->win[0xf] = *(uint8_t*)((char*)(r0_23 + 1))[3];
080207f8                                  r5_2 += 1;
08020804                              }
08020804                              
0802081c                              FatFs* fs_1 = dp->fs;
0802081e                              int32_t r0_29;
0802081e                              (uint8_t)r0_29 = fs_1->win[0xc];
0802081e                              *(uint8_t*)((char*)r0_29)[1] = fs_1->win[0xd];
0802081e                              *(uint8_t*)((char*)r0_29)[2] = fs_1->win[0xe];
0802081e                              *(uint8_t*)((char*)r0_29)[3] = fs_1->win[0xf];
08020822                              int32_t r0_30 = r0_29 - (uint32_t)(uint8_t)r5_2;
08020824                              FatFs* fs_4 = dp->fs;
08020826                              fs_4->win[0xc] = (uint8_t)r0_30;
08020826                              fs_4->win[0xd] = *(uint8_t*)((char*)r0_30)[1];
08020826                              fs_4->win[0xe] = *(uint8_t*)((char*)r0_30)[2];
08020826                              fs_4->win[0xf] = *(uint8_t*)((char*)r0_30)[3];
08020790                          }
08020790                          
08020828                          dp->sclust = clst;
0802082e                          int32_t r0_32 = ff_clust2sect(dp->fs, clst);
08020832                          dp->sfn[0] = (uint8_t)r0_32;
08020832                          dp->sfn[1] = *(uint8_t*)((char*)r0_32)[1];
08020832                          dp->sfn[2] = *(uint8_t*)((char*)r0_32)[2];
08020832                          dp->sfn[3] = *(uint8_t*)((char*)r0_32)[3];
0802076c                      }
0802074e                  }
0802074e                  else if ((uint32_t)(uint16_t)r6_1 >= (uint32_t)dp->fs->fatsz)
0802075c                      return 4;
08020742              }
08020742              
08020834              *(uint16_t*)((char*)dp->index)[2] = (int16_t)r6_1;
08020842              void* r0_35 = &dp->fs->win[0x10 + (((uint32_t)(uint16_t)r6_1 & 0xf) << 5)];
08020844              dp->sfn[4] = (uint8_t)r0_35;
08020844              dp->sfn[5] = *(uint8_t*)((char*)r0_35)[1];
08020844              dp->sfn[6] = *(uint8_t*)((char*)r0_35)[2];
08020844              dp->sfn[7] = *(uint8_t*)((char*)r0_35)[3];
08020846              return 0;
08020738          }
08020732      }
08020732      
0802073a      return 4;
08020724  }
0802084a  // // Compare one VFAT LFN entry against the appropriate 13-char slice of a
0802084a  // UCS-2 name.
0802084a  // // Returns 1 on match, 0 on mismatch.
0802084a  // //
0802084a  // // arg1: pointer to full UCS-2 filename buffer (little-endian 16-bit units)
0802084a  // // arg2: pointer to a single 32-byte LFN directory entry
0802084a  
0802084a    int32_t ff_lfn_match_slice(uint16_t const* ucs2_name, uint8_t const* lfn_entry)
0802084a  {
0802085c      int32_t r6 = 0xd * (((uint32_t)*(uint8_t*)lfn_entry & 0xbf) - 1);
08020860      int32_t i = 0;
08020862      uint32_t r8 = 1;
08020862      
080208bc      do
080208bc      {
08020878          int16_t r0_6 = (uint16_t)lfn_entry[(uint32_t)*(uint8_t*)(&data_803bdb0 + i)] | (
08020878              int16_t)((uint32_t)lfn_entry[(uint32_t)*(uint8_t*)(&data_803bdb0 + i) + 1] << 8);
0802087c          r8 = (uint32_t)(uint16_t)r8;
0802087c          
08020884          if (r8)
08020884          {
0802088c              r8 = sub_8022366(r0_6);
0802088c              
08020890              if (r6 >= 0xff)
080208a6                  return 0;
080208a6              
08020896              int16_t r0_10 = sub_8022366(ucs2_name[r6]);
0802089a              r6 += 1;
0802089a              
080208a4              if ((uint32_t)(uint16_t)r8 != (uint32_t)r0_10)
080208a6                  return 0;
08020884          }
08020884          else if ((uint32_t)r0_6 != 0xffff)
080208b4              return 0;
080208b4          
080208b8          i += 1;
080208bc      } while (i < 0xd);
080208bc      
080208d4      if ((uint32_t)*(uint8_t*)lfn_entry << 0x19 < 0 && (uint32_t)(uint16_t)r8
080208d4              && (uint32_t)ucs2_name[r6])
080208d6          return 0;
080208d6      
080208da      return 1;
0802084a  }
080208e0    int32_t ff_lfn_copy_slice(uint16_t* ucs2_name, LFN_ENTRY const* lfn_entry)
080208e0  {
080208ec      int32_t r2_3 = 0xd * (((uint32_t)lfn_entry->Ord & 0x3f) - 1);
080208ee      int32_t i = 0;
080208f0      uint32_t r4 = 1;
080208f0      
08020922      do
08020922      {
08020904          uint32_t r5_4 = (uint32_t)
08020904              *(uint8_t*)((char*)lfn_entry + (uint32_t)*(uint8_t*)(&data_803bdb0 + i))
08020904              | (uint32_t)
08020904              *(uint8_t*)(&lfn_entry->Name1 + (uint32_t)*(uint8_t*)(&data_803bdb0 + i)) << 8;
08020908          r4 = (uint32_t)(uint16_t)r4;
08020908          
0802090c          if (r4)
0802090c          {
08020910              if (r2_3 >= 0xff)
08020912                  return 0;
08020912              
08020916              r4 = r5_4;
08020918              ucs2_name[r2_3] = (int16_t)r4;
0802091c              r2_3 += 1;
0802090c          }
0802090c          else if ((uint32_t)(uint16_t)r5_4 != 0xffff)
0802093c              return 0;
0802093c          
0802091e          i += 1;
08020922      } while (i < 0xd);
08020922      
08020928      if ((uint32_t)lfn_entry->Ord << 0x19 < 0)
08020928      {
0802092c          if (r2_3 >= 0xff)
0802092e              return 0;
0802092e          
08020942          ucs2_name[r2_3] = 0;
08020928      }
08020928      
08020946      return 1;
080208e0  }
0802094c    void ff_lfn_make_entry(uint16_t const* ucs2_name, LFN_ENTRY* e, uint8_t ord, uint8_t chksum)
0802094c  {
0802094e      e->Chksum = chksum;
08020952      e->Attr = 0xf;
08020956      e->Type = 0;
0802095a      e->FstClusLO = 0;
0802095e      *(uint8_t*)((char*)e->FstClusLO)[1] = 0;
08020960      uint32_t ord_1 = (uint32_t)ord;
08020966      int32_t r4 = 0xd * (ord_1 - 1);
0802096c      uint32_t r5 = 0;
0802096c      
080209a6      for (int32_t i = 0; i < 0xd; i += 1)
080209a6      {
08020970          uint32_t r5_1 = (uint32_t)(uint16_t)r5;
08020970          
08020978          if (r5_1 != 0xffff)
08020978          {
0802097a              r5_1 = (uint32_t)ucs2_name[r4];
0802097e              r4 += 1;
08020978          }
08020978          
08020986          *(uint8_t*)((char*)e + (uint32_t)*(uint8_t*)(&data_803bdb0 + i)) = (char)r5_1;
08020996          *(uint8_t*)(&e->Name1 + (uint32_t)*(uint8_t*)(&data_803bdb0 + i)) =
08020996              (char)((uint32_t)(uint16_t)r5_1 >> 8);
08020998          r5 = (uint32_t)(uint16_t)r5_1;
08020998          
0802099c          if (!r5)
0802099e              r5 = 0xffff;
080209a6      }
080209a6      
080209b8      if ((uint32_t)(uint16_t)r5 == 0xffff || !(uint32_t)ucs2_name[r4])
080209ba          ord_1 |= 0x40;
080209ba      
080209be      e->Ord = (char)ord_1;
0802094c  }
080209c4  // // Generate/insert the "~n" tail into an 8.3 short name.
080209c4  // // - name11: output 11-byte 8.3 name buffer (8 for name, 3 for ext)
080209c4  // // - src11 : candidate 8.3 name to start from (already uppercased/padded)
080209c4  // // - lfn   : UCS-2 long name (used to hash -> n)
080209c4  // // - seed  : initial counter/seed (e.g., retry count)
080209c4  
080209c4    int16_t* ff_sfn_make_numeric_tail(char (& name11)[0xb], char const (& src11)[0xb], uint16_t const* lfn, int32_t seed)
080209c4  {
080209c4      int32_t seed_1 = seed;
080209c4      uint16_t const* result = lfn;
080209c8      uint16_t const* lfn_1 = lfn;
080209d0      memcpy_n(name11, src11, 0xb);
080209d4      uint32_t i = (uint32_t)(uint16_t)seed;
080209d4      
080209d8      if (i >= 6)
080209d8      {
080209ee          do
080209ee          {
080209e6              i = (uint32_t)*(uint16_t*)lfn_1 + (i << 0xf) + ((uint32_t)(uint16_t)i >> 1);
080209e8              lfn_1 = &lfn_1[1];
080209ee          } while ((uint32_t)*(uint16_t*)lfn_1);
080209d8      }
080209d8      
080209f0      int32_t r0_5 = 7;
080209f0      
08020a12      do
08020a12      {
080209f2          uint32_t r5_1 = (uint32_t)(uint16_t)i;
08020a02          *(uint8_t*)(&result + r0_5) = (char)(r5_1 % 0xa) + 0x30;
08020a04          r0_5 -= 1;
08020a0e          i = (uint32_t)(uint16_t)((uint32_t)(uint16_t)r5_1 / 0xa);
08020a12      } while (i);
08020a12      
08020a18      *(uint8_t*)(&result + r0_5) = 0x7e;
08020a22      int32_t i_1;
08020a22      
08020a22      for (i_1 = 0; i_1 < r0_5; i_1 += 1)
08020a22      {
08020a28          if ((uint32_t)(*(uint88_t*)name11)[i_1] == 0x20)
08020a28              break;
08020a22      }
08020a22      
08020a40      do
08020a40      {
08020a2a          int32_t i_2 = i_1;
08020a2c          i_1 = i_2 + 1;
08020a30          char r3;
08020a30          
08020a30          if (r0_5 >= 8)
08020a3a              r3 = 0x20;
08020a30          else
08020a30          {
08020a34              r3 = *(uint8_t*)(&result + r0_5);
08020a36              r0_5 += 1;
08020a30          }
08020a30          
08020a3c          (*(uint88_t*)name11)[i_2] = r3;
08020a40      } while (i_1 < 8);
08020a40      
08020a42      return result;
080209c4  }
08020a44    uint8_t ff_lfn_checksum(uint8_t const (& sfn11)[0xb])
08020a44  {
08020a44      int32_t r1 = 0;
08020a44      
08020a5c      for (int32_t i = 0xb; i; i -= 1)
08020a5c      {
08020a54          r1 = (uint32_t)*(uint8_t*)sfn11 + (r1 << 7) + ((uint32_t)(uint8_t)r1 >> 1);
08020a56          sfn11 = &(*(uint88_t*)sfn11)[1];
08020a5c      }
08020a5c      
08020a62      return (uint8_t)r1;
08020a44  }
08020a64    uint32_t ff_find_entry(DIR_Compat* dp)
08020a64  {
08020a74      uint32_t r4_1 = (uint32_t)ff_dir_seek(dp, 0);
08020a74      
08020a78      if (r4_1)
08020a7c          return (uint32_t)(uint8_t)r4_1;
08020a7c      
08020a80      char r8_1 = -1;
08020a84      uint32_t r7_1 = 0xff;
08020aca      uint32_t i;
08020aca      
08020aca      do
08020aca      {
08020a86          uint32_t sector;
08020a86          (uint8_t)sector = dp->sfn[0];
08020a86          *(uint8_t*)((char*)sector)[1] = dp->sfn[1];
08020a86          *(uint8_t*)((char*)sector)[2] = dp->sfn[2];
08020a86          *(uint8_t*)((char*)sector)[3] = dp->sfn[3];
08020a90          i = (uint32_t)ff_move_window(dp->fs, sector);
08020a90          
08020a94          if (i)
08020a94              break;
08020a94          
08020a96          uint8_t* r6_1;
08020a96          (uint8_t)r6_1 = dp->sfn[4];
08020a96          *(uint8_t*)((char*)r6_1)[1] = dp->sfn[5];
08020a96          *(uint8_t*)((char*)r6_1)[2] = dp->sfn[6];
08020a96          *(uint8_t*)((char*)r6_1)[3] = dp->sfn[7];
08020a9a          uint32_t r0_7 = (uint32_t)*(uint8_t*)r6_1;
08020a9a          
08020a9e          if (!r0_7)
08020a9e          {
08020aa0              i = 4;
08020aa2              break;
08020a9e          }
08020a9e          
08020aa6          uint32_t r1_2 = (uint32_t)r6_1[0xb] & 0x3f;
08020aaa          uint32_t r0_8 = (uint32_t)(uint8_t)r0_7;
08020aaa          
08020aae          if (r0_8 == 0xe5)
08020aba              r7_1 = 0xff;
08020aae          else if (r1_2 << 0x1c >= 0)
08020ab2          {
08020ad6          label_8020ad6:
08020ad6              
08020ad8              if ((uint32_t)(uint8_t)r1_2 != 0xf)
08020ad8              {
08020b1e                  if (!(uint32_t)(uint8_t)r7_1 && (uint32_t)r8_1 == ff_lfn_checksum(r6_1))
08020b2c                      break;
08020b2c                  
08020b2e                  r7_1 = 0xff;
08020b34                  dp->lfn_size = 0xffff;
08020b36                  void* r0_19;
08020b36                  (uint8_t)r0_19 = dp->sfn[8];
08020b36                  *(uint8_t*)((char*)r0_19)[1] = dp->sfn[9];
08020b36                  *(uint8_t*)((char*)r0_19)[2] = dp->sfn[0xa];
08020b36                  *(uint8_t*)((char*)r0_19)[3] = dp->sfn[0xb];
08020b36                  
08020b3c                  if ((uint32_t)*(uint8_t*)((char*)r0_19 + 0xb) << 0x1f >= 0)
08020b3c                  {
08020b40                      void* s2;
08020b40                      (uint8_t)s2 = dp->sfn[8];
08020b40                      *(uint8_t*)((char*)s2)[1] = dp->sfn[9];
08020b40                      *(uint8_t*)((char*)s2)[2] = dp->sfn[0xa];
08020b40                      *(uint8_t*)((char*)s2)[3] = dp->sfn[0xb];
08020b40                      
08020b4a                      if (!memcmp_n(r6_1, s2, 0xb))
08020b4a                          break;
08020b3c                  }
08020ad8              }
08020ad8              else if (dp->lfn_buf)
08020ade              {
08020ae2                  if (r0_8 << 0x19 < 0)
08020ae2                  {
08020ae4                      r8_1 = r6_1[0xd];
08020ae8                      r0_8 &= 0xbf;
08020aec                      r7_1 = r0_8;
08020af0                      dp->lfn_size = *(uint16_t*)((char*)dp->index)[2];
08020ae2                  }
08020ae2                  
08020b04                  int32_t r0_16;
08020b04                  
08020b04                  if ((uint32_t)(uint8_t)r0_8 == (uint32_t)(uint8_t)r7_1
08020b04                          && (uint32_t)r8_1 == (uint32_t)r6_1[0xd])
08020b0a                      r0_16 = ff_lfn_match_slice(dp->lfn_buf, r6_1);
08020b0a                  
08020b10                  if ((uint32_t)(uint8_t)r0_8 != (uint32_t)(uint8_t)r7_1
08020b10                          || (uint32_t)r8_1 != (uint32_t)r6_1[0xd] || !r0_16)
08020b16                      r7_1 = 0xff;
08020b10                  else
08020b12                      r7_1 -= 1;
08020ade              }
08020ab2          }
08020ab2          else
08020ab2          {
08020ab4              r1_2 = (uint32_t)(uint8_t)r1_2;
08020ab4              
08020ab8              if (r1_2 == 0xf)
08020ab8                  goto label_8020ad6;
08020ab8              
08020aba              r7_1 = 0xff;
08020ab2          }
08020ab2          
08020ac6          i = (uint32_t)ff_dir_next(dp, 0);
08020aca      } while (!i);
08020aca      
08020ace      return (uint32_t)(uint8_t)i;
08020a64  }
08020b4e    uint32_t ff_dir_advance_collect_lfn(DIR_Compat* dp)
08020b4e  {
08020b4e      int32_t r3;
08020b4e      int32_t var_18 = r3;
08020b52      uint32_t r6 = 0xff;
08020b54      uint8_t Chksum = -1;
08020b56      uint32_t i = 4;
08020b56      
08020ba8      do
08020ba8      {
08020b58          int32_t r0;
08020b58          (uint8_t)r0 = dp->sfn[0];
08020b58          *(uint8_t*)((char*)r0)[1] = dp->sfn[1];
08020b58          *(uint8_t*)((char*)r0)[2] = dp->sfn[2];
08020b58          *(uint8_t*)((char*)r0)[3] = dp->sfn[3];
08020b58          
08020b5c          if (!r0)
08020b5c              break;
08020b5c          
08020b5e          uint32_t sector;
08020b5e          (uint8_t)sector = dp->sfn[0];
08020b5e          *(uint8_t*)((char*)sector)[1] = dp->sfn[1];
08020b5e          *(uint8_t*)((char*)sector)[2] = dp->sfn[2];
08020b5e          *(uint8_t*)((char*)sector)[3] = dp->sfn[3];
08020b68          i = (uint32_t)ff_move_window(dp->fs, sector);
08020b68          
08020b6c          if (i)
08020b6c              break;
08020b6c          
08020b6e          LFN_ENTRY* r0_3;
08020b6e          (uint8_t)r0_3 = dp->sfn[4];
08020b6e          *(uint8_t*)((char*)r0_3)[1] = dp->sfn[5];
08020b6e          *(uint8_t*)((char*)r0_3)[2] = dp->sfn[6];
08020b6e          *(uint8_t*)((char*)r0_3)[3] = dp->sfn[7];
08020b72          uint32_t Ord = (uint32_t)r0_3->Ord;
08020b72          
08020b76          if (!Ord)
08020b76          {
08020b78              i = 4;
08020b7a              break;
08020b76          }
08020b76          
08020b7e          uint32_t r2_2 = (uint32_t)r0_3->Attr & 0x3f;
08020b82          uint32_t r1_2 = (uint32_t)(uint8_t)Ord;
08020b82          
08020b86          if (r1_2 == 0xe5)
08020b98              r6 = 0xff;
08020b86          else
08020b86          {
08020b88              uint32_t r1_3 = (uint32_t)(uint8_t)r1_2;
08020b88              
08020b8c              if (r1_3 == 0x2e)
08020b98                  r6 = 0xff;
08020b8c              else if (r2_2 << 0x1c >= 0)
08020b90              {
08020bbc              label_8020bbc:
08020bbc                  
08020bbe                  if ((uint32_t)(uint8_t)r2_2 != 0xf)
08020bbe                  {
08020bfc                      int32_t r0_10;
08020bfc                      
08020bfc                      if (!(uint32_t)(uint8_t)r6)
08020bfe                          r0_10 = ff_lfn_checksum(r0_3);
08020bfe                      
08020c06                      if ((uint32_t)(uint8_t)r6 || (uint32_t)Chksum != r0_10)
08020c0c                          dp->lfn_size = 0xffff;
08020c0c                      
08020c06                      break;
08020bbe                  }
08020bbe                  
08020bc2                  if (r1_3 << 0x19 < 0)
08020bc2                  {
08020bc4                      Chksum = r0_3->Chksum;
08020bc6                      r1_3 &= 0xbf;
08020bca                      r6 = r1_3;
08020bce                      dp->lfn_size = *(uint16_t*)((char*)dp->index)[2];
08020bc2                  }
08020bc2                  
08020be2                  int32_t r0_9;
08020be2                  
08020be2                  if ((uint32_t)(uint8_t)r1_3 == (uint32_t)(uint8_t)r6
08020be2                          && (uint32_t)Chksum == (uint32_t)r0_3->Chksum)
08020be8                      r0_9 = ff_lfn_copy_slice(dp->lfn_buf, r0_3);
08020be8                  
08020bee                  if ((uint32_t)(uint8_t)r1_3 != (uint32_t)(uint8_t)r6
08020bee                          || (uint32_t)Chksum != (uint32_t)r0_3->Chksum || !r0_9)
08020bf4                      r6 = 0xff;
08020bee                  else
08020bf0                      r6 -= 1;
08020b90              }
08020b90              else
08020b90              {
08020b92                  r2_2 = (uint32_t)(uint8_t)r2_2;
08020b92                  
08020b96                  if (r2_2 == 0xf)
08020b96                      goto label_8020bbc;
08020b96                  
08020b98                  r6 = 0xff;
08020b90              }
08020b86          }
08020b86          
08020ba4          i = (uint32_t)ff_dir_next(dp, 0);
08020ba8      } while (!i);
08020ba8      
08020baa      uint32_t r5_2 = (uint32_t)(uint8_t)i;
08020baa      
08020bae      if (r5_2)
08020bae      {
08020bb2          dp->sfn[0] = 0;
08020bb2          dp->sfn[1] = 0;
08020bb2          dp->sfn[2] = 0;
08020bb2          dp->sfn[3] = 0;
08020bae      }
08020bae      
08020bb8      return (uint32_t)(uint8_t)r5_2;
08020b4e  }
08020c10  // // Create (or reserve) a new directory entry at dp for the current name:
08020c10  // // - dp->sfn11 must contain the 11-byte SFN already baked (uppercased,
08020c10  // padded).
08020c10  // // - If dp->lfn != NULL and *dp->lfn != 0, it will also write the LFN chain.
08020c10  // // - If SFN collides and the LFN “needs numeric tail”, it tries ~1..~99.
08020c10  // //
08020c10  // // Returns FRESULT style code:
08020c10  // //   FR_OK (0)          success
08020c10  // //   FR_NO_FILE (4)     internal probe expects “not found” when checking
08020c10  // candidates
08020c10  // //   FR_DENIED (7)      ran out of ~nn candidates
08020c10  // //   other              disk/window errors propagated
08020c10  
08020c10    uint32_t ff_dir_create_entry(DIR_Compat* dp, uint32_t flags)
08020c10  {
08020c10      uint32_t entry_r5;
08020c10      uint32_t var_14 = entry_r5;
08020c18      char (* name11)[0xb];
08020c18      (uint8_t)name11 = dp->sfn[8];
08020c18      *(uint8_t*)((char*)name11)[1] = dp->sfn[9];
08020c18      *(uint8_t*)((char*)name11)[2] = dp->sfn[0xa];
08020c18      *(uint8_t*)((char*)name11)[3] = dp->sfn[0xb];
08020c1a      uint16_t* lfn_buf = dp->lfn_buf;
08020c22      char const src11[0xb];
08020c22      memcpy_n(&src11, name11, 0xc);
08020c2c      char var_1d;
08020c2c      
08020c2c      if ((uint32_t)var_1d << 0x1f < 0)
08020c2c      {
08020c30          name11[1][0] = 0;
08020c34          dp->lfn_buf = nullptr;
08020c36          int16_t r8_1 = 1;
08020c40          uint32_t r8_2;
08020c40          
08020c40          while (true)
08020c40          {
08020c40              r8_2 = (uint32_t)r8_1;
08020c40              
08020c48              if (r8_2 >= 0x64)
08020c48                  break;
08020c48              
08020c54              ff_sfn_make_numeric_tail(name11, &src11, lfn_buf, (uint32_t)(uint16_t)r8_2);
08020c60              entry_r5 = (uint32_t)ff_find_entry(dp);
08020c60              
08020c64              if (entry_r5)
08020c64                  break;
08020c64              
08020c3c              r8_1 = (uint16_t)r8_2 + 1;
08020c40          }
08020c40          
08020c6e          if ((uint32_t)(uint16_t)r8_2 == 0x64)
08020c70              return 7;
08020c70          
08020c74          uint32_t r5_1 = (uint32_t)(uint8_t)entry_r5;
08020c74          
08020c78          if (r5_1 != 4)
08020c7c              return (uint32_t)(uint8_t)r5_1;
08020c7c          
08020c84          name11[1][0] = var_1d;
08020c86          dp->lfn_buf = lfn_buf;
08020c2c      }
08020c2c      
08020c8e      int16_t r7_3;
08020c8e      
08020c8e      if ((uint32_t)var_1d << 0x1e >= 0)
08020cae          r7_3 = 1;
08020c8e      else
08020c8e      {
08020c90          int16_t r7 = 0;
08020c96          uint32_t r7_1;
08020c96          
08020c96          while (true)
08020c96          {
08020c96              r7_1 = (uint32_t)r7;
08020c96              
08020c9e              if (!(uint32_t)lfn_buf[r7_1])
08020c9e                  break;
08020c9e              
08020c94              r7 = (uint16_t)r7_1 + 1;
08020c96          }
08020c96          
08020ca8          r7_3 = (int16_t)(((uint32_t)(uint16_t)r7_1 + 0x19) / 0xd);
08020c8e      }
08020c8e      
08020cba      uint32_t r5_3 = (uint32_t)ff_dir_seek(dp, 0);
08020cba      
08020cbe      if (r5_3)
08020cc2          return (uint32_t)(uint8_t)r5_3;
08020cc2      
08020cc6      int16_t r6 = 0;
08020cc8      int16_t r8_4 = 0;
08020d1a      uint32_t i;
08020d1a      
08020d1a      do
08020d1a      {
08020cca          uint32_t sector;
08020cca          (uint8_t)sector = dp->sfn[0];
08020cca          *(uint8_t*)((char*)sector)[1] = dp->sfn[1];
08020cca          *(uint8_t*)((char*)sector)[2] = dp->sfn[2];
08020cca          *(uint8_t*)((char*)sector)[3] = dp->sfn[3];
08020cd4          i = (uint32_t)ff_move_window(dp->fs, sector);
08020cd4          
08020cd8          if (i)
08020cd8              break;
08020cd8          
08020cda          char* r0_18;
08020cda          (uint8_t)r0_18 = dp->sfn[4];
08020cda          *(uint8_t*)((char*)r0_18)[1] = dp->sfn[5];
08020cda          *(uint8_t*)((char*)r0_18)[2] = dp->sfn[6];
08020cda          *(uint8_t*)((char*)r0_18)[3] = dp->sfn[7];
08020cde          uint32_t r0_20 = (uint32_t)*(uint8_t*)r0_18;
08020cde          
08020ce8          if (r0_20 == 0xe5 || !(uint32_t)(uint8_t)r0_20)
08020ce8          {
08020cea              uint32_t r8_5 = (uint32_t)r8_4;
08020cea              
08020cf2              if (!r8_5)
08020cf4                  r6 = *(uint16_t*)((char*)dp->index)[2];
08020cf4              
08020cf6              r8_4 = (uint16_t)r8_5 + 1;
08020cf6              
08020d04              if ((uint32_t)r8_4 == (uint32_t)r7_3)
08020d04                  break;
08020ce8          }
08020ce8          else
08020d08              r8_4 = 0;
08020d08          
08020d16          i = (uint32_t)ff_dir_next(dp, 1);
08020d1a      } while (!i);
08020d1a      
08020d1c      uint32_t r5_7 = (uint32_t)(uint8_t)i;
08020d1c      
08020d20      if (!r5_7)
08020d20      {
08020d22          uint32_t r7_4 = (uint32_t)r7_3;
08020d22          
08020d26          if (r7_4 >= 2)
08020d26          {
08020d34              r5_7 = (uint32_t)ff_dir_seek(dp, (uint32_t)r6);
08020d34              
08020d38              if (!r5_7)
08020d38              {
08020d3a                  uint8_t const (* sfn11)[0xb];
08020d3a                  (uint8_t)sfn11 = dp->sfn[8];
08020d3a                  *(uint8_t*)((char*)sfn11)[1] = dp->sfn[9];
08020d3a                  *(uint8_t*)((char*)sfn11)[2] = dp->sfn[0xa];
08020d3a                  *(uint8_t*)((char*)sfn11)[3] = dp->sfn[0xb];
08020d3c                  uint8_t chksum = ff_lfn_checksum(sfn11);
08020d42                  uint32_t i_1 = r7_4 - 1;
08020d42                  
08020d80                  do
08020d80                  {
08020d44                      uint32_t sector_1;
08020d44                      (uint8_t)sector_1 = dp->sfn[0];
08020d44                      *(uint8_t*)((char*)sector_1)[1] = dp->sfn[1];
08020d44                      *(uint8_t*)((char*)sector_1)[2] = dp->sfn[2];
08020d44                      *(uint8_t*)((char*)sector_1)[3] = dp->sfn[3];
08020d4e                      r5_7 = (uint32_t)ff_move_window(dp->fs, sector_1);
08020d4e                      
08020d52                      if (r5_7)
08020d52                          break;
08020d52                      
08020d5c                      LFN_ENTRY* e;
08020d5c                      (uint8_t)e = dp->sfn[4];
08020d5c                      *(uint8_t*)((char*)e)[1] = dp->sfn[5];
08020d5c                      *(uint8_t*)((char*)e)[2] = dp->sfn[6];
08020d5c                      *(uint8_t*)((char*)e)[3] = dp->sfn[7];
08020d60                      ff_lfn_make_entry(dp->lfn_buf, e, (uint8_t)i_1, chksum);
08020d68                      dp->fs->n_rootdir = 1;
08020d74                      r5_7 = (uint32_t)ff_dir_next(dp, 0);
08020d74                      
08020d78                      if (r5_7)
08020d78                          break;
08020d78                      
08020d7c                      i_1 = (uint32_t)((uint16_t)i_1 - 1);
08020d80                  } while (i_1);
08020d38              }
08020d26          }
08020d20      }
08020d20      
08020d82      uint32_t r5_11 = (uint32_t)(uint8_t)r5_7;
08020d82      
08020d86      if (!r5_11)
08020d86      {
08020d88          uint32_t sector_2;
08020d88          (uint8_t)sector_2 = dp->sfn[0];
08020d88          *(uint8_t*)((char*)sector_2)[1] = dp->sfn[1];
08020d88          *(uint8_t*)((char*)sector_2)[2] = dp->sfn[2];
08020d88          *(uint8_t*)((char*)sector_2)[3] = dp->sfn[3];
08020d92          r5_11 = (uint32_t)ff_move_window(dp->fs, sector_2);
08020d92          
08020d96          if (!r5_11)
08020d96          {
08020d98              void* r6_2;
08020d98              (uint8_t)r6_2 = dp->sfn[4];
08020d98              *(uint8_t*)((char*)r6_2)[1] = dp->sfn[5];
08020d98              *(uint8_t*)((char*)r6_2)[2] = dp->sfn[6];
08020d98              *(uint8_t*)((char*)r6_2)[3] = dp->sfn[7];
08020da0              memset_n(r6_2, 0, 0x20);
08020da6              void* r1_7;
08020da6              (uint8_t)r1_7 = dp->sfn[8];
08020da6              *(uint8_t*)((char*)r1_7)[1] = dp->sfn[9];
08020da6              *(uint8_t*)((char*)r1_7)[2] = dp->sfn[0xa];
08020da6              *(uint8_t*)((char*)r1_7)[3] = dp->sfn[0xb];
08020daa              memcpy_n(r6_2, r1_7, 0xb);
08020dae              void* r0_37;
08020dae              (uint8_t)r0_37 = dp->sfn[8];
08020dae              *(uint8_t*)((char*)r0_37)[1] = dp->sfn[9];
08020dae              *(uint8_t*)((char*)r0_37)[2] = dp->sfn[0xa];
08020dae              *(uint8_t*)((char*)r0_37)[3] = dp->sfn[0xb];
08020db6              *(uint8_t*)((char*)r6_2 + 0xc) = *(uint8_t*)((char*)r0_37 + 0xb) & 0x18;
08020dbc              dp->fs->n_rootdir = 1;
08020d96          }
08020d86      }
08020d86      
08020dc0      return (uint32_t)(uint8_t)r5_11;
08020c10  }
08020dc8  // // Mark a sequence of directory slots (LFN chain + SFN) as deleted (0xE5).
08020dc8  // // It starts at dp->lfn_run_start (0xFFFF means "use dp->sclust/dptr") and
08020dc8  // // walks forward slot-by-slot, writing 0xE5 to the first byte of each entry,
08020dc8  // // until it reaches the recorded end position (dp->sclust at entry time) or
08020dc8  // // runs out of directory.
08020dc8  // //
08020dc8  // // Returns FRESULT-style codes (0 == FR_OK).
08020dc8  
08020dc8    uint32_t ff_dir_delete_reserved(DIR_Compat* dp)
08020dc8  {
08020dc8      int32_t r3;
08020dc8      int32_t var_10 = r3;
08020dcc      uint16_t lfn_size_1 = *(uint16_t*)((char*)dp->index)[2];
08020dd6      uint16_t lfn_size;
08020dd6      
08020dd6      if ((uint32_t)dp->lfn_size != 0xffff)
08020ddc          lfn_size = dp->lfn_size;
08020dd6      else
08020dd8          lfn_size = lfn_size_1;
08020dd8      
08020de6      uint32_t r0_3 = (uint32_t)ff_dir_seek(dp, (uint32_t)lfn_size);
08020de6      
08020dea      if (!r0_3)
08020dea      {
08020e1c          uint32_t i;
08020e1c          
08020e1c          do
08020e1c          {
08020dec              uint32_t sector;
08020dec              (uint8_t)sector = dp->sfn[0];
08020dec              *(uint8_t*)((char*)sector)[1] = dp->sfn[1];
08020dec              *(uint8_t*)((char*)sector)[2] = dp->sfn[2];
08020dec              *(uint8_t*)((char*)sector)[3] = dp->sfn[3];
08020df4              i = (uint32_t)ff_move_window(dp->fs, sector);
08020df4              
08020df8              if (i)
08020df8                  break;
08020df8              
08020dfc              char* r2_1;
08020dfc              (uint8_t)r2_1 = dp->sfn[4];
08020dfc              *(uint8_t*)((char*)r2_1)[1] = dp->sfn[5];
08020dfc              *(uint8_t*)((char*)r2_1)[2] = dp->sfn[6];
08020dfc              *(uint8_t*)((char*)r2_1)[3] = dp->sfn[7];
08020dfe              *(uint8_t*)r2_1 = 0xe5;
08020e04              dp->fs->n_rootdir = 1;
08020e04              
08020e0e              if ((uint32_t)*(uint16_t*)((char*)dp->index)[2] >= (uint32_t)lfn_size_1)
08020e0e                  break;
08020e0e              
08020e18              i = (uint32_t)ff_dir_next(dp, 0);
08020e1c          } while (!i);
08020e1c          
08020e1e          r0_3 = (uint32_t)(uint8_t)i;
08020e1e          
08020e22          if (r0_3 == 4)
08020e24              r0_3 = 2;
08020dea      }
08020dea      
08020e28      return (uint32_t)(uint8_t)r0_3;
08020dc8  }
08020e2a  // // Parse one path segment from a UTF-16 path, validate it, and build the 8.3
08020e2a  // alias.
08020e2a  // // Advances *ppath to the character after the segment separator (‘/’ or
08020e2a  // ‘’) or end.
08020e2a  // // On success returns 0 (FR_OK-like). On error returns 6 (FR_INVALID_NAME) or
08020e2a  // other
08020e2a  // // FatFs-style status codes you’re using.
08020e2a  // //
08020e2a  // // dp->lfn_buf  (at dp+0x1C): temp UTF-16 buffer for the current segment
08020e2a  // (NUL-terminated)
08020e2a  // // dp->fn       (at dp+0x18): 11-byte SFN (padded with spaces) + 1 byte of
08020e2a  // flags at fn[11]
08020e2a  
08020e2a    uint32_t ff_create_name_from_path_segment(DIR_Compat* dp, uint16_t const** ppath)
08020e2a  {
08020e2a      int32_t r3;
08020e2a      int32_t var_28_1 = r3;
08020e32      int32_t i = 0;
08020e34      int32_t r5 = 0;
08020e36      uint16_t const* r9 = *(uint32_t*)ppath;
08020e3a      uint16_t* lfn_buf = dp->lfn_buf;
08020e48      uint32_t r7_2;
08020e48      
08020e48      while (true)
08020e48      {
08020e48          uint16_t r7_1 = (uint16_t)*(uint8_t*)((char*)r9 + r5);
08020e4c          r5 += 1;
08020e4e          r7_2 = (uint32_t)r7_1;
08020e4e          
08020e52          if (r7_2 >= 0x20)
08020e52          {
08020e54              r7_2 = (uint32_t)(uint16_t)r7_2;
08020e54              
08020e58              if (r7_2 != 0x2f)
08020e58              {
08020e5a                  r7_2 = (uint32_t)(uint16_t)r7_2;
08020e5a                  
08020e5e                  if (r7_2 != 0x5c)
08020e5e                  {
08020e76                      if (i >= 0xff)
08020e78                          return 6;
08020e78                      
08020e8c                      uint32_t r7_6 = (uint32_t)sub_8022314((uint16_t)r7_2 & 0xff, 1);
08020e8c                      
08020e90                      if (!r7_6)
08020e92                          return 6;
08020e92                      
08020e96                      uint32_t c = (uint32_t)(uint16_t)r7_6;
08020e96                      
08020e9a                      if (c < 0x80)
08020e9a                      {
08020e9c                          c = (uint32_t)(uint16_t)c;
08020e9c                          
08020eaa                          if (strchr_local(""*:<>", c))
08020eac                              return 6;
08020e9a                      }
08020e9a                      
08020e42                      lfn_buf[i] = (int16_t)c;
08020e46                      i += 1;
08020e46                      continue;
08020e5e                  }
08020e58              }
08020e52          }
08020e52          
08020e64          *(uint32_t*)ppath = (char*)r9 + r5;
08020e6c          break;
08020e48      }
08020e48      
08020e6c      int32_t r8_1;
08020e6c      
08020e6c      r8_1 = (uint32_t)(uint16_t)r7_2 >= 0x20 ? 0 : 4;
08020e6c      
08020eba      for (; i; i -= 1)
08020eba      {
08020ec6          uint32_t r7_8 = (uint32_t)*(uint16_t*)(&lfn_buf[i] - 2);
08020ec6          
08020ed0          if (r7_8 != 0x20 && (uint32_t)(uint16_t)r7_8 != 0x2e)
08020ed0              break;
08020eba      }
08020eba      
08020ed4      if (!i)
08020ed6          return 6;
08020ed6      
08020ede      lfn_buf[i] = 0;
08020ee6      void* r0_9;
08020ee6      (uint8_t)r0_9 = dp->sfn[8];
08020ee6      *(uint8_t*)((char*)r0_9)[1] = dp->sfn[9];
08020ee6      *(uint8_t*)((char*)r0_9)[2] = dp->sfn[0xa];
08020ee6      *(uint8_t*)((char*)r0_9)[3] = dp->sfn[0xb];
08020ee8      memset_n(r0_9, 0x20, 0xb);
08020eec      int32_t i_1 = 0;
08020eec      
08020f04      while (true)
08020f04      {
08020f04          if ((uint32_t)lfn_buf[i_1] != 0x20 && (uint32_t)lfn_buf[i_1] != 0x2e)
08020f04          {
08020f08              if (i_1)
08020f0a                  r8_1 |= 3;
08020f0a              
08020f14              for (; i; i -= 1)
08020f14              {
08020f22                  if ((uint32_t)*(uint16_t*)(&lfn_buf[i] - 2) == 0x2e)
08020f22                      break;
08020f14              }
08020f14              
08020f24              int32_t r9_1 = 0;
08020f28              int32_t r10_1 = 0;
08020f2a              int32_t r11_1 = 8;
08020f2a              
08020f36              while (true)
08020f36              {
08020f36                  int16_t r7_10 = lfn_buf[i_1];
08020f3a                  i_1 += 1;
08020f3c                  uint32_t r7_11 = (uint32_t)r7_10;
08020f3c                  
08020f40                  if (!r7_11)
08020f40                      break;
08020f40                  
08020fa8                  uint32_t r7_12 = (uint32_t)(uint16_t)r7_11;
08020fa8                  
08020fac                  if (r7_12 != 0x20)
08020fac                  {
08020fae                      uint32_t r7_13 = (uint32_t)(uint16_t)r7_12;
08020fae                      
08020fb6                      if (r7_13 != 0x2e || i_1 == i)
08020fb6                      {
08020fbe                          if (r9_1 >= r11_1 || i_1 == i)
08020fbe                          {
08020fc4                              if (r11_1 == 0xb)
08020fc4                              {
08020fc6                                  r8_1 |= 3;
08020fca                                  break;
08020fc4                              }
08020fc4                              
08020fce                              if (i_1 != i)
08020fd0                                  r8_1 |= 3;
08020fd0                              
08020fd6                              if (i < i_1)
08020fd6                                  break;
08020fd6                              
08020fd8                              i_1 = i;
08020fda                              r9_1 = 8;
08020fde                              r11_1 = 0xb;
08020fe2                              r10_1 <<= 2;
08020fe6                              continue;
08020fbe                          }
08020fbe                          
08020fe8                          uint32_t r7_14 = (uint32_t)(uint16_t)r7_13;
08020fe8                          
08020fec                          if (r7_14 >= 0x80)
08020fec                          {
08020ffa                              r7_14 = (uint32_t)sub_8022314((uint16_t)r7_14, 0);
08020ffa                              
08020ffe                              if (r7_14)
08021008                                  r7_14 = (uint32_t)
08021008                                      *(uint8_t*)((uint32_t)(uint16_t)r7_14 + 0x803a918);
08021008                              
0802100c                              r8_1 |= 2;
08020fec                          }
08020fec                          
08021010                          uint32_t r7_17 = (uint32_t)(uint16_t)r7_14;
08021014                          char* r0_30;
08021014                          uint32_t c_1;
08021014                          
08021014                          if (r7_17)
08021014                          {
08021016                              c_1 = (uint32_t)(uint16_t)r7_17;
0802101e                              r0_30 = strchr_local("+,;[=]", c_1);
08021014                          }
08021014                          
08021024                          uint32_t r7_18;
08021024                          
08021024                          if (r7_17 && !r0_30)
08021024                          {
0802102e                              r7_18 = (uint32_t)(uint16_t)c_1;
0802102e                              
08021036                              if (r7_18 - 0x41 >= 0x1a)
08021036                              {
0802103e                                  r7_18 = (uint32_t)(uint16_t)r7_18;
0802103e                                  
08021046                                  if (r7_18 - 0x61 < 0x1a)
08021046                                  {
08021048                                      r10_1 |= 1;
0802104c                                      r7_18 -= 0x20;
08021046                                  }
08021036                              }
08021036                              else
08021038                                  r10_1 |= 2;
08021024                          }
08021024                          else
08021024                          {
08021026                              r7_18 = 0x5f;
08021028                              r8_1 |= 3;
08021024                          }
08021024                          
0802104e                          uint8_t* r0_33;
0802104e                          (uint8_t)r0_33 = dp->sfn[8];
0802104e                          *(uint8_t*)((char*)r0_33)[1] = dp->sfn[9];
0802104e                          *(uint8_t*)((char*)r0_33)[2] = dp->sfn[0xa];
0802104e                          *(uint8_t*)((char*)r0_33)[3] = dp->sfn[0xb];
08021050                          r0_33[r9_1] = (char)r7_18;
08021054                          r9_1 += 1;
08021058                          continue;
08020fb6                      }
08020fac                  }
08020fac                  
08020f30                  r8_1 |= 3;
08020f36              }
08020f36              
08020f42              char* r0_18;
08020f42              (uint8_t)r0_18 = dp->sfn[8];
08020f42              *(uint8_t*)((char*)r0_18)[1] = dp->sfn[9];
08020f42              *(uint8_t*)((char*)r0_18)[2] = dp->sfn[0xa];
08020f42              *(uint8_t*)((char*)r0_18)[3] = dp->sfn[0xb];
08020f42              
08020f48              if ((uint32_t)*(uint8_t*)r0_18 == 0xe5)
08020f48              {
08020f4c                  char* r1_2;
08020f4c                  (uint8_t)r1_2 = dp->sfn[8];
08020f4c                  *(uint8_t*)((char*)r1_2)[1] = dp->sfn[9];
08020f4c                  *(uint8_t*)((char*)r1_2)[2] = dp->sfn[0xa];
08020f4c                  *(uint8_t*)((char*)r1_2)[3] = dp->sfn[0xb];
08020f4e                  *(uint8_t*)r1_2 = 5;
08020f48              }
08020f48              
08020f54              if (r11_1 == 8)
08020f56                  r10_1 <<= 2;
08020f56              
08020f5a              uint32_t r10_2 = (uint32_t)(uint8_t)r10_1;
08020f5a              
08020f64              if ((r10_2 & 0xc) == 0xc)
08020f72                  r8_1 |= 2;
08020f64              else
08020f64              {
08020f66                  r10_2 = (uint32_t)(uint8_t)r10_2;
08020f66                  
08020f70                  if ((r10_2 & 3) == 3)
08020f72                      r8_1 |= 2;
08020f64              }
08020f64              
08020f7a              if (r8_1 << 0x1e >= 0)
08020f7a              {
08020f7c                  uint32_t r10_3 = (uint32_t)(uint8_t)r10_2;
08020f7c                  
08020f86                  if ((r10_3 & 3) == 1)
08020f88                      r8_1 |= 0x10;
08020f88                  
08020f96                  if (((uint32_t)(uint8_t)r10_3 & 0xc) == 4)
08020f98                      r8_1 |= 8;
08020f7a              }
08020f7a              
08020f9c              void* r0_25;
08020f9c              (uint8_t)r0_25 = dp->sfn[8];
08020f9c              *(uint8_t*)((char*)r0_25)[1] = dp->sfn[9];
08020f9c              *(uint8_t*)((char*)r0_25)[2] = dp->sfn[0xa];
08020f9c              *(uint8_t*)((char*)r0_25)[3] = dp->sfn[0xb];
08020f9e              *(uint8_t*)((char*)r0_25 + 0xb) = (char)r8_1;
08020fa2              return 0;
08020f04          }
08020f04          
08020ef0          i_1 += 1;
08020f04      }
08020e2a  }
0802105a  // // Build a FILINFO-like record from the current directory entry in dp.
0802105a  // // - Writes short 8.3 name into fno->fname (lowercasing per NTRes if set).
0802105a  // // - Fills fno->fattrib, fno->fsize, fno->fdate, fno->ftime from the SFN
0802105a  // entry.
0802105a  // // - If fno->lfname != NULL and a valid LFN slice is present in dp,
0802105a  // //   converts the UTF-16 LFN in dp->lfn_buf to single-byte (OEM) using the
0802105a  // //   upcase/codec table and copies it into fno->lfname (truncating to
0802105a  // fno->lfsize-1).
0802105a  // // Returns the fourth argument (kept for calling convention parity in your
0802105a  // dump).
0802105a  
0802105a    int32_t ff_dirent_to_filinfo(DIR_Compat* dp, FILINFO_Compat* fno, int32_t unused, int32_t retcode)
0802105a  {
0802105e      char (* r1)[0xd] = &fno->fname;
08021062      int32_t r2;
08021062      (uint8_t)r2 = dp->sfn[0];
08021062      *(uint8_t*)((char*)r2)[1] = dp->sfn[1];
08021062      *(uint8_t*)((char*)r2)[2] = dp->sfn[2];
08021062      *(uint8_t*)((char*)r2)[3] = dp->sfn[3];
08021062      
08021066      if (r2)
08021066      {
08021068          char* r2_1;
08021068          (uint8_t)r2_1 = dp->sfn[4];
08021068          *(uint8_t*)((char*)r2_1)[1] = dp->sfn[5];
08021068          *(uint8_t*)((char*)r2_1)[2] = dp->sfn[6];
08021068          *(uint8_t*)((char*)r2_1)[3] = dp->sfn[7];
0802106a          uint32_t r6_1 = (uint32_t)r2_1[0xc];
0802106a          
08021090          for (int32_t i = 0; i < 8; i += 1)
08021090          {
08021094              uint32_t r3_2 = (uint32_t)r2_1[i];
08021094              
08021098              if (r3_2 == 0x20)
08021098                  break;
08021098              
08021070              uint32_t r3 = (uint32_t)(uint8_t)r3_2;
08021070              
08021074              if (r3 == 5)
08021076                  r3 = 0xe5;
08021076              
0802107a              if (r6_1 << 0x1c < 0)
0802107a              {
0802107c                  r3 = (uint32_t)(uint8_t)r3;
0802107c                  
08021084                  if (r3 - 0x41 < 0x1a)
08021086                      r3 += 0x20;
0802107a              }
0802107a              
08021088              ADJ(r1)->fname[0] = (char)r3;
0802108a              r1 = &(*(uint104_t*)r1)[1];
08021090          }
08021090          
0802109e          if ((uint32_t)r2_1[8] != 0x20)
0802109e          {
080210a2              ADJ(r1)->fname[0] = 0x2e;
080210a4              r1 = &(*(uint104_t*)r1)[1];
080210a4              
080210c2              for (int32_t i_1 = 8; i_1 < 0xb; i_1 += 1)
080210c2              {
080210c6                  uint32_t r3_4 = (uint32_t)r2_1[i_1];
080210c6                  
080210ca                  if (r3_4 == 0x20)
080210ca                      break;
080210ca                  
080210ac                  if (r6_1 << 0x1b < 0)
080210ac                  {
080210ae                      r3_4 = (uint32_t)(uint8_t)r3_4;
080210ae                      
080210b6                      if (r3_4 - 0x41 < 0x1a)
080210b8                          r3_4 += 0x20;
080210ac                  }
080210ac                  
080210ba                  ADJ(r1)->fname[0] = (char)r3_4;
080210bc                  r1 = &(*(uint104_t*)r1)[1];
080210c2              }
0802109e          }
0802109e          
080210ce          fno->fattrib = r2_1[0xb];
080210e4          fno->fsize = (uint32_t)r2_1[0x1e] << 0x10 | (uint32_t)r2_1[0x1f] << 0x18
080210e4              | (uint32_t)r2_1[0x1d] << 8 | (uint32_t)r2_1[0x1c];
080210ee          fno->fdate = (uint16_t)r2_1[0x18] | (int16_t)((uint32_t)r2_1[0x19] << 8);
080210f8          fno->ftime = (uint16_t)r2_1[0x16] | (int16_t)((uint32_t)r2_1[0x17] << 8);
08021066      }
08021066      
080210fc      ADJ(r1)->fname[0] = 0;
080210fc      
08021102      if (fno->lfname)
08021102      {
08021104          char* lfname = fno->lfname;
08021106          int32_t r5_6 = 0;
08021108          int32_t r1_2;
08021108          (uint8_t)r1_2 = dp->sfn[0];
08021108          *(uint8_t*)((char*)r1_2)[1] = dp->sfn[1];
08021108          *(uint8_t*)((char*)r1_2)[2] = dp->sfn[2];
08021108          *(uint8_t*)((char*)r1_2)[3] = dp->sfn[3];
08021108          
08021116          if (r1_2 && (uint32_t)dp->lfn_size != 0xffff)
08021116          {
08021118              uint16_t* lfn_buf = dp->lfn_buf;
08021118              
08021120              while (true)
08021120              {
08021120                  uint16_t r0 = *(uint16_t*)lfn_buf;
08021122                  lfn_buf = &lfn_buf[1];
08021122                  
0802112a                  if (!(uint32_t)r0)
0802112a                      break;
0802112a                  
08021134                  uint32_t r0_3 = (uint32_t)sub_8022314(r0, 0);
08021134                  
08021138                  if (!r0_3)
08021138                  {
0802113a                      r5_6 = 0;
0802113c                      break;
08021138                  }
08021138                  
08021144                  if (r5_6 >= fno->lfsize - 1)
08021144                  {
08021146                      r5_6 = 0;
08021146                      break;
08021144                  }
08021144                  
0802111c                  lfname[r5_6] = (char)r0_3;
0802111e                  r5_6 += 1;
08021120              }
08021116          }
08021116          
0802114a          lfname[r5_6] = 0;
08021102      }
08021102      
0802114c      return retcode;
0802105a  }
0802114e  // // Follow a UTF-16 (UCS-2) path and position DIR_Compat on the final entry.
0802114e  // // On success, dp points at the entry for the last segment (file or dir).
0802114e  // // Returns a FatFs-style FRESULT code (0 == FR_OK).
0802114e  // //
0802114e  // // Notes:
0802114e  // // - Leading '/' or '' is skipped (treats path as absolute).
0802114e  // // - Each path segment is parsed/normalized via
0802114e  // ff_create_name_from_path_segment(),
0802114e  // //   then looked up with ff_find_entry() in the current directory.
0802114e  // // - If a segment is found but is not a directory while more path remains,
0802114e  // //   the function returns FR_NO_PATH (5). (It translates FR_NO_FILE (4) to
0802114e  // FR_NO_PATH (5)
0802114e  // //   in that case.)
0802114e  // // - When descending into a subdirectory, it updates dp->sclust / current dir
0802114e  // cluster
0802114e  // //   from the found entry’s FstClusHI/FstClusLO fields.
0802114e  // // - If the path is empty, it seeks to the start of the directory
0802114e  // (root/current).
0802114e  
0802114e    uint32_t ff_follow_path_utf16(DIR_Compat* dp, uint16_t const* path)
0802114e  {
0802114e      uint16_t const* ppath = path;
0802114e      DIR_Compat* dp_1 = dp;
0802114e      
08021160      if ((uint32_t)*(uint8_t*)ppath == 0x2f || (uint32_t)*(uint8_t*)ppath == 0x5c)
08021166          ppath += 1;
08021166      
0802116a      dp->dir = 0;
08021172      int32_t r0_9;
08021172      
08021172      if ((uint32_t)*(uint8_t*)ppath >= 0x20)
08021172      {
080211a4          while (true)
080211a4          {
080211a4              r0_9 = (uint32_t)ff_create_name_from_path_segment(dp, &ppath);
080211a4              
080211a8              if (r0_9)
080211a8                  break;
080211a8              
080211ac              char r0_17 = ff_find_entry(dp);
080211b0              void* r1_4;
080211b0              (uint8_t)r1_4 = dp->sfn[8];
080211b0              *(uint8_t*)((char*)r1_4)[1] = dp->sfn[9];
080211b0              *(uint8_t*)((char*)r1_4)[2] = dp->sfn[0xa];
080211b0              *(uint8_t*)((char*)r1_4)[3] = dp->sfn[0xb];
080211b4              char r1_6 = *(uint8_t*)((char*)r1_4 + 0xb) & 4;
080211b8              r0_9 = (uint32_t)r0_17;
080211b8              
080211bc              if (r0_9)
080211bc              {
080211be                  r0_9 = (uint32_t)(uint8_t)r0_9;
080211be                  
080211c8                  if (r0_9 == 4 && !(uint32_t)r1_6)
080211ca                      r0_9 = 5;
080211ca                  
080211c8                  break;
080211bc              }
080211bc              
080211d2              if ((uint32_t)r1_6)
080211d2                  break;
080211d2              
080211d4              void* r0_18;
080211d4              (uint8_t)r0_18 = dp->sfn[4];
080211d4              *(uint8_t*)((char*)r0_18)[1] = dp->sfn[5];
080211d4              *(uint8_t*)((char*)r0_18)[2] = dp->sfn[6];
080211d4              *(uint8_t*)((char*)r0_18)[3] = dp->sfn[7];
080211d4              
080211da              if ((uint32_t)*(uint8_t*)((char*)r0_18 + 0xb) << 0x1b >= 0)
080211da              {
080211dc                  r0_9 = 5;
080211dc                  break;
080211da              }
080211da              
08021196              uint32_t r0_13 = (uint32_t)*(uint8_t*)((char*)r0_18 + 0x1a)
08021196                  | (uint32_t)(uint16_t)((uint32_t)*(uint8_t*)((char*)r0_18 + 0x1b) << 8)
08021196                  | ((uint32_t)*(uint8_t*)((char*)r0_18 + 0x14)
08021196                  | (uint32_t)(uint16_t)((uint32_t)*(uint8_t*)((char*)r0_18 + 0x15) << 8))
08021196                  << 0x10;
0802119a              dp->dir = r0_13;
080211a4          }
08021172      }
08021172      else
08021172      {
08021178          r0_9 = ff_dir_seek(dp, 0);
0802117e          dp->sfn[4] = 0;
0802117e          dp->sfn[5] = 0;
0802117e          dp->sfn[6] = 0;
0802117e          dp->sfn[7] = 0;
08021172      }
08021172      
080211e0      return (uint32_t)(uint8_t)r0_9;
0802114e  }
080211e2    int32_t check_fs(FatFs* fs, uint32_t sect)
080211e2  {
080211f6      if (disk_read(fs->pdrv, &fs->win[0x10], sect, 1))
080211f8          return 3;
080211f8      
08021210      if (((uint32_t)*((char*)fs + 0x22e)
08021210              | (uint32_t)(uint16_t)((uint32_t)*((char*)fs + 0x22f) << 8)) != 0xaa55)
08021212          return 2;
08021212      
08021230      if (((uint32_t)fs->win[0x47] << 8 | (uint32_t)fs->win[0x48] << 0x10
08021230              | (uint32_t)fs->win[0x46]) == 0x544146)
08021232          return 0;
08021232      
08021250      if (((uint32_t)fs->win[0x63] << 8 | (uint32_t)fs->win[0x64] << 0x10
08021250              | (uint32_t)fs->win[0x62]) != 0x544146)
08021256          return 1;
08021256      
08021252      return 0;
080211e2  }
0802125a  // // Parse "X:" volume prefix, ensure the volume is mounted, and return its
0802125a  // FatFs*.
0802125a  // // If `require_idle` is nonzero, fail if the card is write-protected/busy.
0802125a  // // Returns FRESULT (FatFs): 0=FR_OK, 1=FR_DISK_ERR, 3=FR_NOT_READY,
0802125a  // // 10=FR_WRITE_PROTECTED, 11=FR_INVALID_DRIVE, 12=FR_NOT_ENABLED,
0802125a  // 13=FR_NO_FILESYSTEM.
0802125a  
0802125a    uint32_t ff_find_volume_from_prefix(char** pp, FatFs** out_fs, char require_idle)
0802125a  {
0802125e      char* r2 = *(uint32_t*)pp;
08021262      int32_t r6 = (uint32_t)*(uint8_t*)r2 - 0x30;
08021262      
0802126e      if (r6 >= 0xa || (uint32_t)r2[1] != 0x3a)
08021276          r6 = 0;
0802126e      else
08021272          *(uint32_t*)pp = &r2[2];
08021272      
0802127a      if (r6 >= 2)
0802127c          return 0xb;
0802127c      
08021284      FatFs* fs = *(uint32_t*)(&volume_ctrl_block + (r6 << 2));
08021288      *(uint32_t*)out_fs = fs;
08021288      
0802128c      if (!fs)
0802128e          return 0xc;
0802128e      
08021296      if ((uint32_t)fs->fs_type)
08021296      {
0802129a          int32_t r0_3 = disk_status(fs->pdrv);
0802129a          
080212a0          if (r0_3 << 0x1f >= 0)
080212a0          {
080212aa              if ((uint32_t)require_idle && r0_3 << 0x1d < 0)
080212ac                  return 0xa;
080212ac              
080212b0              return 0;
080212a0          }
08021296      }
08021296      
080212b6      fs->fs_type = 0;
080212b8      fs->pdrv = (char)r6;
080212bc      int32_t si = disk_initialize(fs->pdrv);
080212bc      
080212c2      if (si << 0x1f < 0)
080212c4          return 3;
080212c4      
080212d0      if ((uint32_t)require_idle && si << 0x1d < 0)
080212d2          return 0xa;
080212d2      
080212d6      int32_t sect = 0;
080212e2      uint32_t r6_2 = (uint32_t)check_fs(fs, 0);
080212e2      
080212f2      if (r6_2 == 1 && (uint32_t)fs->win[0x1d2])
080212f2      {
08021306          sect = (uint32_t)fs->win[0x1d6] | (uint32_t)fs->win[0x1d8] << 0x10
08021306              | (uint32_t)fs->win[0x1d9] << 0x18 | (uint32_t)fs->win[0x1d7] << 8;
08021312          r6_2 = check_fs(fs, sect);
080212f2      }
080212f2      
08021314      uint32_t r6_3 = (uint32_t)(uint8_t)r6_2;
08021314      
08021318      if (r6_3 == 3)
0802131a          return 1;
0802131a      
08021336      if ((uint32_t)(uint8_t)r6_3 || ((uint32_t)fs->win[0x1b]
08021336              | (uint32_t)(uint16_t)((uint32_t)fs->win[0x1c] << 8)) != 0x200)
08021338          return 0xd;
08021338      
08021348      uint32_t r0_18 =
08021348          (uint32_t)fs->win[0x26] | (uint32_t)(uint16_t)((uint32_t)fs->win[0x27] << 8);
08021348      
0802134c      if (!r0_18)
08021368          r0_18 = (uint32_t)fs->win[0x36] << 0x10 | (uint32_t)fs->win[0x37] << 0x18
08021368              | (uint32_t)fs->win[0x35] << 8 | (uint32_t)fs->win[0x34];
08021368      
0802136a      fs->database = r0_18;
08021370      fs->csize = fs->win[0x20];
08021374      int32_t r0_22 = (uint32_t)fs->csize * r0_18;
08021382      int32_t r1_17 = sect
08021382          + ((uint32_t)fs->win[0x1e] | (uint32_t)(uint16_t)((uint32_t)fs->win[0x1f] << 8));
08021386      fs->win[0] = (uint8_t)r1_17;
08021386      fs->win[1] = *(uint8_t*)((char*)r1_17)[1];
08021386      fs->win[2] = *(uint8_t*)((char*)r1_17)[2];
08021386      fs->win[3] = *(uint8_t*)((char*)r1_17)[3];
0802138c      fs->n_fats = fs->win[0x1d];
0802139a      fs->fatsz = (uint16_t)fs->win[0x21] | (int16_t)((uint32_t)fs->win[0x22] << 8);
080213a8      uint32_t r1_23 =
080213a8          (uint32_t)fs->win[0x23] | (uint32_t)(uint16_t)((uint32_t)fs->win[0x24] << 8);
080213a8      
080213ac      if (!r1_23)
080213c8          r1_23 = (uint32_t)fs->win[0x32] << 0x10 | (uint32_t)fs->win[0x33] << 0x18
080213c8              | (uint32_t)fs->win[0x31] << 8 | (uint32_t)fs->win[0x30];
080213c8      
080213e8      uint32_t r1_31 = (r1_23
080213e8          - ((uint32_t)fs->win[0x1e] | (uint32_t)(uint16_t)((uint32_t)fs->win[0x1f] << 8))
080213e8          - r0_22 - ((uint32_t)fs->fatsz >> 4)) / (uint32_t)fs->n_fats + 2;
080213ea      fs->winsect = r1_31;
080213ec      char r6_5 = 1;
080213ec      
080213f4      if (r1_31 >= 0xff7)
080213f6          r6_5 = 2;
080213f6      
080213fe      if (r1_31 >= 0xfff7)
08021400          r6_5 = 3;
08021400      
08021402      uint32_t r6_6 = (uint32_t)r6_5;
08021402      
08021406      if (r6_6 != 3)
08021406      {
08021428          int32_t r1_36;
08021428          (uint8_t)r1_36 = fs->win[0];
08021428          *(uint8_t*)((char*)r1_36)[1] = fs->win[1];
08021428          *(uint8_t*)((char*)r1_36)[2] = fs->win[2];
08021428          *(uint8_t*)((char*)r1_36)[3] = fs->win[3];
0802142a          int32_t r1_37 = r0_22 + r1_36;
0802142c          fs->win[4] = (uint8_t)r1_37;
0802142c          fs->win[5] = *(uint8_t*)((char*)r1_37)[1];
0802142c          fs->win[6] = *(uint8_t*)((char*)r1_37)[2];
0802142c          fs->win[7] = *(uint8_t*)((char*)r1_37)[3];
08021406      }
08021406      else
08021406      {
08021422          int32_t r1_35 = (uint32_t)fs->win[0x3e] << 0x10 | (uint32_t)fs->win[0x3f] << 0x18
08021422              | (uint32_t)fs->win[0x3d] << 8 | (uint32_t)fs->win[0x3c];
08021424          fs->win[4] = (uint8_t)r1_35;
08021424          fs->win[5] = *(uint8_t*)((char*)r1_35)[1];
08021424          fs->win[6] = *(uint8_t*)((char*)r1_35)[2];
08021424          fs->win[7] = *(uint8_t*)((char*)r1_35)[3];
08021406      }
08021406      
0802142e      int32_t r1_38;
0802142e      (uint8_t)r1_38 = fs->win[0];
0802142e      *(uint8_t*)((char*)r1_38)[1] = fs->win[1];
0802142e      *(uint8_t*)((char*)r1_38)[2] = fs->win[2];
0802142e      *(uint8_t*)((char*)r1_38)[3] = fs->win[3];
08021434      int32_t r0_24 = r0_22 + r1_38 + ((uint32_t)fs->fatsz >> 4);
08021438      fs->win[8] = (uint8_t)r0_24;
08021438      fs->win[9] = *(uint8_t*)((char*)r0_24)[1];
08021438      fs->win[0xa] = *(uint8_t*)((char*)r0_24)[2];
08021438      fs->win[0xb] = *(uint8_t*)((char*)r0_24)[3];
0802143e      fs->fatbase = 0xffffffff;
08021442      fs->n_rootdir = 0;
08021444      uint32_t r6_7 = (uint32_t)(uint8_t)r6_6;
08021444      
08021448      if (r6_7 == 3)
08021448      {
0802144c          *(uint8_t*)((char*)fs->n_rootdir)[1] = 0;
0802145e          fs->dirbase = sect + ((uint32_t)fs->win[0x40]
0802145e              | (uint32_t)(uint16_t)((uint32_t)fs->win[0x41] << 8));
0802145e          
080214ce          if (!disk_read(fs->pdrv, &fs->win[0x10], fs->dirbase, 1) && (
080214ce              (uint32_t)*((char*)fs + 0x22e)
080214ce              | (uint32_t)(uint16_t)((uint32_t)*((char*)fs + 0x22f) << 8)) == 0xaa55 && (
080214ce              (uint32_t)fs->win[0x12] << 0x10 | (uint32_t)fs->win[0x13] << 0x18
080214ce              | (uint32_t)fs->win[0x11] << 8 | (uint32_t)fs->win[0x10]) == 0x41615252 && (
080214ce              (uint32_t)fs->win[0x1f6] << 0x10 | (uint32_t)fs->win[0x1f7] << 0x18
080214ce              | (uint32_t)fs->win[0x1f5] << 8 | (uint32_t)fs->win[0x1f4]) == 0x61417272)
080214ce          {
080214ec              fs->n_fatent = (uint32_t)fs->win[0x1fe] << 0x10
080214ec                  | (uint32_t)fs->win[0x1ff] << 0x18 | (uint32_t)fs->win[0x1fd] << 8
080214ec                  | (uint32_t)fs->win[0x1fc];
0802150a              fs->fatbase = (uint32_t)fs->win[0x1fa] << 0x10
0802150a                  | (uint32_t)fs->win[0x1fb] << 0x18 | (uint32_t)fs->win[0x1f9] << 8
0802150a                  | (uint32_t)fs->win[0x1f8];
080214ce          }
08021448      }
08021448      
0802150c      fs->fs_type = (char)r6_7;
08021510      fs->win[0xc] = 0;
08021510      fs->win[0xd] = 0;
08021510      fs->win[0xe] = 0;
08021510      fs->win[0xf] = 0;
0802151e      data_2000e414 += 1;
08021526      fs->sector_size = data_2000e414;
08021528      return 0;
0802125a  }
0802152c    uint32_t ff_validate_object(void* obj, uint16_t mount_id)
0802152c  {
0802152c      int32_t r7;
0802152c      int32_t var_8 = r7;
0802152c      
0802153e      if (!obj || !(uint32_t)*(uint8_t*)obj
0802153e              || (uint32_t)*(uint16_t*)((char*)obj + 6) != (uint32_t)mount_id)
08021540          return 9;
08021540      
0802154c      if (disk_status(*(uint8_t*)((char*)obj + 1)) << 0x1f >= 0)
08021552          return 0;
08021552      
0802154e      return 3;
0802152c  }
08021556    int32_t fs_set_working_drive(int32_t drive, char const* workdir_or_mount)
08021556  {
08021556      uint32_t r0_3 = (uint32_t)(uint8_t)drive;
08021556      
0802155a      if (r0_3 >= 2)
0802155c          return 0xb;
0802155c      
08021564      uint32_t r0_1 = (uint32_t)(uint8_t)r0_3;
08021566      char* r2_1 = *(uint32_t*)(&volume_ctrl_block + (r0_1 << 2));
08021566      
0802156c      if (r2_1)
08021570          *(uint8_t*)r2_1 = 0;
08021570      
08021574      if (workdir_or_mount)
08021578          *(uint8_t*)workdir_or_mount = 0;
08021578      
08021580      *(uint32_t*)(&volume_ctrl_block + ((uint32_t)(uint8_t)r0_1 << 2)) = workdir_or_mount;
08021584      return 0;
08021556  }
08021588  int32_t data_8021588 = 0x803bdb0
0802158c    int32_t f_open(void* fil, char const* path, uint8_t mode)
0802158c  {
0802158c      char* path_1 = path;
0802159c      *(uint32_t*)fil = 0;
0802159e      int32_t r5_1 = mode & 0x1f;
080215ae      FatFs* var_50;
080215ae      uint32_t r0_2 =
080215ae          (uint32_t)ff_find_volume_from_prefix(&path_1, &var_50, (uint8_t)r5_1 & 0x1e);
080215ae      
080215b2      if (r0_2)
080215b4          return (uint32_t)(uint8_t)r0_2;
080215b4      
080215ba      void var_2c;
080215ba      void* var_38_1 = &var_2c;
080215bc      void* var_34_1 = &data_2000d450;
080215c2      char r0_5 = ff_follow_path_utf16(&var_50, path_1);
080215ca      void* var_3c;
080215ca      void* r6_1;
080215ca      
080215ca      if (!(r5_1 & 0x1c))
080215ca      {
0802170c          uint32_t r0_39 = (uint32_t)r0_5;
0802170c          
08021710          if (r0_39)
08021712              return (uint32_t)(uint8_t)r0_39;
08021712          
08021716          r6_1 = var_3c;
08021716          
08021720          if (!r6_1 || (uint32_t)*(uint8_t*)((char*)r6_1 + 0xb) << 0x1b < 0)
08021722              return 4;
08021722          
08021730          if (r5_1 << 0x1e < 0 && (uint32_t)*(uint8_t*)((char*)r6_1 + 0xb) << 0x1f < 0)
08021734              return 7;
080215ca      }
080215ca      else
080215ca      {
080215ce          uint32_t r0_6 = (uint32_t)r0_5;
080215ce          
080215d2          if (!r0_6)
080215d2          {
0802167c              if (r5_1 << 0x1d < 0)
0802167e                  return 8;
0802167e              
08021682              r6_1 = var_3c;
08021682              
0802168e              if (!r6_1 || (uint32_t)*(uint8_t*)((char*)r6_1 + 0xb) & 0x11)
08021690                  return 7;
08021690              
08021696              if (r5_1 << 0x1c < 0)
08021696              {
080216ac                  uint32_t clst = (uint32_t)*(uint8_t*)((char*)r6_1 + 0x1a) |
080216ac                      (uint32_t)(uint16_t)((uint32_t)*(uint8_t*)((char*)r6_1 + 0x1b) << 8) | (
080216ac                      (uint32_t)*(uint8_t*)((char*)r6_1 + 0x14) |
080216ac                      (uint32_t)(uint16_t)((uint32_t)*(uint8_t*)((char*)r6_1 + 0x15) << 8))
080216ac                      << 0x10;
080216b2                  *(uint8_t*)((char*)r6_1 + 0x14) = 0;
080216b6                  *(uint8_t*)((char*)r6_1 + 0x15) = 0;
080216ba                  *(uint8_t*)((char*)r6_1 + 0x1a) = 0;
080216be                  *(uint8_t*)((char*)r6_1 + 0x1b) = 0;
080216c2                  *(uint8_t*)((char*)r6_1 + 0x1c) = 0;
080216c6                  *(uint8_t*)((char*)r6_1 + 0x1d) = 0;
080216ca                  *(uint8_t*)((char*)r6_1 + 0x1e) = 0;
080216ce                  *(uint8_t*)((char*)r6_1 + 0x1f) = 0;
080216d4                  var_50->n_rootdir = 1;
080216d6                  FatFs* r0_31 = var_50;
080216d8                  uint32_t sector;
080216d8                  (uint8_t)sector = r0_31->win[0xc];
080216d8                  *(uint8_t*)((char*)sector)[1] = r0_31->win[0xd];
080216d8                  *(uint8_t*)((char*)sector)[2] = r0_31->win[0xe];
080216d8                  *(uint8_t*)((char*)sector)[3] = r0_31->win[0xf];
080216d8                  
080216de                  if (clst)
080216de                  {
080216e8                      uint32_t r0_34 = (uint32_t)ff_remove_chain(var_50, clst);
080216e8                      
080216ec                      if (r0_34)
080216ee                          return (uint32_t)(uint8_t)r0_34;
080216ee                      
080216f6                      var_50->n_fatent = clst - 1;
080216de                  }
080216de                  
08021700                  uint32_t r0_38 = (uint32_t)ff_move_window(var_50, sector);
08021700                  
08021704                  if (r0_38)
08021708                      return (uint32_t)(uint8_t)r0_38;
08021696              }
080215d2          }
080215d2          else
080215d2          {
080215d4              uint32_t r0_7 = (uint32_t)(uint8_t)r0_6;
080215d4              
080215d8              if (r0_7 == 4)
080215dc                  r0_7 = ff_dir_create_entry(&var_50, 0x1c);
080215dc              
080215e0              uint32_t r0_9 = (uint32_t)(uint8_t)r0_7;
080215e0              
080215e4              if (r0_9)
080215e6                  return (uint32_t)(uint8_t)r0_9;
080215e6              
080215ea              r5_1 |= 8;
080215ee              r6_1 = var_3c;
080215d2          }
080215d2          
080215f2          if (r5_1 << 0x1c < 0)
080215f2          {
080215f6              *(uint8_t*)((char*)r6_1 + 0xb) = 0;
080215fe              *(uint8_t*)((char*)r6_1 + 0xe) = 0;
08021608              *(uint8_t*)((char*)r6_1 + 0xf) = 0;
0802160e              *(uint8_t*)((char*)r6_1 + 0x10) = 0;
08021614              *(uint8_t*)((char*)r6_1 + 0x11) = 0;
0802161a              var_50->n_rootdir = 1;
0802161c              r5_1 |= 0x20;
080215f2          }
080215ca      }
080215ca      
08021620      FatFs* r0_11 = var_50;
08021622      int32_t r0_12;
08021622      (uint8_t)r0_12 = r0_11->win[0xc];
08021622      *(uint8_t*)((char*)r0_12)[1] = r0_11->win[0xd];
08021622      *(uint8_t*)((char*)r0_12)[2] = r0_11->win[0xe];
08021622      *(uint8_t*)((char*)r0_12)[3] = r0_11->win[0xf];
08021624      *(uint32_t*)((char*)fil + 0x1c) = r0_12;
08021628      *(uint32_t*)((char*)fil + 0x20) = var_3c;
0802162a      *(uint8_t*)((char*)fil + 6) = (char)r5_1;
08021640      uint32_t r0_17 = (uint32_t)*(uint8_t*)((char*)r6_1 + 0x1a)
08021640          | (uint32_t)(uint16_t)((uint32_t)*(uint8_t*)((char*)r6_1 + 0x1b) << 8) | (
08021640          (uint32_t)*(uint8_t*)((char*)r6_1 + 0x14)
08021640          | (uint32_t)(uint16_t)((uint32_t)*(uint8_t*)((char*)r6_1 + 0x15) << 8)) << 0x10;
08021644      *(uint32_t*)((char*)fil + 0x10) = r0_17;
0802165a      *(uint32_t*)((char*)fil + 0xc) = (uint32_t)*(uint8_t*)((char*)r6_1 + 0x1e) << 0x10
0802165a          | (uint32_t)*(uint8_t*)((char*)r6_1 + 0x1f) << 0x18
0802165a          | (uint32_t)*(uint8_t*)((char*)r6_1 + 0x1d) << 8
0802165a          | (uint32_t)*(uint8_t*)((char*)r6_1 + 0x1c);
0802165e      *(uint32_t*)((char*)fil + 8) = 0;
08021662      *(uint8_t*)((char*)fil + 7) = 0xff;
08021666      *(uint32_t*)((char*)fil + 0x18) = 0;
0802166a      *(uint32_t*)fil = var_50;
08021670      *(uint16_t*)((char*)fil + 4) = var_50->sector_size;
08021672      return 0;
0802158c  }
08021738  int32_t data_8021738 = 0x803bf6c
0802173c  int32_t data_802173c = 0x803a998
08021740  int32_t data_8021740 = 0x803c058
08021744    uint32_t ff_f_read(FIL_Compat* fp, void* buff, uint32_t btr, uint32_t* bytes_read)
08021744  {
08021744      uint32_t* bytes_read_1 = bytes_read;
0802174a      uint32_t i = btr;
0802174e      void* buff_1 = buff;
08021752      *(uint32_t*)bytes_read = 0;
08021754      uint16_t mount_id;
08021754      (uint8_t)mount_id = fp->flag;
08021754      *(uint8_t*)((char*)mount_id)[1] = fp->csect;
0802175c      uint32_t r0_2 = (uint32_t)ff_validate_object(fp->fs, mount_id);
0802175c      
08021760      if (r0_2)
08021762          return (uint32_t)(uint8_t)r0_2;
08021762      
0802176a      if ((uint32_t)fp->pad6 << 0x18 < 0)
0802176c          return 2;
0802176c      
08021774      if ((uint32_t)fp->pad6 << 0x1f >= 0)
08021776          return 7;
08021776      
0802177e      uint32_t i_1 = fp->fsize - fp->fptr;
0802177e      
08021782      if (i_1 < i)
08021784          i = i_1;
08021784      
080217ce      uint32_t n;
080217ce      
080217ce      for (; i; i -= n)
080217ce      {
080217d6          if (fp->fptr << 0x17)
080217d6          {
08021798          label_8021798:
08021798              n = 0x200 - (fp->fptr << 0x17 >> 0x17);
08021798              
0802179e              if (i < n)
080217a0                  n = i;
080217a0              
080217b2              memcpy_n(buff_1, &fp->buf[8 + (fp->fptr << 0x17 >> 0x17)], n);
080217d6          }
080217d6          else
080217d6          {
080217e0              if ((uint32_t)fp->pad7 >= (uint32_t)fp->fs->n_fats)
080217e0              {
080217e6                  uint32_t sclust;
080217e6                  
080217e6                  if (fp->fptr)
080217f0                      sclust = ff_get_fat(fp->fs, fp->clust);
080217e6                  else
080217e8                      sclust = fp->sclust;
080217e8                  
080217f6                  if (sclust < 2)
080217f6                  {
080217fe                      fp->pad6 |= 0x80;
08021800                      return 2;
080217f6                  }
080217f6                  
08021808                  if (sclust == 0xffffffff)
08021808                  {
08021810                      fp->pad6 |= 0x80;
08021812                      return 1;
08021808                  }
08021808                  
08021816                  fp->clust = sclust;
0802181a                  fp->pad7 = 0;
080217e0              }
080217e0              
08021820              int32_t r0_33 = ff_clust2sect(fp->fs, fp->clust);
08021820              
0802182a              if (!r0_33)
0802182a              {
08021832                  fp->pad6 |= 0x80;
08021834                  return 2;
0802182a              }
0802182a              
0802183a              uint32_t sector = r0_33 + (uint32_t)fp->pad7;
0802183e              uint32_t r9_1 = i >> 9;
0802183e              
08021846              if (!r9_1)
08021846              {
080218c0                  if ((uint32_t)fp->pad6 << 0x19 < 0)
080218c0                  {
080218d4                      if (disk_write(fp->fs->pdrv, &fp->buf[8], fp->dsect, 1))
080218d4                      {
080218dc                          fp->pad6 |= 0x80;
080218de                          return 1;
080218d4                      }
080218d4                      
080218e8                      fp->pad6 &= 0xbf;
080218c0                  }
080218c0                  
080218ee                  if (fp->dsect != sector
080218ee                      && disk_read(fp->fs->pdrv, &fp->buf[8], sector, 1))
080218ee                  {
0802190e                      fp->pad6 |= 0x80;
08021910                      return 1;
080218ee                  }
080218ee                  
08021788                  fp->dsect = sector;
08021790                  fp->pad7 += 1;
080218ee                  goto label_8021798;
08021846              }
08021846              
08021854              if ((uint32_t)fp->fs->n_fats < r9_1 + (uint32_t)fp->pad7)
0802185c                  r9_1 = (uint32_t)fp->fs->n_fats - (uint32_t)fp->pad7;
0802185c              
08021872              if (disk_read(fp->fs->pdrv, buff_1, sector, (uint32_t)(uint8_t)r9_1))
08021872              {
0802187a                  fp->pad6 |= 0x80;
0802187c                  return 1;
08021872              }
08021872              
0802188e              if ((uint32_t)fp->pad6 << 0x19 < 0 && fp->dsect - sector < r9_1)
080218a6                  memcpy_n(0x200 * (fp->dsect - sector) + buff_1, &fp->buf[8], 0x200);
080218a6              
080218b0              fp->pad7 += (uint8_t)r9_1;
080218b6              n = 0x200 * r9_1;
080217d6          }
080217d6          
080217b6          buff_1 += n;
080217be          fp->fptr += n;
080217c6          *(uint32_t*)bytes_read += n;
080217ce      }
080217ce      
08021914      return 0;
08021744  }
0802191a    int32_t f_write(void* fil, void const* buf, uint32_t len, uint32_t* bw)
0802191a  {
0802191a      uint32_t* bw_1 = bw;
08021920      uint32_t i = len;
08021924      void const* buf_1 = buf;
08021928      *(uint32_t*)bw = 0;
08021932      uint32_t r0_2 =
08021932          (uint32_t)ff_validate_object(*(uint32_t*)fil, *(uint16_t*)((char*)fil + 4));
08021932      
08021936      if (r0_2)
08021938          return (uint32_t)(uint8_t)r0_2;
08021938      
08021940      if ((uint32_t)*(uint8_t*)((char*)fil + 6) << 0x18 < 0)
08021942          return 2;
08021942      
0802194a      if ((uint32_t)*(uint8_t*)((char*)fil + 6) << 0x1e >= 0)
0802194c          return 7;
0802194c      
08021958      if (i + *(uint32_t*)((char*)fil + 0xc) < *(uint32_t*)((char*)fil + 0xc))
0802195a          i = 0;
0802195a      
080219aa      uint32_t n;
080219aa      
080219aa      for (; i; i -= n)
080219aa      {
080219b0          if (*(uint32_t*)((char*)fil + 8) << 0x17)
080219b0          {
0802196e          label_802196e:
0802196e              n = 0x200 - (*(uint32_t*)((char*)fil + 8) << 0x17 >> 0x17);
0802196e              
08021974              if (i < n)
08021976                  n = i;
08021976              
08021986              memcpy_n((*(uint32_t*)((char*)fil + 8) << 0x17 >> 0x17) + fil + 0x24, buf_1, 
08021986                  n);
08021990              *(uint8_t*)((char*)fil + 6) |= 0x40;
080219b0          }
080219b0          else
080219b0          {
080219ba              if ((uint32_t)*(uint8_t*)((char*)fil + 7)
080219ba                  >= (uint32_t)*(uint8_t*)(*(uint32_t*)fil + 2))
080219ba              {
080219c0                  uint32_t r0_30;
080219c0                  
080219c0                  if (*(uint32_t*)((char*)fil + 8))
080219d8                      r0_30 =
080219d8                          ff_create_chain(*(uint32_t*)fil, *(uint32_t*)((char*)fil + 0x14));
080219c0                  else
080219c0                  {
080219c2                      r0_30 = *(uint32_t*)((char*)fil + 0x10);
080219c2                      
080219c6                      if (!r0_30)
080219c6                      {
080219cc                          r0_30 = ff_create_chain(*(uint32_t*)fil, 0);
080219d0                          *(uint32_t*)((char*)fil + 0x10) = r0_30;
080219c6                      }
080219c0                  }
080219c0                  
080219de                  if (!r0_30)
080219de                      break;
080219de                  
080219fc                  if (r0_30 == 1)
080219fc                  {
08021a04                      *(uint8_t*)((char*)fil + 6) |= 0x80;
08021a06                      return 2;
080219fc                  }
080219fc                  
08021a0e                  if (r0_30 == 0xffffffff)
08021a0e                  {
08021a16                      *(uint8_t*)((char*)fil + 6) |= 0x80;
08021a18                      return 1;
08021a0e                  }
08021a0e                  
08021a1c                  *(uint32_t*)((char*)fil + 0x14) = r0_30;
08021a20                  *(uint8_t*)((char*)fil + 7) = 0;
080219ba              }
080219ba              
08021a26              if ((uint32_t)*(uint8_t*)((char*)fil + 6) << 0x19 < 0)
08021a26              {
08021a3a                  if (disk_write(*(uint8_t*)(*(uint32_t*)fil + 1), (char*)fil + 0x24, 
08021a3a                      *(uint32_t*)((char*)fil + 0x18), 1))
08021a3a                  {
08021a42                      *(uint8_t*)((char*)fil + 6) |= 0x80;
08021a44                      return 1;
08021a3a                  }
08021a3a                  
08021a4e                  *(uint8_t*)((char*)fil + 6) &= 0xbf;
08021a26              }
08021a26              
08021a54              int32_t r0_51 =
08021a54                  ff_clust2sect(*(uint32_t*)fil, *(uint32_t*)((char*)fil + 0x14));
08021a54              
08021a5e              if (!r0_51)
08021a5e              {
08021a66                  *(uint8_t*)((char*)fil + 6) |= 0x80;
08021a68                  return 2;
08021a5e              }
08021a5e              
08021a6e              int32_t sector = r0_51 + (uint32_t)*(uint8_t*)((char*)fil + 7);
08021a72              uint32_t r9_1 = i >> 9;
08021a72              
08021a7a              if (!r9_1)
08021a7a              {
08021b02                  if (*(uint32_t*)((char*)fil + 0x18) != sector
08021b02                      && *(uint32_t*)((char*)fil + 8) < *(uint32_t*)((char*)fil + 0xc) &&
08021b02                      disk_read(*(uint8_t*)(*(uint32_t*)fil + 1), (char*)fil + 0x24, 
08021b02                      sector, 1))
08021b02                  {
08021b22                      *(uint8_t*)((char*)fil + 6) |= 0x80;
08021b24                      return 1;
08021b02                  }
08021b02                  
0802195e                  *(uint32_t*)((char*)fil + 0x18) = sector;
08021966                  *(uint8_t*)((char*)fil + 7) += 1;
08021966                  goto label_802196e;
08021a7a              }
08021a7a              
08021a88              if ((uint32_t)*(uint8_t*)(*(uint32_t*)fil + 2)
08021a88                      < r9_1 + (uint32_t)*(uint8_t*)((char*)fil + 7))
08021a90                  r9_1 = (uint32_t)*(uint8_t*)(*(uint32_t*)fil + 2)
08021a90                      - (uint32_t)*(uint8_t*)((char*)fil + 7);
08021a90              
08021aa6              if (disk_write(*(uint8_t*)(*(uint32_t*)fil + 1), buf_1, sector, 
08021aa6                  (uint32_t)(uint8_t)r9_1))
08021aa6              {
08021aae                  *(uint8_t*)((char*)fil + 6) |= 0x80;
08021ab0                  return 1;
08021aa6              }
08021aa6              
08021abc              if (*(uint32_t*)((char*)fil + 0x18) - sector < r9_1)
08021abc              {
08021ad6                  memcpy_n((char*)fil + 0x24, 
08021ad6                      (char*)buf_1 + 0x200 * (*(uint32_t*)((char*)fil + 0x18) - sector), 
08021ad6                      0x200);
08021ae0                  *(uint8_t*)((char*)fil + 6) &= 0xbf;
08021abc              }
08021abc              
08021ae8              *(uint8_t*)((char*)fil + 7) += (uint8_t)r9_1;
08021aee              n = 0x200 * r9_1;
080219b0          }
080219b0          
08021992          buf_1 += n;
0802199a          *(uint32_t*)((char*)fil + 8) += n;
080219a2          *(uint32_t*)bw += n;
080219aa      }
080219aa      
080219e6      if (*(uint32_t*)((char*)fil + 0xc) < *(uint32_t*)((char*)fil + 8))
080219ea          *(uint32_t*)((char*)fil + 0xc) = *(uint32_t*)((char*)fil + 8);
080219ea      
080219f2      *(uint8_t*)((char*)fil + 6) |= 0x20;
080219f4      return 0;
0802191a  }
08021b28    uint32_t sub_8021b28(int32_t* arg1)
08021b28  {
08021b28      int32_t r3;
08021b28      int32_t var_10 = r3;
08021b34      uint32_t r0_2 = (uint32_t)ff_validate_object(*(uint32_t*)arg1, arg1[1]);
08021b34      
08021b3e      if (!r0_2 && (uint32_t)*(uint8_t*)((char*)arg1 + 6) << 0x1a < 0)
08021b3e      {
08021b44          if ((uint32_t)*(uint8_t*)((char*)arg1 + 6) << 0x19 < 0)
08021b44          {
08021b58              if (disk_write(*(uint8_t*)(*(uint32_t*)arg1 + 1), &arg1[9], arg1[6], 1))
08021b5a                  return 1;
08021b5a              
08021b64              *(uint8_t*)((char*)arg1 + 6) &= 0xbf;
08021b44          }
08021b44          
08021b6e          r0_2 = (uint32_t)ff_move_window(*(uint32_t*)arg1, arg1[7]);
08021b6e          
08021b72          if (!r0_2)
08021b72          {
08021b74              void* r5_1 = arg1[8];
08021b7c              *(uint8_t*)((char*)r5_1 + 0xb) |= 0x20;
08021b80              *(uint8_t*)((char*)r5_1 + 0x1c) = (char)arg1[3];
08021b88              *(uint8_t*)((char*)r5_1 + 0x1d) = (char)((uint32_t)(uint16_t)arg1[3] >> 8);
08021b8e              *(uint8_t*)((char*)r5_1 + 0x1e) = (char)(arg1[3] >> 0x10);
08021b94              *(uint8_t*)((char*)r5_1 + 0x1f) = (char)(arg1[3] >> 0x18);
08021b98              *(uint8_t*)((char*)r5_1 + 0x1a) = (char)arg1[4];
08021ba0              *(uint8_t*)((char*)r5_1 + 0x1b) = (char)((uint32_t)(uint16_t)arg1[4] >> 8);
08021ba6              *(uint8_t*)((char*)r5_1 + 0x14) = (char)(arg1[4] >> 0x10);
08021bb0              *(uint8_t*)((char*)r5_1 + 0x15) =
08021bb0                  (char)((uint32_t)(uint16_t)(arg1[4] >> 0x10) >> 8);
08021bb6              *(uint8_t*)((char*)r5_1 + 0x16) = 0;
08021bbe              *(uint8_t*)((char*)r5_1 + 0x17) = 0;
08021bc2              *(uint8_t*)((char*)r5_1 + 0x18) = 0;
08021bc6              *(uint8_t*)((char*)r5_1 + 0x19) = 0;
08021bce              *(uint8_t*)((char*)arg1 + 6) &= 0xdf;
08021bd4              *(uint8_t*)(*(uint32_t*)arg1 + 4) = 1;
08021bd8              r0_2 = ff_sync(*(uint32_t*)arg1);
08021b72          }
08021b3e      }
08021b3e      
08021bdc      return (uint32_t)(uint8_t)r0_2;
08021b28  }
08021be0    int32_t f_close(void* fil)
08021be0  {
08021bea      uint32_t r0_2 = (uint32_t)sub_8021b28(fil);
08021bea      
08021bee      if (!r0_2)
08021bf2          *(uint32_t*)fil = 0;
08021bf2      
08021bf6      return (uint32_t)(uint8_t)r0_2;
08021be0  }
08021bf8    uint32_t sub_8021bf8(int32_t* arg1, int32_t arg2)
08021bf8  {
08021bfe      int32_t r5 = arg2;
08021c0a      uint32_t r6_1 = (uint32_t)ff_validate_object(*(uint32_t*)arg1, arg1[1]);
08021c0a      
08021c0e      if (r6_1)
08021c12          return (uint32_t)(uint8_t)r6_1;
08021c12      
08021c1a      if ((uint32_t)*(uint8_t*)((char*)arg1 + 6) << 0x18 < 0)
08021c1c          return 2;
08021c1c      
08021c2a      if (arg1[3] < r5 && (uint32_t)*(uint8_t*)((char*)arg1 + 6) << 0x1e >= 0)
08021c2c          r5 = arg1[3];
08021c2c      
08021c2e      int32_t r0_9 = arg1[2];
08021c30      uint32_t sector = 0;
08021c32      arg1[2] = 0;
08021c36      *(uint8_t*)((char*)arg1 + 7) = 0xff;
08021c36      
08021c3a      if (r5)
08021c3a      {
08021c44          int32_t r8_1 = 0x200 * (uint32_t)*(uint8_t*)(*(uint32_t*)arg1 + 2);
08021c5a          uint32_t r0_13;
08021c5a          
08021c5a          if (!r0_9 || (r5 - 1) / r8_1 < (r0_9 - 1) / r8_1)
08021c5a          {
08021c6e              r0_13 = arg1[4];
08021c6e              
08021c72              if (!r0_13)
08021c72              {
08021c78                  r0_13 = ff_create_chain(*(uint32_t*)arg1, 0);
08021c78                  
08021c7e                  if (r0_13 == 1)
08021c7e                  {
08021c86                      *(uint8_t*)((char*)arg1 + 6) |= 0x80;
08021c88                      return 2;
08021c7e                  }
08021c7e                  
08021c90                  if (r0_13 == 0xffffffff)
08021c90                  {
08021c98                      *(uint8_t*)((char*)arg1 + 6) |= 0x80;
08021c9a                      return 1;
08021c90                  }
08021c90                  
08021c9e                  arg1[4] = r0_13;
08021c72              }
08021c72              
08021ca0              arg1[5] = r0_13;
08021c5a          }
08021c5a          else
08021c5a          {
08021c64              arg1[2] = (r0_9 - 1) & ~(r8_1 - 1);
08021c68              r5 -= arg1[2];
08021c6a              r0_13 = arg1[5];
08021c5a          }
08021c5a          
08021ca4          if (r0_13)
08021ca4          {
08021cb8              while (true)
08021cb8              {
08021cb8                  if (r8_1 < r5)
08021cb8                  {
08021cbe                      if ((uint32_t)*(uint8_t*)((char*)arg1 + 6) << 0x1e >= 0)
08021cbe                      {
08021cfa                          r0_13 = ff_get_fat(*(uint32_t*)arg1, r0_13);
08021cfe                      label_8021cfe:
08021cfe                          
08021d02                          if (r0_13 == 0xffffffff)
08021d02                          {
08021d0a                              *(uint8_t*)((char*)arg1 + 6) |= 0x80;
08021d0c                              return 1;
08021d02                          }
08021d02                          
08021d1a                          if (r0_13 < 2 || r0_13 >= *(uint32_t*)(*(uint32_t*)arg1 + 0x1c))
08021d1a                          {
08021d22                              *(uint8_t*)((char*)arg1 + 6) |= 0x80;
08021d24                              return 2;
08021d1a                          }
08021d1a                          
08021ca8                          arg1[5] = r0_13;
08021cb0                          arg1[2] += r8_1;
08021cb2                          r5 -= r8_1;
08021cb2                          continue;
08021cbe                      }
08021cbe                      else
08021cbe                      {
08021cc4                          r0_13 = ff_create_chain(*(uint32_t*)arg1, r0_13);
08021cc4                          
08021cca                          if (r0_13)
08021cca                              goto label_8021cfe;
08021cca                          
08021ccc                          r5 = r8_1;
08021cbe                      }
08021cb8                  }
08021cb8                  
08021cd2                  arg1[2] += r5;
08021cd6                  *(uint8_t*)((char*)arg1 + 7) = (char)(r5 >> 9);
08021cda                  break;
08021cb8              }
08021cb8              
08021cda              if (r5 << 0x17)
08021cda              {
08021ce0                  int32_t r0_21 = ff_clust2sect(*(uint32_t*)arg1, r0_13);
08021ce0                  
08021ce8                  if (!r0_21)
08021ce8                  {
08021cf0                      *(uint8_t*)((char*)arg1 + 6) |= 0x80;
08021cf2                      return 2;
08021ce8                  }
08021ce8                  
08021d2a                  sector = r0_21 + (uint32_t)*(uint8_t*)((char*)arg1 + 7);
08021d30                  *(uint8_t*)((char*)arg1 + 7) += 1;
08021cda              }
08021ca4          }
08021c3a      }
08021c3a      
08021d3c      if (arg1[2] << 0x17 && sector != arg1[6])
08021d3c      {
08021d42          if ((uint32_t)*(uint8_t*)((char*)arg1 + 6) << 0x19 < 0)
08021d42          {
08021d56              if (disk_write(*(uint8_t*)(*(uint32_t*)arg1 + 1), &arg1[9], arg1[6], 1))
08021d56              {
08021d5e                  *(uint8_t*)((char*)arg1 + 6) |= 0x80;
08021d60                  return 1;
08021d56              }
08021d56              
08021d6a              *(uint8_t*)((char*)arg1 + 6) &= 0xbf;
08021d42          }
08021d42          
08021d7e          if (disk_read(*(uint8_t*)(*(uint32_t*)arg1 + 1), &arg1[9], sector, 1))
08021d7e          {
08021d86              *(uint8_t*)((char*)arg1 + 6) |= 0x80;
08021d88              return 1;
08021d7e          }
08021d7e          
08021d8c          arg1[6] = sector;
08021d3c      }
08021d3c      
08021d94      if (arg1[3] < arg1[2])
08021d94      {
08021d98          arg1[3] = arg1[2];
08021da0          *(uint8_t*)((char*)arg1 + 6) |= 0x20;
08021d94      }
08021d94      
08021da4      return (uint32_t)(uint8_t)r6_1;
08021bf8  }
08021daa    uint32_t sub_8021daa(DIR_Compat* arg1, char* arg2)
08021daa  {
08021daa      char* var_10 = arg2;
08021dbe      uint32_t r0_2 = (uint32_t)ff_find_volume_from_prefix(&var_10, arg1, 0);
08021dbe      
08021dc2      if (!r0_2)
08021dc2      {
08021dc6          void var_20;
08021dc6          arg1->sfn[8] = &var_20;
08021dc8          arg1->lfn_buf = &data_2000d450;
08021dd2          uint32_t r0_5 = (uint32_t)ff_follow_path_utf16(arg1, var_10);
08021dd2          
08021dd6          if (!r0_5)
08021dd6          {
08021dd8              void* r1_2;
08021dd8              (uint8_t)r1_2 = arg1->sfn[4];
08021dd8              *(uint8_t*)((char*)r1_2)[1] = arg1->sfn[5];
08021dd8              *(uint8_t*)((char*)r1_2)[2] = arg1->sfn[6];
08021dd8              *(uint8_t*)((char*)r1_2)[3] = arg1->sfn[7];
08021dd8              
08021ddc              if (r1_2)
08021ddc              {
08021de2                  if ((uint32_t)*(uint8_t*)((char*)r1_2 + 0xb) << 0x1b >= 0)
08021e00                      r0_5 = 5;
08021de2                  else
08021de2                  {
08021df8                      uint32_t r1_6 = (uint32_t)*(uint8_t*)((char*)r1_2 + 0x1a) | (
08021df8                          uint32_t)(uint16_t)((uint32_t)*(uint8_t*)((char*)r1_2 + 0x1b) << 8)
08021df8                          | ((uint32_t)*(uint8_t*)((char*)r1_2 + 0x14) | (uint32_t)(
08021df8                          uint16_t)((uint32_t)*(uint8_t*)((char*)r1_2 + 0x15) << 8)) << 0x10;
08021dfc                      arg1->dir = r1_6;
08021de2                  }
08021ddc              }
08021ddc              
08021e02              r0_5 = (uint32_t)(uint8_t)r0_5;
08021e02              
08021e06              if (!r0_5)
08021e06              {
08021e0c                  arg1->index = arg1->fs->sector_size;
08021e12                  r0_5 = ff_dir_seek(arg1, 0);
08021e06              }
08021dd6          }
08021dd6          
08021e16          r0_2 = (uint32_t)(uint8_t)r0_5;
08021e16          
08021e1a          if (r0_2 == 4)
08021e1c              r0_2 = 5;
08021dc2      }
08021dc2      
08021e22      return (uint32_t)(uint8_t)r0_2;
08021daa  }
08021e24    uint32_t sub_8021e24(int32_t* arg1, FILINFO_Compat* arg2)
08021e24  {
08021e36      uint32_t r0_2 = (uint32_t)ff_validate_object(*(uint32_t*)arg1, arg1[1]);
08021e36      
08021e3a      if (!r0_2)
08021e3a      {
08021e3e          void var_20;
08021e3e          arg1[6] = &var_20;
08021e40          arg1[7] = &data_2000d450;
08021e40          
08021e44          if (arg2)
08021e44          {
08021e52              char r0_5;
08021e52              int32_t unused;
08021e52              int32_t retcode;
08021e52              r0_5 = ff_dir_advance_collect_lfn(arg1);
08021e56              uint32_t r0_6 = (uint32_t)r0_5;
08021e56              
08021e5a              if (r0_6 == 4)
08021e5a              {
08021e5e                  arg1[4] = 0;
08021e60                  r0_6 = 0;
08021e5a              }
08021e5a              
08021e62              r0_2 = (uint32_t)(uint8_t)r0_6;
08021e62              
08021e66              if (!r0_2)
08021e66              {
08021e6c                  ff_dirent_to_filinfo(arg1, arg2, unused, retcode);
08021e78                  r0_2 = (uint32_t)ff_dir_next(arg1, 0);
08021e78                  
08021e7c                  if (r0_2 == 4)
08021e7c                  {
08021e80                      arg1[4] = 0;
08021e82                      r0_2 = 0;
08021e7c                  }
08021e66              }
08021e44          }
08021e44          else
08021e4a              r0_2 = ff_dir_seek(arg1, 0);
08021e3a      }
08021e3a      
08021e88      return (uint32_t)(uint8_t)r0_2;
08021e24  }
08021e8a                                00 00                                                                        ..
08021e8c  int32_t data_8021e8c = 0x544146
08021e90  int32_t data_8021e90 = 0x2000e2e4
08021e94    uint32_t sub_8021e94(char* arg1)
08021e94  {
08021e94      char* var_c = arg1;
08021ea4      FatFs* var_60;
08021ea4      uint32_t r0_2 = (uint32_t)ff_find_volume_from_prefix(&var_c, &var_60, 1);
08021ea4      
08021ea8      if (r0_2)
08021eaa          return (uint32_t)(uint8_t)r0_2;
08021eaa      
08021eb0      void var_3c;
08021eb0      void* var_48_1 = &var_3c;
08021eb2      void* var_44_1 = &data_2000d450;
08021ebc      uint32_t r0_6 = (uint32_t)ff_follow_path_utf16(&var_60, var_c);
08021ebc      
08021ec0      if (r0_6)
08021ec2          return (uint32_t)(uint8_t)r0_6;
08021ec2      
08021eca      void* var_4c;
08021eca      
08021eca      if (!var_4c)
08021ecc          return 6;
08021ecc      
08021ed4      if ((uint32_t)*(uint8_t*)((char*)var_4c + 0xb) << 0x1f < 0)
08021ed6          return 7;
08021ed6      
08021eee      uint32_t clst = (uint32_t)*(uint8_t*)((char*)var_4c + 0x1a)
08021eee          | (uint32_t)(uint16_t)((uint32_t)*(uint8_t*)((char*)var_4c + 0x1b) << 8) | (
08021eee          (uint32_t)*(uint8_t*)((char*)var_4c + 0x14)
08021eee          | (uint32_t)(uint16_t)((uint32_t)*(uint8_t*)((char*)var_4c + 0x15) << 8))
08021eee          << 0x10;
08021eee      
08021ef6      if ((uint32_t)*(uint8_t*)((char*)var_4c + 0xb) << 0x1b < 0)
08021ef6      {
08021efa          if (clst < 2)
08021efc              return 2;
08021efc          
08021f06          DIR_Compat dp;
08021f06          memcpy_n(&dp, &var_60, 0x24);
08021f0a          dp.dir = clst;
08021f14          uint32_t r0_13 = (uint32_t)ff_dir_seek(&dp, 2);
08021f14          
08021f18          if (r0_13)
08021f1a              return (uint32_t)(uint8_t)r0_13;
08021f1a          
08021f24          uint32_t r0_16 = (uint32_t)ff_dir_advance_collect_lfn(&dp);
08021f24          
08021f28          if (!r0_16)
08021f2a              r0_16 = 7;
08021f2a          
08021f2c          uint32_t r0_17 = (uint32_t)(uint8_t)r0_16;
08021f2c          
08021f30          if (r0_17 != 4)
08021f32              return (uint32_t)(uint8_t)r0_17;
08021ef6      }
08021ef6      
08021f3c      uint32_t r0_20 = (uint32_t)ff_dir_delete_reserved(&var_60);
08021f3c      
08021f40      if (!r0_20)
08021f40      {
08021f44          if (clst)
08021f4a              r0_20 = ff_remove_chain(var_60, clst);
08021f4a          
08021f4e          r0_20 = (uint32_t)(uint8_t)r0_20;
08021f4e          
08021f52          if (!r0_20)
08021f56              r0_20 = ff_sync(var_60);
08021f40      }
08021f40      
08021f5a      return (uint32_t)(uint8_t)r0_20;
08021e94  }
08021f60  00 00 00 00                                                                                      ....
08021f64  int32_t data_8021f64 = 0x41615252
08021f68  int32_t data_8021f68 = 0x61417272
08021f6c  int32_t data_8021f6c = 0x2000e414
08021f70  int32_t data_8021f70 = 0x2000d450
08021f74    int32_t sub_8021f74(int32_t arg1, void* arg2)
08021f74  {
08021f7e      if (arg1 == 0xa)
08021f84          sub_8021f74(0xd, arg2);
08021f84      
08021f8a      if (!arg2)
08021f8c          return arg1;
08021f8c      
08021f92      char buf = (uint8_t)arg1;
08021f9e      uint32_t bw;
08021f9e      f_write(arg2, &buf, 1, &bw);
08021f9e      
08021fa6      if (bw)
08021fac          return arg1;
08021fac      
08021fa8      return 0xffffffff;
08021f74  }
08021fb0    int32_t sub_8021fb0(char* arg1, void* arg2)
08021fb0  {
08021fb2      char* r4 = arg1;
08021fb6      int32_t result = 0;
08021fb6      
08021fc2      while (true)
08021fc2      {
08021fc2          if (!(uint32_t)*(uint8_t*)r4)
08021fd8              return result;
08021fd8          
08021fd0          if (sub_8021f74((uint32_t)*(uint8_t*)r4, arg2) == 0xffffffff)
08021fd0              break;
08021fd0          
08021fba          r4 = &r4[1];
08021fbc          result += 1;
08021fc2      }
08021fc2      
08021fd2      return 0xffffffff;
08021fb0  }
08021fdc    int32_t sub_8021fdc(void* arg1, char* arg2, int32_t arg3)
08021fdc  {
08021fdc      int32_t r3;
08021fdc      int32_t var_4 = r3;
08021fdc      int32_t var_8 = arg3;
08021fde      int32_t var_24 = r3;
08021fde      int32_t var_28 = arg3;
08021fde      char* var_2c = arg2;
08021fde      void* var_30 = arg1;
08021fe4      char* r6 = arg2;
08021fe6      int32_t* r7 = &var_8;
08021fe8      int32_t r4 = 0;
08021fea      int32_t i = 0;
08021fea      
08021ffe      while (i != 0xffffffff)
08021ffe      {
08022000          char r2 = *(uint8_t*)r6;
08022002          r6 = &r6[1];
08022004          uint32_t r2_1 = (uint32_t)r2;
08022004          
08022008          if (!r2_1)
08022008              break;
08022008          
08022014          uint32_t r2_2 = (uint32_t)(uint8_t)r2_1;
08022014          
08022018          if (r2_2 == 0x25)
08022018          {
08022030              int32_t r1_2 = 0;
08022032              int32_t r3_1 = 0;
08022034              char r2_4 = *(uint8_t*)r6;
08022036              r6 = &r6[1];
08022038              uint32_t r2_5 = (uint32_t)r2_4;
08022038              
0802203c              if (r2_5 == 0x30)
0802203c              {
0802203e                  r1_2 = 1;
08022040                  r2_5 = (uint32_t)*(uint8_t*)r6;
08022042                  r6 = &r6[1];
0802203c              }
0802203c              
08022058              uint32_t r2_8;
08022058              
08022058              while (true)
08022058              {
08022058                  r2_8 = (uint32_t)(uint8_t)r2_5;
08022058                  
08022062                  if (r2_8 - 0x30 >= 0xa)
08022062                      break;
08022062                  
08022050                  r3_1 = (uint32_t)(uint8_t)r2_8 + 0xa * r3_1 - 0x30;
08022054                  r2_5 = (uint32_t)*(uint8_t*)r6;
08022056                  r6 = &r6[1];
08022058              }
08022058              
08022064              uint32_t r2_9 = (uint32_t)(uint8_t)r2_8;
08022064              
08022068              if (r2_9 == 0x6c)
08022068              {
0802206a                  r1_2 |= 2;
0802206e                  r2_9 = (uint32_t)*(uint8_t*)r6;
08022070                  r6 = &r6[1];
08022068              }
08022068              
08022072              uint32_t r2_10 = (uint32_t)(uint8_t)r2_9;
08022072              
08022076              if (r2_10 != 0x73)
08022076              {
08022084                  uint32_t r2_11 = (uint32_t)(uint8_t)r2_10;
08022084                  
08022088                  if (r2_11 != 0x63)
08022088                  {
0802209e                      char r12_2 = 0;
080220a2                      uint32_t r2_12 = (uint32_t)(uint8_t)r2_11;
080220a2                      
080220a6                      if (r2_12 == 0x64)
080220a8                          r12_2 = 0xa;
080220a8                      
080220ac                      uint32_t r2_13 = (uint32_t)(uint8_t)r2_12;
080220ac                      
080220b0                      if (r2_13 == 0x75)
080220b2                          r12_2 = 0xa;
080220b2                      
080220b6                      uint32_t r2_14 = (uint32_t)(uint8_t)r2_13;
080220b6                      
080220ba                      if (r2_14 == 0x58)
080220bc                          r12_2 = 0x10;
080220bc                      
080220c0                      uint32_t r12_4 = (uint32_t)r12_2;
080220c0                      
080220c8                      if (!r12_4)
080220c8                          break;
080220c8                      
080220cc                      uint32_t j;
080220cc                      
080220cc                      if (r1_2 << 0x1e >= 0)
080220cc                      {
080220d6                          r2_14 = (uint32_t)(uint8_t)r2_14;
080220d6                          
080220da                          if (r2_14 != 0x64)
080220da                          {
080220e4                              j = *(uint32_t*)r7;
080220e8                              r7 = &r7[1];
080220da                          }
080220da                          else
080220da                          {
080220dc                              j = *(uint32_t*)r7;
080220e0                              r7 = &r7[1];
080220da                          }
080220cc                      }
080220cc                      else
080220cc                      {
080220ce                          j = *(uint32_t*)r7;
080220d2                          r7 = &r7[1];
080220cc                      }
080220cc                      
080220f4                      if ((uint32_t)(uint8_t)r2_14 == 0x64 && j < 0)
080220f4                      {
080220f6                          j = 0 - j;
080220fa                          r1_2 |= 4;
080220f4                      }
080220f4                      
080220fe                      int32_t j_1 = 0xf;
08022104                      *(uint8_t*)((char*)var_24)[3] = 0;
08022104                      
08022136                      do
08022136                      {
08022108                          uint32_t r12_3 = (uint32_t)(uint8_t)r12_4;
08022116                          uint32_t r2_19 = (uint32_t)((uint8_t)j
08022116                              - (uint8_t)r12_3 * (char)(j / r12_3) + 0x30);
08022116                          
0802211a                          if (r2_19 >= 0x3a)
0802211c                              r2_19 += 7;
0802211c                          
0802211e                          j_1 -= 1;
08022122                          *(uint8_t*)(&var_30 + j_1) = (char)r2_19;
08022126                          r12_4 = (uint32_t)(uint8_t)r12_3;
0802212a                          j u/= r12_4;
0802212a                          
08022130                          if (!j_1)
08022130                              break;
08022136                      } while (j);
08022136                      
0802213e                      if (j_1 && r1_2 << 0x1d < 0)
0802213e                      {
08022140                          j_1 -= 1;
08022146                          *(uint8_t*)(&var_30 + j_1) = 0x2d;
0802213e                      }
0802213e                      
0802215a                      while (j_1)
0802215a                      {
08022160                          if (0xf - r3_1 >= j_1)
08022160                              break;
08022160                          
08022164                          int32_t j_2 = j_1 - 1;
08022168                          j_1 = j_2;
0802216c                          char r2_21;
0802216c                          
0802216c                          r2_21 = r1_2 << 0x1f >= 0 ? 0x20 : 0x30;
0802216c                          
08022154                          *(uint8_t*)(&var_30 + j_2) = r2_21;
0802215a                      }
0802215a                      
08021ff4                      i = sub_8021fb0(j_1 + &var_30, arg1);
08022088                  }
08022088                  else
08022088                  {
0802208a                      int32_t r0_3 = *(uint32_t*)r7;
0802208c                      r7 = &r7[1];
08022090                      i = sub_8021f74(r0_3, arg1);
08022090                      
08022098                      if (i != 0xffffffff)
0802209a                          i = 1;
08022088                  }
08022076              }
08022076              else
08022076              {
08022078                  char* r0_2 = *(uint32_t*)r7;
0802207a                  r7 = &r7[1];
0802207e                  i = sub_8021fb0(r0_2, arg1);
08022076              }
08022018          }
08022018          else
08022018          {
08022020              i = sub_8021f74((uint32_t)(uint8_t)r2_2, arg1);
08022020              
08022028              if (i != 0xffffffff)
0802202a                  i = 1;
08022018          }
08022018          
08021ff8          r4 += i;
08021ffe      }
08021ffe      
0802200e      if (i != 0xffffffff)
08022172          return r4;
08022172      
0802217a      return i;
08021fdc  }
0802217e    int32_t sub_802217e() __pure
0802217e  {
08022180      return 0;
0802217e  }
08022182    int32_t sub_8022182(char* arg1)
08022182  {
08022184      *(uint8_t*)arg1 = 8;
08022188      return 1;
08022182  }
0802218a    int32_t sub_802218a() __pure
0802218a  {
0802218a      return;
0802218a  }
0802218c    uint8_t disk_initialize(uint8_t pdrv)
0802218c  {
0802218c      int32_t r7;
0802218c      int32_t var_8 = r7;
0802218c      
08022196      if (sub_802265c(0x20000740))
080221a2          data_20000de9 &= 0xfe;
080221a2      
080221a8      return data_20000de9;
0802218c  }
080221aa  // // Returns DSTATUS bitfield. Code checks (status<<31)<0 → STA_NOINIT, and
080221aa  // // (status<<29)<0 → STA_PROTECT, exactly like FatFs expects.
080221aa  
080221aa    uint8_t disk_status(uint8_t pdrv)
080221aa  {
080221ae      if (!(uint32_t)pdrv)
080221b6          return data_20000de9;
080221b6      
080221b0      return 1;
080221aa  }
080221ba    int32_t disk_read(uint8_t pdrv, uint8_t* buff, uint32_t sector, uint32_t count)
080221ba  {
080221ba      uint32_t count_1 = count;
080221c2      uint32_t i = 0;
080221c2      
080221c8      if (!(uint32_t)pdrv)
080221c8      {
080221ca          uint32_t r6_1 = (uint32_t)(uint8_t)count;
080221ca          
080221ce          if (r6_1)
080221ce          {
080221da              if ((uint32_t)data_20000de9 << 0x1f < 0)
080221dc                  return 3;
080221dc              
080221e8              if (sub_802265c(0x20000740))
080221e8              {
0802221c                  do
0802221c                  {
080221ea                      r6_1 = (uint32_t)(uint8_t)r6_1;
080221fa                      char i_1 = sub_8022d44(0x20000740, buff, sector, 0x200 * r6_1);
08022206                      sub_8022ea0(0x20000740, 0x20000b78, 0x2000dd28);
08022206                      
08022212                      if (!sub_802265c(0x20000740))
08022214                          return 1;
08022214                      
08022218                      i = (uint32_t)i_1;
0802221c                  } while (i == 3);
080221e8              }
080221e8              
08022222              if ((uint32_t)(uint8_t)i)
08022228                  return 1;
08022228              
08022224              return 0;
080221ce          }
080221c8      }
080221c8      
080221d0      return 4;
080221ba  }
0802222c    int32_t disk_write(char arg1, int32_t arg2, int32_t arg3, int32_t arg4)
0802222c  {
0802222c      int32_t var_18 = arg4;
08022234      uint32_t i = 0;
08022234      
0802223a      if (!(uint32_t)arg1)
0802223a      {
0802223c          uint32_t r6_1 = (uint32_t)(uint8_t)arg4;
0802223c          
08022240          if (r6_1)
08022240          {
0802224c              if ((uint32_t)data_20000de9 << 0x1f < 0)
0802224e                  return 3;
0802224e              
08022258              if ((uint32_t)data_20000de9 << 0x1d < 0)
0802225a                  return 2;
0802225a              
08022266              if (sub_802265c(0x20000740))
08022266              {
0802229a                  do
0802229a                  {
08022268                      r6_1 = (uint32_t)(uint8_t)r6_1;
08022278                      char i_1 = sub_8022c6a(0x20000740, arg2, arg3, 0x200 * r6_1);
08022284                      sub_8022ea0(0x20000740, 0x20000b78, 0x2000dd28);
08022284                      
08022290                      if (!sub_802265c(0x20000740))
08022292                          return 1;
08022292                      
08022296                      i = (uint32_t)i_1;
0802229a                  } while (i == 3);
08022266              }
08022266              
080222a0              if ((uint32_t)(uint8_t)i)
080222a6                  return 1;
080222a6              
080222a2              return 0;
08022240          }
0802223a      }
0802223a      
08022242      return 4;
0802222c  }
080222aa    uint32_t disk_ioctl(char arg1, char arg2, int32_t* arg3)
080222aa  {
080222b0      if ((uint32_t)arg1)
080222b2          return 4;
080222b2      
080222b6      char r3 = 1;
080222b6      
080222be      if ((uint32_t)data_20000de9 << 0x1f < 0)
080222c0          return 3;
080222c0      
080222c4      uint32_t r1 = (uint32_t)arg2;
080222c4      
080222c8      if (!r1)
080222d6          r3 = 0;
080222c8      else if (r1 == 2)
080222cc      {
080222e8          *(uint16_t*)arg3 = 0x200;
080222ea          r3 = 0;
080222cc      }
080222cc      else if (r1 < 2)
080222ce      {
080222de          *(uint32_t*)arg3 = data_2000e278;
080222e0          r3 = 0;
080222ce      }
080222ce      else if (r1 == 3)
080222f2          *(uint32_t*)arg3 = 0x200;
080222d2      else
080222f6          r3 = 4;
080222f6      
080222fa      return (uint32_t)r3;
080222aa  }
080222fe                                                                                            00 00                                ..
08022300  int32_t data_8022300 = 0x20000740
08022304  int32_t data_8022304 = 0x20000de9
08022308  int32_t data_8022308 = 0x2000dd28
0802230c  int32_t data_802230c = 0x20000b78
08022310  int32_t data_8022310 = 0x2000e278
08022314    uint32_t sub_8022314(int16_t arg1, int32_t arg2)
08022314  {
08022314      uint32_t r0_7 = (uint32_t)arg1;
08022318      uint16_t r1;
08022318      
08022318      if (r0_7 < 0x80)
0802231a          r1 = (uint16_t)r0_7;
08022318      else if (!arg2)
08022320      {
0802233c          int16_t r1_1 = 0;
08022342          uint32_t r1_2;
08022342          
08022342          while (true)
08022342          {
08022342              r1_2 = (uint32_t)r1_1;
08022342              
08022346              if (r1_2 >= 0x80)
08022346                  break;
08022346              
0802234c              r1_2 = (uint32_t)(uint16_t)r1_2;
0802234c              
08022356              if ((uint32_t)(uint16_t)r0_7
08022356                      == (uint32_t)*(uint16_t*)(&data_803a7f8 + (r1_2 << 1)))
08022356                  break;
08022356              
08022340              r1_1 = (uint16_t)r1_2 + 1;
08022342          }
08022342          
0802235c          r1 = (uint16_t)((uint8_t)r1_2 - 0x80);
08022320      }
08022320      else
08022320      {
08022322          uint32_t r0 = (uint32_t)(uint16_t)r0_7;
08022322          
08022326          if (r0 <= 0xff)
08022338              r1 = *(uint16_t*)(((uint32_t)(uint16_t)r0 << 1) + SystemInit+0x54);
08022326          else
08022328              r1 = 0;
08022320      }
08022320      
08022364      return (uint32_t)r1;
08022314  }
08022366    uint32_t sub_8022366(int16_t arg1)
08022366  {
08022366      int32_t r1 = 0;
08022366      
08022374      while ((uint32_t)*(uint16_t*)(&data_803a2e4 + (r1 << 1)))
08022374      {
08022382          if ((uint32_t)arg1 == (uint32_t)*(uint16_t*)(&data_803a2e4 + (r1 << 1)))
08022382              break;
08022382          
0802236a          r1 += 1;
08022374      }
08022374      
0802238c      if ((uint32_t)*(uint16_t*)(&data_803a2e4 + (r1 << 1)))
08022390          arg1 = *(uint16_t*)(&data_803a4c4 + (r1 << 1));
08022390      
08022398      return (uint32_t)arg1;
08022366  }
0802239a                                                                                00 00                                        ..
0802239c  int32_t data_802239c = 0x803a7f8
080223a0  int32_t data_80223a0 = 0x803a2e4
080223a4  int32_t data_80223a4 = 0x803a4c4
080223a8    int32_t sub_80223a8() __pure
080223a8  {
080223aa      return 0;
080223a8  }
080223ac    int32_t sub_80223ac(void* arg1, int32_t arg2, char* arg3)
080223ac  {
080223ac      int32_t r3;
080223ac      int32_t var_18 = r3;
080223b8      sub_8022746(arg3, 0);
080223b8      
080223c4      if ((int32_t)arg3[0x38] != 0xffffffff)
080223c4      {
080223f8          uint32_t r7_2 = (uint32_t)arg3[8];
080223f8          
08022402          if (!sub_802265c(arg1))
08022402          {
08022404              r7_2 = (uint32_t)(uint8_t)r7_2;
08022404              
08022408              if (r7_2)
08022408              {
0802240a                  r7_2 = (uint32_t)(uint8_t)r7_2;
0802240a                  
0802240e                  if (r7_2 != 2)
0802240e                  {
08022412                      arg3[8] = 2;
08022414                      r7_2 = 2;
08022418                      *(uint8_t*)arg3 = 2;
0802240e                  }
08022408              }
08022402          }
08022402          
0802242a          (*(uint32_t*)(&data_200005cc + ((uint32_t)(uint8_t)r7_2 << 2)))(arg1, arg2, arg3);
080223c4      }
080223c4      else
080223c4      {
080223c6          uint32_t r7 = (uint32_t)*(uint8_t*)arg3;
080223c6          
080223d0          if (!sub_802265c(arg1))
080223d0          {
080223d2              r7 = (uint32_t)(uint8_t)r7;
080223d2              
080223d6              if (r7)
080223d6              {
080223d8                  r7 = (uint32_t)(uint8_t)r7;
080223d8                  
080223dc                  if (r7 != 2)
080223dc                  {
080223e0                      *(uint8_t*)arg3 = 2;
080223e2                      r7 = 2;
080223dc                  }
080223d6              }
080223d0          }
080223d0          
080223f4          (*(uint32_t*)(&data_200005cc + ((uint32_t)(uint8_t)r7 << 2)))(arg1, arg2, arg3);
080223c4      }
080223c4      
0802242e      return 0;
080223ac  }
08022430    uint32_t sub_8022430(void* arg1, int32_t arg2, char* arg3)
08022430  {
08022442      uint32_t result;
08022442      
08022442      if (sub_802265c(arg1))
08022442      {
08022446          result = (uint32_t)*(uint8_t*)arg3;
08022450          sub_8022786(arg1, arg2, arg3, 0, (uint8_t)result);
08022450          
0802245a          if (*(uint32_t*)((char*)arg1 + 0x434))
08022462              (*(uint32_t*)((char*)arg1 + 0x434))(0x64);
08022442      }
08022442      
08022464      return result;
08022430  }
08022466    uint32_t sub_8022466(void* arg1, void* arg2, uint32_t arg3)
08022466  {
08022466      uint32_t r3;
08022466      uint32_t var_14_1 = r3;
08022466      uint32_t result = arg3;
0802246c      char* r6 = arg3;
08022472      (*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 8))();
0802247c      *(uint8_t*)((char*)arg2 + 9) = sub_802341a(arg1, 0);
08022486      *(uint8_t*)((char*)arg2 + 8) = sub_802341a(arg1, 0x80);
08022486      
08022490      if (!sub_8023914(arg1))
08022490      {
08022496          (*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 0xc))();
080224a4          *(uint8_t*)((char*)arg2 + 0x1d) = (char)(*(uint32_t*)0x50000440 >> 0x11) & 3;
080224ac          (*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 0x18))((uint32_t)
080224ac              *(uint8_t*)((char*)arg2 + 0x1d));
080224c0          sub_8023384(arg1, *(uint8_t*)((char*)arg2 + 8), *(uint8_t*)((char*)arg2 + 0x1c), 
080224c0              *(uint8_t*)((char*)arg2 + 0x1d), 0, (uint16_t)*(uint8_t*)((char*)arg2 + 0xa));
080224d6          sub_8023384(arg1, *(uint8_t*)((char*)arg2 + 9), *(uint8_t*)((char*)arg2 + 0x1c), 
080224d6              *(uint8_t*)((char*)arg2 + 0x1d), 0, (uint16_t)*(uint8_t*)((char*)arg2 + 0xa));
080224dc          result = (uint32_t)*(uint8_t*)r6;
080224e6          sub_8022786(arg1, arg2, r6, 1, (uint8_t)result);
08022490      }
08022490      
080224ea      return result;
08022466  }
080224ec    uint32_t sub_80224ec(int32_t arg1, void* arg2, char* arg3)
080224ec  {
08022502      uint32_t result;
08022502      
08022502      if (!sub_8023d20(arg1, arg2, arg3))
08022502      {
08022508          (*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 0x34))();
0802250c          result = (uint32_t)*(uint8_t*)arg3;
08022516          sub_8022786(arg1, arg2, arg3, 2, (uint8_t)result);
08022502      }
08022502      
0802251a      return result;
080224ec  }
0802251c    uint32_t sub_802251c(int32_t arg1, void* arg2, char* arg3)
0802251c  {
0802252e      uint32_t result;
0802252e      
0802252e      if ((*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 0x38))() == 1
0802252e          && !(*(uint32_t*)((char*)arg2 + 0x6c))(arg1, arg2))
0802252e      {
0802253e          result = (uint32_t)*(uint8_t*)arg3;
08022548          sub_8022786(arg1, arg2, arg3, 3, (uint8_t)result);
0802252e      }
0802252e      
0802254c      return result;
0802251c  }
0802254e    uint32_t sub_802254e(int32_t arg1, int32_t arg2, char* arg3)
0802254e  {
08022564      uint32_t result;
08022564      
08022564      if (!sub_802284e())
08022564      {
08022568          result = (uint32_t)*(uint8_t*)arg3;
08022572          sub_8022786(arg1, arg2, arg3, 4, (uint8_t)result);
08022564      }
08022564      
08022576      return result;
0802254e  }
08022578    int32_t sub_8022578(int32_t arg1 @ r7)
08022578  {
0802257a      sub_8022858();
0802257e      return arg1;
08022578  }
08022580    int32_t sub_8022580() __pure
08022580  {
08022580      return;
08022580  }
08022582    uint32_t sub_8022582(void* arg1, void* arg2, char* arg3)
08022582  {
08022592      sub_802267e(arg1, arg2, 0x2000dd28);
0802259a      (*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 4))();
080225a4      (*(uint32_t*)((char*)arg2 + 0x70))(arg1, (char*)arg2 + 0x1c);
080225a6      uint32_t result = (uint32_t)*(uint8_t*)arg3;
080225b2      sub_8022786(arg1, arg2, arg3, 7, (uint8_t)result);
080225b6      return result;
08022582  }
080225b8    uint32_t sub_80225b8(void* arg1, void* arg2, char* arg3)
080225b8  {
080225c6      (*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 0x10))();
080225ce      sub_802267e(arg1, arg2, 0x2000dd28);
080225d6      (*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 4))();
080225e0      (*(uint32_t*)((char*)arg2 + 0x70))(arg1, (char*)arg2 + 0x1c);
080225e4      sub_8023470(arg1);
080225e8      uint32_t result = (uint32_t)*(uint8_t*)arg3;
080225f4      sub_8022786(arg1, arg2, arg3, 7, (uint8_t)result);
080225f8      return result;
080225b8  }
080225fa    int32_t sub_80225fa() __pure
080225fa  {
080225fa      return;
080225fa  }
080225fc    int32_t sub_80225fc(void* arg1)
080225fc  {
080225fe      *(uint8_t*)((char*)arg1 + 0x20c) = 1;
08022604      return 0;
080225fc  }
08022606    int32_t sub_8022606(void* arg1)
08022606  {
08022608      *(uint8_t*)((char*)arg1 + 0x20c) = 0;
0802260e      return 0;
08022606  }
08022610    int32_t sub_8022610() __pure
08022610  {
08022612      return 0;
08022610  }
08022614    int32_t sub_8022614(char* arg1, char arg2)
08022614  {
0802261a      arg1[0x20c] = 0;
08022620      *(uint16_t*)(arg1 + 0x216) = 8;
08022628      sub_802356c(arg1, arg2);
08022636      *(uint32_t*)0x50000008 = *(uint32_t*)0x50000008 >> 1 << 1;
0802263a      sub_80235b2(arg1);
08022642      sub_8023716(arg1, 1);
08022648      sub_802377c(arg1);
08022656      *(uint32_t*)0x50000008 |= 1;
0802265a      return 0;
08022614  }
0802265c    uint32_t sub_802265c(void* arg1)
0802265c  {
08022660      return (uint32_t)*(uint8_t*)((char*)arg1 + 0x20c);
0802265c  }
08022662    uint32_t sub_8022662(void* arg1, char arg2)
08022662  {
0802266e      return (uint32_t)*(uint8_t*)((char*)arg1 + 0x24 * (uint32_t)arg2 + 0x231);
08022662  }
08022670    int32_t sub_8022670(void* arg1, char arg2)
08022670  {
0802267c      return *(uint32_t*)((char*)arg1 + 0x24 * (uint32_t)arg2 + 0x224);
08022670  }
0802267e    int32_t sub_802267e(void* arg1, void* arg2, char* arg3)
0802267e  {
08022688      *(uint8_t*)((char*)arg2 + 0xa) = 0x40;
0802268c      *(uint8_t*)((char*)arg2 + 0x1c) = 0;
08022690      *(uint8_t*)((char*)arg2 + 0x1d) = 1;
08022696      sub_8023448(arg1, *(uint8_t*)((char*)arg2 + 8));
0802269e      sub_8023448(arg1, *(uint8_t*)((char*)arg2 + 9));
080226a4      sub_80226e0(arg3);
080226b0      sub_8022724(arg3, 0x200005f4, 0, 9);
080226bc      sub_8022724(arg3, 0x200006f0, 1, 0xa);
080226c8      sub_8022724(arg3, 0x20000658, 3, 0xd);
080226d0      sub_8022746(arg3, 0);
080226d8      sub_8022782(arg3, 0);
080226de      return 0;
0802267e  }
080226e0    int32_t sub_80226e0(char* arg1)
080226e0  {
080226e2      *(uint8_t*)arg1 = 0;
080226e6      *(uint32_t*)(arg1 + 4) = 0;
080226ea      arg1[1] = 0;
080226f0      arg1[0x38] = 0xff;
080226f6      arg1[8] = 0;
080226fa      arg1[0x10] = 0;
080226fe      *(uint32_t*)(arg1 + 0xc) = 0;
08022702      arg1[0xb4] = 0;
08022708      *(uint32_t*)(arg1 + 0x40) = 0;
0802270c      arg1[0x44] = 0;
08022712      arg1[0x3c] = 0;
0802271a      data_2000e45e = 0;
08022720      data_2000e465 = 0;
08022722      return 0;
080226e0  }
08022724    void sub_8022724(void* arg1, int32_t arg2, char arg3, char arg4)
08022724  {
08022730      void* r4_3 = 0xc * (uint32_t)*(uint8_t*)((char*)arg1 + 0xb4) + arg1 + 0x3c;
08022732      *(uint8_t*)r4_3 = arg3;
08022734      *(uint32_t*)((char*)r4_3 + 4) = arg2;
08022736      *(uint8_t*)((char*)r4_3 + 8) = arg4;
0802273e      *(uint8_t*)((char*)arg1 + 0xb4) += 1;
08022724  }
08022746    void sub_8022746(void* arg1, char arg2)
08022746  {
0802274e      char r2 = 0;
0802274e      
0802275e      while ((uint32_t)r2 < (uint32_t)*(uint8_t*)((char*)arg1 + 0xb4))
0802275e      {
08022760          uint32_t r2_1 = (uint32_t)r2;
08022760          
08022774          if ((uint32_t)arg2 == (uint32_t)*(uint8_t*)(0xc * r2_1 + arg1 + 0x3c))
08022774          {
08022778              *(uint32_t*)((char*)arg1 + 4) = *(uint32_t*)(0xc * r2_1 + arg1 + 0x40);
0802277c              *(uint8_t*)((char*)arg1 + 1) = *(uint8_t*)(0xc * r2_1 + arg1 + 0x44);
0802277c              break;
08022774          }
08022774          
08022752          r2 = (uint8_t)r2_1 + 1;
0802275e      }
08022746  }
08022782    void sub_8022782(char* arg1, char arg2)
08022782  {
08022782      *(uint8_t*)arg1 = arg2;
08022782  }
08022786    int32_t sub_8022786(int32_t arg1, int32_t arg2, char* arg3, char arg4, char arg5)
08022786  {
0802278e      int32_t r5 = 0;
08022792      char* r7 = *(uint32_t*)(arg3 + 4);
08022794      int32_t r12 = 0;
08022798      char r4 = arg5;
08022798      
080227ae      while ((uint32_t)(uint8_t)r12 < (uint32_t)arg3[1])
080227ae      {
080227bc          if ((uint32_t)r4 != (uint32_t)*(uint8_t*)r7)
0802279c              r7 = &r7[8];
080227bc          else
080227bc          {
080227ca              if ((uint32_t)arg4 == (uint32_t)r7[1])
080227ca              {
080227cc                  r4 = r7[2];
080227ce                  r5 = *(uint32_t*)(r7 + 4);
080227ce                  break;
080227ca              }
080227ca              
080227ea              r7 = &r7[8];
080227bc          }
080227bc          
0802279e          r12 += 1;
080227ae      }
080227ae      
080227d0      *(uint32_t*)(arg3 + 4) = *(uint32_t*)(arg3 + 4);
080227d0      
080227d6      if (r5)
080227d6      {
080227e0          if (r5 != sub_802288c)
080227ee              return r5();
080227ee          
080227e2          *(uint8_t*)arg3 = r4;
080227d6      }
080227d6      
080227e4      return 1;
08022786  }
080227f2    void sub_80227f2(char* arg1)
080227f2  {
080227f8      if ((int32_t)arg1[0x38] >= 4)
080227f8          return;
080227f8      
08022800      arg1[0x38] += 1;
08022810      char* r1_5 = (int16_t)arg1[0x38] * 0xc + arg1 + 8;
08022814      *(uint8_t*)r1_5 = *(uint8_t*)arg1;
08022818      *(uint32_t*)(r1_5 + 4) = *(uint32_t*)(arg1 + 4);
0802281c      r1_5[8] = arg1[1];
080227f2  }
08022820    void sub_8022820(char* arg1)
08022820  {
0802282c      void* r1_2 = (int16_t)arg1[0x38] * 0xc + arg1 + 8;
0802282c      
08022834      if ((int32_t)arg1[0x38] < 0)
08022834          return;
08022834      
08022838      *(uint8_t*)arg1 = *(uint8_t*)r1_2;
0802283c      *(uint32_t*)(arg1 + 4) = *(uint32_t*)((char*)r1_2 + 4);
08022840      arg1[1] = *(uint8_t*)((char*)r1_2 + 8);
08022848      arg1[0x38] -= 1;
08022820  }
0802284e    int32_t sub_802284e()
0802284e  {
0802284e      int32_t r7;
0802284e      int32_t var_8 = r7;
08022856      return data_200006c0();
0802284e  }
08022858    int32_t sub_8022858()
08022858  {
08022858      int32_t r7;
08022858      int32_t var_8 = r7;
08022860      return data_200006c4();
08022858  }
08022862        00 00                                                                                        ..
08022864  int32_t data_8022864 = 0x200005cc
08022868  int32_t data_8022868 = 0x50000440
0802286c  int32_t data_802286c = 0x2000dd28
08022870  int32_t data_8022870 = 0x50000008
08022874  int32_t data_8022874 = 0x200005f4
08022878  int32_t data_8022878 = 0x200006f0
0802287c  int32_t data_802287c = 0x20000658
08022880  int32_t data_8022880 = 0x2000e45e
08022884  int32_t data_8022884 = 0x2000e465
08022888  int32_t data_8022888 = 0x200006c0
0802288c    int32_t sub_802288c() __pure
0802288c  {
0802288e      return 0;
0802288c  }
08022890    int32_t sub_8022890(int32_t arg1, int32_t arg2, char* arg3)
08022890  {
08022890      int32_t r7;
08022890      int32_t var_8 = r7;
08022894      sub_8022820(arg3);
0802289a      return 0;
08022890  }
0802289c    uint32_t sub_802289c(void* arg1)
0802289c  {
0802289e      char r4 = 3;
0802289e      
080228a6      if (sub_802265c(arg1))
080228a6      {
080228ac          uint32_t r0_1 = (uint32_t)data_2000e26b;
080228ac          
080228b0          if (r0_1 == 1)
080228b0          {
080228be              data_2000e0b0 = 0;
080228c6              data_2000e0b4 = 0;
080228ce              data_2000e0b6 = 6;
080228d8              data_2000e270 = &data_2000e258;
080228e0              data_2000e274 = 0x3f;
080228e8              data_2000e26a = 3;
080228ea              char r0_2 = 0x10;
080228ea              
080228fc              while (true)
080228fc              {
080228fc                  uint32_t r0_4 = (uint32_t)r0_2;
080228fc                  
08022900                  if (!r0_4)
08022900                      break;
08022900                  
080228f4                  uint32_t r0_3 = (uint32_t)(uint8_t)r0_4;
080228f8                  (&data_2000e0b7)[r0_3] = 0;
080228fa                  r0_2 = (uint8_t)r0_3 - 1;
080228fc              }
080228fc              
08022908              data_2000e0b7 = 0;
08022910              data_2000e26c = 1;
08022918              data_2000e268 = 7;
08022920              data_2000e277 = 3;
08022928              data_2000e26b = 2;
0802292a              r4 = 3;
080228b0          }
080228b0          else if (r0_1 == 2)
080228b4          {
08022936              if (!(uint32_t)data_2000e277)
08022936              {
0802293e                  data_2000e26b = 1;
08022940                  r4 = 0;
08022936              }
08022936              else if ((uint32_t)data_2000e277 == 1)
0802294c              {
08022954                  data_2000e26b = 1;
08022956                  r4 = 1;
0802294c              }
0802294c              else if ((uint32_t)data_2000e277 == 2)
08022962              {
0802296a                  data_2000e26b = 1;
0802296c                  r4 = 2;
08022962              }
080228b4          }
080228a6      }
080228a6      
08022974      return (uint32_t)r4;
0802289c  }
08022976    uint32_t sub_8022976(void* arg1)
08022976  {
08022978      char r4 = 3;
08022978      
08022980      if (sub_802265c(arg1))
08022980      {
08022988          uint32_t r0_1 = (uint32_t)data_2000e26b;
08022988          
0802298c          if (r0_1 == 1)
0802298c          {
0802299a              data_2000e0b0 = 8;
080229a2              data_2000e0b4 = 0x80;
080229aa              data_2000e0b6 = 0xa;
080229b4              data_2000e270 = &data_2000d650;
080229bc              data_2000e26a = 4;
080229be              char r0_2 = 0x10;
080229be              
080229d0              while (true)
080229d0              {
080229d0                  uint32_t r0_4 = (uint32_t)r0_2;
080229d0                  
080229d4                  if (!r0_4)
080229d4                      break;
080229d4                  
080229c8                  uint32_t r0_3 = (uint32_t)(uint8_t)r0_4;
080229cc                  (&data_2000e0b7)[r0_3] = 0;
080229ce                  r0_2 = (uint8_t)r0_3 - 1;
080229d0              }
080229d0              
080229dc              data_2000e0b7 = 0x25;
080229e4              data_2000e26c = 1;
080229ec              data_2000e268 = 7;
080229f4              data_2000e277 = 3;
080229fc              data_2000e26b = 2;
080229fe              r4 = 3;
0802298c          }
0802298c          else if (r0_1 == 2)
08022990          {
08022a0a              if (!(uint32_t)data_2000e277)
08022a0a              {
08022a16                  (*(int32_t*)((char*)data_2000e278 + 3)) = data_2000d650;
08022a22                  (*(int32_t*)((char*)data_2000e278 + 2)) = data_2000d651;
08022a2e                  (*(int32_t*)((char*)data_2000e278 + 1)) = data_2000d652;
08022a3a                  (*(uint8_t*)data_2000e278) = data_2000d653;
08022a46                  data_2000e281 = data_2000d656;
08022a52                  data_2000e280 = data_2000d657;
08022a5a                  data_2000e26b = 1;
08022a5c                  r4 = 0;
08022a0a              }
08022a0a              else if ((uint32_t)data_2000e277 == 1)
08022a68              {
08022a70                  data_2000e26b = 1;
08022a72                  r4 = 1;
08022a68              }
08022a68              else if ((uint32_t)data_2000e277 == 2)
08022a7e              {
08022a86                  data_2000e26b = 1;
08022a88                  r4 = 2;
08022a7e              }
08022990          }
08022980      }
08022980      
08022a90      return (uint32_t)r4;
08022976  }
08022a92    uint32_t sub_8022a92(void* arg1)
08022a92  {
08022a94      char r4 = 3;
08022a94      
08022a9c      if (sub_802265c(arg1))
08022a9c      {
08022aa2          uint32_t r0_1 = (uint32_t)data_2000e26b;
08022aa2          
08022aa6          if (r0_1 == 1)
08022aa6          {
08022ab4              data_2000e0b0 = 0x3f;
08022abc              data_2000e0b4 = 0x80;
08022ac4              data_2000e0b6 = 0xa;
08022ace              data_2000e270 = &data_2000d650;
08022ad6              data_2000e26a = 5;
08022ad8              char r0_2 = 0x10;
08022ad8              
08022aea              while (true)
08022aea              {
08022aea                  uint32_t r0_4 = (uint32_t)r0_2;
08022aea                  
08022aee                  if (!r0_4)
08022aee                      break;
08022aee                  
08022ae2                  uint32_t r0_3 = (uint32_t)(uint8_t)r0_4;
08022ae6                  (&data_2000e0b7)[r0_3] = 0;
08022ae8                  r0_2 = (uint8_t)r0_3 - 1;
08022aea              }
08022aea              
08022af6              data_2000e0b7 = 0x1a;
08022afe              data_2000e0b9 = 0x3f;
08022b06              data_2000e0bb = 0x3f;
08022b0e              data_2000e26c = 1;
08022b16              data_2000e268 = 7;
08022b1e              data_2000e277 = 3;
08022b26              data_2000e26b = 2;
08022b28              r4 = 3;
08022aa6          }
08022aa6          else if (r0_1 == 2)
08022aaa          {
08022b34              if (!(uint32_t)data_2000e277)
08022b34              {
08022b3e                  if ((uint32_t)data_2000d652 << 0x18 >= 0)
08022b50                      data_2000e284 = 0;
08022b3e                  else
08022b46                      data_2000e284 = 1;
08022b46                  
08022b58                  data_2000e26b = 1;
08022b5a                  r4 = 0;
08022b34              }
08022b34              else if ((uint32_t)data_2000e277 == 1)
08022b66              {
08022b6c                  data_2000e26b = 1;
08022b6e                  r4 = 1;
08022b66              }
08022b66              else if ((uint32_t)data_2000e277 == 2)
08022b78              {
08022b7e                  data_2000e26b = 1;
08022b80                  r4 = 2;
08022b78              }
08022aaa          }
08022a9c      }
08022a9c      
08022b88      return (uint32_t)r4;
08022a92  }
08022b8a    uint32_t sub_8022b8a(void* arg1)
08022b8a  {
08022b8c      char r4 = 3;
08022b8c      
08022b94      if (sub_802265c(arg1))
08022b94      {
08022b98          uint32_t r0_1 = (uint32_t)data_2000e26b;
08022b98          
08022b9c          if (r0_1 == 1)
08022b9c          {
08022ba8              data_2000e0b0 = 0x3f;
08022bae              data_2000e0b4 = 0x80;
08022bb4              data_2000e0b6 = 0xa;
08022bba              data_2000e270 = &data_2000d650;
08022bc2              data_2000e269 = data_2000e26a;
08022bc8              data_2000e26a = 6;
08022bca              char r0_3 = 0x10;
08022bca              
08022bda              while (true)
08022bda              {
08022bda                  uint32_t r0_5 = (uint32_t)r0_3;
08022bda                  
08022bde                  if (!r0_5)
08022bde                      break;
08022bde                  
08022bd2                  uint32_t r0_4 = (uint32_t)(uint8_t)r0_5;
08022bd6                  (&data_2000e0b7)[r0_4] = 0;
08022bd8                  r0_3 = (uint8_t)r0_4 - 1;
08022bda              }
08022bda              
08022be4              data_2000e0b7 = 3;
08022bea              data_2000e0b8 = 0;
08022bf0              data_2000e0bb = 0x3f;
08022bf6              data_2000e26c = 1;
08022bfc              data_2000e268 = 7;
08022c02              data_2000e277 = 3;
08022c08              data_2000e26b = 2;
08022c0a              r4 = 3;
08022b9c          }
08022b9c          else if (r0_1 == 2)
08022ba0          {
08022c14              if (!(uint32_t)data_2000e277)
08022c14              {
08022c1c                  data_2000e27f = data_2000d650;
08022c24                  data_2000e27e = data_2000d651;
08022c2c                  data_2000e27d = data_2000d652;
08022c34                  data_2000e27c = data_2000d653;
08022c3a                  data_2000e26b = 1;
08022c3c                  r4 = 0;
08022c14              }
08022c14              else if ((uint32_t)data_2000e277 == 1)
08022c46              {
08022c4c                  data_2000e26b = 1;
08022c4e                  r4 = 1;
08022c46              }
08022c46              else if ((uint32_t)data_2000e277 == 2)
08022c58              {
08022c5e                  data_2000e26b = 1;
08022c60                  r4 = 2;
08022c58              }
08022ba0          }
08022b94      }
08022b94      
08022c68      return (uint32_t)r4;
08022b8a  }
08022c6a    uint32_t sub_8022c6a(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
08022c6a  {
08022c6a      int32_t var_18 = arg2;
08022c70      char r6 = 3;
08022c70      
08022c78      if (sub_802265c(arg1))
08022c78      {
08022c7c          uint32_t r0_1 = (uint32_t)data_2000e26b;
08022c7c          
08022c80          if (r0_1 == 1)
08022c80          {
08022c8a              data_2000e0b0 = arg4;
08022c90              data_2000e0b4 = 0;
08022c96              data_2000e0b6 = 0xa;
08022c9a              data_2000e270 = arg2;
08022c9c              char r0_2 = 0x10;
08022c9c              
08022cac              while (true)
08022cac              {
08022cac                  uint32_t r0_4 = (uint32_t)r0_2;
08022cac                  
08022cb0                  if (!r0_4)
08022cb0                      break;
08022cb0                  
08022ca4                  uint32_t r0_3 = (uint32_t)(uint8_t)r0_4;
08022ca8                  (&data_2000e0b7)[r0_3] = 0;
08022caa                  r0_2 = (uint8_t)r0_3 - 1;
08022cac              }
08022cac              
08022cb6              data_2000e0b7 = 0x2a;
08022cbe              data_2000e0b9 = *(uint8_t*)((char*)arg3)[3];
08022cc6              data_2000e0ba = *(uint8_t*)((char*)arg3)[2];
08022cce              data_2000e0bb = *(uint8_t*)((char*)arg3)[1];
08022cd6              data_2000e0bc = (uint8_t)arg3;
08022cda              (uint16_t)var_18 = (int16_t)(arg4 >> 9);
08022ce4              data_2000e0be = *(uint8_t*)((char*)var_18)[1];
08022cec              data_2000e0bf = (uint8_t)var_18;
08022cf2              data_2000e26c = 1;
08022cf8              data_2000e268 = 7;
08022cfe              data_2000e277 = 3;
08022d04              data_2000e26b = 2;
08022d06              r6 = 3;
08022c80          }
08022c80          else if (r0_1 == 2)
08022c84          {
08022d10              if (!(uint32_t)data_2000e277)
08022d10              {
08022d16                  data_2000e26b = 1;
08022d18                  r6 = 0;
08022d10              }
08022d10              else if ((uint32_t)data_2000e277 == 1)
08022d28                  data_2000e26b = 1;
08022d22              else if ((uint32_t)data_2000e277 == 2)
08022d32              {
08022d38                  data_2000e26b = 1;
08022d3a                  r6 = 2;
08022d32              }
08022c84          }
08022c78      }
08022c78      
08022d42      return (uint32_t)r6;
08022c6a  }
08022d44    uint32_t sub_8022d44(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
08022d44  {
08022d44      int32_t var_18 = arg2;
08022d50      data_20000dea = 3;
08022d50      
08022d5a      if (sub_802265c(arg1))
08022d5a      {
08022d5e          uint32_t r0_2 = (uint32_t)data_2000e26b;
08022d5e          
08022d62          if (r0_2 == 1)
08022d62          {
08022d6c              data_2000e0b0 = arg4;
08022d72              data_2000e0b4 = 0x80;
08022d78              data_2000e0b6 = 0xa;
08022d7c              data_2000e270 = arg2;
08022d7e              char r0_3 = 0x10;
08022d7e              
08022d8e              while (true)
08022d8e              {
08022d8e                  uint32_t r0_5 = (uint32_t)r0_3;
08022d8e                  
08022d92                  if (!r0_5)
08022d92                      break;
08022d92                  
08022d86                  uint32_t r0_4 = (uint32_t)(uint8_t)r0_5;
08022d8a                  (&data_2000e0b7)[r0_4] = 0;
08022d8c                  r0_3 = (uint8_t)r0_4 - 1;
08022d8e              }
08022d8e              
08022d98              data_2000e0b7 = 0x28;
08022da0              data_2000e0b9 = *(uint8_t*)((char*)arg3)[3];
08022da8              data_2000e0ba = *(uint8_t*)((char*)arg3)[2];
08022db0              data_2000e0bb = *(uint8_t*)((char*)arg3)[1];
08022db8              data_2000e0bc = (uint8_t)arg3;
08022dbc              (uint16_t)var_18 = (int16_t)(arg4 >> 9);
08022dc6              data_2000e0be = *(uint8_t*)((char*)var_18)[1];
08022dce              data_2000e0bf = (uint8_t)var_18;
08022dd4              data_2000e26c = 1;
08022dda              data_2000e268 = 7;
08022de0              data_2000e277 = 3;
08022de6              data_2000e26b = 2;
08022dec              data_20000dea = 3;
08022d62          }
08022d62          else if (r0_2 == 2)
08022d66          {
08022df6              uint32_t r0_15;
08022df6              
08022df6              if (!(uint32_t)data_2000e277)
08022dfa                  r0_15 = sub_802265c(arg1);
08022dfa              
08022e00              if ((uint32_t)data_2000e277 || !r0_15)
08022e00              {
08022e16                  uint32_t r0_18;
08022e16                  
08022e16                  if ((uint32_t)data_2000e277 == 1)
08022e1a                      r0_18 = sub_802265c(arg1);
08022e1a                  
08022e20                  if ((uint32_t)data_2000e277 == 1 && r0_18)
08022e26                      data_2000e26b = 1;
08022e20                  else if ((uint32_t)data_2000e277 == 2)
08022e30                  {
08022e36                      data_2000e26b = 1;
08022e3c                      data_20000dea = 2;
08022e30                  }
08022e00              }
08022e00              else
08022e00              {
08022e06                  data_2000e26b = 1;
08022e0c                  data_20000dea = 0;
08022e00              }
08022d66          }
08022d5a      }
08022d5a      
08022e44      return (uint32_t)data_20000dea;
08022d44  }
08022e46                    00 00                                                                                ..
08022e48  int32_t data_8022e48 = 0x2000e268
08022e4c  int32_t data_8022e4c = 0x2000e0a8
08022e50  int32_t data_8022e50 = 0x2000e258
08022e54  int32_t data_8022e54 = 0x2000d650
08022e58  int32_t data_8022e58 = 0x2000e278
08022e5c  int32_t data_8022e5c = 0x20000dea
08022e60    int32_t sub_8022e60(void* arg1, int32_t arg2 @ r7)
08022e60  {
08022e68      if (sub_802265c(arg1))
08022e68      {
08022e72          __builtin_strncpy(&data_2000e0a8, "USBCP@0 ", 8);
08022e84          data_2000e0b5 = 0;
08022e8c          data_2000e26b = 1;
08022e68      }
08022e68      
08022e94      data_2000e3d4 = 0;
08022e9c      data_2000e463 = 0;
08022e9e      return arg2;
08022e60  }
08022ea0    uint32_t sub_8022ea0(void* arg1, void* arg2, char* arg3)
08022ea0  {
08022eac      uint32_t result = sub_802265c(arg1);
08022eac      
08022eb2      if (result)
08022eb2      {
08022eba          result = (uint32_t)data_2000e26c;
08022eba          
08022ebe          if (result == 1)
08022ebe          {
08022ef4              sub_8024986(arg1, &data_2000e0a8, data_2000d245, 0x1f);
08022efe              data_2000e26d = 1;
08022f00              result = 2;
08022f06              data_2000e26c = 2;
08022ebe          }
08022ebe          else if (result >= 1)
08022ec0          {
08022ec6              if (result == 3)
08022ec6              {
08022fc0                  uint32_t r0_11 = (uint32_t)sub_8022662(arg1, data_2000d244);
08022fc0                  
08022fce                  if (r0_11 == 1 || (uint32_t)data_2000e26d != 3)
08022fce                  {
08022fd6                      data_2000e3d4 = 0;
08022fde                      data_2000e26d = 3;
08022fde                      
08022fee                      if ((uint32_t)data_2000d248 < data_2000e3d8)
08022fee                      {
08023004                          sub_8024986(arg1, data_2000e3dc, data_2000d244, 
08023004                              (uint32_t)data_2000d248);
0802301a                          data_2000e3d8 -= (uint32_t)data_2000d248;
08023028                          result = data_2000e3dc + (uint32_t)data_2000d248;
0802302e                          data_2000e3dc = result;
08022fee                      }
08022fee                      else if (data_2000e3d8)
0802303a                      {
0802305c                          sub_8024986(arg1, data_2000e3dc, data_2000d244, 
0802305c                              (uint32_t)(uint16_t)data_2000e3d8);
08023060                          result = 0;
08023066                          data_2000e3d8 = 0;
0802303a                      }
0802303a                      else
0802303a                      {
0802303c                          result = 5;
08023042                          data_2000e26c = 5;
0802303a                      }
08022fce                  }
08022fce                  else
08022fce                  {
0802306a                      result = (uint32_t)(uint8_t)r0_11;
0802306a                      
0802306e                      if (result == 4)
0802306e                      {
08023076                          data_2000e462 = 0;
0802307c                          data_2000e26c = 7;
0802307e                          result = 5;
08023082                          data_2000e26d = 5;
0802306e                      }
08022fce                  }
08022ec6              }
08022ec6              else if (result < 3)
08022ec8              {
08022f16                  uint32_t r0_4 = (uint32_t)sub_8022662(arg1, data_2000d245);
08022f16                  
08022f1a                  if (r0_4 != 1)
08022f1a                  {
08022f88                      uint32_t r0_8 = (uint32_t)(uint8_t)r0_4;
08022f88                      
08022f8c                      if (r0_8 != 2)
08022f8c                      {
08022f9c                          result = (uint32_t)(uint8_t)r0_8;
08022f9c                          
08022fa0                          if (result == 4)
08022fa0                          {
08022fa8                              data_2000e462 = 1;
08022faa                              result = 8;
08022fb0                              data_2000e26c = 8;
08022fa0                          }
08022f8c                      }
08022f8c                      else
08022f8c                      {
08022f92                          result = (uint32_t)data_2000e26d;
08022f98                          data_2000e26c = (char)result;
08022f8c                      }
08022f1a                  }
08022f1a                  else
08022f1a                  {
08022f22                      data_2000e3d4 = 0;
08022f2a                      data_2000e26d = 2;
08022f32                      char r0_6 = data_2000e0b4 & 0x80;
08022f32                      
08022f3e                      if (!data_2000e0b0)
08022f3e                      {
08022f7e                          result = 5;
08022f84                          data_2000e26c = 5;
08022f3e                      }
08022f3e                      else
08022f3e                      {
08022f4a                          data_2000e3d8 = data_2000e0b0;
08022f56                          data_2000e3dc = data_2000e270;
08022f62                          data_2000e3e0 = data_2000e3dc;
08022f62                          
08022f68                          if ((uint32_t)r0_6 != 0x80)
08022f68                          {
08022f74                              result = 4;
08022f7a                              data_2000e26c = 4;
08022f68                          }
08022f68                          else
08022f68                          {
08022f6a                              result = 3;
08022f70                              data_2000e26c = 3;
08022f68                          }
08022f3e                      }
08022f1a                  }
08022ec8              }
08022ec8              else if (result == 5)
08022ecc              {
08023188                  data_2000e26d = 5;
0802318e                  data_2000e270 = &data_2000e258;
08023194                  data_2000e274 = 0x3f;
08023196                  char r0_37 = 0xd;
08023196                  
080231a4                  while (true)
080231a4                  {
080231a4                      uint32_t r0_39 = (uint32_t)r0_37;
080231a4                      
080231a8                      if (!r0_39)
080231a8                          break;
080231a8                      
0802319e                      uint32_t r0_38 = (uint32_t)(uint8_t)r0_39;
080231a0                      *(uint8_t*)(&data_2000e258 + r0_38) = 0;
080231a2                      r0_37 = (uint8_t)r0_38 - 1;
080231a4                  }
080231a4                  
080231ae                  (*(uint8_t*)data_2000e258) = 0;
080231bc                  sub_8024986(arg1, data_2000e270, data_2000d244, 0x3f);
080231c0                  result = 6;
080231c4                  data_2000e26c = 6;
08022ecc              }
08022ecc              else if (result < 5)
08022ed0              {
08023090                  uint32_t r0_21 = (uint32_t)sub_8022662(arg1, data_2000d245);
08023090                  
08023094                  if (r0_21 != 1)
08023094                  {
08023128                      uint32_t r0_32 = (uint32_t)(uint8_t)r0_21;
08023128                      
0802312c                      if (r0_32 == 2)
0802312c                      {
08023138                          if (data_2000e3dc == data_2000e3e0)
08023164                              return sub_8024986(arg1, data_2000e3dc, data_2000d245, 
08023164                                  (uint32_t)data_2000d24a);
08023164                          
08023150                          return sub_8024986(arg1, 
08023150                              0 - (uint32_t)data_2000d24a + data_2000e3dc, data_2000d245, 
08023150                              (uint32_t)data_2000d24a);
0802312c                      }
0802312c                      
0802316a                      result = (uint32_t)(uint8_t)r0_32;
0802316a                      
0802316e                      if (result == 4)
0802316e                      {
08023174                          data_2000e462 = 1;
0802317a                          data_2000e26c = 8;
0802317c                          result = 5;
08023180                          data_2000e26d = 5;
0802316e                      }
08023094                  }
08023094                  else
08023094                  {
0802309a                      data_2000e3d4 = 0;
080230a0                      data_2000e26d = 4;
080230a0                      
080230ac                      if ((uint32_t)data_2000d24a < data_2000e3d8)
080230ac                      {
080230bc                          sub_8024986(arg1, data_2000e3dc, data_2000d245, 
080230bc                              (uint32_t)data_2000d24a);
080230c6                          data_2000e3e0 = data_2000e3dc;
080230d4                          data_2000e3dc += (uint32_t)data_2000d24a;
080230de                          result = data_2000e3d8 - (uint32_t)data_2000d24a;
080230e2                          data_2000e3d8 = result;
080230ac                      }
080230ac                      else if (data_2000e3d8)
080230ec                      {
08023106                          sub_8024986(arg1, data_2000e3dc, data_2000d245, 
08023106                              (uint32_t)(uint16_t)data_2000e3d8);
0802310e                          data_2000e3d8 = 0;
08023116                          data_2000e3e0 = data_2000e3dc;
08023120                          result = data_2000e3dc + (uint32_t)data_2000d24a;
08023124                          data_2000e3dc = result;
080230ec                      }
080230ec                      else
080230ec                      {
080230ee                          result = 5;
080230f2                          data_2000e26c = 5;
080230ec                      }
08023094                  }
08022ed0              }
08022ed0              else if (result == 7)
08022ed6              {
0802321a                  uint32_t r0_48 = (uint32_t)sub_8023274(arg1, arg2, arg3, 0);
0802321a                  
0802321e                  if (r0_48)
0802321e                  {
0802323a                      result = (uint32_t)(uint8_t)r0_48;
0802323a                      
0802323e                      if (result == 4)
0802323e                      {
08023240                          result = 2;
08023244                          data_2000e277 = 2;
0802323e                      }
0802321e                  }
0802321e                  else if ((uint32_t)data_2000e462 != 2)
08023226                  {
08023232                      result = (uint32_t)data_2000e26d;
08023236                      data_2000e26c = (char)result;
08023226                  }
08023226                  else
08023226                  {
08023228                      result = 8;
0802322c                      data_2000e26c = 8;
08023226                  }
08022ed6              }
08022ed6              else if (result < 7)
08022eda              {
080231d2                  uint32_t r0_43 = (uint32_t)sub_8022662(arg1, data_2000d244);
080231d2                  
080231d6                  if (r0_43 != 1)
080231d6                  {
080231fa                      result = (uint32_t)(uint8_t)r0_43;
080231fa                      
080231fe                      if (result == 4)
080231fe                      {
08023204                          data_2000e462 = 0;
08023206                          result = 7;
0802320a                          data_2000e26c = 7;
080231fe                      }
080231d6                  }
080231d6                  else
080231d6                  {
080231dc                      data_2000e3d4 = 0;
080231e2                      data_2000e26d = 5;
080231ea                      data_2000e268 = data_2000e26a;
080231f0                      result = sub_80232e6(arg1);
080231f6                      data_2000e277 = (char)result;
080231d6                  }
08022eda              }
08022eda              else if (result == 8)
08022ee0              {
08023254                  uint32_t r0_52 = (uint32_t)sub_8023274(arg1, arg2, arg3, 1);
08023254                  
08023258                  if (r0_52)
08023258                  {
08023264                      result = (uint32_t)(uint8_t)r0_52;
08023264                      
08023268                      if (result == 4)
08023268                      {
0802326a                          result = 2;
0802326e                          data_2000e277 = 2;
08023268                      }
08023258                  }
08023258                  else
08023258                  {
0802325c                      result = (uint32_t)data_2000e26d;
08023260                      data_2000e26c = (char)result;
08023258                  }
08022ee0              }
08022ec0          }
08022eb2      }
08022eb2      
08023272      return result;
08022ea0  }
08023274    uint32_t sub_8023274(void* arg1, void* arg2, char* arg3, char arg4)
08023274  {
0802327c      char r0 = 1;
0802327e      uint32_t r3 = (uint32_t)arg4;
0802327e      
08023282      if (!r3)
08023282      {
0802328e          if (!(uint32_t)*(uint8_t*)((char*)arg2 + 2))
0802329c              sub_8024e30(arg1, arg2, data_2000d247, data_2000d244);
0802329c          
080232a6          r0 = sub_80244ec(arg1, arg2, arg3);
08023282      }
08023282      else if (r3 == 1)
08023286      {
080232b0          if (!(uint32_t)*(uint8_t*)((char*)arg2 + 2))
080232be              sub_8024e30(arg1, arg2, data_2000d246, data_2000d245);
080232be          
080232c8          r0 = sub_80244ec(arg1, arg2, arg3);
08023286      }
08023286      
080232d6      data_2000e3d4 += 1;
080232d6      
080232de      if (data_2000e3d4 >= 5)
080232e0          r0 = 4;
080232e0      
080232e4      return (uint32_t)r0;
08023274  }
080232e6    uint32_t sub_80232e6(void* arg1)
080232e6  {
080232e6      int32_t r3;
080232e6      int32_t var_10 = r3;
080232ec      char r4 = 1;
080232ec      
080232f6      if (sub_802265c(arg1))
080232f6      {
08023304          if (sub_8022670(arg1, data_2000d244) != 0xd)
08023306              r4 = 2;
08023304          else if (data_2000e258 != 0x53425355)
08023344              r4 = 2;
08023312          else if (data_2000e25c == data_2000e0ac)
0802331e          {
08023326              if (!(uint32_t)data_2000e264)
08023328                  r4 = 0;
08023326              else if ((uint32_t)data_2000e264 == 1)
08023334                  r4 = 1;
08023332              else if ((uint32_t)data_2000e264 == 2)
08023340                  r4 = 2;
0802331e          }
080232f6      }
080232f6      
08023348      data_2000e277 = r4;
0802334e      return (uint32_t)r4;
080232e6  }
08023350  int32_t data_8023350 = 0x43425355
08023354  int32_t data_8023354 = 0x2000e0a8
08023358  int32_t data_8023358 = 0x20304050
0802335c  int32_t data_802335c = 0x2000e268
08023360  int32_t data_8023360 = 0x2000e3d4
08023364  int32_t data_8023364 = 0x2000e463
08023368  int32_t data_8023368 = 0x2000d244
0802336c  int32_t data_802336c = 0x2000e3d8
08023370  int32_t data_8023370 = 0x2000e3dc
08023374  int32_t data_8023374 = 0x2000e3e0
08023378  int32_t data_8023378 = 0x2000e462
0802337c  int32_t data_802337c = 0x2000e258
08023380  int32_t data_8023380 = 0x53425355
08023384    int32_t sub_8023384(void* arg1, char arg2, char arg3, char arg4, char arg5, int16_t arg6)
08023384  {
08023386      uint32_t r1 = (uint32_t)arg2;
08023396      char r4_2 = (char)*(uint16_t*)(0x24 * r1 + arg1 + 0x218);
0802339c      *(uint8_t*)(0x24 * r1 + arg1 + 0x213) = r4_2 & 0x7f;
080233a2      *(uint8_t*)(0x24 * r1 + arg1 + 0x214) = r4_2 >> 7;
080233a6      *(uint8_t*)(0x24 * r1 + arg1 + 0x215) = arg5;
080233aa      *(uint16_t*)(0x24 * r1 + arg1 + 0x216) = arg6;
080233ac      *(uint8_t*)(0x210 + 0x24 * r1 + arg1) = arg3;
080233ae      *(uint8_t*)(0x24 * r1 + arg1 + 0x211) = arg4;
080233b2      *(uint8_t*)(0x24 * r1 + arg1 + 0x232) = 0;
080233b8      *(uint8_t*)(0x24 * r1 + arg1 + 0x233) = 0;
080233b8      
080233c0      if (!(uint32_t)arg4)
080233c4          *(uint8_t*)(0x24 * r1 + arg1 + 0x21a) = 1;
080233c4      
080233c8      sub_8023960(arg1, (char)r1);
080233ce      return 0;
08023384  }
080233d0    int32_t sub_80233d0(void* arg1, char arg2, char arg3, char arg4, int16_t arg5)
080233d0  {
080233d2      uint32_t r1 = (uint32_t)arg2;
080233e2      uint32_t r2 = (uint32_t)arg3;
080233e2      
080233e6      if (r2)
080233e8          *(uint8_t*)(0x24 * r1 + arg1 + 0x210) = (char)r2;
080233e8      
080233f4      if ((uint32_t)*(uint16_t*)(0x24 * r1 + arg1 + 0x216) != (uint32_t)arg5)
080233f4      {
080233f6          uint32_t r2_2 = (uint32_t)arg5;
080233f6          
080233fa          if (r2_2)
080233fc              *(uint16_t*)(0x24 * r1 + arg1 + 0x216) = (int16_t)r2_2;
080233f4      }
080233f4      
08023406      if ((uint32_t)*(uint8_t*)(0x24 * r1 + arg1 + 0x211) != (uint32_t)arg4)
08023406      {
08023408          uint32_t r3 = (uint32_t)arg4;
08023408          
0802340c          if (r3)
0802340e              *(uint8_t*)(0x24 * r1 + arg1 + 0x211) = (char)r3;
08023406      }
08023406      
08023412      sub_8023960(arg1, (char)r1);
08023418      return 0;
080233d0  }
0802341a    uint32_t sub_802341a(int32_t arg1, char arg2)
0802341a  {
0802341a      int32_t r3;
0802341a      int32_t var_10 = r3;
08023426      uint32_t r0_2 = (uint32_t)sub_8023490(arg1);
08023426      
0802342e      if (r0_2 != 0xffff)
0802342e      {
08023436          r0_2 = (uint32_t)(uint16_t)r0_2;
08023440          *(uint16_t*)(0x24 * r0_2 + arg1 + 0x218) = (uint16_t)arg2 | 0x8000;
0802342e      }
0802342e      
08023446      return (uint32_t)(uint8_t)r0_2;
0802341a  }
08023448    int32_t sub_8023448(void* arg1, char arg2)
08023448  {
08023448      uint32_t r1_3 = (uint32_t)arg2;
08023448      
0802344c      if (r1_3 < 8)
0802344c      {
0802344e          uint32_t r1 = (uint32_t)(uint8_t)r1_3;
08023468          *(uint16_t*)((char*)arg1 + 0x24 * (uint32_t)(uint8_t)r1 + 0x218) =
08023468              (int16_t)((uint32_t)*(uint16_t*)(0x24 * r1 + arg1 + 0x218) << 0x11 >> 0x11);
0802344c      }
0802344c      
0802346e      return 0;
08023448  }
08023470    int32_t sub_8023470(int32_t arg1)
08023470  {
08023470      char r1_1 = 2;
08023470      
08023486      while (true)
08023486      {
08023486          uint32_t r1_2 = (uint32_t)r1_1;
08023486          
0802348a          if (r1_2 >= 8)
0802348a              break;
0802348a          
08023476          uint32_t r1 = (uint32_t)(uint8_t)r1_2;
08023480          *(uint16_t*)(0x24 * r1 + arg1 + 0x218) = 0;
08023484          r1_1 = (uint8_t)r1 + 1;
08023486      }
08023486      
0802348e      return 0;
08023470  }
08023490    uint32_t sub_8023490(int32_t arg1)
08023490  {
08023492      char r1 = 0;
08023498      uint32_t r1_2;
08023498      
08023498      while (true)
08023498      {
08023498          uint32_t r1_1 = (uint32_t)r1;
08023498          
0802349c          if (r1_1 >= 8)
080234b8              return 0xffff;
080234b8          
0802349e          r1_2 = (uint32_t)(uint8_t)r1_1;
0802349e          
080234ae          if ((uint32_t)*(uint16_t*)(0x24 * r1_2 + arg1 + 0x218) << 0x10 >= 0)
080234ae              break;
080234ae          
08023496          r1 = (uint8_t)r1_2 + 1;
08023498      }
08023498      
080234b4      return (uint32_t)(uint8_t)r1_2;
08023490  }
080234be    int32_t putc_fn_80234be(int32_t state, int32_t ch)
080234be  {
080234be      char* r2 = *(uint32_t*)state;
080234c2      *(uint32_t*)state = &r2[1];
080234c4      *(uint8_t*)r2 = (char)ch;
080234c6      return state;
080234be  }
080234c8    int32_t sub_80234c8()
080234c8  {
080234d0      *(uint32_t*)0x50000004 = 0xffffffff;
080234da      *(uint32_t*)0x50000018 = 0x80000800;
080234dc      return 0x80000800;
080234c8  }
080234de    int32_t sub_80234de(void* arg1)
080234de  {
080234de      int32_t r7;
080234de      int32_t var_8 = r7;
080234e2      int32_t r0 = 0;
080234f2      *(uint32_t*)0x50000010 |= 1;
080234f2      
08023506      do
08023506      {
080234f4          r0 += 1;
080234f4          
080234fc          if (r0 >= 0x30d41)
080234fc              break;
08023506      } while (*(uint32_t*)0x50000010 << 0x1f < 0);
08023506      
0802350e      if (*(uint32_t*)((char*)arg1 + 0x430))
08023516          (*(uint32_t*)((char*)arg1 + 0x430))(3);
08023516      
0802351a      return 0;
080234de  }
0802351c    int32_t sub_802351c(int32_t* arg1, char arg2, int16_t arg3)
0802351c  {
08023542      for (int32_t i = 0; i < ((uint32_t)arg3 + 3) >> 2; i += 1)
08023542      {
0802353a          *(uint32_t*)(((uint32_t)arg2 << 0xc) + 0x50001000) = *(uint32_t*)arg1;
0802353c          arg1 = &arg1[1];
08023542      }
08023542      
08023548      return 0;
0802351c  }
0802354a    void sub_802354a(int32_t* arg1, int16_t arg2)
0802354a  {
08023566      for (int32_t i = 0; i < ((uint32_t)arg2 + 3) >> 2; i += 1)
08023566      {
0802355e          *(uint32_t*)arg1 = *(uint32_t*)0x50001000;
08023560          arg1 = &arg1[1];
08023566      }
0802354a  }
0802356c    int32_t sub_802356c(char* arg1, char arg2)
0802356c  {
0802356e      arg1[1] = 1;
08023572      *(uint16_t*)(arg1 + 8) = 0x40;
08023576      arg1[5] = 0;
08023578      uint32_t r1 = (uint32_t)arg2;
08023578      
0802357c      if (r1 == 1)
0802357c      {
08023580          *(uint8_t*)arg1 = 1;
08023584          arg1[3] = 8;
08023588          arg1[4] = 4;
0802358e          *(uint16_t*)(arg1 + 0xa) = 0x140;
08023592          arg1[2] = 2;
0802357c      }
0802357c      else if (!(uint32_t)(uint8_t)r1)
0802359a      {
0802359e          *(uint8_t*)arg1 = 0;
080235a2          arg1[3] = 0xc;
080235a6          arg1[4] = 6;
080235ac          *(uint16_t*)(arg1 + 0xa) = 0x500;
0802359a      }
0802359a      
080235b0      return 0;
0802356c  }
080235b2    int32_t sub_80235b2(char* arg1)
080235b2  {
080235ba      if ((uint32_t)arg1[2] == 1)
080235ba      {
080235ca          *(uint32_t*)0x50000038 &= 0xfffeffff;
080235ca          
080235d0          if ((uint32_t)arg1[6])
080235e0              *(uint32_t*)0x50000038 |= 0x100000;
080235e0          
080235f0          *(uint32_t*)0x5000000c &= 0xffffffbf;
08023600          *(uint32_t*)0x5000000c &= 0xffdfffff;
08023610          *(uint32_t*)0x5000000c &= 0xffefffff;
08023614          sub_80234de(arg1);
080235ba      }
080235ba      else if ((uint32_t)arg1[2] == 2)
0802361e      {
08023624          if (!(uint32_t)*(uint8_t*)arg1)
08023634              *(uint32_t*)0x5000000c |= 0x40;
08023634          
08023638          sub_80234de(arg1);
0802364a          *(uint32_t*)0x50000038 |= 0xd0000;
0802365a          *(uint32_t*)0x50000008 &= 0xffffff7f;
0802366a          *(uint32_t*)0x50000038 |= 0x200000;
0802366a          
08023670          if ((uint32_t)arg1[6])
08023680              *(uint32_t*)0x50000038 |= 0x100000;
08023680          
08023688          if (*(uint32_t*)(arg1 + 0x434))
08023690              (*(uint32_t*)(arg1 + 0x434))(0x14);
0802361e      }
0802361e      
08023696      if ((uint32_t)arg1[5] == 1)
0802369e          *(uint32_t*)0x50000008 = 0x2a;
0802369e      
080236a2      return 0;
080235b2  }
080236a4    int32_t sub_80236a4(void* arg1, char arg2)
080236a4  {
080236a4      int32_t r7;
080236a4      int32_t var_8 = r7;
080236a8      int32_t r0 = 0;
080236b6      *(uint32_t*)0x50000010 = (uint32_t)arg2 << 6 | 0x20;
080236b6      
080236ca      do
080236ca      {
080236b8          r0 += 1;
080236b8          
080236c0          if (r0 >= 0x30d41)
080236c0              break;
080236ca      } while (*(uint32_t*)0x50000010 << 0x1a < 0);
080236ca      
080236d2      if (*(uint32_t*)((char*)arg1 + 0x430))
080236da          (*(uint32_t*)((char*)arg1 + 0x430))(3);
080236da      
080236de      return 0;
080236a4  }
080236e0    int32_t sub_80236e0(void* arg1)
080236e0  {
080236e0      int32_t r7;
080236e0      int32_t var_8 = r7;
080236e4      int32_t r0 = 0;
080236ec      *(uint32_t*)0x50000010 = 0x10;
080236ec      
08023700      do
08023700      {
080236ee          r0 += 1;
080236ee          
080236f6          if (r0 >= 0x30d41)
080236f6              break;
08023700      } while (*(uint32_t*)0x50000010 << 0x1b < 0);
08023700      
08023708      if (*(uint32_t*)((char*)arg1 + 0x430))
08023710          (*(uint32_t*)((char*)arg1 + 0x430))(3);
08023710      
08023714      return 0;
080236e0  }
08023716    int32_t sub_8023716(void* arg1, char arg2)
08023716  {
08023716      int32_t r7;
08023716      int32_t var_8 = r7;
0802371a      uint32_t r1 = (uint32_t)arg2;
0802371a      
0802371e      if (r1 == 1)
0802371e      {
0802372e          *(uint32_t*)0x5000000c &= 0xbfffffff;
0802373e          *(uint32_t*)0x5000000c |= &turnTable;
0802371e      }
0802371e      else if (!(uint32_t)(uint8_t)r1)
08023746      {
08023756          *(uint32_t*)0x5000000c &= 0xdfffffff;
08023766          *(uint32_t*)0x5000000c |= 0x40000000;
08023746      }
08023746      
0802376e      if (*(uint32_t*)((char*)arg1 + 0x434))
08023776          (*(uint32_t*)((char*)arg1 + 0x434))(0x32);
08023776      
0802377a      return 0;
08023716  }
0802377c    int32_t sub_802377c(char* arg1)
0802377c  {
0802377c      int32_t r3;
0802377c      int32_t var_c_1 = r3;
0802377c      int32_t r2;
0802377c      int32_t var_10_1 = r2;
08023784      int32_t var_c = 0;
08023788      int32_t var_10 = 0;
08023790      *(uint32_t*)0x50000e00 = 0;
08023790      
08023796      if ((uint32_t)arg1[2] != 1)
080237b8          *(uint32_t*)0x50000400 &= 0xfffffffd;
08023796      else
080237a6          *(uint32_t*)0x50000400 = *(uint32_t*)0x50000400 >> 2 << 2;
080237a6      
080237be      if ((uint32_t)*(uint8_t*)arg1 == 1)
080237be      {
080237c6          *(uint32_t*)0x50000024 = 0x80;
080237e4          var_c = 0x600080;
080237ec          *(uint32_t*)0x50000028 = 0x600080;
0802380a          var_10 = 0x6000e0;
08023812          *(uint32_t*)0x50000100 = 0x6000e0;
080237be      }
080237be      
08023818      sub_80236a4(arg1, 0x10);
0802381e      sub_80236e0(arg1);
08023830      *(uint32_t*)0x50000418 = *(uint32_t*)0x50000418 >> 0xc << 0xc;
08023830      
08023856      for (int32_t i = 0; i < (uint32_t)arg1[3]; i += 1)
08023856      {
08023840          *(uint32_t*)(0x5000050c + (i << 5)) = 0;
0802384e          *(uint32_t*)(0x50000508 + (i << 5)) = 0xffffffff;
08023856      }
08023856      
0802385c      sub_802386a(arg1, 1);
08023862      sub_80238c6(arg1);
08023868      return 0;
0802377c  }
0802386a    int32_t sub_802386a(void* arg1, char arg2)
0802386a  {
0802386a      int32_t r3;
0802386a      int32_t var_10_1 = r3;
08023872      int32_t var_10 = 0;
08023872      
0802387a      if (*(uint32_t*)((char*)arg1 + 0x42c))
08023886          (*(uint32_t*)((char*)arg1 + 0x42c))(arg1, (uint32_t)arg2);
08023886      
08023892      int32_t result = *(uint32_t*)0x50000440 & 0xfffffff1;
08023892      
0802389e      if (result << 0x13 >= 0 && (uint32_t)arg2 == 1)
080238a6          result |= 0x1000;
080238a6      
080238b2      *(uint32_t*)0x50000440 = result;
080238b2      
080238ba      if (*(uint32_t*)((char*)arg1 + 0x434))
080238c2          (*(uint32_t*)((char*)arg1 + 0x434))(0xc8);
080238c2      
080238c4      return result;
0802386a  }
080238c6    int32_t sub_80238c6(void* arg1)
080238c6  {
080238c6      int32_t r3;
080238c6      int32_t var_10 = r3;
080238ca      int32_t r4 = 0;
080238d2      *(uint32_t*)0x50000018 = 0;
080238dc      *(uint32_t*)0x50000014 = 0xffffffff;
080238e0      sub_80234c8();
080238e0      
080238e8      if (!(uint32_t)*(uint8_t*)((char*)arg1 + 5))
080238ea          r4 = 0x10;
080238ea      
080238f2      int32_t r4_1 = r4 | 0x23200008;
08023900      *(uint32_t*)0x50000018 &= ~r4_1;
0802390e      *(uint32_t*)0x50000018 |= r4_1;
08023912      return 0;
080238c6  }
08023914    int32_t sub_8023914(void* arg1)
08023914  {
0802392a      *(uint32_t*)0x50000440 = (*(uint32_t*)0x50000440 & 0xfffffff1) | 0x100;
0802392a      
08023932      if (*(uint32_t*)((char*)arg1 + 0x434))
0802393a          (*(uint32_t*)((char*)arg1 + 0x434))(0xa);
0802393a      
0802394a      *(uint32_t*)0x50000440 &= 0xfffffeff;
0802394a      
08023952      if (*(uint32_t*)((char*)arg1 + 0x434))
0802395a          (*(uint32_t*)((char*)arg1 + 0x434))(0x14);
0802395a      
0802395e      return 0;
08023914  }
08023960    int32_t sub_8023960(void* arg1, char arg2)
08023960  {
08023960      int32_t r3;
08023960      int32_t var_10_7 = r3;
08023960      int32_t r2;
08023960      int32_t var_14_2 = r2;
08023964      char r3_1 = 0;
08023968      int32_t var_14 = 0;
0802396c      int32_t var_10 = 0;
0802396e      uint32_t r1 = (uint32_t)arg2;
08023982      uint32_t r1_1 = (uint32_t)(uint8_t)r1;
0802398c      *(uint32_t*)(0x50000508 + (r1_1 << 5)) = 0xffffffff;
0802398c      
08023992      if ((uint32_t)*(uint8_t*)((char*)arg1 + 5) == 1)
0802399a          var_14 = 4;
0802399a      
0802399c      uint32_t r0_1 = (uint32_t)*(uint8_t*)(0x24 * r1 + arg1 + 0x215);
0802399c      
080239a4      if (!r0_1 || r0_1 == 2)
080239a4      {
080239b4          int32_t r0_3 = var_14 | 0x499;
080239b4          
080239bc          if (!(uint32_t)*(uint8_t*)(0x24 * r1 + arg1 + 0x214))
080239bc          {
080239ce              var_14 = r0_3 | 0x40;
080239ce              
080239d4              if ((uint32_t)*(uint8_t*)(0x24 * r1 + arg1 + 0x21a))
080239dc                  var_14 |= 0x20;
080239bc          }
080239bc          else
080239c4              var_14 = r0_3 | 0x100;
080239a4      }
080239a4      else if (r0_1 < 2)
080239a6      {
08023a02          var_14 |= 0x221;
08023a02          
08023a08          if ((uint32_t)*(uint8_t*)(0x24 * r1 + arg1 + 0x214))
08023a10              var_14 |= 0x180;
080239a6      }
080239a6      else if (r0_1 == 3)
080239aa      {
080239e8          var_14 |= 0x699;
080239e8          
080239ee          if ((uint32_t)*(uint8_t*)(0x24 * r1 + arg1 + 0x214))
080239f6              var_14 |= 0x100;
080239aa      }
080239aa      
08023a16      uint32_t r1_2 = (uint32_t)(uint8_t)r1_1;
08023a1e      *(uint32_t*)(0x5000050c + (r1_2 << 5)) = var_14;
08023a2c      *(uint32_t*)0x50000418 |= 1 << r1_2;
08023a38      *(uint32_t*)0x50000018 |= 0x2000000;
08023a38      
08023a42      if ((uint32_t)*(uint8_t*)(0x24 * r1 + arg1 + 0x211) == 2)
08023a44          r3_1 = 1;
08023a44      
08023a5e      int32_t r0_32 = (uint32_t)*(uint8_t*)(0x24 * r1 + arg1 + 0x210) << 0x16
08023a5e          | (uint32_t)*(uint8_t*)(0x24 * r1 + arg1 + 0x215) << 0x12
08023a5e          | (uint32_t)*(uint8_t*)(0x24 * r1 + arg1 + 0x213) << 0xb;
08023a7e      int32_t var_10_6 = r0_32 | (uint32_t)*(uint8_t*)(0x24 * r1 + arg1 + 0x214) << 0xf
08023a7e          | (uint32_t)r3_1 << 0x11 | (uint32_t)*(uint16_t*)(0x24 * r1 + arg1 + 0x216);
08023a7e      
08023a84      if ((uint32_t)*(uint8_t*)(0x24 * r1 + arg1 + 0x215) == 3)
08023a8c          var_10_6 |= &turnTable;
08023a8c      
08023a9c      *(uint32_t*)(((uint32_t)(uint8_t)r1_2 << 5) + 0x50000500) = var_10_6;
08023aa4      return 0;
08023960  }
08023aa6    int32_t sub_8023aa6(void* arg1, char arg2)
08023aa6  {
08023aa6      int32_t r3;
08023aa6      int32_t var_14_5 = r3;
08023aa6      int32_t r2;
08023aa6      int32_t var_18_5 = r2;
08023ab4      int32_t var_14 = 0;
08023ab6      uint32_t r1 = (uint32_t)arg2;
08023aca      uint32_t r2_8;
08023aca      
08023aca      if (!*(uint32_t*)(0x24 * r1 + arg1 + 0x220))
08023aee          r2_8 = 1;
08023aca      else
08023aca      {
08023ada          r2_8 = (uint32_t)(uint16_t)(((uint32_t)*(uint16_t*)(0x24 * r1 + arg1 + 0x220)
08023ada              + (uint32_t)*(uint16_t*)(0x24 * r1 + arg1 + 0x216) - 1) / (uint32_t)
08023ada              *(uint16_t*)(0x24 * r1 + arg1 + 0x216));
08023ada          
08023ade          if (r2_8 >= 0x8d)
08023ade          {
08023ae2              r2_8 = 0x8c;
08023aea              *(uint32_t*)(0x24 * r1 + arg1 + 0x220) =
08023aea                  (uint32_t)*(uint16_t*)(0x24 * r1 + arg1 + 0x216) * 0x8c;
08023ade          }
08023aca      }
08023aca      
08023af4      if ((uint32_t)*(uint8_t*)(0x24 * r1 + arg1 + 0x214))
08023af4      {
08023af6          r2_8 = (uint32_t)(uint16_t)r2_8;
08023afe          *(uint32_t*)(0x24 * r1 + arg1 + 0x220) =
08023afe              (uint32_t)*(uint16_t*)(0x24 * r1 + arg1 + 0x216) * r2_8;
08023af4      }
08023af4      
08023b36      uint32_t r1_1 = (uint32_t)(uint8_t)r1;
08023b3e      *(uint32_t*)(0x50000510 + (r1_1 << 5)) = (((*(uint32_t*)(0x24 * r1 + arg1 + 0x220)
08023b3e          & 0xe007ffff) | (uint32_t)(uint16_t)r2_8 << 0x13) & 0x9fffffff)
08023b3e          | (uint32_t)*(uint8_t*)(0x24 * r1 + arg1 + 0x212) << 0x1d;
08023b3e      
08023b44      if ((uint32_t)*(uint8_t*)((char*)arg1 + 5) == 1)
08023b44      {
08023b48          r1_1 = (uint32_t)(uint8_t)r1_1;
08023b50          *(uint32_t*)(0x50000514 + (r1_1 << 5)) = *(uint32_t*)(0x24 * r1 + arg1 + 0x21c);
08023b44      }
08023b44      
08023b52      uint32_t r1_2 = (uint32_t)(uint8_t)r1_1;
08023b5e      int32_t r2_21 = *(uint32_t*)((r1_2 << 5) + 0x50000500);
08023b72      int32_t var_14_2;
08023b72      
08023b72      if (((uint32_t)(uint8_t)*(uint32_t*)0x50000408 & 1) == 1)
08023b84          var_14_2 = r2_21 & 0xdfffffff;
08023b72      else
08023b7a          var_14_2 = r2_21 | &turnTable;
08023b7a      
08023b98      uint32_t r1_3 = (uint32_t)(uint8_t)r1_2;
08023ba4      *(uint32_t*)((r1_3 << 5) + 0x50000500) = (var_14_2 | 0x80000000) & 0xbfffffff;
08023ba4      
08023bb6      if (!(uint32_t)*(uint8_t*)((char*)arg1 + 5)
08023bb6          && !(uint32_t)*(uint8_t*)(0x24 * r1 + arg1 + 0x214)
08023bb6          && *(uint32_t*)(0x24 * r1 + arg1 + 0x220))
08023bb6      {
08023bbe          uint16_t r2_35 = ((int16_t)*(uint32_t*)(0x24 * r1 + arg1 + 0x220) + 3) >> 2;
08023bc0          uint32_t r0_6 = (uint32_t)*(uint8_t*)(0x24 * r1 + arg1 + 0x215);
08023bc0          
08023bc8          if (!r0_6 || r0_6 == 2)
08023bc8          {
08023bdc              if ((uint32_t)(uint16_t)*(uint32_t*)0x5000002c < (uint32_t)r2_35)
08023be8                  *(uint32_t*)0x50000018 |= 0x20;
08023bc8          }
08023bc8          else if ((r0_6 < 2 || r0_6 == 3)
08023bc8                  && (uint32_t)(uint16_t)*(uint32_t*)0x50000410 < (uint32_t)r2_35)
08023c02              *(uint32_t*)0x50000018 |= 0x4000000;
08023c02          
08023c0e          sub_802351c(*(uint32_t*)(0x24 * r1 + arg1 + 0x21c), (char)r1_3, 
08023c0e              (int16_t)*(uint32_t*)(0x24 * r1 + arg1 + 0x220));
08023bb6      }
08023bb6      
08023c16      return 0;
08023aa6  }
08023c18    int32_t sub_8023c18(int32_t arg1, char arg2)
08023c18  {
08023c1c      uint32_t r1 = (uint32_t)arg2;
08023c32      int32_t var_4_1 = *(uint32_t*)((r1 << 5) + 0x50000500) | 0xc0000000;
08023c3c      uint32_t r0_9 = (uint32_t)(uint8_t)(var_4_1 >> 0x12) & 3;
08023c3c      
08023c46      if (!r0_9 || (uint32_t)(uint8_t)r0_9 == 2)
08023c46      {
08023c4e          if (!(*(uint32_t*)0x5000002c << 0x10))
08023c56              var_4_1 |= 0x40000000;
08023c46      }
08023c46      else if (!(*(uint32_t*)0x50000410 << 0x10))
08023c68          var_4_1 |= 0x80000000;
08023c68      
08023c78      *(uint32_t*)(((uint32_t)(uint8_t)r1 << 5) + 0x50000500) = var_4_1;
08023c7e      return 0;
08023c18  }
08023c80    int32_t sub_8023c80(int32_t arg1, char arg2)
08023c80  {
08023c84      uint32_t r1 = (uint32_t)arg2;
08023c8c      *(uint32_t*)(0x50000510 + (r1 << 5)) = 0x80080000;
08023c8e      uint32_t r1_1 = (uint32_t)(uint8_t)r1;
08023cb0      *(uint32_t*)(((uint32_t)(uint8_t)r1_1 << 5) + 0x50000500) =
08023cb0          (*(uint32_t*)((r1_1 << 5) + 0x50000500) | 0x80000000) & 0xbfffffff;
08023cb4      return 0;
08023c80  }
08023cb6                                                                    00 00                                                ..
08023cb8  int32_t data_8023cb8 = 0x50000004
08023cbc  int32_t data_8023cbc = -0x7ffff800
08023cc0  int32_t data_8023cc0 = 0x50000018
08023cc4  int32_t data_8023cc4 = 0x50000010
08023cc8  int32_t data_8023cc8 = 0x30d41
08023ccc  int32_t data_8023ccc = 0x50001000
08023cd0  int32_t data_8023cd0 = 0x50000038
08023cd4  int32_t data_8023cd4 = 0x5000000c
08023cd8  int32_t data_8023cd8 = 0x50000008
08023cdc  int32_t data_8023cdc = 0x50000e00
08023ce0  int32_t data_8023ce0 = 0x50000400
08023ce4  int32_t data_8023ce4 = 0x50000024
08023ce8  int32_t data_8023ce8 = 0x50000028
08023cec  int32_t data_8023cec = 0x50000100
08023cf0  int32_t data_8023cf0 = 0x50000418
08023cf4  int32_t data_8023cf4 = 0x5000050c
08023cf8  int32_t data_8023cf8 = 0x50000508
08023cfc  int32_t data_8023cfc = 0x50000440
08023d00  int32_t data_8023d00 = 0x50000014
08023d04  int32_t data_8023d04 = 0x23200008
08023d08  int32_t data_8023d08 = 0x50000510
08023d0c  int32_t data_8023d0c = 0x50000514
08023d10  int32_t data_8023d10 = 0x50000408
08023d14  int32_t data_8023d14 = 0x5000002c
08023d18  int32_t data_8023d18 = 0x50000410
08023d1c  int32_t data_8023d1c = -0x7ff80000
08023d20    uint32_t sub_8023d20(int32_t arg1, void* arg2, char* arg3)
08023d20  {
08023d20      int32_t r3;
08023d20      int32_t var_18 = r3;
08023d28      char r6 = 1;
08023d28      
08023d32      if (!(uint32_t)data_2000e465)
08023d32      {
08023d3a          data_2000e465 = 1;
08023d3e          sub_80227f2(arg3);
08023d46          sub_8022782(arg3, 0);
08023d32      }
08023d32      
08023d4e      sub_8022746(arg3, 1);
08023d4e      
08023d58      if ((int32_t)arg3[0x38])
08023d7e          (*(uint32_t*)(&data_200006c8 + ((uint32_t)arg3[0x14] << 2)))(arg1, arg2, arg3);
08023d58      else
08023d6a          (*(uint32_t*)(&data_200006c8 + ((uint32_t)*(uint8_t*)arg3 << 2)))(arg1, arg2, 
08023d6a              arg3);
08023d6a      
08023d84      if ((uint32_t)*(uint8_t*)((char*)arg2 + 1) == 9)
08023d84      {
08023d88          *(uint8_t*)((char*)arg2 + 1) = 0;
08023d90          data_2000e465 = 0;
08023d92          r6 = 0;
08023d84      }
08023d84      
08023d98      return (uint32_t)r6;
08023d20  }
08023d9a    uint32_t sub_8023d9a(void* arg1, void* arg2, uint32_t arg3)
08023d9a  {
08023d9a      uint32_t r3;
08023d9a      uint32_t var_14 = r3;
08023d9a      uint32_t result = arg3;
08023da0      char* r6 = arg3;
08023da4      *(uint8_t*)((char*)arg2 + 1) = 0;
08023da4      
08023daa      if (!(uint32_t)*(uint8_t*)((char*)arg2 + 2))
08023daa      {
08023dae          var_14 = 8;
08023db4          result = 0x100;
08023dc0          sub_8024228(arg1, arg2, (char*)arg1 + 0xc, 0, 0x100, 8);
08023dc0          
08023dca          if (*(uint32_t*)((char*)arg1 + 0x434))
08023dd2              (*(uint32_t*)((char*)arg1 + 0x434))(0x64);
08023daa      }
08023daa      
08023de0      if (!sub_80244ec(arg1, arg2, r6))
08023de0      {
08023dec          sub_80242a2((char*)arg2 + 0x1e, (char*)arg1 + 0xc, 8);
08023df4          *(uint8_t*)((char*)arg2 + 0xa) = *(uint8_t*)((char*)arg2 + 0x25);
08023df8          sub_8023914(arg1);
08023e00          uint32_t var_14_1 = (uint32_t)*(uint8_t*)((char*)arg2 + 0xa);
08023e0e          sub_80233d0(arg1, *(uint8_t*)((char*)arg2 + 9), 0, 0, 0);
08023e16          var_14 = (uint32_t)*(uint8_t*)((char*)arg2 + 0xa);
08023e24          sub_80233d0(arg1, *(uint8_t*)((char*)arg2 + 8), 0, 0, 0);
08023e2a          result = (uint32_t)*(uint8_t*)r6;
08023e34          sub_8022786(arg1, arg2, r6, 1, (uint8_t)result);
08023de0      }
08023de0      
08023e38      return result;
08023d9a  }
08023e3a    uint32_t sub_8023e3a(void* arg1, void* arg2, uint32_t arg3)
08023e3a  {
08023e3a      int32_t r3;
08023e3a      int32_t var_14 = r3;
08023e3a      uint32_t result = arg3;
08023e40      char* r6 = arg3;
08023e44      *(uint8_t*)((char*)arg2 + 1) = 2;
08023e44      
08023e4a      if (!(uint32_t)*(uint8_t*)((char*)arg2 + 2))
08023e4a      {
08023e4e          var_14 = 0x12;
08023e54          result = 0x100;
08023e60          sub_8024228(arg1, arg2, (char*)arg1 + 0xc, 0, 0x100, 0x12);
08023e4a      }
08023e4a      
08023e70      if (!sub_80244ec(arg1, arg2, r6))
08023e70      {
08023e7c          sub_80242a2((char*)arg2 + 0x1e, (char*)arg1 + 0xc, 0x12);
08023e88          (*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 0x1c))((char*)arg2 + 0x1e);
08023e8c          result = (uint32_t)*(uint8_t*)r6;
08023e96          sub_8022786(arg1, arg2, r6, 3, (uint8_t)result);
08023e70      }
08023e70      
08023e9a      return result;
08023e3a  }
08023e9c    uint32_t sub_8023e9c(void* arg1, void* arg2, uint32_t arg3)
08023e9c  {
08023e9c      int32_t r3;
08023e9c      int32_t var_14_1 = r3;
08023e9c      uint32_t result = arg3;
08023ea2      char* r6 = arg3;
08023ea6      *(uint8_t*)((char*)arg2 + 1) = 1;
08023ea6      
08023eac      if (!(uint32_t)*(uint8_t*)((char*)arg2 + 2))
08023eac      {
08023eb4          sub_8024260(arg1, arg2, 1);
08023eb4          
08023ebe          if (*(uint32_t*)((char*)arg1 + 0x434))
08023ec6              (*(uint32_t*)((char*)arg1 + 0x434))(0x64);
08023eac      }
08023eac      
08023ed4      if (!sub_80244ec(arg1, arg2, r6))
08023ed4      {
08023edc          if (*(uint32_t*)((char*)arg1 + 0x434))
08023ee4              (*(uint32_t*)((char*)arg1 + 0x434))(2);
08023ee4          
08023ee8          *(uint8_t*)((char*)arg2 + 0x1c) = 1;
08023eee          (*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 0x20))();
08023ef2          int32_t var_14 = 0;
08023f00          sub_80233d0(arg1, *(uint8_t*)((char*)arg2 + 8), *(uint8_t*)((char*)arg2 + 0x1c), 
08023f00              0, 0);
08023f06          var_14_1 = 0;
08023f14          sub_80233d0(arg1, *(uint8_t*)((char*)arg2 + 9), *(uint8_t*)((char*)arg2 + 0x1c), 
08023f14              0, 0);
08023f1a          result = (uint32_t)*(uint8_t*)r6;
08023f24          sub_8022786(arg1, arg2, r6, 2, (uint8_t)result);
08023ed4      }
08023ed4      
08023f28      return result;
08023e9c  }
08023f2a    uint32_t sub_8023f2a(void* arg1, void* arg2, char* arg3)
08023f2a  {
08023f34      int16_t r7 = 0;
08023f38      *(uint8_t*)((char*)arg2 + 1) = 3;
08023f3e      uint32_t result;
08023f3e      
08023f3e      if (!(uint32_t)*(uint8_t*)((char*)arg2 + 2))
08023f3e      {
08023f42          int32_t var_1c = 9;
08023f48          result = 0x200;
08023f54          sub_8024228(arg1, arg2, (char*)arg1 + 0xc, 0, 0x200, 9);
08023f3e      }
08023f3e      
08023f64      if (!sub_80244ec(arg1, arg2, arg3))
08023f64      {
08023f7a          while (true)
08023f7a          {
08023f7a              uint32_t r7_3 = (uint32_t)r7;
08023f7a              
08023f7e              if (r7_3 >= 9)
08023f7e                  break;
08023f7e              
08023f68              uint32_t r7_1 = (uint32_t)(uint16_t)r7_3;
08023f74              uint32_t r7_2 = (uint32_t)(uint16_t)r7_1;
08023f76              *(uint8_t*)(&data_2000d850 + r7_2) = *(uint8_t*)((char*)arg1 + r7_1 + 0xc);
08023f78              r7 = (uint16_t)r7_2 + 1;
08023f7a          }
08023f7a          
08023f94          sub_80242fe((char*)arg2 + 0x30, (char*)arg2 + 0x39, (char*)arg2 + 0x4b, 
08023f94              (char*)arg1 + 0xc, 9);
08023f9a          result = (uint32_t)*(uint8_t*)arg3;
08023fa4          sub_8022786(arg1, arg2, arg3, 4, (uint8_t)result);
08023f64      }
08023f64      
08023fa8      return result;
08023f2a  }
08023faa    uint32_t sub_8023faa(void* arg1, void* arg2, char* arg3)
08023faa  {
08023fb4      int16_t r7 = 0;
08023fb8      *(uint8_t*)((char*)arg2 + 1) = 4;
08023fbe      uint32_t result;
08023fbe      
08023fbe      if (!(uint32_t)*(uint8_t*)((char*)arg2 + 2))
08023fbe      {
08023fc8          result = 0x200;
08023fd4          sub_8024228(arg1, arg2, (char*)arg1 + 0xc, 0, 0x200, 
08023fd4              *(uint16_t*)((char*)arg2 + 0x32));
08023fbe      }
08023fbe      
08023fe4      if (!sub_80244ec(arg1, arg2, arg3))
08023fe4      {
08024002          while ((uint32_t)r7 < (uint32_t)*(uint16_t*)((char*)arg2 + 0x32))
08024002          {
08023fe8              uint32_t r7_1 = (uint32_t)r7;
08023ff4              uint32_t r7_2 = (uint32_t)(uint16_t)r7_1;
08023ff6              *(uint8_t*)(&data_2000d850 + r7_2) = *(uint8_t*)((char*)arg1 + r7_1 + 0xc);
08023ff8              r7 = (uint16_t)r7_2 + 1;
08024002          }
08024002          
08024018          sub_80242fe((char*)arg2 + 0x30, (char*)arg2 + 0x39, (char*)arg2 + 0x4b, 
08024018              (char*)arg1 + 0xc, (uint32_t)*(uint16_t*)((char*)arg2 + 0x32));
0802402c          (*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 0x24))((char*)arg2 + 0x30, 
0802402c              (char*)arg2 + 0x39, (char*)arg2 + 0x4b);
08024030          result = (uint32_t)*(uint8_t*)arg3;
0802403a          sub_8022786(arg1, arg2, arg3, 5, (uint8_t)result);
08023fe4      }
08023fe4      
0802403e      return result;
08023faa  }
08024040    uint32_t sub_8024040(void* arg1, void* arg2, char* arg3)
08024040  {
08024040      int32_t r3;
08024040      int32_t var_14 = r3;
08024040      uint32_t result = arg3;
0802404a      *(uint8_t*)((char*)arg2 + 1) = 5;
0802404a      
08024052      if (!(uint32_t)*(uint8_t*)((char*)arg2 + 0x2c))
08024052      {
080240b6          (*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 0x28))(sub_80241d0);
080240bc          sub_8022782(arg3, 6);
08024052      }
08024052      else
08024052      {
08024058          if (!(uint32_t)*(uint8_t*)((char*)arg2 + 2))
08024058          {
0802405c              var_14 = 0xff;
08024068              result = (uint32_t)*(uint8_t*)((char*)arg2 + 0x2c) | 0x300;
08024074              sub_8024228(arg1, arg2, (char*)arg1 + 0xc, 0, (uint16_t)result, 0xff);
08024058          }
08024058          
08024084          if (!sub_80244ec(arg1, arg2, arg3))
08024084          {
08024090              sub_802449e((char*)arg1 + 0xc, 0x2000dc28, 0xff);
0802409c              (*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 0x28))(0x2000dc28);
080240a0              result = (uint32_t)*(uint8_t*)arg3;
080240aa              sub_8022786(arg1, arg2, arg3, 6, (uint8_t)result);
08024084          }
08024052      }
08024052      
080240c0      return result;
08024040  }
080240c2    uint32_t sub_80240c2(void* arg1, void* arg2, char* arg3)
080240c2  {
080240c2      int32_t r3;
080240c2      int32_t var_14 = r3;
080240c2      uint32_t result = arg3;
080240cc      *(uint8_t*)((char*)arg2 + 1) = 6;
080240cc      
080240d4      if (!(uint32_t)*(uint8_t*)((char*)arg2 + 0x2d))
080240d4      {
08024134          (*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 0x2c))(sub_80241d0);
08024138          result = (uint32_t)*(uint8_t*)arg3;
08024142          sub_8022786(arg1, arg2, arg3, 7, (uint8_t)result);
080240d4      }
080240d4      else
080240d4      {
080240da          if (!(uint32_t)*(uint8_t*)((char*)arg2 + 2))
080240da          {
080240de              var_14 = 0xff;
080240ea              result = (uint32_t)*(uint8_t*)((char*)arg2 + 0x2d) | 0x300;
080240f6              sub_8024228(arg1, arg2, (char*)arg1 + 0xc, 0, (uint16_t)result, 0xff);
080240da          }
080240da          
08024106          if (!sub_80244ec(arg1, arg2, arg3))
08024106          {
08024110              sub_802449e((char*)arg1 + 0xc, 0x2000dc28, 0xff);
0802411a              (*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 0x2c))(0x2000dc28);
0802411e              result = (uint32_t)*(uint8_t*)arg3;
08024128              sub_8022786(arg1, arg2, arg3, 7, (uint8_t)result);
08024106          }
080240d4      }
080240d4      
08024146      return result;
080240c2  }
08024148    uint32_t sub_8024148(void* arg1, void* arg2, char* arg3)
08024148  {
08024148      int32_t r3;
08024148      int32_t var_14 = r3;
08024148      uint32_t result = arg3;
08024152      *(uint8_t*)((char*)arg2 + 1) = 7;
08024152      
0802415a      if (!(uint32_t)*(uint8_t*)((char*)arg2 + 0x2e))
0802415a      {
080241ba          (*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 0x30))(sub_80241d0);
080241be          result = (uint32_t)*(uint8_t*)arg3;
080241c8          sub_8022786(arg1, arg2, arg3, 8, (uint8_t)result);
0802415a      }
0802415a      else
0802415a      {
08024160          if (!(uint32_t)*(uint8_t*)((char*)arg2 + 2))
08024160          {
08024164              var_14 = 0xff;
08024170              result = (uint32_t)*(uint8_t*)((char*)arg2 + 0x2e) | 0x300;
0802417c              sub_8024228(arg1, arg2, (char*)arg1 + 0xc, 0, (uint16_t)result, 0xff);
08024160          }
08024160          
0802418c          if (!sub_80244ec(arg1, arg2, arg3))
0802418c          {
08024196              sub_802449e((char*)arg1 + 0xc, 0x2000dc28, 0xff);
080241a0              (*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 0x30))(0x2000dc28);
080241a4              result = (uint32_t)*(uint8_t*)arg3;
080241ae              sub_8022786(arg1, arg2, arg3, 8, (uint8_t)result);
0802418c          }
0802415a      }
0802415a      
080241cc      return result;
08024148  }
080241ce                                            00 00                                                                ..
080241d0    uint32_t sub_80241d0(int32_t arg1, int32_t arg2, char* arg3)
080241d0  {
080241d2      int32_t r1 = arg1 << 1;
080241e0      *(uint8_t*)(r1 + 1) = 8;
080241e0      
080241e6      if (!(uint32_t)*(uint8_t*)(r1 + 2))
080241f2          sub_8024282(arg1, r1, (uint16_t)*(uint8_t*)(r1 + 0x35));
080241f2      
08024202      uint32_t result;
08024202      
08024202      if (!sub_80244ec(arg1, r1, arg3))
08024202      {
08024206          result = (uint32_t)*(uint8_t*)arg3;
08024210          sub_8022786(arg1, r1, arg3, 9, (uint8_t)result);
08024202      }
08024202      
08024214      return result;
080241d0  }
08024216    uint32_t sub_8024216(int32_t arg1, void* arg2, char* arg3)
08024216  {
08024216      int32_t r7;
08024216      int32_t var_8_1 = r7;
0802421a      *(uint8_t*)((char*)arg2 + 1) = 9;
0802421c      uint32_t result = (uint32_t)*(uint8_t*)arg3;
08024222      sub_8022786(arg1, arg2, arg3, 0x64, (uint8_t)result);
08024226      return result;
08024216  }
08024228    int32_t sub_8024228(int32_t arg1, void* arg2, int32_t arg3, char arg4, int16_t arg5, int16_t arg6)
08024228  {
08024232      *(uint8_t*)((char*)arg2 + 0x14) = arg4 | 0x80;
08024236      *(uint8_t*)((char*)arg2 + 0x15) = 6;
0802423a      *(uint16_t*)((char*)arg2 + 0x16) = arg5;
0802423a      
08024246      if (((uint32_t)arg5 & 0xff00) != 0x300)
08024252          *(uint16_t*)((char*)arg2 + 0x18) = 0;
08024246      else
0802424c          *(uint16_t*)((char*)arg2 + 0x18) = 0x409;
0802424c      
08024256      *(uint16_t*)((char*)arg2 + 0x1a) = arg6;
08024258      *(uint32_t*)((char*)arg2 + 0x10) = arg3;
0802425a      *(uint16_t*)((char*)arg2 + 0xc) = arg6;
0802425e      return arg6;
08024228  }
08024260    int32_t sub_8024260(int32_t arg1, void* arg2, char arg3)
08024260  {
08024266      *(uint8_t*)((char*)arg2 + 0x14) = 0;
0802426a      *(uint8_t*)((char*)arg2 + 0x15) = 5;
0802426e      *(uint16_t*)((char*)arg2 + 0x16) = (uint16_t)arg3;
08024272      *(uint16_t*)((char*)arg2 + 0x18) = 0;
08024276      *(uint16_t*)((char*)arg2 + 0x1a) = 0;
0802427a      *(uint32_t*)((char*)arg2 + 0x10) = 0;
0802427e      *(uint16_t*)((char*)arg2 + 0xc) = 0;
08024280      return 0;
08024260  }
08024282    int32_t sub_8024282(int32_t arg1, void* arg2, int16_t arg3)
08024282  {
08024288      *(uint8_t*)((char*)arg2 + 0x14) = 0;
0802428c      *(uint8_t*)((char*)arg2 + 0x15) = 9;
0802428e      *(uint16_t*)((char*)arg2 + 0x16) = arg3;
08024292      *(uint16_t*)((char*)arg2 + 0x18) = 0;
08024296      *(uint16_t*)((char*)arg2 + 0x1a) = 0;
0802429a      *(uint32_t*)((char*)arg2 + 0x10) = 0;
0802429e      *(uint16_t*)((char*)arg2 + 0xc) = 0;
080242a0      return 0;
08024282  }
080242a2    void sub_80242a2(char* arg1, char* arg2, int16_t arg3)
080242a2  {
080242a6      *(uint8_t*)arg1 = *(uint8_t*)arg2;
080242aa      arg1[1] = arg2[1];
080242b4      *(uint16_t*)(arg1 + 2) = (int16_t)((uint32_t)arg2[3] << 8) + (uint16_t)arg2[2];
080242b8      arg1[4] = arg2[4];
080242bc      arg1[5] = arg2[5];
080242c0      arg1[6] = arg2[6];
080242c4      arg1[7] = arg2[7];
080242c4      
080242ca      if ((uint32_t)arg3 < 9)
080242ca          return;
080242ca      
080242d4      *(uint16_t*)(arg1 + 8) = (int16_t)((uint32_t)arg2[9] << 8) + (uint16_t)arg2[8];
080242de      *(uint16_t*)(arg1 + 0xa) = (int16_t)((uint32_t)arg2[0xb] << 8) + (uint16_t)arg2[0xa];
080242e8      *(uint16_t*)(arg1 + 0xc) = (int16_t)((uint32_t)arg2[0xd] << 8) + (uint16_t)arg2[0xc];
080242ec      arg1[0xe] = arg2[0xe];
080242f0      arg1[0xf] = arg2[0xf];
080242f4      arg1[0x10] = arg2[0x10];
080242f8      arg1[0x11] = arg2[0x11];
080242a2  }
080242fe    int32_t sub_80242fe(char* arg1, void* arg2, int32_t arg3, char* arg4, int32_t arg5)
080242fe  {
0802430a      char* r7 = arg4;
0802431e      int16_t var_38 = 0;
08024324      *(uint8_t*)arg1 = *(uint8_t*)r7;
08024328      arg1[1] = r7[1];
08024332      *(uint16_t*)(arg1 + 2) = (int16_t)((uint32_t)r7[3] << 8) + (uint16_t)r7[2];
08024336      arg1[4] = r7[4];
0802433a      arg1[5] = r7[5];
0802433e      arg1[6] = r7[6];
08024342      arg1[7] = r7[7];
08024346      arg1[8] = r7[8];
08024348      int32_t result = arg5;
08024348      
0802434c      if (result >= 0xa)
0802434c      {
08024350          var_38 = 9;
08024350          
08024358          if ((uint32_t)arg1[4] < 3)
08024358          {
0802437a              while ((uint32_t)var_38 < (uint32_t)*(uint16_t*)(arg1 + 2))
0802437a              {
08024384                  r7 = sub_80244da(r7, &var_38);
08024384                  
0802438a                  if ((uint32_t)r7[1] == 4)
0802438a                  {
08024390                      uint32_t r10_2 = (uint32_t)r7[2];
0802439a                      char* r8_2 = (char*)arg2 + 9 * r10_2;
0802439a                      
080243a2                      if ((uint32_t)r7[3] < 3)
080243a2                      {
080243a8                          void var_34;
080243a8                          sub_8024458(&var_34, r7);
080243b2                          char var_30;
080243b2                          
080243b2                          if ((uint32_t)var_30 < 3)
080243b2                          {
080243b4                              char r11_1 = 0;
080243b4                              
080243e4                              while ((uint32_t)r11_1 < (uint32_t)var_30)
080243e4                              {
080243ee                                  r7 = sub_80244da(r7, &var_38);
080243ee                                  
080243f4                                  if ((uint32_t)r7[1] == 5)
080243f4                                  {
080243f6                                      r10_2 = (uint32_t)(uint8_t)r10_2;
08024402                                      uint32_t r11_2 = (uint32_t)r11_1;
08024402                                      
0802441a                                      if ((uint32_t)data_2000e466
0802441a                                          == (uint32_t)(uint8_t)r10_2)
0802441a                                      {
08024370                                          if ((uint32_t)(uint16_t)((uint32_t)r7[5] << 8)
08024370                                                  + (uint32_t)r7[4] < (uint32_t)data_2000e424)
08024370                                              break;
08024370                                          
080243be                                          sub_8024458(r8_2, &var_34);
0802441a                                      }
0802441a                                      else
0802441a                                      {
0802441e                                          data_2000e466 = (char)r10_2;
08024426                                          sub_8024458(r8_2, &var_34);
0802441a                                      }
0802441a                                      
080243c6                                      sub_802447e(0xe * r10_2 + arg3 + 7 * r11_2, r7);
080243d4                                      data_2000e424 =
080243d4                                          (int16_t)((uint32_t)r7[5] << 8) + (uint16_t)r7[4];
080243d6                                      r11_1 = (uint8_t)r11_2 + 1;
080243f4                                  }
080243e4                              }
080243b2                          }
080243a2                      }
0802438a                  }
0802437a              }
08024358          }
08024358          
08024430          data_2000e424 = 0;
08024432          result = 0;
08024436          data_2000e466 = 0;
0802434c      }
0802434c      
0802443a      return result;
080242fe  }
0802443e                                                                                            00 00                                ..
08024440  int32_t data_8024440 = 0x2000e465
08024444  int32_t data_8024444 = 0x200006c8
08024448  int32_t data_8024448 = 0x2000d850
0802444c  int32_t data_802444c = 0x2000dc28
08024450  int32_t data_8024450 = 0x2000e424
08024454  int32_t data_8024454 = 0x2000e466
08024458    void sub_8024458(char* arg1, char* arg2)
08024458  {
0802445a      *(uint8_t*)arg1 = *(uint8_t*)arg2;
0802445e      arg1[1] = arg2[1];
08024462      arg1[2] = arg2[2];
08024466      arg1[3] = arg2[3];
0802446a      arg1[4] = arg2[4];
0802446e      arg1[5] = arg2[5];
08024472      arg1[6] = arg2[6];
08024476      arg1[7] = arg2[7];
0802447a      arg1[8] = arg2[8];
08024458  }
0802447e    void sub_802447e(char* arg1, char* arg2)
0802447e  {
08024480      *(uint8_t*)arg1 = *(uint8_t*)arg2;
08024484      arg1[1] = arg2[1];
08024488      arg1[2] = arg2[2];
0802448c      arg1[3] = arg2[3];
08024496      *(uint16_t*)(arg1 + 4) = (int16_t)((uint32_t)arg2[5] << 8) + (uint16_t)arg2[4];
0802449a      arg1[6] = arg2[6];
0802447e  }
0802449e    void sub_802449e(char* arg1, char* arg2, int16_t arg3)
0802449e  {
080244a4      if ((uint32_t)arg1[1] != 3)
080244a4          return;
080244a4      
080244a6      uint32_t r2 = (uint32_t)arg3;
080244a6      
080244ae      if (r2 >= (uint32_t)*(uint8_t*)arg1 - 2)
080244b2          r2 = (uint32_t)*(uint8_t*)arg1 - 2;
080244b2      
080244b8      int16_t r3_3 = 0;
080244b8      
080244d0      while ((uint32_t)r3_3 < (uint32_t)(uint16_t)r2)
080244d0      {
080244bc          uint32_t r3_4 = (uint32_t)r3_3;
080244c0          *(uint8_t*)arg2 = arg1[2 + r3_4];
080244c2          arg2 = &arg2[1];
080244c4          r3_3 = (uint16_t)r3_4 + 2;
080244d0      }
080244d0      
080244d4      *(uint8_t*)arg2 = 0;
0802449e  }
080244da    void* sub_80244da(char* arg1, int16_t* arg2)
080244da  {
080244da      char r2_1 = *(uint8_t*)arg1;
080244e2      *(uint16_t*)arg2 += (uint16_t)r2_1;
080244e8      return &arg1[(uint32_t)r2_1];
080244da  }
080244ea                                12 13                                                                        ..
080244ec    uint32_t sub_80244ec(int32_t arg1, void* arg2, char* arg3)
080244ec  {
080244fe      if (!(uint32_t)data_2000e45e)
080244fe      {
08024506          data_2000e45e = 1;
0802450a          sub_80227f2(arg3);
08024512          sub_8022782(arg3, 0);
080244fe      }
080244fe      
0802451a      sub_8022746(arg3, 3);
0802452e      (*(uint32_t*)(&data_2000063c + ((uint32_t)*(uint8_t*)arg3 << 2)))(arg1, arg2, arg3);
08024530      uint32_t r0_5 = (uint32_t)*(uint8_t*)((char*)arg2 + 2);
08024534      char r0_6;
08024534      
08024534      if (r0_5 == 4)
08024534      {
08024566          data_2000e45e = 0;
0802456a          *(uint8_t*)((char*)arg2 + 2) = 0;
0802456c          r0_6 = 2;
08024534      }
08024534      else if (r0_5 < 4)
08024570          r0_6 = 1;
08024536      else if (r0_5 == 6)
0802453a      {
08024546          data_2000e45e = 0;
0802454a          *(uint8_t*)((char*)arg2 + 2) = 0;
0802454c          r0_6 = 0;
0802453a      }
0802453a      else if (r0_5 < 6)
0802453c      {
08024556          data_2000e45e = 0;
0802455a          *(uint8_t*)((char*)arg2 + 2) = 0;
0802455c          r0_6 = 3;
0802453c      }
0802453c      else
08024570          r0_6 = 1;
08024570      
08024574      return (uint32_t)r0_6;
080244ec  }
08024576    uint32_t sub_8024576(int32_t arg1, void* arg2, char* arg3)
08024576  {
08024576      int32_t r7;
08024576      int32_t var_8_1 = r7;
0802457a      *(uint8_t*)((char*)arg2 + 2) = 0;
0802457c      uint32_t result = (uint32_t)*(uint8_t*)arg3;
08024582      sub_8022786(arg1, arg2, arg3, 1, (uint8_t)result);
08024586      return result;
08024576  }
08024588    uint32_t sub_8024588(void* arg1, void* arg2, char* arg3)
08024588  {
08024596      *(uint8_t*)((char*)arg2 + 2) = 1;
080245a0      uint32_t result;
080245a0      
080245a0      if ((uint32_t)data_2000e45f)
080245a0      {
080245c0          uint32_t r0_4 = (uint32_t)sub_8022662(arg1, *(uint8_t*)((char*)arg2 + 9));
080245c0          
080245c4          if (r0_4 == 1)
080245c4          {
080245ca              if (!(uint32_t)*(uint16_t*)((char*)arg2 + 0x1a))
080245ca              {
080245f4                  usb_timeout_ms = 0x32;
080245fa                  data_2000e45f = 0;
080245fe                  result = (uint32_t)*(uint8_t*)arg3;
08024608                  sub_8022786(arg1, arg2, arg3, 3, (uint8_t)result);
080245ca              }
080245ca              else
080245ca              {
080245d2                  data_2000e45f = 0;
080245dc                  usb_timeout_ms = 0x1388;
080245e0                  result = (uint32_t)*(uint8_t*)arg3;
080245ea                  sub_8022786(arg1, arg2, arg3, 2, (uint8_t)result);
080245ca              }
080245ca              
08024610              *(uint16_t*)((char*)arg2 + 0xe) = (int16_t)*(uint32_t*)0x50000408;
080245c4          }
080245c4          else if ((uint32_t)(uint8_t)r0_4 == 3)
08024618          {
0802461e              data_2000e45f = 0;
08024622              result = (uint32_t)*(uint8_t*)arg3;
0802462c              sub_8022786(arg1, arg2, arg3, 5, (uint8_t)result);
08024618          }
080245a0      }
080245a0      else
080245a0      {
080245a8          data_2000e45f = 1;
080245b2          sub_8024a62(arg1, (char*)arg2 + 0x14, *(uint8_t*)((char*)arg2 + 9));
080245a0      }
080245a0      
08024630      return result;
08024588  }
08024632    uint32_t USB_host_timing_and_state(void* arg1, void* arg2, char* arg3)
08024632  {
08024640      *(uint8_t*)((char*)arg2 + 2) = 2;
0802464c      uint32_t result;
0802464c      
0802464c      if (((uint32_t)*(uint8_t*)((char*)arg2 + 0x14) & 0x80) != 0x80)
0802464c      {
080246fa          if ((uint32_t)busy_in_progress_flag)
080246fa          {
08024726              uint32_t r0_24 = (uint32_t)sub_8022662(arg1, *(uint8_t*)((char*)arg2 + 9));
08024726              
0802472a              if (r0_24 == 1)
0802472a              {
0802473e                  busy_in_progress_flag = 0;
08024742                  result = (uint32_t)*(uint8_t*)arg3;
0802474c                  sub_8022786(arg1, arg2, arg3, 3, (uint8_t)result);
0802472a              }
0802472a              else if (r0_24 >= 1)
0802472c              {
08024730                  if (r0_24 == 3)
08024730                  {
08024776                      busy_in_progress_flag = 0;
0802477a                      result = (uint32_t)*(uint8_t*)arg3;
08024784                      sub_8022786(arg1, arg2, arg3, 5, (uint8_t)result);
08024730                  }
08024730                  else if (r0_24 < 3)
0802476e                      busy_in_progress_flag = 0;
08024732                  else if (r0_24 == 4)
08024736                  {
08024756                      busy_in_progress_flag = 0;
0802475a                      result = (uint32_t)*(uint8_t*)arg3;
08024764                      sub_8022786(arg1, arg2, arg3, 6, (uint8_t)result);
08024736                  }
0802472c              }
080246fa          }
080246fa          else
080246fa          {
08024700              busy_in_progress_flag = 1;
0802470c              *(uint8_t*)(0x24 * (uint32_t)*(uint8_t*)((char*)arg2 + 9) + arg1 + 0x233) = 1;
08024718              sub_8024986(arg1, *(uint32_t*)((char*)arg2 + 0x10), 
08024718                  *(uint8_t*)((char*)arg2 + 9), (uint32_t)*(uint16_t*)((char*)arg2 + 0xc));
080246fa          }
0802464c      }
0802464c      else if ((uint32_t)busy_in_progress_flag)
08024654      {
08024672          uint32_t r0_7 = (uint32_t)sub_8022662(arg1, *(uint8_t*)((char*)arg2 + 8));
08024672          
08024676          if (r0_7 == 1)
08024676          {
08024686              busy_in_progress_flag = 0;
0802468a              result = (uint32_t)*(uint8_t*)arg3;
08024694              sub_8022786(arg1, arg2, arg3, 3, (uint8_t)result);
08024676          }
08024676          else if (r0_7 == 3)
0802467a          {
080246b6              busy_in_progress_flag = 0;
080246ba              result = (uint32_t)*(uint8_t*)arg3;
080246c4              sub_8022786(arg1, arg2, arg3, 5, (uint8_t)result);
0802467a          }
0802467a          else if (r0_7 == 4)
0802467e          {
0802469e              busy_in_progress_flag = 0;
080246a2              result = (uint32_t)*(uint8_t*)arg3;
080246ac              sub_8022786(arg1, arg2, arg3, 6, (uint8_t)result);
0802467e          }
0802467e          else if ((uint32_t)usb_timeout_ms < (uint32_t)(uint16_t)*(uint32_t*)0x50000408
0802467e              - (uint32_t)*(uint16_t*)((char*)arg2 + 0xe))
080246da          {
080246e0              busy_in_progress_flag = 0;
080246e4              result = (uint32_t)*(uint8_t*)arg3;
080246ee              sub_8022786(arg1, arg2, arg3, 5, (uint8_t)result);
080246da          }
08024654      }
08024654      else
08024654      {
0802465a          busy_in_progress_flag = 1;
08024664          sub_8024986(arg1, *(uint32_t*)((char*)arg2 + 0x10), *(uint8_t*)((char*)arg2 + 8), 
08024664              (uint32_t)*(uint16_t*)((char*)arg2 + 0xc));
08024654      }
08024654      
0802478a      return result;
08024632  }
0802478c    uint32_t sub_802478c(void* arg1, void* arg2, char* arg3)
0802478c  {
0802479a      *(uint8_t*)((char*)arg2 + 2) = 3;
080247a6      uint32_t result;
080247a6      
080247a6      if ((uint32_t)*(uint8_t*)((char*)arg2 + 0x14) & 0x80)
080247a6      {
08024854          if ((uint32_t)data_2000e461)
08024854          {
080248cc              uint32_t r0_35 = (uint32_t)sub_8022662(arg1, *(uint8_t*)((char*)arg2 + 9));
080248cc              
080248d0              if (r0_35 == 1)
080248d0              {
080248e0                  data_2000e461 = 0;
080248e4                  result = (uint32_t)*(uint8_t*)arg3;
080248ee                  sub_8022786(arg1, arg2, arg3, 4, (uint8_t)result);
080248d0              }
080248d0              else if (r0_35 >= 1)
080248d2              {
080248d6                  if (r0_35 == 3)
080248d6                  {
08024900                      data_2000e461 = 0;
08024904                      result = (uint32_t)*(uint8_t*)arg3;
0802490e                      sub_8022786(arg1, arg2, arg3, 5, (uint8_t)result);
080248d6                  }
080248d6                  else if (r0_35 < 3)
080248f8                      data_2000e461 = 0;
080248d2              }
08024854          }
08024854          else
08024854          {
0802485a              data_2000e461 = 1;
08024874              *(uint8_t*)(0x24 * (uint32_t)*(uint8_t*)((char*)arg2 + 9) + arg1 + 0x233) ^=
08024874                  1;
08024880              sub_8024986(arg1, 0, *(uint8_t*)((char*)arg2 + 9), 0);
0802489c              *(uint32_t*)(0x50000510 + ((uint32_t)*(uint8_t*)((char*)arg2 + 9) << 5)) |= 1;
080248c0              *(uint32_t*)(((uint32_t)*(uint8_t*)((char*)arg2 + 9) << 5) + 0x50000500) = (
080248c0                  *(uint32_t*)(((uint32_t)*(uint8_t*)((char*)arg2 + 9) << 5) + 0x50000500)
080248c0                  & 0x3fffffff) | 0x80000000;
08024854          }
080247a6      }
080247a6      else if ((uint32_t)data_2000e461)
080247ae      {
080247cc          uint32_t r0_7 = (uint32_t)sub_8022662(arg1, *(uint8_t*)((char*)arg2 + 8));
080247cc          
080247d0          if (r0_7 == 1)
080247d0          {
080247e0              data_2000e461 = 0;
080247e4              result = (uint32_t)*(uint8_t*)arg3;
080247ee              sub_8022786(arg1, arg2, arg3, 4, (uint8_t)result);
080247d0          }
080247d0          else if (r0_7 == 3)
080247d4          {
080247f8              data_2000e461 = 0;
080247fc              result = (uint32_t)*(uint8_t*)arg3;
08024806              sub_8022786(arg1, arg2, arg3, 5, (uint8_t)result);
080247d4          }
080247d4          else if (r0_7 == 4)
080247d8          {
08024810              data_2000e461 = 0;
08024814              result = (uint32_t)*(uint8_t*)arg3;
0802481e              sub_8022786(arg1, arg2, arg3, 6, (uint8_t)result);
080247d8          }
080247d8          else if ((uint32_t)usb_timeout_ms < (uint32_t)(uint16_t)*(uint32_t*)0x50000408
080247d8              - (uint32_t)*(uint16_t*)((char*)arg2 + 0xe))
08024834          {
0802483a              data_2000e461 = 0;
0802483e              result = (uint32_t)*(uint8_t*)arg3;
08024848              sub_8022786(arg1, arg2, arg3, 5, (uint8_t)result);
08024834          }
080247ae      }
080247ae      else
080247ae      {
080247b4          data_2000e461 = 1;
080247be          sub_8024986(arg1, 0, *(uint8_t*)((char*)arg2 + 8), 0);
080247ae      }
080247ae      
08024914      return result;
0802478c  }
08024916                                                                    00 00                                                ..
08024918  int32_t data_8024918 = 0x2000e45e
0802491c  int32_t data_802491c = 0x2000063c
08024920  int32_t data_8024920 = 0x2000e45f
08024924  int32_t data_8024924 = 0x2000e422
08024928  int32_t data_8024928 = 0x50000408
0802492c  int32_t data_802492c = 0x2000e460
08024930  int32_t data_8024930 = 0x2000e461
08024934  int32_t data_8024934 = 0x50000510
08024938    uint32_t sub_8024938(int32_t arg1, void* arg2, char* arg3)
08024938  {
08024938      int32_t r7;
08024938      int32_t var_8 = r7;
0802493c      *(uint8_t*)((char*)arg2 + 2) = 4;
08024942      *(uint8_t*)((char*)arg2 + 0xb) += 1;
08024948      uint32_t result;
08024948      
08024948      if ((uint32_t)*(uint8_t*)((char*)arg2 + 0xb) >= 3)
08024948      {
08024958          result = (uint32_t)*(uint8_t*)arg3;
0802495c          sub_8022786(arg1, arg2, arg3, 0x64, (uint8_t)result);
08024948      }
08024948      else
08024948      {
0802494c          result = (uint32_t)*(uint8_t*)arg3;
08024950          sub_8022786(arg1, arg2, arg3, 1, (uint8_t)result);
08024948      }
08024948      
08024960      return result;
08024938  }
08024962    uint32_t sub_8024962(int32_t arg1, void* arg2, char* arg3)
08024962  {
08024962      int32_t r7;
08024962      int32_t var_8_1 = r7;
08024966      *(uint8_t*)((char*)arg2 + 2) = 5;
08024968      uint32_t result = (uint32_t)*(uint8_t*)arg3;
0802496e      sub_8022786(arg1, arg2, arg3, 0x64, (uint8_t)result);
08024972      return result;
08024962  }
08024974    uint32_t sub_8024974(int32_t arg1, void* arg2, char* arg3)
08024974  {
08024974      int32_t r7;
08024974      int32_t var_8_1 = r7;
08024978      *(uint8_t*)((char*)arg2 + 2) = 6;
0802497a      uint32_t result = (uint32_t)*(uint8_t*)arg3;
08024980      sub_8022786(arg1, arg2, arg3, 0x64, (uint8_t)result);
08024984      return result;
08024974  }
08024986    int32_t sub_8024986(void* arg1, int32_t arg2, char arg3, int32_t arg4)
08024986  {
08024986      int32_t var_10 = arg4;
08024988      uint32_t r2 = (uint32_t)arg3;
08024998      *(uint32_t*)(0x24 * r2 + arg1 + 0x21c) = arg2;
0802499a      uint32_t r3 = (uint32_t)(uint16_t)arg4;
0802499c      *(uint32_t*)(0x24 * r2 + arg1 + 0x220) = r3;
0802499e      uint32_t r1 = (uint32_t)*(uint8_t*)(0x24 * r2 + arg1 + 0x215);
0802499e      
080249a2      if (!r1)
080249a2      {
080249b4          if ((uint32_t)*(uint8_t*)(0x24 * r2 + arg1 + 0x214))
080249d8              *(uint8_t*)(0x24 * r2 + arg1 + 0x212) = 2;
080249b4          else
080249b4          {
080249ba              if (!(uint32_t)(uint16_t)r3)
080249be                  *(uint8_t*)(0x24 * r2 + arg1 + 0x233) = 1;
080249be              
080249c8              if ((uint32_t)*(uint8_t*)(0x24 * r2 + arg1 + 0x233))
080249d2                  *(uint8_t*)(0x24 * r2 + arg1 + 0x212) = 2;
080249c8              else
080249cc                  *(uint8_t*)(0x24 * r2 + arg1 + 0x212) = 0;
080249b4          }
080249a2      }
080249a2      else if (r1 == 2)
080249a6      {
080249e6          if ((uint32_t)*(uint8_t*)(0x24 * r2 + arg1 + 0x214))
080249e6          {
08024a02              if ((uint32_t)*(uint8_t*)(0x24 * r2 + arg1 + 0x232))
08024a0c                  *(uint8_t*)(0x24 * r2 + arg1 + 0x212) = 2;
08024a02              else
08024a06                  *(uint8_t*)(0x24 * r2 + arg1 + 0x212) = 0;
080249e6          }
080249e6          else if ((uint32_t)*(uint8_t*)(0x24 * r2 + arg1 + 0x233))
080249f8              *(uint8_t*)(0x24 * r2 + arg1 + 0x212) = 2;
080249ee          else
080249f2              *(uint8_t*)(0x24 * r2 + arg1 + 0x212) = 0;
080249a6      }
080249a6      else if (r1 < 2)
080249de          *(uint8_t*)(0x24 * r2 + arg1 + 0x212) = 0;
080249a8      else if (r1 == 3)
080249ac      {
08024a14          if ((uint32_t)*(uint8_t*)(0x24 * r2 + arg1 + 0x214))
08024a14          {
08024a3c              if ((uint32_t)*(uint8_t*)(0x24 * r2 + arg1 + 0x232))
08024a46                  *(uint8_t*)(0x24 * r2 + arg1 + 0x212) = 2;
08024a3c              else
08024a40                  *(uint8_t*)(0x24 * r2 + arg1 + 0x212) = 0;
08024a40              
08024a50              *(uint8_t*)(0x24 * r2 + arg1 + 0x232) ^= 1;
08024a14          }
08024a14          else
08024a14          {
08024a1c              if ((uint32_t)*(uint8_t*)(0x24 * r2 + arg1 + 0x233))
08024a26                  *(uint8_t*)(0x24 * r2 + arg1 + 0x212) = 2;
08024a1c              else
08024a20                  *(uint8_t*)(0x24 * r2 + arg1 + 0x212) = 0;
08024a20              
08024a30              *(uint8_t*)(0x24 * r2 + arg1 + 0x233) ^= 1;
08024a14          }
080249ac      }
080249ac      
08024a5a      sub_8024a8a(arg1, (uint8_t)r2);
08024a60      return 0;
08024986  }
08024a62    uint32_t sub_8024a62(void* arg1, int32_t arg2, char arg3)
08024a62  {
08024a64      uint32_t r2 = (uint32_t)arg3;
08024a76      *(uint8_t*)(0x24 * r2 + arg1 + 0x212) = 3;
08024a78      *(uint32_t*)(0x24 * r2 + arg1 + 0x21c) = arg2;
08024a7c      *(uint32_t*)(0x24 * r2 + arg1 + 0x220) = 8;
08024a88      return (uint32_t)sub_8024a8a(arg1, (uint8_t)r2);
08024a62  }
08024a8a    int32_t sub_8024a8a(void* arg1, char arg2)
08024a8a  {
08024a8a      int32_t r7;
08024a8a      int32_t var_8 = r7;
08024a8c      uint32_t r1 = (uint32_t)arg2;
08024a9e      *(uint8_t*)(0x24 * r1 + arg1 + 0x231) = 0;
08024aa4      *(uint32_t*)(0x24 * r1 + arg1 + 0x224) = 0;
08024aac      return sub_8023aa6(arg1, (char)r1);
08024a8a  }
08024aae    int32_t sub_8024aae(void* arg1, void* arg2, int32_t arg3, int32_t arg4)
08024aae  {
08024aae      /* unimplemented  {vsli.32 d27, d16, #0x1f} */
08024aae      
08024ac6      if ((uint32_t)*(uint8_t*)((char*)arg2 + 0x3e) != 8
08024ac6              || (uint32_t)*(uint8_t*)((char*)arg2 + 0x40) != 0x50)
08024b76          (*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 0x40))();
08024ac6      else
08024ac6      {
08024ace          if ((uint32_t)*(uint8_t*)((char*)arg2 + 0x4d) << 0x18 >= 0)
08024ace          {
08024aee              data_2000d246 = *(uint8_t*)((char*)arg2 + 0x4d);
08024af8              data_2000d24a = *(uint16_t*)((char*)arg2 + 0x4f);
08024ace          }
08024ace          else
08024ace          {
08024ad8              data_2000d247 = *(uint8_t*)((char*)arg2 + 0x4d);
08024ae2              data_2000d248 = *(uint16_t*)((char*)arg2 + 0x4f);
08024ace          }
08024ace          
08024b00          if ((uint32_t)*(uint8_t*)((char*)arg2 + 0x54) << 0x18 >= 0)
08024b00          {
08024b1a              data_2000d246 = *(uint8_t*)((char*)arg2 + 0x54);
08024b22              data_2000d24a = *(uint16_t*)((char*)arg2 + 0x56);
08024b00          }
08024b00          else
08024b00          {
08024b08              data_2000d247 = *(uint8_t*)((char*)arg2 + 0x54);
08024b10              data_2000d248 = *(uint16_t*)((char*)arg2 + 0x56);
08024b00          }
08024b00          
08024b30          data_2000d245 = sub_802341a(arg1, data_2000d246);
08024b3e          data_2000d244 = sub_802341a(arg1, data_2000d247);
08024b54          sub_8023384(arg1, data_2000d245, *(uint8_t*)((char*)arg2 + 0x1c), 
08024b54              *(uint8_t*)((char*)arg2 + 0x1d), 2, data_2000d24a);
08024b60          int32_t var_c = 2;
08024b6c          sub_8023384(arg1, data_2000d244, *(uint8_t*)((char*)arg2 + 0x1c), 
08024b6c              *(uint8_t*)((char*)arg2 + 0x1d), 2, data_2000d248);
08024ac6      }
08024ac6      
08024b7a      return 0;
08024aae  }
08024b7c    uint32_t sub_8024b7c(void* arg1)
08024b7c  {
08024b84      data_20000b7c = 0;
08024b8a      data_20000b7b = 0;
08024b8a      
08024b92      if ((uint32_t)data_2000d245)
08024b92      {
08024b9a          sub_8023c18(arg1, data_2000d245);
08024ba4          sub_8023448(arg1, data_2000d245);
08024bac          data_2000d245 = 0;
08024b92      }
08024b92      
08024bb0      uint32_t result = (uint32_t)data_2000d244;
08024bb0      
08024bb4      if (result)
08024bb4      {
08024bbc          sub_8023c18(arg1, data_2000d244);
08024bc6          sub_8023448(arg1, data_2000d244);
08024bca          result = 0;
08024bce          data_2000d244 = 0;
08024bb4      }
08024bb4      
08024bd0      return result;
08024b7c  }
08024bd2    int32_t sub_8024bd2()
08024bd2  {
08024bd8      data_2000e268 = 0;
08024bdc      return 0;
08024bd2  }
08024bde    uint32_t sub_8024bde(void* arg1, void* arg2, char* arg3)
08024bde  {
08024bea      uint32_t r4 = 1;
08024bea      
08024bf8      if (sub_802265c(arg1))
08024bf8      {
08024bfe          uint32_t r0_2 = (uint32_t)data_2000e268;
08024bfe          
08024c02          if (!r0_2)
08024c02          {
08024c32              sub_8022e60(arg1, arg3);
08024c3a              data_2000e268 = 1;
08024c02          }
08024c02          else if (r0_2 == 2)
08024c06          {
08024c52              if (!(uint32_t)*(uint8_t*)((char*)arg2 + 2))
08024c58                  sub_8024db4(arg1, arg2);
08024c58              
08024c68              r4 = (uint32_t)sub_80244ec(arg1, arg2, arg3);
08024c68              
08024c6c              if (r4)
08024c6c                  goto label_8024ca0;
08024c6c              
08024c74              data_2000d44c = data_2000d24c;
08024c74              
08024c88              if (!(uint32_t)data_2000d44c || (uint32_t)data_2000e464)
08024c88              {
08024c9e                  data_2000e268 = 3;
08024ca0              label_8024ca0:
08024ca0                  r4 = (uint32_t)(uint8_t)r4;
08024ca0                  
08024ca4                  if (r4 == 3)
08024ca4                  {
08024caa                      data_2000e269 = 3;
08024cb0                      data_2000e268 = 9;
08024ca4                  }
08024c88              }
08024c88              else
08024c88              {
08024c8e                  data_2000e464 = 1;
08024c96                  (*(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 0x40))();
08024c88              }
08024c06          }
08024c06          else if (r0_2 < 2)
08024c08          {
08024c40              r4 = 0;
08024c4a              data_2000e268 = 2;
08024c08          }
08024c08          else if (r0_2 == 4)
08024c0c          {
08024d16              uint32_t r0_24 = (uint32_t)sub_8022976(arg1);
08024d16              
08024d1a              if (r0_24)
08024d2e                  sub_8024dd8((char)r0_24);
08024d1a              else
08024d1a              {
08024d20                  data_2000e268 = 5;
08024d26                  data_2000e463 = 0;
08024d28                  r4 = 0;
08024d1a              }
08024c0c          }
08024c0c          else if (r0_2 < 4)
08024c10          {
08024cf2              uint32_t r0_20 = (uint32_t)sub_802289c(arg1);
08024cf2              
08024cf6              if (r0_20)
08024d0a                  sub_8024dd8((char)r0_20);
08024cf6              else
08024cf6              {
08024cfc                  data_2000e268 = 4;
08024d02                  data_2000e463 = 0;
08024d04                  r4 = 0;
08024cf6              }
08024c10          }
08024c10          else if (r0_2 == 6)
08024c14          {
08024d5e              uint32_t r0_32 = (uint32_t)sub_8022b8a(arg1);
08024d5e              
08024d62              if (r0_32)
08024d72                  sub_8024dd8((char)r0_32);
08024d62              else
08024d62              {
08024d6a                  data_2000e268 = data_2000e269;
08024d6c                  r4 = 0;
08024d62              }
08024c14          }
08024c14          else if (r0_2 < 6)
08024c18          {
08024d3a              uint32_t r0_28 = (uint32_t)sub_8022a92(arg1);
08024d3a              
08024d3e              if (r0_28)
08024d52                  sub_8024dd8((char)r0_28);
08024d3e              else
08024d3e              {
08024d44                  data_2000e268 = 8;
08024d4a                  data_2000e463 = 0;
08024d4c                  r4 = 0;
08024d3e              }
08024c18          }
08024c18          else if (r0_2 == 8)
08024c1e          {
08024d90              uint32_t r0_38 = (uint32_t)(
08024d90                  *(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x68) + 0x3c))(arg1, 0);
08024d90              
08024d94              if (!r0_38)
08024d9a                  data_2000e268 = 8;
08024d94              else if ((uint32_t)(uint8_t)r0_38 == 1)
08024da4                  r4 = 6;
08024c1e          }
08024c1e          else if (r0_2 < 8)
08024d7e              sub_8022ea0(arg1, arg2, arg3);
08024c22          else if (r0_2 == 0xa)
08024da8              r4 = 4;
08024c28          else if (r0_2 < 0xa)
08024c2c          {
08024cb8              if (!(uint32_t)*(uint8_t*)((char*)arg2 + 2))
08024cc4                  sub_8024e30(arg1, arg2, 0, *(uint8_t*)((char*)arg2 + 9));
08024cc4              
08024cd4              r4 = (uint32_t)sub_80244ec(arg1, arg2, arg3);
08024cd4              
08024cd8              if (!r4)
08024cd8              {
08024cde                  data_2000d44c = 0;
08024ce8                  data_2000e268 = data_2000e269;
08024cd8              }
08024c2c          }
08024bf8      }
08024bf8      
08024db0      return (uint32_t)(uint8_t)r4;
08024bde  }
08024db4    int32_t sub_8024db4(int32_t arg1, void* arg2)
08024db4  {
08024dba      *(uint8_t*)((char*)arg2 + 0x14) = 0xa1;
08024dbe      *(uint8_t*)((char*)arg2 + 0x15) = 0xfe;
08024dc2      *(uint16_t*)((char*)arg2 + 0x16) = 0;
08024dc6      *(uint16_t*)((char*)arg2 + 0x18) = 0;
08024dca      *(uint16_t*)((char*)arg2 + 0x1a) = 1;
08024dce      *(uint32_t*)((char*)arg2 + 0x10) = &data_2000d24c;
08024dd2      *(uint16_t*)((char*)arg2 + 0xc) = 1;
08024dd6      return 0;
08024db4  }
08024dd8    uint32_t sub_8024dd8(char arg1)
08024dd8  {
08024dd8      uint32_t r0_3 = (uint32_t)arg1;
08024ddc      uint32_t result;
08024ddc      
08024ddc      if (r0_3 != 1)
08024ddc      {
08024e06          result = (uint32_t)(uint8_t)r0_3;
08024e06          
08024e0a          if (result == 2)
08024e0a          {
08024e0c              result = 0xa;
08024e10              data_2000e268 = 0xa;
08024e0a          }
08024ddc      }
08024ddc      else
08024ddc      {
08024de6          data_2000e463 += 1;
08024de6          
08024dee          if ((uint32_t)data_2000e463 >= 0xa)
08024dee          {
08024dfe              result = 0xa;
08024e02              data_2000e268 = 0xa;
08024dee          }
08024dee          else
08024dee          {
08024df4              data_2000e268 = 6;
08024df6              result = 1;
08024dfa              data_2000e26b = 1;
08024dee          }
08024ddc      }
08024ddc      
08024e14      return result;
08024dd8  }
08024e16                                                                    00 00                                                ..
08024e18  int32_t data_8024e18 = 0x2000d244
08024e1c  int32_t data_8024e1c = 0x20000b78
08024e20  int32_t data_8024e20 = 0x2000e268
08024e24  int32_t data_8024e24 = 0x2000e464
08024e28  int32_t data_8024e28 = 0x2000e463
08024e2c  int32_t data_8024e2c = 0x2000d24c
08024e30    int32_t sub_8024e30(void* arg1, void* arg2, char arg3, char arg4)
08024e30  {
08024e38      *(uint8_t*)((char*)arg2 + 0x14) = 2;
08024e3c      *(uint8_t*)((char*)arg2 + 0x15) = 1;
08024e40      *(uint16_t*)((char*)arg2 + 0x16) = 0;
08024e42      uint16_t r2 = (uint16_t)arg3;
08024e44      *(uint16_t*)((char*)arg2 + 0x18) = r2;
08024e48      *(uint16_t*)((char*)arg2 + 0x1a) = 0;
08024e48      
08024e4e      if ((uint32_t)(uint8_t)r2 << 0x18 >= 0)
08024e6a          *(uint8_t*)((char*)arg1 + 0x24 * (uint32_t)arg4 + 0x233) = 0;
08024e4e      else
08024e5a          *(uint8_t*)((char*)arg1 + 0x24 * (uint32_t)arg4 + 0x232) = 0;
08024e5a      
08024e70      *(uint32_t*)((char*)arg2 + 0x10) = 0;
08024e74      *(uint16_t*)((char*)arg2 + 0xc) = 0;
08024e7a      return 0;
08024e30  }
08024e7c    uint32_t sub_8024e7c(char arg1, char* arg2)
08024e7c  {
08024e7c      int32_t r3;
08024e7c      int32_t var_18_1 = r3;
08024e82      char r5 = 6;
08024e8e      memset16x2(&data_2000e170, 0x14, 0);
08024e96      USART_TypeDef* usart;
08024e96      void* dmactx;
08024e96      
08024e96      if ((uint32_t)arg1)
08024e96      {
08024ea8          usart = data_20000c34;
08024eaa          dmactx = &data_20000c64;
08024e96      }
08024e96      else
08024e96      {
08024e9c          usart = data_20000560;
08024e9e          dmactx = &data_20000590;
08024e96      }
08024e96      
08024eb0      int32_t var_18 = 0xa;
08024ebc      cam_uart_tx_start(usart, dmactx, &data_2000e170);
08024ebc      
08024ec8      if ((uint32_t)data_2000e170 == 0x43)
08024ec8      {
08024ecc          var_18 = 0xa;
08024ed8          cam_uart_tx_start(usart, dmactx, &data_2000e171);
08024ed8          
08024ee4          if ((uint32_t)data_2000e171 == 0x6c)
08024ee4          {
08024ee8              var_18 = 0xa;
08024ef4              cam_uart_tx_start(usart, dmactx, &data_2000e172);
08024ef4              
08024f00              if ((uint32_t)data_2000e172 == 0x65)
08024f00              {
08024f06                  var_18 = 0x3e8;
08024f12                  cam_uart_tx_start(usart, dmactx, &data_2000e173);
08024f12                  
08024f28                  if ((uint32_t)data_2000e182 == 0x76 && (uint32_t)data_2000e183 == 0x61
08024f28                      && ((uint32_t)data_2000e181
08024f28                      | (uint32_t)(uint16_t)((uint32_t)data_2000e180 << 8))
08024f28                      == sub_8025c3c(&data_2000e170))
08024f28                  {
08024f4a                      if (arg2)
08024f4a                      {
08024f52                          *(uint8_t*)arg2 = data_2000e173;
08024f5a                          arg2[1] = data_2000e174;
08024f6c                          *(uint16_t*)(arg2 + 2) = (uint16_t)data_2000e176
08024f6c                              | (int16_t)((uint32_t)data_2000e175 << 8);
08024f7e                          *(uint16_t*)(arg2 + 4) = (uint16_t)data_2000e178
08024f7e                              | (int16_t)((uint32_t)data_2000e177 << 8);
08024f90                          *(uint16_t*)(arg2 + 6) = (uint16_t)data_2000e17a
08024f90                              | (int16_t)((uint32_t)data_2000e179 << 8);
08024fa2                          *(uint16_t*)(arg2 + 8) = (uint16_t)data_2000e17c
08024fa2                              | (int16_t)((uint32_t)data_2000e17b << 8);
08024f4a                      }
08024f4a                      
08024fa8                      r5 = data_2000e173;
08024f28                  }
08024f00              }
08024ee4          }
08024ec8      }
08024ec8      
08024fae      return (uint32_t)r5;
08024e7c  }
08024fb0    int32_t sub_8024fb0(char arg1, int32_t arg2, int32_t arg3, int32_t arg4)
08024fb0  {
08024fc0      memset16x2(&data_2000e184, 0x14, 0);
08024fca      data_2000e184 = 0x43;
08024fd2      data_2000e185 = 0x6c;
08024fda      data_2000e186 = 0x65;
08024fe2      data_2000e196 = 0x76;
08024fea      data_2000e197 = 0x61;
08024ff4      data_2000e187 = (uint8_t)arg2;
08024ffe      data_2000e188 = *(uint8_t*)((char*)arg2)[1];
0802500c      data_2000e189 = (char)((uint32_t)*(uint16_t*)((char*)arg2)[2] >> 8);
08025016      data_2000e18a = *(uint8_t*)((char*)arg2)[2];
08025024      data_2000e18b = (char)((uint32_t)(uint16_t)arg3 >> 8);
0802502e      data_2000e18c = (uint8_t)arg3;
0802503c      data_2000e18d = (char)((uint32_t)*(uint16_t*)((char*)arg3)[2] >> 8);
08025046      data_2000e18e = *(uint8_t*)((char*)arg3)[2];
08025054      data_2000e18f = (char)((uint32_t)(uint16_t)arg4 >> 8);
0802505e      data_2000e190 = (uint8_t)arg4;
08025064      int16_t r0_18 = sub_8025c3c(&data_2000e184);
08025072      data_2000e194 = (char)((uint32_t)r0_18 >> 8);
08025078      data_2000e195 = (uint8_t)r0_18;
08025078      
0802507e      if ((uint32_t)arg1)
080250a6          sub_8026c3a(data_20000c34, &data_20000c64);
0802507e      else
08025090          sub_8026c3a(data_20000560, &data_20000590);
08025090      
080250ac      return 1;
08024fb0  }
080250ae    uint32_t BoardTest_CheckEntryCondition(char arg1, char* arg2)
080250ae  {
080250ae      int32_t r3;
080250ae      int32_t var_10 = r3;
080250ae      int32_t r2;
080250ae      int32_t var_14 = r2;
080250ae      char* var_18 = arg2;
080250c6      uint32_t r4_1 = (uint32_t)sub_8024e7c(arg1, arg2);
080250c6      
080250ca      if (r4_1 == 6)
080250e6          return (uint32_t)(uint8_t)r4_1;
080250e6      
080250da      sub_8024fb0(0, 0, 0, 0);
080250e0      return (uint32_t)(uint8_t)r4_1;
080250ae  }
080250ea    uint32_t sub_80250ea(char arg1, char* arg2, char arg3)
080250ea  {
08025100      char r0_1 = sub_8024e7c(arg1, arg2);
08025100      
0802510e      if ((uint32_t)r0_1 != (uint32_t)arg3)
0802512a          return (uint32_t)r0_1;
0802512a      
0802511e      sub_8024fb0(0, 0, 0, 0);
08025124      return (uint32_t)r0_1;
080250ea  }
08025130    BootResult SystemBringUp_AndMaybeRunBoardTest()
08025130  {
0802513c      int32_t var_1c = 0;
0802513c      int32_t var_18 = 0;
0802513c      int32_t var_14 = 0;
08025144      cam_usart_init1();
0802514c      int32_t r7;
0802514c      cam_uart_gpio_init_retpassthru(cam_usart_init2(r7));
08025152      char result_1;
08025152      cam_usart_init3(&result_1);
0802515a      char result_3;
0802515a      cam_usart_init4(&result_3);
0802516c      char result_2;
0802516c      int128_t q4;
0802516c      
0802516c      if (!(uint32_t)result_1 && (uint32_t)result_2 == 1)
0802516c      {
0802516e          createSpeakerTask();
0802516e          
08025178          if (sub_80277c2() != 1)
08025178          {
080251a6              sub_802717c();
080251a6              
080251aa              while (true)
080251aa                  /* nop */
08025178          }
08025178          else
08025178          {
0802517a              sub_8028c2c();
0802517a              
08025188              if (sub_8027c8c(sub_8028c74(), q4) != 1)
08025188              {
080251a0                  sub_802717c();
080251a0                  
080251a4                  while (true)
080251a4                      /* nop */
08025188              }
08025188              else
08025188              {
0802518a                  while (true)
0802518a                  {
0802518a                      sub_802717c();
08025190                      rtos_delay_ticks(0x64);
08025194                      sub_802718c();
0802519a                      rtos_delay_ticks(0x64);
0802518a                  }
08025188              }
08025178          }
0802516c      }
0802516c      
080251ac      uint32_t result = (uint32_t)result_1;
080251ac      
080251b2      if (result == 1)
080251b2      {
080251b4          result = (uint32_t)result_2;
080251b4          
080251ba          if (!result)
080251ba          {
080251bc              result = (uint32_t)result_3;
080251bc              
080251c2              if (!result)
080251c2              {
080251c4                  char result_4;
080251c4                  result = (uint32_t)result_4;
080251c4                  
080251ca                  if (!result)
080251ca                  {
080251ce                      sub_802a0b0();
080251dc                      int32_t var_54;
080251dc                      memcpy(&var_54, 0x20000568, 0x28);
080251e6                      int32_t var_50;
080251e6                      int32_t var_4c;
080251e6                      usart_init(data_20000560, var_54, var_50, var_4c);
080251ec                      sub_8026c14(&data_20000590);
080251fa                      memcpy(&var_54, 0x20000c3c, 0x28);
08025204                      usart_init(data_20000c34, var_54, var_50, var_4c);
0802520a                      sub_8026c14(&data_20000c64);
08025212                      console_printf("wait start com\r\n");
08025216                      char r5_1 = 0;
08025216                      
0802521c                      while (true)
0802521c                      {
0802521c                          uint32_t r5_2 = (uint32_t)r5_1;
0802521c                          
08025220                          if (r5_2 >= 0x32)
08025220                              break;
08025220                          
08025230                          if ((uint32_t)sub_80250ea(0, nullptr, 4) == 4)
08025230                              break;
08025230                          
0802521a                          r5_1 = (uint8_t)r5_2 + 1;
0802521c                      }
0802521c                      
08025234                      sub_8025bf0(1);
0802523a                      sub_802a0d8(1, r7);
0802523e                      sub_802a720(r7);
08025242                      createSpeakerTask();
08025246                      sub_802717c();
0802524c                      rtos_delay_ticks(0x64);
08025250                      sub_802718c();
08025258                      console_printf("start board test\r\n");
08025268                      char result_5;
08025268                      
08025268                      while (true)
08025268                      {
0802526e                          if (BoardTest_CheckEntryCondition(0, &result_5) != 6)
0802526e                          {
08025270                              result = (uint32_t)result_5;
08025270                              
08025276                              if (result == 5)
08025276                                  break;
08025276                              
08025284                              memset16x2(&var_1c, 0xa, 0);
08025298                              int16_t var_24;
08025298                              uint32_t var_48 = (uint32_t)var_24;
080252b4                              char var_27;
080252b4                              int16_t var_26;
080252b4                              int16_t var_22;
080252b4                              int16_t var_20;
080252b4                              console_printf("====== %d %s %d %d %d %d\r\n", 
080252b4                                  (uint32_t)result_5, 0x200001a8 + ((uint32_t)var_27 << 4), 
080252b4                                  (uint32_t)var_26, var_48, (uint32_t)var_22, 
080252b4                                  (uint32_t)var_20);
080252b8                              uint32_t r0_20 = (uint32_t)var_27;
080252b8                              
080252be                              if (!r0_20)
08025310                                  sub_8025c56(&var_1c, result_5, var_24, var_20);
080252be                              else if (r0_20 == 2)
080252c2                              {
08025348                                  sub_802abc4(r7);
08025350                                  camera_pa8_set(false, false);
080252c2                              }
080252c2                              else if (r0_20 == 3)
080252c6                              {
08025356                                  sub_802abc4(r7);
0802535e                                  camera_pa8_set(true, false);
080252c6                              }
080252c6                              else if (r0_20 == 7)
080252ca                              {
0802536c                                  sub_8025cbe(&var_48, (int16_t)result_5);
08025376                                  memcpy_(&var_1c, &var_48, 0xa);
080252ca                              }
080252ca                              else
080252ca                              {
080252ce                                  dbl_bits q5;
080252ce                                  
080252ce                                  if (r0_20 == 8)
080252ce                                  {
08025384                                      q4 = BoardTest_TestAccelerator(&var_48, result_5, 
08025384                                          var_24, q4, q5);
0802538e                                      memcpy_(&var_1c, &var_48, 0xa);
080252ce                                  }
080252ce                                  else if (r0_20 == 9)
080252d2                                  {
0802539c                                      BoardTest_LEDs(&var_48, (int16_t)result_5);
080253a6                                      memcpy_(&var_1c, &var_48, 0xa);
080252d2                                  }
080252d2                                  else if (r0_20 - 0xa <= 6)
080252d8                                  {
080253b4                                      q4 = BoardTest_RunAll(&var_48, result_5, var_24, q4, 
080253b4                                          q5);
080253be                                      memcpy_(&var_1c, &var_48, 0xa);
080252d8                                  }
080252d8                                  else if (r0_20 == 0x11)
080252dc                                  {
080253cc                                      int128_t q0_1;
080253cc                                      q0_1 = BoardTest_RunAll(&var_48, result_5, var_24, 
080253cc                                          q4, q5);
080253d6                                      memcpy_(&var_1c, &var_48, 0xa);
080253da                                      (uint32_t)q0_1 = 0x5600000;
080253de                                      sub_802a770();
080253e4                                      sub_802a6bc(0);
080252dc                                  }
080252dc                                  else if (r0_20 == 0x12)
080252e0                                  {
080253f2                                      sub_802653c(&var_48, (int16_t)result_5);
080253fc                                      memcpy_(&var_1c, &var_48, 0xa);
080252e0                                  }
080252e0                                  else if (r0_20 - 0x14 <= 1)
080252e8                                  {
0802540a                                      q4 = sub_8026668(&var_48, result_5, var_24);
08025414                                      memcpy_(&var_1c, &var_48, 0xa);
080252e8                                  }
080252e8                                  else if (r0_20 - 0x16 <= 1)
080252f0                                  {
08025422                                      q4 = sub_802686c(&var_48, result_5, var_24);
0802542c                                      memcpy_(&var_1c, &var_48, 0xa);
080252f0                                  }
080252f0                                  else if (r0_20 == 0x19)
080252f6                                  {
0802543a                                      sub_80269d8(&var_48, (int16_t)result_5);
08025444                                      memcpy_(&var_1c, &var_48, 0xa);
080252f6                                  }
080252f6                                  else if (r0_20 == 0x1a)
080252fc                                  {
08025452                                      sub_8025f9a(&var_48, (int16_t)result_5);
0802545c                                      memcpy_(&var_1c, &var_48, 0xa);
080252fc                                  }
080252fc                                  else if (r0_20 == 0x1b)
08025302                                  {
08025464                                      sub_802a0d8(0, r7);
08025468                                      sub_802717c();
08025468                                      
0802546c                                      while (true)
0802546c                                          /* nop */
08025302                                  }
080252ca                              }
080252ca                              
08025324                              var_48 = (uint32_t)(uint16_t)var_18;
08025336                              console_printf("%d %d %d %d %d %d\r\n", 
08025336                                  (uint32_t)(uint8_t)var_1c, 
08025336                                  (uint32_t)*(uint8_t*)((char*)var_1c)[1], 
08025336                                  (uint32_t)*(uint16_t*)((char*)var_1c)[2], var_48, 
08025336                                  (uint32_t)*(uint16_t*)((char*)var_18)[2], 
08025336                                  (uint32_t)(uint16_t)var_14);
08025336                              
08025340                              if ((uint32_t)var_27 == 0x18)
08025340                              {
08025344                                  char r5_3 = 0;
08025344                                  
08025476                                  while (true)
08025476                                  {
08025476                                      uint32_t r5_4 = (uint32_t)r5_3;
08025476                                      
0802547a                                      if (r5_4 >= 0x32)
0802547a                                          break;
0802547a                                      
0802547e                                      result_5 = 0;
08025486                                      sub_8024e7c(1, &result_5);
08025486                                      
08025490                                      if ((uint32_t)result_5 == 4)
08025490                                      {
08025494                                          (uint8_t)var_1c = 0;
080254a0                                          sub_8024fb0(1, var_1c, var_18, var_14);
080254a6                                          (uint8_t)var_1c = 2;
080254ac                                          *(uint8_t*)((char*)var_1c)[1] = 0x18;
080254b2                                          *(uint16_t*)((char*)var_1c)[2] = 0;
080254b6                                          break;
08025490                                      }
08025490                                      
08025470                                      (uint8_t)var_1c = 3;
08025474                                      r5_3 = (uint8_t)r5_4 + 1;
08025476                                  }
08025340                              }
08025340                              else if (!(uint32_t)var_27 || (uint32_t)var_27 >= 7)
080254d0                                  sub_8024fb0(0, var_1c, var_18, var_14);
080254d0                              
080254da                              if ((uint32_t)(uint8_t)var_1c == 3)
080254da                              {
080254e0                                  sub_802a0d8(0, r7);
080254e0                                  
080254e4                                  while (true)
080254e4                                      /* nop */
080254da                              }
0802526e                          }
08025268                      }
080251ca                  }
080251c2              }
080251ba          }
080251b2      }
080251b2      
080254e8      return result;
08025130  }
080254ea                                00 00 00 00                                                                  ....
080254ee  int32_t data_80254ee = 0x5600000
080254f2                                                        00 20                                                        . 
080254f4  int32_t data_80254f4 = 0x20000590
080254f8  int32_t data_80254f8 = 0x20000c34
080254fc  int32_t data_80254fc = 0x20000c64
08025500  int32_t data_8025500 = 0x2000e171
08025504  int32_t data_8025504 = 0x2000e172
08025508  int32_t data_8025508 = 0x2000e173
0802550c  int32_t data_802550c = 0x2000e184
08025510    uint32_t sub_8025510(int128_t arg1 @ q4, int64_t arg2 @ q5)
08025510  {
08025514      int64_t var_28 = (uint64_t)arg1;
08025514      int64_t var_30 = *(uint64_t*)((char*)arg1)[8];
0802551a      int32_t r7 = 0;
08025520      uint32_t r6 = 0;
08025522      (uint32_t)arg1 = 0;
08025526      *(uint32_t*)((char*)arg1)[4] = 0;
0802552a      int128_t q0;
0802552a      (uint32_t)q0 = 0;
0802552e      int32_t r4 = 0;
08025530      int32_t r5 = 0;
08025538      int16_t b = 0xffff;
0802553c      uint32_t result = sub_8025c0e();
0802553c      
08025542      if (!result)
08025542      {
08025546          (uint64_t)arg1 = arg2;
08025546          *(uint64_t*)((char*)arg1)[8] = var_30;
0802554a          return result;
08025542      }
08025542      
08025550      sub_802bbd4(1);
0802555a      sub_802bd04(1, "HMI TURN ON ALL LED\r\n", 0);
08025564      sub_802c00e(0);
0802556a      sub_802bff8(&b);
08025574      sub_802bd04(1, "moduleMotorInit\r\n", 0);
0802557e      sub_802bd04(1, "devSensorInit\r\n", 0);
08025582      cam_link_hw_init();
0802558c      sub_802bd04(1, "devSamplerAdcInit\r\n", 0);
08025590      sub_802c0d2(0);
0802559a      sub_802bd04(1, "devUltrasonicInit\r\n", 0);
0802559e      sub_802c536();
080255a8      sub_802bd04(1, "vbCommMoudlePowerInit vbCommMoudleInit\r\n", 0);
080255ac      sub_802abc4(0);
080255b0      vbCommMoudleInit();
080255ba      sub_802bd04(1, "devAccelermeterInit\r\n", 0);
080255be      sub_80277c2();
080255c8      sub_802bd04(1, "moduleSpkInit\r\n", 0);
080255cc      createSpeakerTask();
080255d2      set_motion_state(1);
080255d6      char r8 = 0;
080255d6      
080255f4      while (true)
080255f4      {
080255f4          uint32_t r8_1 = (uint32_t)r8;
080255f4          
080255fc          if (r8_1 >= 0xa)
080255fc              break;
080255fc          
080255dc          sub_802717c();
080255e2          rtos_delay_ticks(0x14);
080255e6          sub_802718c();
080255ec          rtos_delay_ticks(0x14);
080255f0          r8 = (uint8_t)r8_1 + 1;
080255f4      }
080255f4      
080255fe      while (true)
080255fe      {
080255fe          sub_802cea6();
080255fe          
08025608          if (!sub_802cf64() && !sub_802cf58())
08025608          {
08025620              while (true)
08025620              {
08025620                  sub_802cea6();
08025620                  
0802562a                  if (sub_802cf64())
0802562a                      break;
0802562a                  
08025632                  if (sub_802cf58())
08025632                      break;
08025632                  
0802561c                  rtos_delay_ticks(0xa);
08025620              }
08025620              
0802563a              sub_802bd04(1, "start factoryTestLogic\r\n", 0);
08025646              sub_802bd04(1, "moduleMotorForward %f\r\n", 0);
0802564a              int64_t q0_1;
0802564a              *(uint32_t*)((char*)q0_1)[4] = 0x437a;
0802564e              (uint32_t)q0_1 = 0x437a;
08025652              sub_802d226(q0_1);
0802565e              sub_802bd04(1, "moduleMotorStartCutter %f\r\n", 0);
08025666              beeper_config_apply(0xf00142c8);
0802566c              char var_5c;
0802566c              cam_usart_init3(&var_5c);
08025670              char r0_7 = cam_uart_status_probe();
08025670              
0802567c              if (sub_8028c74() == 1)
0802567e                  r6 = 1;
0802567e              
08025696              while (true)
08025696              {
08025696                  rtos_delay_ticks(0x64);
080256a0                  sub_802bd04(1, "============================================\r\n", r7);
080256a4                  int32_t r0_9 = r7 & 3;
080256aa                  int32_t a;
080256aa                  int128_t q4;
080256aa                  
080256aa                  if (r0_9 != 3)
080256aa                  {
080256b2                      (uint32_t)q4 = reduceSpeedOrGuard(0);
080256bc                      *(uint32_t*)((char*)q4)[4] = reduceSpeedOrGuard(1);
080256c4                      int32_t a_1;
080256c4                      int32_t r1_1;
080256c4                      a_1 = float32_process(*(uint32_t*)((char*)q4)[4]);
080256c8                      a = a_1;
080256c8                      int32_t var_64_1 = r1_1;
080256d0                      int32_t r0_12;
080256d0                      int32_t r1_2;
080256d0                      r0_12 = float32_process((uint32_t)q4);
080256dc                      bool n_1 = false;
080256de                      sub_802bd04(1, "CurrentSpeed : %f %f\r\n", r7);
080256e2                      int128_t q0_5;
080256e2                      (uint32_t)q0_5 = 0x14396;
080256e6                      /* unimplemented  {vcmp.f32.F32 s16, s0} */
080256ea                      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08025702                      (uint32_t)q0_5 = 0x14396;
08025706                      /* unimplemented  {vcmp.f32.F32 s17, s0} */
0802570a                      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802570a                      
0802570e                      if (n_1)
0802570e                      {
08025710                          (uint32_t)q0_5 = 0x43480001;
08025714                          /* unimplemented  {vcmp.f32.F32 s17, s0} */
08025718                          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08025718                          
0802571c                          if (n_1 == r0_9 - 3)
0802571e                              r7 |= 2;
0802570e                      }
0802570e                      
08025728                      if ((r7 & 3) == 3)
08025728                      {
0802572a                          motorBrake();
08025732                          rtos_delay_ticks(0x1f4);
08025728                      }
080256aa                  }
080256aa                  
08025744                  sub_802bd04(1, "walk motor %d %d\r\n", r7);
08025744                  
0802574a                  if (r7 << 0x1d >= 0)
0802574a                  {
08025750                      char var_5e;
08025750                      cam_usart_init3(&var_5e);
0802576a                      char var_5d;
0802576a                      char var_5b;
0802576a                      
0802576a                      if ((uint32_t)var_5c != (uint32_t)var_5e
0802576a                              && (uint32_t)var_5b != (uint32_t)var_5d)
0802576c                          r7 |= 4;
0802574a                  }
0802574a                  
0802577a                  sub_802bd04(1, "lift Sensor %d\r\n", r7);
0802577a                  
08025780                  if (r7 << 0x1b >= 0 && cam_uart_status_probe() != (uint32_t)r0_7)
08025780                  {
0802578e                      r7 |= 0x10;
08025796                      rtos_delay_ticks(0x1f4);
08025780                  }
08025780                  
0802579a                  /* unimplemented  {ands r2, r7, #0x10} */
080257a4                  int32_t r2_7;
080257a4                  int32_t r3_3;
080257a4                  r2_7 = sub_802bd04(1, "stop button %d\r\n", r7);
080257ac                  void var_4c;
080257ac                  sub_802c0fa(&var_4c, 1, r2_7, r3_3);
080257b4                  int16_t var_40;
080257b4                  sub_802e6b8((uint32_t)var_40);
080257be                  soft_dmul(a, b);
080257ca                  soft_dmul();
080257d4                  int32_t r0_22;
080257d4                  int32_t r1_7;
080257d4                  r0_22 = soft_dadd();
080257dc                  (uint32_t)q4 = sub_802ead0(r0_22, r1_7);
080257e0                  int128_t q0_6;
080257e0                  (uint32_t)q0_6 = 0x41d00000;
080257e4                  /* unimplemented  {vcmp.f32.F32 s16, s0} */
080257e8                  /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08025804                  int32_t a_2;
08025804                  int32_t r1_8;
08025804                  a_2 = float32_process((uint32_t)q4);
08025808                  a = a_2;
08025808                  int32_t var_64_2 = r1_8;
08025816                  sub_802bd04(1, "battery %d %.2f\r\n", r7);
0802581a                  r7 |= 0x1000;
08025822                  int32_t a_3;
08025822                  int32_t r1_9;
08025822                  a_3 = float32_process((uint32_t)q4);
08025826                  a = a_3;
08025826                  int32_t var_64_3 = r1_9;
0802582a                  bool v_3 = /* bool v_3 = unimplemented  {ands r2, r7, #0x1000} */;
08025834                  sub_802bd04(1, "rain %d %.2f\r\n", r7);
0802583a                  reduceSpeedOrGuard(2);
0802583e                  int64_t q0_7;
0802583e                  *(uint32_t*)((char*)q0_7)[4] = 0x2001451c;
08025842                  /* unimplemented  {vcmp.f32.F32 s0, s1} */
08025846                  /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08025846                  
0802584a                  if (false == v_3)
0802584a                  {
0802584c                      motorStop();
08025850                      r7 |= 0x2000;
08025850                      v_3 = /* v_3 = unimplemented  {orrs r7, r7, #0x2000} */;
0802584a                  }
0802584a                  
08025858                  int16_t var_42;
08025858                  sub_802e6b8((uint32_t)var_42);
08025864                  soft_dmul();
0802586e                  int32_t r0_27;
0802586e                  int32_t r1_10;
0802586e                  r0_27 = soft_dadd();
08025876                  (uint32_t)q4 = sub_802ead0(r0_27, r1_10);
0802587a                  (uint32_t)q0_7 = 0x41200000;
0802587e                  (uint32_t)q0_7 = (uint32_t)q4 * 10f;
08025886                  int32_t r0_30;
08025886                  int32_t r1_11;
08025886                  r0_30 = float32_process((uint32_t)q0_7);
08025892                  int32_t r0_32;
08025892                  int32_t r1_12;
08025892                  r0_32 = float32_process((uint32_t)q4);
080258a2                  int32_t r0_33;
080258a2                  int32_t r1_13;
080258a2                  r0_33 = sub_802eb60(0x66666666, 0x400a6666, r0_32, r1_12);
080258ae                  int32_t r0_35;
080258ae                  int32_t r1_15;
080258ae                  r0_35 = soft_dadd();
080258b6                  (uint32_t)q0_7 = sub_802ead0(r0_35, r1_15);
080258be                  int32_t r0_38;
080258be                  int32_t r1_16;
080258be                  r0_38 = float32_process((uint32_t)q0_7);
080258c6                  int128_t q0_8;
080258c6                  int96_t q4_1;
080258c6                  q0_8 = sub_802ece0(r7, );
080258d6                  int32_t r0_40;
080258d6                  int32_t r1_18;
080258d6                  r0_40 = soft_dmul();
080258e2                  int32_t r0_41;
080258e2                  int32_t r1_19;
080258e2                  r0_41 = sub_802ecf4(r0_40, r1_18, 0x76c8b439, 0x4056e7be);
080258ea                  *(uint32_t*)((char*)q4_1)[8] = sub_802ead0(r0_41, r1_19);
080258ee                  *(uint64_t*)((char*)q0_8)[8] = 0;
080258f2                  (uint32_t)q4_1 = 0;
080258f6                  *(uint32_t*)((char*)q4_1)[4] = 0;
080258fe                  int32_t r0_44;
080258fe                  int32_t r1_20;
080258fe                  r0_44 = float32_process(*(uint32_t*)((char*)q4_1)[8]);
08025902                  (uint64_t)q0_8 = (r1_20 << 32) | r0_44;
08025906                  *(uint32_t*)((char*)q0_8)[8] = 0;
0802590a                  *(uint32_t*)((char*)q0_8)[0xc] = 0;
0802590e                  int64_t q0_9;
0802590e                  q0_9 = sub_802f2a2(q0_8);
08025912                  (uint32_t)q4 = (uint32_t)q0_9;
08025916                  *(uint32_t*)((char*)q4)[4] = *(uint32_t*)((char*)q0_9)[4];
0802591e                  int32_t r0_46;
0802591e                  int32_t r1_21;
0802591e                  r0_46 = float32_process(*(uint32_t*)((char*)q4)[8]);
08025932                  int32_t r0_48;
08025932                  int32_t r1_23;
08025932                  r0_48 = soft_dmul();
08025942                  soft_dmul();
0802594e                  int32_t r0_50;
0802594e                  int32_t r1_25;
0802594e                  r0_50 = soft_dmul();
08025956                  int32_t r0_51;
08025956                  int32_t r1_26;
08025956                  r0_51 = sub_802ecf4(r0_50, r1_25, r0_48, r1_23);
08025962                  float32_process(*(uint32_t*)((char*)q4)[8]);
0802596e                  int32_t r0_53;
0802596e                  int32_t r1_27;
0802596e                  r0_53 = soft_dmul();
08025976                  int32_t r0_54;
08025976                  int32_t r1_28;
08025976                  r0_54 = sub_802ecf4(r0_53, r1_27, r0_51, r1_26);
08025982                  int32_t r0_55;
08025982                  int32_t r1_29;
08025982                  r0_55 = sub_802ecf4(r0_54, r1_28, 0x3afb7e91, 0xc00dce70);
0802598a                  (uint32_t)q4 = sub_802ead0(r0_55, r1_29);
08025992                  int32_t r0_58;
08025992                  int32_t r1_30;
08025992                  r0_58 = float32_process((uint32_t)q4);
080259a2                  soft_dmul();
080259ae                  int32_t r0_60;
080259ae                  int32_t r1_32;
080259ae                  r0_60 = soft_dmul();
080259ba                  float32_process((uint32_t)q4);
080259c6                  int32_t r0_62;
080259c6                  int32_t r1_33;
080259c6                  r0_62 = soft_dmul();
080259ce                  int32_t r0_63;
080259ce                  int32_t r1_34;
080259ce                  r0_63 = sub_802ecf4(r0_62, r1_33, r0_60, r1_32);
080259da                  int32_t r0_64;
080259da                  int32_t r1_35;
080259da                  r0_64 = sub_802ecf4(r0_63, r1_34, 0x5f6fd220, 0x3f99ce07);
080259e2                  (uint32_t)q4 = sub_802ead0(r0_64, r1_35);
080259e6                  (uint32_t)q0_9 = 0xcccd4040;
080259ea                  /* unimplemented  {vcmp.f32.F32 s16, s0} */
080259ee                  /* unimplemented  {vmrs apsr_nzcv, fpscr} */
080259ee                  
080259f2                  if (r1_13 < 0 == v_3)
080259f4                      r7 |= 0x20000;
080259f4                  
080259fc                  int32_t a_4;
080259fc                  int32_t r1_36;
080259fc                  a_4 = float32_process((uint32_t)q4);
08025a00                  a = a_4;
08025a00                  int32_t var_64_4 = r1_36;
08025a04                  bool v_4 = /* bool v_4 = unimplemented  {ands r2, r7, #0x20000} */;
08025a0e                  sub_802bd04(1, "ntc %d %.2f\r\n", r7);
08025a16                  int16_t var_3e;
08025a16                  sub_802e6b8((uint32_t)var_3e);
08025a22                  soft_dmul(a);
08025a2c                  int32_t r0_68;
08025a2c                  int32_t r1_37;
08025a2c                  r0_68 = soft_dadd();
08025a34                  (uint32_t)q4 = sub_802ead0(r0_68, r1_37);
08025a38                  int128_t q0_10;
08025a38                  (uint32_t)q0_10 = 0x3faccccd;
08025a3c                  /* unimplemented  {vcmp.f32.F32 s16, s0} */
08025a40                  /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08025a40                  
08025a44                  if (false == v_4)
08025a46                      r7 |= 0x40000;
08025a46                  
08025a4e                  int32_t a_5;
08025a4e                  int32_t r1_38;
08025a4e                  a_5 = float32_process((uint32_t)q4);
08025a52                  a = a_5;
08025a52                  int32_t var_64_5 = r1_38;
08025a6a                  sub_802bd04(1, "UV %d %.2f\r\n", r7);
08025a6a                  
08025a70                  if (r7 << 0x14 >= 0)
08025a70                  {
08025a72                      r6 = (uint32_t)(uint8_t)r6;
08025a72                      
08025a76                      if (r6 == 1)
08025a76                      {
08025a7e                          int32_t var_58;
08025a7e                          void var_54;
08025a7e                          void var_50;
08025a7e                          int128_t q0_11;
08025a7e                          q0_11 = sub_8027844(&var_58, &var_50, &var_54, q4, );
08025a82                          (uint32_t)q0_11 = var_58;
08025a86                          *(uint32_t*)((char*)q0_11)[4] = 0x40a00000;
08025a8a                          /* unimplemented  {vcmp.f32.F32 s0, s1} */
08025a8e                          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08025a8e                          
08025a92                          if (r6 - 1 < 0)
08025a94                              r7 |= 0x800;
08025a76                      }
08025a70                  }
08025a70                  
08025aa2                  sub_802bd04(1, "Accelerometer %d\r\n", r7);
08025aa2                  
08025aa8                  if (r7 << 0xf >= 0 && sub_802ac52() >= 6)
08025ab2                      r7 |= 0x10000;
08025ab2                  
08025ac0                  sub_802bd04(1, "VB %d\r\n", r7);
08025ac0                  
08025aca                  if ((r7 & 3) == 3)
08025ad4                      (uint8_t)b &= 0xf7;
08025ad4                  
08025ae4                  if ((0x61100 & r7) == 0x61100)
08025aee                      (uint8_t)b &= 0xfb;
08025aee                  
08025af4                  if (r7 << 0x14 < 0)
08025afe                      (uint8_t)b &= 0xdf;
08025afe                  
08025b04                  if (r7 << 0x12 < 0)
08025b0e                      (uint8_t)b &= 0x7f;
08025b0e                  
08025b14                  if (r7 << 0x1d < 0)
08025b1e                      *(uint8_t*)((char*)b)[1] &= 0xf7;
08025b1e                  
08025b24                  if (r7 << 0x1b < 0)
08025b2e                      *(uint8_t*)((char*)b)[1] &= 0xfb;
08025b2e                  
08025b34                  if (r7 << 0xf < 0)
08025b3e                      *(uint8_t*)((char*)b)[1] &= 0xdf;
08025b3e                  
08025b44                  if (r7 << 0x1b < 0)
08025b44                  {
08025b48                      if (r7 << 0x10 >= 0)
08025b48                      {
08025b4a                          r4 += 1;
08025b4e                          sub_802c5ca(&a);
08025b68                          console_printf("%d %d\r\n", (uint32_t)(uint16_t)a, 
08025b68                              (uint32_t)*(uint16_t*)((char*)a)[2]);
08025b68                          
08025b82                          if ((uint32_t)(uint16_t)a - 0x119 < 0x27
08025b82                                  && (uint32_t)*(uint16_t*)((char*)a)[2] - 0x119 < 0x27)
08025b84                              r5 += 1;
08025b84                          
08025b88                          if (r5 >= 8)
08025b88                          {
08025b8a                              r4 = 0x10;
08025b8c                              r7 |= 0x8000;
08025b88                          }
08025b48                      }
08025b48                      
08025b9a                      sub_802bd04(1, "ultrasonic %d\r\n", r7);
08025b44                  }
08025b44                  
08025ba0                  if (r7 << 0x10 < 0)
08025baa                      *(uint8_t*)((char*)b)[1] &= 0x7f;
08025baa                  
08025bb4                  sub_802c00e(r7);
08025bba                  sub_802bff8(&b);
08025bba                  
08025bc0                  if (r4 >= 0xb)
08025bc0                  {
08025bd2                      sub_802bd04(1, "================================%d\r\n", r7);
08025bd2                      
08025bdc                      if (r7 == 0x7b917)
08025bdc                          break;
08025bdc                      
08025690                      sub_802717c();
08025bc0                  }
08025696              }
08025696              
08025be0              sub_802717c();
08025be6              rtos_delay_ticks(0x64);
08025bea              sub_802718c();
08025bea              
08025bee              while (true)
08025bee                  /* nop */
08025608          }
08025608          
08025614          rtos_delay_ticks(0xa);
080255fe      }
08025510  }
08025682        00 bf 00 00                                                                                  ....
08025686  int32_t data_8025686 = 0x0
0802568a  int32_t data_802568a = 0x437a
0802568e  int32_t data_802568e = -0xffebd38
08025a60  00 00                                                                                            ..
08025a62  int32_t data_8025a62 = 0x14396
08025a66                    48 43                                                                                HC
08025b64              01 00                                                                                    ..
08025b66  int32_t data_8025b66 = -0xffbbe80
08025bcc                                      01 40                                                                    .@
08025bce  int32_t data_8025bce = 0x2001451c
08025bf0    int32_t sub_8025bf0(char arg1)
08025bf0  {
08025bf4      data_2000e440 = arg1;
08025bf8      return 1;
08025bf0  }
08025bfa    int32_t sub_8025bfa(char arg1)
08025bfa  {
08025bfe      data_2000e441 = arg1;
08025c02      return 1;
08025bfa  }
08025c04    uint32_t sub_8025c04()
08025c04  {
08025c0c      return (uint32_t)data_2000e440;
08025c04  }
08025c0e    uint32_t sub_8025c0e()
08025c0e  {
08025c16      return (uint32_t)data_2000e441;
08025c0e  }
08025c18    int32_t sub_8025c18(int32_t arg1 @ r7, int16_t arg2, int16_t arg3, int16_t arg4, int16_t arg5, int32_t arg6)
08025c18  {
08025c1c      uint32_t r4 = arg1 >> 0x10;
08025c1c      
08025c20      if (!r4)
08025c20      {
08025c2c          *(uint32_t*)(r4 + 8);
08025c2c          *(uint32_t*)(r4 + 0xc);
08025c2c          *(uint32_t*)(r4 + 0x10);
08025c38          /* tailcall */
08025c38          return sub_8025f1c(nullptr, 0, *(uint32_t*)(r4 + 4), r4 + 0x14);
08025c20      }
08025c20      
08025c76      int16_t arg_2 = 1;
08025c7c      int16_t arg_4 = 0;
08025c82      int16_t arg_6 = 1;
08025c88      int16_t arg_8 = 0;
08025caa      char arg_0;
08025caa      
08025caa      if ((uint32_t)arg2 == 1 && !(uint32_t)arg3 && (uint32_t)arg4 == 1 && !(uint32_t)arg5)
08025cae          arg_0 = 2;
08025cae      
08025cbc      return memcpy_(nullptr, &arg_0, 0xa);
08025c18  }
08025c3a                                                                                00 20                                        . 
08025c3c    uint32_t sub_8025c3c(int32_t arg1)
08025c3c  {
08025c3c      int32_t r1 = 0;
08025c3e      char r2 = 0;
08025c3e      
08025c4a      while (true)
08025c4a      {
08025c4a          uint32_t r2_2 = (uint32_t)r2;
08025c4a          
08025c4e          if (r2_2 >= 0x10)
08025c4e              break;
08025c4e          
08025c42          uint32_t r2_1 = (uint32_t)(uint8_t)r2_2;
08025c46          r1 += (uint32_t)*(uint8_t*)(arg1 + r2_1);
08025c48          r2 = (uint8_t)r2_1 + 1;
08025c4a      }
08025c4a      
08025c54      return (uint32_t)(uint16_t)r1;
08025c3c  }
08025c56    int32_t sub_8025c56(char* arg1, int32_t arg2, int32_t arg3, int16_t arg4)
08025c56  {
08025c62      int32_t var_20 = 0;
08025c62      int32_t var_1c = 0;
08025c62      int32_t var_18 = 0;
08025c68      (uint8_t)var_20 = 3;
08025c70      *(uint8_t*)((char*)var_20)[1] = *(uint8_t*)((char*)arg2)[1];
08025c76      *(uint16_t*)((char*)var_20)[2] = 1;
08025c7c      (uint16_t)var_1c = 0;
08025c82      *(uint16_t*)((char*)var_1c)[2] = 1;
08025c88      (uint16_t)var_18 = 0;
08025c88      
08025caa      if ((uint32_t)*(uint16_t*)((char*)arg2)[2] == 1 && !(uint32_t)(uint16_t)arg3
08025caa              && (uint32_t)*(uint16_t*)((char*)arg3)[2] == 1 && !(uint32_t)arg4)
08025cae          (uint8_t)var_20 = 2;
08025cae      
08025cbc      return memcpy_(arg1, &var_20, 0xa);
08025c56  }
08025cbe    int32_t sub_8025cbe(char* arg1, int16_t arg2)
08025cbe  {
08025cbe      int32_t r3;
08025cbe      int32_t var_10 = r3;
08025cbe      int32_t r2;
08025cbe      int32_t var_14 = r2;
08025ccc      int32_t var_28 = 0;
08025ccc      int32_t var_24 = 0;
08025ccc      int32_t var_20 = 0;
08025cd8      memset16x2(&var_28, 0xa, 0);
08025ce0      *(uint8_t*)((char*)var_28)[1] = *(uint8_t*)((char*)arg2)[1];
08025ce4      createUsbTask();
08025ce4      
08025ce8      while (true)
08025ce8      {
08025ce8          int32_t r7;
08025ce8          sub_802fa0c(r7);
08025ce8          
08025cf2          if (sub_802fb48() == 1)
08025cf2          {
08025cf6              (uint8_t)var_28 = 2;
08025cfa              break;
08025cf2          }
08025cf2          
08025d02          if (sub_802fb48() == 2)
08025d02          {
08025d06              (uint8_t)var_28 = 3;
08025d06              break;
08025d02          }
08025ce8      }
08025ce8      
08025d16      return memcpy_(arg1, &var_28, 0xa);
08025cbe  }
08025d18    int32_t BoardTest_TestAccelerator(char* arg1, int32_t arg2, int32_t arg3, int128_t arg4 @ q4, dbl_bits arg5 @ q5)
08025d18  {
08025d18      int32_t r3;
08025d18      int32_t var_10 = r3;
08025d1a      dbl_bits var_20;
08025d1a      var_20.lo = (uint32_t)arg4;
08025d1a      var_20.hi = *(uint32_t*)((char*)arg4)[4];
08025d1a      int64_t var_28 = *(uint64_t*)((char*)arg4)[8];
08025d1a      dbl_bits var_30;
08025d1a      var_30.lo = arg5.lo;
08025d1a      var_30.hi = arg5.hi;
08025d2a      int32_t var_44 = 0;
08025d2a      int32_t var_40 = 0;
08025d2a      int32_t var_3c = 0;
08025d32      console_printf("test accelerometer module:\n", 0, 0, 0);
08025d38      int32_t var_48 = 0;
08025d3c      int32_t var_4c = 0;
08025d40      int32_t var_50 = 0;
08025d44      int32_t var_54 = 0;
08025d48      int32_t var_58 = 0;
08025d4c      int32_t var_5c = 0;
08025d4e      *(uint32_t*)((char*)arg4)[4] = 0xf8bd0000;
08025d52      *(uint32_t*)((char*)arg4)[8] = 0xf8bd0000;
08025d56      (uint32_t)arg4 = 0xf8bd0000;
08025d5e      *(uint8_t*)((char*)var_44)[1] = *(uint8_t*)((char*)arg2)[1];
08025d6a      *(uint32_t*)((char*)arg4)[0xc] = (float)(uint32_t)*(uint16_t*)((char*)arg2)[2];
08025d76      arg5.lo = (float)(uint32_t)(uint16_t)arg3;
08025d7a      sub_80277c2();
08025d84      uint32_t var_60;
08025d84      
08025d84      if (sub_8028c74())
08025d84      {
08025d9a          sub_8027bcc(&var_48, &var_4c, &var_50);
08025d9e          char r5_1 = 0;
08025d9e          
08025dfc          while (true)
08025dfc          {
08025dfc              uint32_t r5_2 = (uint32_t)r5_1;
08025dfc              
08025e00              if (r5_2 >= 5)
08025e00                  break;
08025e00              
08025da4              rtos_delay_ticks(0x32);
08025dae              sub_8027bcc(&var_54, &var_58, &var_5c);
08025db2              int64_t q0_1;
08025db2              (uint32_t)q0_1 = var_54;
08025db6              *(uint32_t*)((char*)q0_1)[4] = var_48;
08025dba              (uint32_t)q0_1 = (uint32_t)q0_1 - *(uint32_t*)((char*)q0_1)[4];
08025dbe              (uint32_t)q0_1 = fabsf((uint32_t)q0_1);
08025dc2              *(uint32_t*)((char*)arg4)[4] = *(uint32_t*)((char*)arg4)[4] + (uint32_t)q0_1;
08025dc6              (uint32_t)q0_1 = var_58;
08025dca              *(uint32_t*)((char*)q0_1)[4] = var_4c;
08025dce              (uint32_t)q0_1 = (uint32_t)q0_1 - *(uint32_t*)((char*)q0_1)[4];
08025dd2              (uint32_t)q0_1 = fabsf((uint32_t)q0_1);
08025dd6              *(uint32_t*)((char*)arg4)[8] = *(uint32_t*)((char*)arg4)[8] + (uint32_t)q0_1;
08025dda              (uint32_t)q0_1 = var_5c;
08025dde              *(uint32_t*)((char*)q0_1)[4] = var_50;
08025de2              (uint32_t)q0_1 = (uint32_t)q0_1 - *(uint32_t*)((char*)q0_1)[4];
08025de6              (uint32_t)q0_1 = fabsf((uint32_t)q0_1);
08025dea              (uint32_t)arg4 = (uint32_t)arg4 + (uint32_t)q0_1;
08025df0              var_48 = var_54;
08025df4              var_4c = var_58;
08025df8              var_50 = var_5c;
08025dfa              r5_1 = (uint8_t)r5_2 + 1;
08025dfc          }
08025dfc          
08025e08          void var_38;
08025e08          void var_34;
08025e08          arg4 = sub_8027844(&var_60, &var_34, &var_38, arg4, arg5);
08025e10          int32_t r0_11;
08025e10          int32_t r1_3;
08025e10          r0_11 = float32_process((uint32_t)arg4);
08025e14          int32_t var_68_1 = r0_11;
08025e14          int32_t var_64_1 = r1_3;
08025e1c          int32_t r0_13;
08025e1c          int32_t r1_4;
08025e1c          r0_13 = float32_process(*(uint32_t*)((char*)arg4)[8]);
08025e20          int32_t var_70_1 = r0_13;
08025e20          int32_t var_6c_1 = r1_4;
08025e28          int32_t r1_5 = float32_process(*(uint32_t*)((char*)arg4)[4]);
08025e34          console_printf("sumX %f, sumY %f, sumZ %f\r\n");
08025e3c          /* unimplemented  {vcmp.f32.F32 s17, s0} */
08025e40          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08025e40          
08025e44          if (r1_5 < 0)
08025e44          {
08025e64              (uint8_t)var_44 = 3;
08025e6c              var_60 = 0x437f0000;
08025e44          }
08025e44          else
08025e44          {
08025e4a              /* unimplemented  {vcmp.f32.F32 s18, s0} */
08025e4e              /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08025e4e              
08025e52              if (r1_5 < 0)
08025e52              {
08025e64                  (uint8_t)var_44 = 3;
08025e6c                  var_60 = 0x437f0000;
08025e52              }
08025e52              else
08025e52              {
08025e58                  /* unimplemented  {vcmp.f32.F32 s16, s0} */
08025e5c                  /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08025e5c                  
08025e60                  if (r1_5 >= 0)
08025e60                  {
08025e74                      int32_t r0_16;
08025e74                      int32_t r1_6;
08025e74                      r0_16 = float32_process(arg5.lo);
08025e78                      int32_t var_68_2 = r0_16;
08025e78                      int32_t var_64_2 = r1_6;
08025e80                      int32_t r0_18;
08025e80                      int32_t r1_7;
08025e80                      r0_18 = float32_process(*(uint32_t*)((char*)arg4)[0xc]);
08025e84                      int32_t var_70_2 = r0_18;
08025e84                      int32_t var_6c_2 = r1_7;
08025e8a                      int32_t r1_8 = float32_process(var_60);
08025e96                      console_printf("angle : %f  (%f, %f)\r\n");
08025e9e                      /* unimplemented  {vcmp.f32.F32 s19, s0} */
08025ea2                      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08025ea2                      
08025ea6                      if (r1_8 < 0)
08025ea6                      {
08025eac                          /* unimplemented  {vcmp.f32.F32 s0, s20} */
08025eb0                          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08025ea6                      }
08025ea6                      
08025eb4                      if (r1_8 >= 0 || r1_8 >= 0)
08025ec0                          (uint8_t)var_44 = 3;
08025eb4                      else
08025eb8                          (uint8_t)var_44 = 2;
08025e60                  }
08025e60                  else
08025e60                  {
08025e64                      (uint8_t)var_44 = 3;
08025e6c                      var_60 = 0x437f0000;
08025e60                  }
08025e52              }
08025e44          }
08025d84      }
08025d84      else
08025d84      {
08025d8a          var_60 = 0x437f0000;
08025d8e          (uint8_t)var_44 = 3;
08025d84      }
08025d84      
08025ed0      *(uint16_t*)((char*)var_44)[2] = ((float)var_60);
08025eda      memcpy_(arg1, &var_44, 0xa);
08025ee0      (uint32_t)arg4 = var_30.lo;
08025ee0      *(uint32_t*)((char*)arg4)[4] = var_30.hi;
08025ee0      *(uint64_t*)((char*)arg4)[8] = var_28;
08025ee0      arg5.lo = var_20.lo;
08025ee0      arg5.hi = var_20.hi;
08025ee4      return arg2;
08025d18  }
08025ee6                    00 00                                                                                ..
08025ee8  int32_t data_8025ee8 = 0x200001a8
08025eec  int32_t data_8025eec = 0x803b4d4
08025ef0  int32_t data_8025ef0 = 0x803bb6c
08025ef4  int32_t data_8025ef4 = 0x3e4ccccd
08025ef8  int32_t data_8025ef8 = 0x8024aae
08025efc  int32_t data_8025efc = 0x803b914
08025f00  int32_t data_8025f00 = 0x803bb80
08025f04  int32_t data_8025f04 = 0x803bdd0
08025f08  int32_t data_8025f08 = 0x803bb94
08025f0c  int32_t data_8025f0c = 0x803bba8
08025f10  int32_t data_8025f10 = 0x803ad54
08025f14  int32_t data_8025f14 = 0x803b92c
08025f18  int32_t data_8025f18 = 0x803bde0
08025f1c    int32_t sub_8025f1c(void* arg1, uint32_t arg2, int32_t arg3, void* arg4 @ r4)
08025f1c  {
08025f1c      int32_t r7;
08025f1c      int32_t var_4 = r7;
08025f1c      int32_t r6;
08025f1c      int32_t var_8 = r6;
08025f1c      void* var_10 = arg4;
08025f1c      int32_t* sp = &var_10;
08025f20      void* r0;
08025f20      
08025f20      if (arg4)
08025f20      {
08025f34      label_8025f34:
08025f34          
08025f34          if (arg1)
08025f34              goto label_8025fac;
08025f34          
08025f38          if (arg4)
08025f38              goto label_8025fb4;
08025f38          
08025f3c          r0 = arg1;
08025f3c          
08025f40          if (!r0)
08025f42              /* tailcall */
08025f42              return BoardTest_LEDs(r0, (uint16_t)arg2 & (uint16_t)arg4);
08025f20      }
08025f20      else
08025f20      {
08025f24          int32_t lr;
08025f24          int32_t var_14_1 = lr;
08025f24          uint32_t var_18_1 = arg1 >> 0x20;
08025f24          int32_t var_1c = arg3;
08025f24          sp = &var_1c;
08025f28          void arg_304;
08025f28          arg4 = &arg_304;
08025f28          
08025f2c          if (&arg_304)
08025f2c          {
08025f52              int32_t var_28 = 0;
08025f52              int32_t var_24 = 0;
08025f52              int32_t var_20 = 0;
08025f5e              memset16x2(&var_28, 0xa, 0);
08025f66              *(uint8_t*)((char*)var_28)[1] = *(uint8_t*)((char*)var_1c)[1];
08025f6c              (uint8_t)var_28 = 3;
08025f72              char var_2c;
08025f72              cam_usart_init3(&var_2c);
08025f84              char var_2b;
08025f84              
08025f84              if (!(uint32_t)var_2c && (uint32_t)var_2b == 1)
08025f88                  (uint8_t)var_28 = 2;
08025f88              
08025f98              return memcpy_(arg1, &var_28, 0xa);
08025f2c          }
08025f2c          
08025f30          if (!&arg_304)
08025f30              goto label_8025f34;
08025f30          
08025fa8          *(uint32_t*)arg1 = 0;
08025fa8          *(uint32_t*)((char*)arg1 + 4) = 0;
08025fa8          *(uint32_t*)((char*)arg1 + 8) = 0;
08025fac      label_8025fac:
08025fac          arg2 = 0xa;
08025fae          arg3 = 0;
08025fb2          arg1 = &sp[1];
08025fb4      label_8025fb4:
08025fb4          memset16x2(arg1, arg2, (uint8_t)arg3);
08025fbc          *(uint8_t*)((char*)sp + 5) = *(uint8_t*)((char*)sp + 0x11);
08025fc0          r0 = 3;
08025f20      }
08025f20      
08025fc2      sp[1] = (char)r0;
08025fc8      cam_usart_init4(sp);
08025fc8      
08025fda      if ((uint32_t)*(uint8_t*)sp == 1 && (uint32_t)*(uint8_t*)((char*)sp + 1) == 1)
08025fde          sp[1] = 2;
08025fde      
08025fe8      int32_t result = memcpy_(arg4, &sp[1], 0xa);
08025fec      sp[7];
08025fee      sp[8];
08025fee      return result;
08025f1c  }
08025f44    int32_t BoardTest_LEDs(char* arg1, int16_t arg2)
08025f44  {
08025f44      int32_t r3;
08025f44      int32_t var_10 = r3;
08025f44      int32_t r2;
08025f44      int32_t var_14 = r2;
08025f52      int32_t var_24 = 0;
08025f52      int32_t var_20 = 0;
08025f52      int32_t var_1c = 0;
08025f5e      memset16x2(&var_24, 0xa, 0);
08025f66      *(uint8_t*)((char*)var_24)[1] = *(uint8_t*)((char*)arg2)[1];
08025f6c      (uint8_t)var_24 = 3;
08025f72      char var_28;
08025f72      cam_usart_init3(&var_28);
08025f84      char var_27;
08025f84      
08025f84      if (!(uint32_t)var_28 && (uint32_t)var_27 == 1)
08025f88          (uint8_t)var_24 = 2;
08025f88      
08025f98      return memcpy_(arg1, &var_24, 0xa);
08025f44  }
08025f9a    int32_t sub_8025f9a(char* arg1, int16_t arg2)
08025f9a  {
08025f9a      int32_t r3;
08025f9a      int32_t var_10 = r3;
08025f9a      int32_t r2;
08025f9a      int32_t var_14 = r2;
08025fa8      int32_t var_24 = 0;
08025fa8      int32_t var_20 = 0;
08025fa8      int32_t var_1c = 0;
08025fb4      memset16x2(&var_24, 0xa, 0);
08025fbc      *(uint8_t*)((char*)var_24)[1] = *(uint8_t*)((char*)arg2)[1];
08025fc2      (uint8_t)var_24 = 3;
08025fc8      char var_28;
08025fc8      cam_usart_init4(&var_28);
08025fda      char var_27;
08025fda      
08025fda      if ((uint32_t)var_28 == 1 && (uint32_t)var_27 == 1)
08025fde          (uint8_t)var_24 = 2;
08025fde      
08025fee      return memcpy_(arg1, &var_24, 0xa);
08025f9a  }
08025ff0    char* BoardTest_RunAll(char* arg1, int32_t arg2, int32_t arg3, int128_t arg4 @ q4, int64_t arg5 @ q5)
08025ff0  {
08025ff2      int64_t var_28 = (uint64_t)arg4;
08025ff2      int64_t var_30 = *(uint64_t*)((char*)arg4)[8];
08026002      int32_t a = 0;
08026002      int32_t var_54 = 0;
08026002      int32_t b = 0;
08026006      (uint32_t)arg4 = 0xf8bd0000;
0802600a      int128_t q0;
0802600a      (uint32_t)q0 = 0xf8bd0000;
0802600e      uint32_t r4 = 0;
08026010      *(uint32_t*)((char*)arg4)[4] = 0;
08026018      *(uint8_t*)((char*)a)[1] = *(uint8_t*)((char*)arg2)[1];
0802601e      (uint8_t)a = 3;
08026022      int32_t r2;
08026022      int32_t r3;
08026022      int32_t r7;
08026022      r2 = sub_802c0d2(r7);
0802602a      void var_4c;
0802602a      sub_802c0fa(&var_4c, 1, r2, r3);
0802602e      uint32_t r0_2 = (uint32_t)*(uint8_t*)((char*)a)[1];
0802602e      
08026034      if (r0_2 == 0xa)
08026034      {
0802605c          (uint8_t)a = 2;
0802643c          memcpy_(arg1, &a, 0xa);
08026034      }
08026034      else if (r0_2 < 0xa)
0802643c          memcpy_(arg1, &a, 0xa);
08026036      else if (r0_2 == 0xc)
0802603c      {
0802606e          int16_t var_40;
0802606e          sub_802e6b8((uint32_t)var_40);
0802607a          soft_dmul(a, b);
08026084          int32_t r0_4;
08026084          int32_t r1;
08026084          r0_4 = soft_dadd();
0802608c          (uint32_t)arg4 = sub_802ead0(r0_4, r1);
08026094          float32_process((uint32_t)arg4);
0802609e          soft_dmul();
080260a8          int32_t r0_7;
080260a8          int32_t r1_1;
080260a8          r0_7 = soft_dmul();
080260b0          *(uint16_t*)((char*)a)[2] = sub_802ff74(r0_7, r1_1);
080260b0          
080260ca          if ((uint32_t)*(uint16_t*)((char*)arg2)[2] < (uint32_t)*(uint16_t*)((char*)a)[2]
080260ca                  && (uint32_t)*(uint16_t*)((char*)a)[2] < (uint32_t)(uint16_t)arg3)
080260ce              (uint8_t)a = 2;
080260ce          
0802643c          memcpy_(arg1, &a, 0xa);
0802603c      }
0802603c      else if (r0_2 < 0xc)
0802603e      {
08026064          (uint8_t)a = 2;
0802643c          memcpy_(arg1, &a, 0xa);
0802603e      }
0802603e      else
0802603e      {
08026042          int64_t q0_1;
08026042          
08026042          if (r0_2 == 0xe)
08026042          {
08026278          label_8026278:
08026278              int16_t var_3c;
08026278              sub_802e6b8((uint32_t)var_3c);
08026282              soft_dmul(a, b);
0802628a              int32_t r0_55;
0802628a              int32_t r1_32;
0802628a              r0_55 = soft_dadd();
08026292              (uint32_t)arg4 = sub_802ead0(r0_55, r1_32);
08026296              (uint32_t)q0_1 = 0xfe00447a;
0802629a              (uint32_t)q0_1 = (uint32_t)arg4 * -4.26241835e+37f;
0802629e              (uint32_t)q0_1 = (float)(uint32_t)q0_1;
080262a6              *(uint16_t*)((char*)a)[2] = (uint16_t)q0_1;
080262a6              
080262c0              if ((uint32_t)*(uint16_t*)((char*)arg2)[2]
080262c0                      < (uint32_t)*(uint16_t*)((char*)a)[2]
080262c0                      && (uint32_t)*(uint16_t*)((char*)a)[2] < (uint32_t)(uint16_t)arg3)
080262c4                  (uint8_t)a = 2;
080262c4              
0802643c              memcpy_(arg1, &a, 0xa);
08026042          }
08026042          else if (r0_2 < 0xe)
08026046          {
080260dc              int16_t var_42;
080260dc              sub_802e6b8((uint32_t)var_42);
080260e6              soft_dmul(a, b);
080260ee              int32_t r0_12;
080260ee              int32_t r1_4;
080260ee              r0_12 = soft_dadd();
080260f6              (uint32_t)arg4 = sub_802ead0(r0_12, r1_4);
080260fa              (uint32_t)q0_1 = 0x41200000;
080260fe              (uint32_t)q0_1 = (uint32_t)arg4 * 10f;
08026106              int32_t r0_15;
08026106              int32_t r1_5;
08026106              r0_15 = float32_process((uint32_t)q0_1);
08026112              int32_t r0_17;
08026112              int32_t r1_6;
08026112              r0_17 = float32_process((uint32_t)arg4);
08026120              int32_t r0_18;
08026120              int32_t r1_7;
08026120              r0_18 = sub_802eb60(0x66666666, 0x400a6666, r0_17, r1_6);
0802612c              int32_t r0_20;
0802612c              int32_t r1_9;
0802612c              r0_20 = soft_dadd();
08026134              (uint32_t)q0_1 = sub_802ead0(r0_20, r1_9);
0802613c              int32_t r0_23;
0802613c              int32_t r1_10;
0802613c              r0_23 = float32_process((uint32_t)q0_1);
08026144              int128_t q0_2;
08026144              int96_t q4;
08026144              q0_2 = sub_802ece0(r7, );
08026150              int32_t r0_25;
08026150              int32_t r1_12;
08026150              r0_25 = soft_dmul();
08026158              int32_t r0_26;
08026158              int32_t r1_13;
08026158              r0_26 = sub_802ecf4(r0_25, r1_12, 0x76c8b439, 0x4056e7be);
08026160              *(uint32_t*)((char*)q4)[8] = sub_802ead0(r0_26, r1_13);
08026164              *(uint64_t*)((char*)q0_2)[8] = 0;
08026168              (uint32_t)q4 = 0;
0802616c              *(uint32_t*)((char*)q4)[4] = 0;
08026174              int32_t r0_29;
08026174              int32_t r1_14;
08026174              r0_29 = float32_process(*(uint32_t*)((char*)q4)[8]);
08026178              (uint64_t)q0_2 = (r1_14 << 32) | r0_29;
0802617c              *(uint32_t*)((char*)q0_2)[8] = 0;
08026180              *(uint32_t*)((char*)q0_2)[0xc] = 0;
08026184              int64_t q0_3;
08026184              q0_3 = sub_802f2a2(q0_2);
08026188              (uint32_t)arg4 = (uint32_t)q0_3;
0802618c              *(uint32_t*)((char*)arg4)[4] = *(uint32_t*)((char*)q0_3)[4];
08026194              int32_t r0_31;
08026194              int32_t r1_15;
08026194              r0_31 = float32_process(*(uint32_t*)((char*)arg4)[8]);
080261a4              int32_t r0_33;
080261a4              int32_t r1_17;
080261a4              r0_33 = soft_dmul();
080261b4              soft_dmul();
080261bc              int32_t r0_35;
080261bc              int32_t r1_19;
080261bc              r0_35 = soft_dmul();
080261c4              int32_t r0_36;
080261c4              int32_t r1_20;
080261c4              r0_36 = sub_802ecf4(r0_35, r1_19, r0_33, r1_17);
080261d0              float32_process(*(uint32_t*)((char*)arg4)[8]);
080261d8              int32_t r0_38;
080261d8              int32_t r1_21;
080261d8              r0_38 = soft_dmul();
080261e0              int32_t r0_39;
080261e0              int32_t r1_22;
080261e0              r0_39 = sub_802ecf4(r0_38, r1_21, r0_36, r1_20);
080261e8              int32_t r0_40;
080261e8              int32_t r1_23;
080261e8              r0_40 = sub_802ecf4(r0_39, r1_22, 0x3afb7e91, 0xc00dce70);
080261f0              (uint32_t)arg4 = sub_802ead0(r0_40, r1_23);
080261f8              int32_t r0_43;
080261f8              int32_t r1_24;
080261f8              r0_43 = float32_process((uint32_t)arg4);
08026208              soft_dmul();
08026210              int32_t r0_45;
08026210              int32_t r1_26;
08026210              r0_45 = soft_dmul();
0802621c              float32_process((uint32_t)arg4);
08026224              int32_t r0_47;
08026224              int32_t r1_27;
08026224              r0_47 = soft_dmul();
0802622c              int32_t r0_48;
0802622c              int32_t r1_28;
0802622c              r0_48 = sub_802ecf4(r0_47, r1_27, r0_45, r1_26);
08026234              int32_t r0_49;
08026234              int32_t r1_29;
08026234              r0_49 = sub_802ecf4(r0_48, r1_28, 0x5f6fd220, 0x3f99ce07);
0802623c              (uint32_t)arg4 = sub_802ead0(r0_49, r1_29);
08026240              (uint32_t)q0_3 = 0x42c80000;
08026244              (uint32_t)q0_3 = (uint32_t)arg4 * 100f;
08026248              (uint32_t)q0_3 = (float)(uint32_t)q0_3;
08026250              *(uint16_t*)((char*)a)[2] = (uint16_t)q0_3;
08026250              
0802626a              if ((uint32_t)*(uint16_t*)((char*)arg2)[2]
0802626a                      < (uint32_t)*(uint16_t*)((char*)a)[2]
0802626a                      && (uint32_t)*(uint16_t*)((char*)a)[2] < (uint32_t)(uint16_t)arg3)
0802626e                  (uint8_t)a = 2;
0802626e              
0802643c              memcpy_(arg1, &a, 0xa);
08026046          }
08026046          else if (r0_2 == 0x10)
0802604a          {
080262ce              int16_t var_3e;
080262ce              sub_802e6b8((uint32_t)var_3e);
080262d8              soft_dmul(a, b);
080262e0              int32_t r0_61;
080262e0              int32_t r1_35;
080262e0              r0_61 = soft_dadd();
080262e8              (uint32_t)arg4 = sub_802ead0(r0_61, r1_35);
080262ec              (uint32_t)q0_1 = 0x447a0000;
080262f0              (uint32_t)q0_1 = (uint32_t)arg4 * 1000f;
080262f4              (uint32_t)q0_1 = (float)(uint32_t)q0_1;
080262fc              *(uint16_t*)((char*)a)[2] = (uint16_t)q0_1;
080262fc              
08026316              if ((uint32_t)*(uint16_t*)((char*)arg2)[2]
08026316                      < (uint32_t)*(uint16_t*)((char*)a)[2]
08026316                      && (uint32_t)*(uint16_t*)((char*)a)[2] < (uint32_t)(uint16_t)arg3)
0802631a                  (uint8_t)a = 2;
0802631a              
0802643c              memcpy_(arg1, &a, 0xa);
0802604a          }
0802604a          else
0802604a          {
0802604e              if (r0_2 < 0x10)
0802604e                  goto label_8026278;
0802604e              
08026054              if (r0_2 == 0x11)
08026054              {
08026322                  sub_802a6f8(0, r7);
08026328                  sub_802a6bc(1);
0802632c                  int128_t q0_4;
0802632c                  (uint32_t)q0_4 = 0x42480000;
08026330                  int32_t r2_24;
08026330                  int32_t r3_24;
08026330                  r2_24 = sub_802a770();
08026334                  char r5_5 = 0;
08026334                  
0802633a                  while (true)
0802633a                  {
0802633a                      uint32_t r5_6 = (uint32_t)r5_5;
0802633c                      bool v_1 = r5_6 - 0x32;
0802633c                      
0802633e                      if (r5_6 - 0x32 < 0 == v_1)
0802633e                          break;
0802633e                      
08026342                      rtos_delay_ticks(0xfa);
08026348                      float q0_5;
08026348                      r2_24 = sub_802aa8c(2);
08026350                      /* unimplemented  {vcmp.f32.F32 s0, s1} */
08026354                      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08026354                      
08026358                      if (false == v_1)
08026358                      {
0802635c                          r4 = (uint32_t)((uint8_t)r4 + 1);
0802635c                          
08026360                          if (r4 >= 0xb)
08026360                          {
08026364                              (uint8_t)a = 2;
0802636c                              float32_process(0x44af0001);
08026378                              r2_24 = logging_wrapper("%d \r\n");
08026378                              break;
08026360                          }
08026358                      }
08026358                      
08026338                      r5_5 = (uint8_t)r5_6 + 1;
0802633a                  }
0802633a                  
08026382                  if ((uint32_t)(uint8_t)a == 2)
08026382                  {
080263cc                      for (int32_t i = 0; i < 0xc8; i += 1)
080263cc                      {
08026394                          sub_802c0fa(&var_4c, 1, r2_24, r3_24);
080263a0                          int16_t var_48;
080263a0                          sub_802e6a4(0x64 * (uint32_t)var_48);
080263aa                          soft_dmul(a, b);
080263b2                          int32_t r0_71;
080263b2                          int32_t r1_38;
080263b2                          r0_71 = soft_dadd();
080263c0                          (uint32_t)arg4 = (float)(uint32_t)sub_802ff74(r0_71, r1_38);
080263c4                          *(uint32_t*)((char*)arg4)[4] =
080263c4                              *(uint32_t*)((char*)arg4)[4] + (uint32_t)arg4;
080263cc                      }
080263cc                      
080263da                      float32_process(*(uint32_t*)((char*)arg4)[4] * 20f);
080263e4                      soft_dadd(a, b);
080263ee                      int32_t r0_75;
080263ee                      int32_t r1_39;
080263ee                      r0_75 = soft_dadd();
080263f6                      *(uint16_t*)((char*)a)[2] = sub_802ff74(r0_75, r1_39);
08026402                      console_printf("%d \r\n", (uint32_t)*(uint16_t*)((char*)a)[2]);
08026402                      
0802641c                      if ((uint32_t)*(uint16_t*)((char*)arg2)[2]
0802641c                          >= (uint32_t)*(uint16_t*)((char*)a)[2]
0802641c                          || (uint32_t)*(uint16_t*)((char*)a)[2]
0802641c                          >= (uint32_t)(uint16_t)arg3)
0802641c                      {
08026432                          (uint8_t)a = 3;
0802643c                          memcpy_(arg1, &a, 0xa);
0802641c                      }
0802641c                      else
0802641c                      {
08026420                          (uint8_t)a = 2;
0802642a                          memcpy_(arg1, &a, 0xa);
0802641c                      }
08026382                  }
08026382                  else
08026382                  {
08026386                      (uint8_t)a = 3;
0802643c                      memcpy_(arg1, &a, 0xa);
08026382                  }
08026054              }
08026054              else
0802643c                  memcpy_(arg1, &a, 0xa);
0802604a          }
0802603e      }
0802603e      
08026442      (uint64_t)arg4 = arg5;
08026442      *(uint64_t*)((char*)arg4)[8] = var_30;
08026446      return arg1;
08025ff0  }
080260d4  int32_t data_80260d4 = 0x0
08026448  int32_t data_8026448 = 0x42c80000
0802644c  int32_t data_802644c = 0x400a6666
08026450  int32_t data_8026450 = 0x447a0000
08026454  int32_t data_8026454 = 0x40affe00
08026458  int32_t data_8026458 = 0x803bdf0
0802645c  int32_t data_802645c = 0x42480000
0802645e    int32_t sub_802645e(int32_t arg1, int32_t arg2, int32_t arg3 @ r5)
0802645e  {
08026462      /* jump -> &*(int32_t*)((char*)data_8026464 + 2) + arg3 */
0802645e  }
08026464  int32_t data_8026464 = 0x7ae147ae
08026468  int32_t data_8026468 = -0x3fc591ec
0802646c  int32_t data_802646c = 0x76c8b439
08026470  int32_t data_8026470 = 0x4056e7be
08026474  int32_t data_8026474 = -0x5f4a1273
08026478  int32_t data_8026478 = 0x3ee0c6f7
0802647c  int32_t data_802647c = -0x15b573eb
08026480  int32_t data_8026480 = 0x3f613404
08026484  int32_t data_8026484 = 0x1ff2e48f
08026488  int32_t data_8026488 = 0x3feb6fd2
0802648c  int32_t data_802648c = 0x3afb7e91
08026490  int32_t data_8026490 = -0x3ff23190
08026494  int32_t data_8026494 = 0x4d551d69
08026498  int32_t data_8026498 = 0x3eff7510
0802649c  int32_t data_802649c = 0x23a29c78
080264a0  int32_t data_80264a0 = 0x3feffcb9
080264a4  int32_t data_80264a4 = 0x5f6fd220
080264a8  int32_t data_80264a8 = 0x3f99ce07
080264ac  int32_t data_80264ac = 0x803be00
080264b0  int32_t data_80264b0 = 0x803be10
080264b4  int32_t data_80264b4 = 0x803bc0c
080264b8  int32_t data_80264b8 = 0x803c078
080264bc  int32_t data_80264bc = 0x61100
080264c0  int32_t data_80264c0 = 0x0
080264c4              00 00 08 40                                                                              ...@
080264c8    int32_t sub_80264c8(uint32_t arg1)
080264c8  {
080264ce      char r0 = 0;
080264da      char buf[0x84];
080264da      
080264da      while (true)
080264da      {
080264da          uint32_t r0_2 = (uint32_t)r0;
080264da          
080264de          if (r0_2 >= 0x80)
080264de              break;
080264de          
080264d4          uint32_t r0_1 = (uint32_t)(uint8_t)r0_2;
080264d6          buf[r0_1] = (char)r0_1;
080264d8          r0 = (uint8_t)r0_1 + 1;
080264da      }
080264da      
080264e8      camera_link_send(0, arg1, 0x80, &buf);
080264f4      memset16x2(&buf, 0x80, 0);
08026500      sub_8026ed4(0, arg1, 0x80, &buf);
08026504      char r0_4 = 0;
08026504      
08026512      while (true)
08026512      {
08026512          uint32_t r0_6 = (uint32_t)r0_4;
08026512          
08026516          if (r0_6 >= 0x80)
08026516          {
08026532              camera_link_send(0, arg1, 0x80, &buf);
08026536              return 1;
08026516          }
08026516          
0802651a          uint32_t r0_7 = (uint32_t)(uint8_t)r0_6;
0802651a          
08026524          if ((uint32_t)buf[r0_7] != (uint32_t)(uint8_t)r0_7)
08026524              break;
08026524          
0802650c          uint32_t r0_5 = (uint32_t)(uint8_t)r0_7;
0802650e          buf[r0_5] = 0;
08026510          r0_4 = (uint8_t)r0_5 + 1;
08026512      }
08026512      
08026526      return 0;
080264c8  }
0802653c    int32_t sub_802653c(char* arg1, int16_t arg2)
0802653c  {
0802653c      int32_t r3;
0802653c      int32_t var_c = r3;
0802653c      int32_t r2;
0802653c      int32_t var_10 = r2;
0802654a      int32_t var_20 = 0;
0802654a      int32_t var_1c = 0;
0802654a      int32_t var_18 = 0;
08026552      *(uint8_t*)((char*)var_20)[1] = *(uint8_t*)((char*)arg2)[1];
08026558      (uint8_t)var_20 = 2;
0802655c      cam_usart_init1();
0802655c      
08026568      if (!sub_80264c8(0))
08026568      {
0802656c          (uint8_t)var_20 = 3;
08026572          *(uint16_t*)((char*)var_20)[2] = 1;
0802657c          return memcpy_(arg1, &var_20, 0xa);
08026568      }
08026568      
0802658c      if (!sub_80264c8(0x1000))
0802658c      {
08026590          (uint8_t)var_20 = 3;
08026596          *(uint16_t*)((char*)var_20)[2] = 2;
080265a0          return memcpy_(arg1, &var_20, 0xa);
0802658c      }
0802658c      
080265b0      if (!sub_80264c8(0x2000))
080265b0      {
080265b4          (uint8_t)var_20 = 3;
080265ba          *(uint16_t*)((char*)var_20)[2] = 3;
080265c4          return memcpy_(arg1, &var_20, 0xa);
080265b0      }
080265b0      
080265d4      if (!sub_80264c8(0x3000))
080265d4      {
080265d8          (uint8_t)var_20 = 3;
080265de          *(uint16_t*)((char*)var_20)[2] = 4;
080265e8          return memcpy_(arg1, &var_20, 0xa);
080265d4      }
080265d4      
080265f8      if (!sub_80264c8(0x4000))
080265f8      {
080265fc          (uint8_t)var_20 = 3;
08026602          *(uint16_t*)((char*)var_20)[2] = 5;
0802660c          return memcpy_(arg1, &var_20, 0xa);
080265f8      }
080265f8      
0802661c      if (!sub_80264c8(0x5000))
0802661c      {
08026620          (uint8_t)var_20 = 3;
08026626          *(uint16_t*)((char*)var_20)[2] = 6;
08026630          return memcpy_(arg1, &var_20, 0xa);
0802661c      }
0802661c      
08026640      if (sub_80264c8(0x6000))
08026660          return memcpy_(arg1, &var_20, 0xa);
08026660      
08026644      (uint8_t)var_20 = 3;
0802664a      *(uint16_t*)((char*)var_20)[2] = 7;
08026654      return memcpy_(arg1, &var_20, 0xa);
0802653c  }
08026668    int32_t sub_8026668(char* arg1, int32_t arg2, int32_t arg3)
08026668  {
08026668      int32_t r3;
08026668      int32_t var_10 = r3;
0802667a      int32_t var_30 = 0;
0802667a      int32_t var_2c = 0;
0802667a      int32_t var_28 = 0;
08026686      int64_t q4;
08026686      (uint32_t)q4 = (float)(uint32_t)*(uint16_t*)((char*)arg3)[2];
0802668c      (uint8_t)var_30 = 2;
08026694      *(uint8_t*)((char*)var_30)[1] = *(uint8_t*)((char*)arg2)[1];
0802669e      char r5_1;
0802669e      
0802669e      if ((uint32_t)*(uint8_t*)((char*)arg2)[1] != 0x14)
0802669e      {
0802676c          if ((uint32_t)*(uint8_t*)((char*)arg2)[1] == 0x15)
0802676c          {
0802676e              r5_1 = 1;
08026770              goto label_80266a8;
0802676c          }
0802676c          
08026774          (uint8_t)var_30 = 3;
0802677e          memcpy_(arg1, &var_30, 0xa);
0802669e      }
0802669e      else
0802669e      {
080266a0          r5_1 = 0;
080266a8      label_80266a8:
080266a8          sub_802a9cc(r5_1, 0);
080266b2          sub_802a9e0((uint32_t)r5_1, 1);
080266b6          int128_t q0_1;
080266b6          (uint32_t)q0_1 = (uint32_t)q4;
080266be          sub_802d600((uint32_t)r5_1);
080266c6          rtos_delay_ticks(0x1f4);
080266ce          int32_t q0_2;
080266ce          int64_t q4_1;
080266ce          q0_2 = sub_802aa8c(r5_1);
080266d2          *(uint32_t*)((char*)q4_1)[4] = q0_2;
080266de          sub_802d600((uint32_t)r5_1);
080266e8          sub_802a9e0((uint32_t)r5_1, 0);
080266f4          *(uint16_t*)((char*)var_30)[2] = (int16_t)(float)*(uint32_t*)((char*)q4_1)[4];
08026700          *(uint16_t*)((char*)var_30)[2] += 0x3e8;
08026714          int32_t r0_21;
08026714          int32_t r1;
08026714          r0_21 = float32_process(*(uint32_t*)((char*)q4_1)[4]);
0802671c          uint32_t r5_2 = (uint32_t)r5_1;
08026724          console_printf("%d F %f min %d max %d\r\n", r5_2, r0_21, r1, 
08026724              (uint32_t)*(uint16_t*)((char*)arg2)[2], (uint32_t)(uint16_t)arg3, var_30, 
08026724              var_2c, var_28);
08026734          /* unimplemented  {vcmp.f32.F32 s17, s0} */
08026738          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08026738          
0802673c          if (r5_2 >= 0)
0802673c          {
0802674a              /* unimplemented  {vcmp.f32.F32 s0, s17} */
0802674e              /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802673c          }
0802673c          
08026752          if (r5_2 >= 0 && r5_2 >= 0)
08026752          {
08026786              rtos_delay_ticks(0x64);
08026790              sub_802a9cc((uint8_t)r5_2, 1);
0802679a              sub_802a9e0((uint32_t)(uint8_t)r5_2, 1);
0802679e              int128_t q0_5;
0802679e              (uint32_t)q0_5 = (uint32_t)q4_1;
080267a6              sub_802d600((uint32_t)(uint8_t)r5_2);
080267ae              rtos_delay_ticks(0x1f4);
080267b6              int32_t q0_6;
080267b6              int64_t q4_2;
080267b6              q0_6 = sub_802aa8c((uint8_t)r5_2);
080267ba              *(uint32_t*)((char*)q4_2)[4] = q0_6;
080267c6              sub_802d600((uint32_t)(uint8_t)r5_2);
080267d0              sub_802a9e0((uint32_t)(uint8_t)r5_2, 0);
080267dc              *(uint16_t*)((char*)var_30)[2] = (int16_t)(float)*(uint32_t*)((char*)q4_2)[4];
080267e8              *(uint16_t*)((char*)var_30)[2] += 0x7d0;
080267fc              int32_t r0_45;
080267fc              int32_t r1_4;
080267fc              r0_45 = float32_process(*(uint32_t*)((char*)q4_2)[4]);
08026804              uint32_t r5_3 = (uint32_t)(uint8_t)r5_2;
0802680a              console_printf("%d B %f min %d max %d\r\n", r5_3, r0_45, r1_4, 
0802680a                  (uint32_t)*(uint16_t*)((char*)arg2)[2], (uint32_t)(uint16_t)arg3, var_30);
0802681a              /* unimplemented  {vcmp.f32.F32 s17, s0} */
0802681e              /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802681e              
08026822              if (r5_3 >= 0)
08026822              {
08026830                  /* unimplemented  {vcmp.f32.F32 s0, s17} */
08026834                  /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08026822              }
08026822              
08026838              if (r5_3 >= 0 && r5_3 >= 0)
08026852                  memcpy_(arg1, &var_30, 0xa);
08026838              else
08026838              {
0802683c                  (uint8_t)var_30 = 3;
08026846                  memcpy_(arg1, &var_30, 0xa);
08026838              }
08026752          }
08026752          else
08026752          {
08026756              (uint8_t)var_30 = 3;
08026760              memcpy_(arg1, &var_30, 0xa);
08026752          }
0802669e      }
0802685c      return arg2;
08026668  }
0802685e                                                                                            00 00                                ..
08026860  int32_t data_8026860 = 0x803c080
08026864  int32_t data_8026864 = 0x803be20
08026868  int32_t data_8026868 = 0x803ae50
0802686c    int32_t sub_802686c(char* arg1, int32_t arg2, int32_t arg3)
0802686c  {
0802686c      int32_t r3;
0802686c      int32_t var_10 = r3;
0802687e      int32_t var_30 = 0;
0802687e      int32_t var_2c = 0;
0802687e      int32_t var_28 = 0;
0802688a      int64_t q4;
0802688a      (uint32_t)q4 = (float)(uint32_t)*(uint16_t*)((char*)arg3)[2];
08026890      (uint8_t)var_30 = 2;
08026898      *(uint8_t*)((char*)var_30)[1] = *(uint8_t*)((char*)arg2)[1];
080268a2      int32_t r5_1;
080268a2      
080268a2      if ((uint32_t)*(uint8_t*)((char*)arg2)[1] != 0x16)
080268a2      {
08026956          if ((uint32_t)*(uint8_t*)((char*)arg2)[1] == 0x17)
08026956          {
08026958              r5_1 = 1;
0802695a              goto label_80268ac;
08026956          }
08026956          
0802695e          (uint8_t)var_30 = 3;
08026968          memcpy_(arg1, &var_30, 0xa);
080268a2      }
080268a2      else
080268a2      {
080268a4          r5_1 = 0;
080268ac      label_80268ac:
080268ac          sub_802a9cc((uint8_t)r5_1, 0);
080268b6          sub_802a9e0((uint32_t)(uint8_t)r5_1, 1);
080268ba          int128_t q0_1;
080268ba          (uint32_t)q0_1 = (uint32_t)q4;
080268c2          sub_802d600((uint32_t)(uint8_t)r5_1);
080268ca          *(uint16_t*)((char*)var_30)[2] = *(uint16_t*)((char*)arg2)[2];
080268de          sub_802a458((uint8_t)r5_1, r5_1);
080268e4          rtos_delay_ticks(0x64);
080268e4          
080268f2          if (sub_802a4cc((uint8_t)r5_1) != 1)
080268f2          {
08026978              console_printf("%d %d LOW\r\n", (uint32_t)(uint8_t)r5_1, 
08026978                  (uint32_t)*(uint16_t*)((char*)var_30)[2]);
0802697e              (uint8_t)var_30 = 3;
08026988              memcpy_(arg1, &var_30, 0xa);
080268f2          }
080268f2          else
080268f2          {
080268f8              uint32_t r5_2 = (uint32_t)(uint8_t)r5_1;
080268fe              console_printf("%d %d HIGH\r\n", r5_2, 
080268fe                  (uint32_t)*(uint16_t*)((char*)var_30)[2]);
08026906              *(uint16_t*)((char*)var_30)[2] = (uint16_t)arg3;
0802691a              sub_802a458((uint8_t)r5_2, r5_2);
08026920              rtos_delay_ticks(0x64);
08026920              
0802692e              if (sub_802a4cc((uint8_t)r5_2) != 1)
0802692e              {
08026992                  uint32_t r5_5 = (uint32_t)(uint8_t)r5_2;
08026998                  console_printf("%d %d LOW\r\n", r5_5, 
08026998                      (uint32_t)*(uint16_t*)((char*)var_30)[2]);
0802699c                  int128_t q0_4;
0802699c                  (uint32_t)q0_4 = 0;
080269a4                  sub_802d600((uint32_t)(uint8_t)r5_5);
080269ae                  sub_802a9e0((uint32_t)(uint8_t)r5_5, 0);
080269b8                  memcpy_(arg1, &var_30, 0xa);
0802692e              }
0802692e              else
0802692e              {
0802693a                  console_printf("%d %d HIGH\r\n", (uint32_t)(uint8_t)r5_2, 
0802693a                      (uint32_t)*(uint16_t*)((char*)var_30)[2]);
08026940                  (uint8_t)var_30 = 3;
0802694a                  memcpy_(arg1, &var_30, 0xa);
0802692e              }
080268f2          }
080268a2      }
080269c2      return arg2;
0802686c  }
080269c4  int32_t data_80269c4 = 0x7b917
080269c8  int32_t data_80269c8 = 0x2000e440
080269cc  int32_t data_80269cc = 0x2000e441
080269d0  int32_t data_80269d0 = 0x0
080269d4  int32_t data_80269d4 = 0x803b528
080269d8    int32_t sub_80269d8(char* arg1, int16_t arg2)
080269d8  {
080269d8      int32_t r3;
080269d8      int32_t var_10 = r3;
080269d8      int32_t r2;
080269d8      int32_t var_14 = r2;
080269e6      int32_t var_28 = 0;
080269e6      int32_t var_24 = 0;
080269e6      int32_t var_20 = 0;
080269ec      (uint8_t)var_28 = 2;
080269f4      *(uint8_t*)((char*)var_28)[1] = *(uint8_t*)((char*)arg2)[1];
08026a04      sub_8030026(&GPIOA, 0x400, 0xc00, 0);
08026a14      gpio_config_af(0x40020c00, 0x8000, 0xc03, 2);
08026a24      sub_8030026(0x40020c00, 0x4000, 0xc03, 0);
08026a30      gpio_write(0x40020c00, 0x8000, true);
08026a34      char r5 = 0;
08026a34      
08026a46      while (true)
08026a46      {
08026a46          uint32_t r5_1 = (uint32_t)r5;
08026a46          
08026a4a          if (r5_1 >= 0x64)
08026a4a              break;
08026a4a          
08026a58          if (!sub_803004c(&GPIOA, 0x400) && !sub_803004c(0x40020c00, 0x4000))
08026a58          {
08026a70              gpio_write(0x40020c00, 0x8000, false);
08026a76              (uint8_t)var_28 = 2;
08026a76              break;
08026a58          }
08026a58          
08026a3a          (uint8_t)var_28 = 3;
08026a40          rtos_delay_ticks(0xa);
08026a44          r5 = (uint8_t)r5_1 + 1;
08026a46      }
08026a46      
08026a7a      char r5_2 = 0;
08026a7a      
08026a8c      while (true)
08026a8c      {
08026a8c          uint32_t r5_3 = (uint32_t)r5_2;
08026a8c          
08026a90          if (r5_3 >= 0x64)
08026ac0              return memcpy_(arg1, &var_28, 0xa);
08026ac0          
08026a9e          if (sub_803004c(&GPIOA, 0x400) == 1 && sub_803004c(0x40020c00, 0x4000) == 1)
08026a9e          {
08026ab0              (uint8_t)var_28 = 2;
08026ac0              return memcpy_(arg1, &var_28, 0xa);
08026a9e          }
08026a9e          
08026a80          (uint8_t)var_28 = 3;
08026a86          rtos_delay_ticks(0xa);
08026a8a          r5_2 = (uint8_t)r5_3 + 1;
08026a8c      }
080269d8  }
08026ac2        00 00                                                                                        ..
08026ac4  int32_t data_8026ac4 = 0x437f0000
08026ac8  int32_t data_8026ac8 = 0x803b544
08026acc  int32_t data_8026acc = 0x803b974
08026ad0  int32_t data_8026ad0 = 0x40210000
08026ad4  int32_t data_8026ad4 = 0x408f4000
08026ad8  int32_t data_8026ad8 = 0x803c088
08026adc  int32_t data_8026adc = 0x401e0000
08026ae0  int32_t data_8026ae0 = 0x40690000
08026ae4  int32_t data_8026ae4 = 0x803b98c
08026ae8  int32_t data_8026ae8 = 0x803b9a4
08026aec  int32_t data_8026aec = 0x803be30
08026af0  int32_t data_8026af0 = 0x803bf78
08026af4  int32_t data_8026af4 = 0x40020000
08026af8  int32_t data_8026af8 = 0x40020c00
08026afc    void* memset16x2(void* dst, uint32_t len, uint8_t value)
08026afc  {
08026afc      uint16_t r2_1 = (uint16_t)value | (int16_t)((uint32_t)value << 8);
08026b00      /* tailcall */
08026b00      return memfill_back32(dst, len, (uint32_t)r2_1 | (uint32_t)r2_1 << 0x10);
08026afc  }
08026b04    void* memfill_back32(void* dst, uint32_t len, uint32_t pattern32)
08026b04  {
08026b04      void* result = (char*)dst + len;
08026b06      void* r3 = result & 3;
08026b06      
08026b0a      if (r3)
08026b0a      {
08026b0c          uint32_t len_1 = len;
08026b0c          len -= r3;
08026b0c          
08026b0e          if (len_1 < r3)
08026b0e          {
08026b52              if (len != -(r3))
08026b52              {
08026b54                  result -= 1;
08026b54                  *(uint8_t*)result = (char)pattern32;
08026b52              }
08026b52              
08026b5a              if (TEST_BIT(len + r3, 1))
08026b5a              {
08026b5c                  result -= 1;
08026b5c                  *(uint8_t*)result = (char)pattern32;
08026b5a              }
08026b5a              
08026b60              return result;
08026b0e          }
08026b0e          
08026b12          if (r3 << 0x1f < 0)
08026b12          {
08026b14              result -= 1;
08026b14              *(uint8_t*)result = (char)pattern32;
08026b12          }
08026b12          
08026b18          if (TEST_BIT(r3, 1))
08026b18          {
08026b1a              result -= 2;
08026b1a              *(uint16_t*)result = (int16_t)pattern32;
08026b18          }
08026b0a      }
08026b0a      
08026b2e      uint32_t i;
08026b2e      
08026b2e      do
08026b2e      {
08026b26          i = len;
08026b26          len -= 0x10;
08026b26          
08026b28          if (i >= 0x10)
08026b28          {
08026b2a              *(uint32_t*)((char*)result - 0x10) = pattern32;
08026b2a              *(uint32_t*)((char*)result - 0xc) = pattern32;
08026b2a              *(uint32_t*)((char*)result - 8) = pattern32;
08026b2a              *(uint32_t*)((char*)result - 4) = pattern32;
08026b2a              result -= 0x10;
08026b28          }
08026b2e      } while (i > 0x10);
08026b30      uint32_t r1 = len << 0x1d;
08026b30      
08026b32      if (TEST_BIT(len, 3))
08026b32      {
08026b34          *(uint32_t*)((char*)result - 8) = pattern32;
08026b34          *(uint32_t*)((char*)result - 4) = pattern32;
08026b34          result -= 8;
08026b32      }
08026b32      
08026b38      if (len << 0x1d < 0)
08026b38      {
08026b3a          result -= 4;
08026b3a          *(uint32_t*)result = pattern32;
08026b38      }
08026b38      
08026b40      if (TEST_BIT(r1, 0x1e))
08026b40      {
08026b42          result -= 2;
08026b42          *(uint16_t*)result = (int16_t)pattern32;
08026b40      }
08026b40      
08026b46      if (r1 << 2 < 0)
08026b46      {
08026b48          result -= 1;
08026b48          *(uint8_t*)result = (char)pattern32;
08026b46      }
08026b46      
08026b4e      return result;
08026b04  }
08026b62    int32_t* cam_uart_boot_t()
08026b62  {
08026b62      /* tailcall */
08026b62      return cam_uart_boot();
08026b62  }
08026b64    int32_t* cam_uart_boot()
08026b64  {
08026b70      int32_t var_2c;
08026b70      memcpy(&var_2c, &cam_uart_cfg_default, 0x28);
08026b7a      int32_t var_28;
08026b7a      int32_t var_24;
08026b7a      usart_init(CAM_USART_BASE, var_2c, var_28, var_24);
08026b86      return sub_8026c14(0x20000538);
08026b64  }
08026b88    int32_t usart_init(USART_TypeDef* arg1, int16_t arg2, int32_t arg3, int32_t arg4, GPIO_TypeDef* arg5, int32_t arg6, int32_t arg7, int16_t arg8, GPIO_TypeDef* arg9, int32_t arg10, int32_t arg11)
08026b88  {
08026b92      rcc_enable_by_code((uint16_t)arg4);
08026b9a      rcc_enable_by_code(arg8);
08026ba2      rcc_enable_by_code(arg2);
08026bac      sub_80304da(arg5, arg7, arg6);
08026bb6      sub_80304da(arg9, arg11, arg10);
08026bc2      gpio_config_mode_pull(arg5, 2, 1, (uint16_t)arg6);
08026bce      gpio_config_otype_speed(arg5, 0, 2, (uint16_t)arg6);
08026bda      gpio_config_mode_pull(arg9, 2, 1, (uint16_t)arg10);
08026be6      gpio_config_otype_speed(arg9, 0, 2, (uint16_t)arg10);
08026bec      int32_t r2_2;
08026bec      int32_t r3_4;
08026bec      int32_t r7;
08026bec      r2_2 = usart_enable_clock_from_base(arg1, r7);
08026bf4      usart_set_baud_brr(arg1, arg3, r2_2, r3_4);
08026bfc      usart_enable_rx(arg1, 4);
08026c04      usart_enable_tx(arg1, 8);
08026c0a      usart_enable(arg1);
08026c10      return arg4;
08026b88  }
08026c14    int32_t* sub_8026c14(int16_t* arg1)
08026c14  {
08026c1c      rcc_enable_by_code(*(uint16_t*)arg1);
08026c2a      *(uint32_t*)((char*)arg1 + 0x14) = sub_80308ae(1, 0, 3);
08026c32      int32_t* result = sub_80308ae(1, 0, 3);
08026c36      *(uint32_t*)((char*)arg1 + 0x24) = result;
08026c38      return result;
08026c14  }
08026c3a    int32_t sub_8026c3a(void* arg1, void* arg2)
08026c3a  {
08026c4c      dma_stream_reset_and_clear_flags(*(uint32_t*)((char*)arg2 + 4), 
08026c4c          *(uint8_t*)((char*)arg2 + 8));
08026c52      int32_t var_24 = 0x40;
08026c54      int32_t r2;
08026c54      int32_t var_34 = r2;
08026c58      int32_t var_30 = 0;
08026c5c      int32_t var_2c = 0;
08026c5e      int32_t r3;
08026c5e      int32_t var_20 = r3;
08026c62      int32_t var_3c = *(uint32_t*)((char*)arg2 + 0xc);
08026c66      int32_t var_38 = 1;
08026c6c      int32_t var_1c = 0x30000;
08026c76      uint32_t par;
08026c76      memcpy(&par, &var_3c, 0x24);
08026c80      uint32_t m0ar;
08026c80      dma_stream_config(*(uint32_t*)((char*)arg2 + 4), 
08026c80          (uint32_t)*(uint8_t*)((char*)arg2 + 8), par, m0ar);
08026c88      dma_cr_clear_bit(*(uint32_t*)((char*)arg2 + 4), *(uint8_t*)((char*)arg2 + 8));
08026c92      dma_set_priority(*(uint32_t*)((char*)arg2 + 4), *(uint8_t*)((char*)arg2 + 8), 
08026c92          *(uint8_t*)((char*)arg2 + 0x10));
08026c9c      dma_or_bits(*(uint32_t*)((char*)arg2 + 4), *(uint8_t*)((char*)arg2 + 8), 0x10);
08026ca6      nvic_enable_irq_with_priority(*(uint8_t*)((char*)arg2 + 0x11), 2, 0);
08026cae      dma_stream_enable(*(uint32_t*)((char*)arg2 + 4), *(uint8_t*)((char*)arg2 + 8));
08026cb6      sub_803077c(arg1, 0x80);
08026cc0      rtos_dma_rx_wait_and_service(*(uint32_t*)((char*)arg2 + 0x14), 0xffffffff);
08026cca      dma_andnot_bits(*(uint32_t*)((char*)arg2 + 4), *(uint8_t*)((char*)arg2 + 8), 0x10);
08026cd0      nvic_disable_irq(*(uint8_t*)((char*)arg2 + 0x11));
08026cd8      dma_stream_disable(*(uint32_t*)((char*)arg2 + 4), *(uint8_t*)((char*)arg2 + 8));
08026ce0      sub_803077c(arg1, 0);
08026cea      dma_clear_flags(*(uint32_t*)((char*)arg2 + 4), *(uint8_t*)((char*)arg2 + 8), 0x20);
08026cf2      return 1;
08026c3a  }
08026cf4    int32_t cam_uart_tx_start(USART_TypeDef* usart, void* dmactx, uint8_t const* pByte)
08026cf4  {
08026d06      dma_stream_reset_and_clear_flags(*(uint32_t*)((char*)dmactx + 4), 
08026d06          *(uint8_t*)((char*)dmactx + 0x18));
08026d0c      int32_t var_24 = 0;
08026d0e      uint8_t const* pByte_1 = pByte;
08026d12      int32_t var_30 = 0;
08026d16      int32_t var_2c = 0;
08026d18      int32_t r3;
08026d18      int32_t var_20 = r3;
08026d1c      int32_t var_3c = *(uint32_t*)((char*)dmactx + 0x1c);
08026d20      int32_t var_38 = 1;
08026d26      int32_t var_1c = 0x30000;
08026d30      uint32_t par;
08026d30      memcpy(&par, &var_3c, 0x24);
08026d3a      uint32_t m0ar;
08026d3a      dma_stream_config(*(uint32_t*)((char*)dmactx + 4), 
08026d3a          (uint32_t)*(uint8_t*)((char*)dmactx + 0x18), par, m0ar);
08026d42      dma_cr_clear_bit(*(uint32_t*)((char*)dmactx + 4), *(uint8_t*)((char*)dmactx + 0x18));
08026d4e      dma_set_priority(*(uint32_t*)((char*)dmactx + 4), *(uint8_t*)((char*)dmactx + 0x18), 
08026d4e          *(uint8_t*)((char*)dmactx + 0x20));
08026d58      dma_or_bits(*(uint32_t*)((char*)dmactx + 4), *(uint8_t*)((char*)dmactx + 0x18), 0x10);
08026d64      nvic_enable_irq_with_priority(*(uint8_t*)((char*)dmactx + 0x21), 2, 0);
08026d6c      dma_stream_enable(*(uint32_t*)((char*)dmactx + 4), *(uint8_t*)((char*)dmactx + 0x18));
08026d74      usart_set_dmar(usart, 0x40);
08026d7c      int32_t timeoutTicks;
08026d7c      rtos_dma_rx_wait_and_service(*(uint32_t*)((char*)dmactx + 0x24), timeoutTicks);
08026d86      dma_andnot_bits(*(uint32_t*)((char*)dmactx + 4), *(uint8_t*)((char*)dmactx + 0x18), 
08026d86          0x10);
08026d8e      nvic_disable_irq(*(uint8_t*)((char*)dmactx + 0x21));
08026d96      dma_stream_disable(*(uint32_t*)((char*)dmactx + 4), 
08026d96          *(uint8_t*)((char*)dmactx + 0x18));
08026d9e      usart_set_dmar(usart, 0);
08026da8      dma_clear_flags(*(uint32_t*)((char*)dmactx + 4), *(uint8_t*)((char*)dmactx + 0x18), 
08026da8          0x20);
08026db0      return 1;
08026cf4  }
08026db2    int32_t sub_8026db2(void* arg1)
08026db2  {
08026dbe      dma_andnot_bits(*(uint32_t*)((char*)arg1 + 4), *(uint8_t*)((char*)arg1 + 8), 0x10);
08026dc4      nvic_disable_irq(*(uint8_t*)((char*)arg1 + 0x11));
08026dcc      dma_stream_disable(*(uint32_t*)((char*)arg1 + 4), *(uint8_t*)((char*)arg1 + 8));
08026dd6      dma_clear_flags(*(uint32_t*)((char*)arg1 + 4), *(uint8_t*)((char*)arg1 + 8), 0x20);
08026dde      int32_t result;
08026dde      sub_8030aea(*(uint32_t*)((char*)arg1 + 0x14), &result);
08026dde      
08026de6      if (result)
08026de6      {
08026dee          *(uint32_t*)0xe000ed04 = 0x10000000;
08026df0          __dsb_SY();
08026df4          __isb();
08026de6      }
08026de6      
08026df8      return result;
08026db2  }
08026dfa    int32_t sub_8026dfa(void* arg1)
08026dfa  {
08026e06      dma_andnot_bits(*(uint32_t*)((char*)arg1 + 4), *(uint8_t*)((char*)arg1 + 0x18), 0x10);
08026e0e      nvic_disable_irq(*(uint8_t*)((char*)arg1 + 0x21));
08026e16      dma_stream_disable(*(uint32_t*)((char*)arg1 + 4), *(uint8_t*)((char*)arg1 + 0x18));
08026e20      dma_clear_flags(*(uint32_t*)((char*)arg1 + 4), *(uint8_t*)((char*)arg1 + 0x18), 0x20);
08026e28      int32_t result;
08026e28      sub_8030aea(*(uint32_t*)((char*)arg1 + 0x24), &result);
08026e28      
08026e30      if (result)
08026e30      {
08026e38          *(uint32_t*)0xe000ed04 = 0x10000000;
08026e3a          __dsb_SY();
08026e3e          __isb();
08026e30      }
08026e30      
08026e42      return result;
08026dfa  }
08026e44    int32_t uart_send_blocking(int32_t usart_base, int32_t ch)
08026e44  {
08026e50      usart_write_dr(CAM_USART_BASE, (uint32_t)(uint8_t)usart_base);
08026e60      int32_t i;
08026e60      
08026e60      do
08026e5a          i = usart_check_flag(CAM_USART_BASE, 7);
08026e60       while (!i);
08026e64      return usart_base;
08026e44  }
08026e66    int32_t sub_8026e66(int32_t arg1 @ r7)
08026e66  {
08026e6a      sub_8026dfa(0x20000538);
08026e6e      return arg1;
08026e66  }
08026e70    int32_t cam_uart_tx_followup(uint8_t* buf, uint8_t len)
08026e70  {
08026e78      uint32_t len_1 = (uint32_t)len;
08026e7c      int32_t result;
08026e7c      
08026e7c      if (len_1 >= 3)
08026e7c      {
08026e82          result = 0xffffffff;
08026e8e          cam_uart_tx_start(CAM_USART_BASE, 0x20000538, buf);
08026e7c      }
08026e7c      
08026e92      int32_t r6 = 2;
08026e92      
08026eac      while (true)
08026eac      {
08026eac          len_1 = (uint32_t)(uint8_t)len_1;
08026eac          
08026eb0          if (r6 >= len_1)
08026eb0              break;
08026eb0          
08026e98          result = 0x64;
08026ea6          cam_uart_tx_start(CAM_USART_BASE, 0x20000538, &buf[r6]);
08026eaa          r6 += 1;
08026eac      }
08026eac      
08026eb2      return result;
08026e70  }
08026eb4  int32_t data_8026eb4 = 0x20000510
08026eb8  int32_t data_8026eb8 = 0x20000508
08026ebc  int32_t data_8026ebc = 0x20000538
08026ec0  int32_t data_8026ec0 = -0x1fff12fc
08026ec4    int32_t cam_usart_init1()
08026ec4  {
08026ec4      int32_t r7;
08026ec4      int32_t var_8 = r7;
08026ec6      sub_80312dc();
08026ece      g_cam_link_busy = 0;
08026ed2      return 1;
08026ec4  }
08026ed4    int32_t sub_8026ed4(char arg1, int32_t arg2, char arg3, char* arg4)
08026ed4  {
08026ed4      char* var_18 = arg4;
08026ed4      
08026eec      while ((uint32_t)g_cam_link_busy)
08026ee2          rtos_delay_ticks(1);
08026ee2      
08026ef2      g_cam_link_busy = 1;
08026f00      sub_803155e(arg4, arg2 + (uint32_t)arg1, (uint32_t)arg3);
08026f08      g_cam_link_busy = 0;
08026f0c      return 1;
08026ed4  }
08026f0e  // //
08026f0e  // ---------------------------------------------------------------------------
08026f0e  // // sub_8026f0e
08026f0e  // // Sends a small frame/buffer to the camera link, with a simple busy flag.
08026f0e  // // Args (by position from HLIL):
08026f0e  // //   chan_or_offset (arg1) : small offset (added to base)
08026f0e  // //   base_addr      (arg2) : base destination (0xE000 in your callsite)
08026f0e  // //   len_bytes      (arg3) : number of bytes to send
08026f0e  // //   buf            (arg4) : pointer to data to send
08026f0e  // // Returns 1 on success.
08026f0e  // //
08026f0e  // ---------------------------------------------------------------------------
08026f0e  
08026f0e    int32_t camera_link_send(uint8_t chan_or_offset, uint32_t base_addr, uint16_t len_bytes, void const* buf)
08026f0e  {
08026f0e      void const* buf_1 = buf;
08026f0e      
08026f26      while ((uint32_t)g_cam_link_busy)
08026f1c          rtos_delay_ticks(1);
08026f1c      
08026f2c      g_cam_link_busy = 1;
08026f30      camlink_select_base(base_addr);
08026f40      camlink_write(buf, base_addr + (uint32_t)chan_or_offset, 
08026f40          (uint16_t)(uint8_t)len_bytes);
08026f48      g_cam_link_busy = 0;
08026f4c      return 1;
08026f0e  }
08026f4e                                            00 00                                                                ..
08026f50  int32_t data_8026f50 = 0x2000e435
08026f54  // /*-----------------------------------------------------------------------------
08026f54  //  * sub_8026f54
08026f54  //  * High-level “camera link HW init”: configure pins, then init the UART
08026f54  // block.
08026f54  //  * Always returns 1.
08026f54  //  
08026f54  // *---------------------------------------------------------------------------*/
08026f54  
08026f54    int32_t cam_link_hw_init()
08026f54  {
08026f54      int32_t r7;
08026f54      int32_t var_8 = r7;
08026f56      int32_t entry_passthrough;
08026f56      cam_uart_gpio_init_retpassthru(entry_passthrough);
08026f5a      cam_usart_init2(r7);
08026f60      return 1;
08026f54  }
08026f62  // /*-----------------------------------------------------------------------------
08026f62  //  * sub_8026f62
08026f62  //  * Configure GPIO mux for the camera UART pins.
08026f62  //  * In HLIL it calls:
08026f62  //  *   sub_8030026(0x40020C00, 0x800, 0xC03, 1);
08026f62  //  *   sub_8030026(0x40020C00, 0x400, 0xC03, 1);
08026f62  //  *
08026f62  //  * 0x40020C00 = GPIOD base on STM32/GD32F4x (GD32F407 too).
08026f62  //  * 0x0800 = PD11, 0x0400 = PD10. Mode 0xC03 + AF=1 is the board’s encoding
08026f62  //  * for “alternate function UART” with whatever drive/pull settings they
08026f62  // use.
08026f62  //  *
08026f62  //  * Returns its input unmodified (matches HLIL behavior).
08026f62  //  
08026f62  // *---------------------------------------------------------------------------*/
08026f62  
08026f62    int32_t cam_uart_gpio_init_retpassthru(int32_t passthrough)
08026f62  {
08026f70      sub_8030026(0x40020c00, 0x800, 0xc03, 1);
08026f80      sub_8030026(0x40020c00, 0x400, 0xc03, 1);
08026f84      int32_t entry_result;
08026f84      return entry_result;
08026f62  }
08026f86    int32_t cam_usart_init4(char* arg1)
08026f86  {
08026f94      *(uint8_t*)arg1 = sub_803004c(0x40020c00, 0x800);
08026f9c      char result = sub_803004c(0x40020c00, 0x400);
08026fa0      arg1[1] = result;
08026fa2      return result;
08026f86  }
08026fa4  // /**
08026fa4  //  * sub_8026fa4
08026fa4  //  * Probes/reads a pair of UART-related status bytes and returns a small code.
08026fa4  //  *
08026fa4  //  * Return codes (by observed behavior):
08026fa4  //  *   4 : the two status bytes are equal
08026fa4  //  *   0 : the first status byte is non-zero (and != second)
08026fa4  //  *   1 : the first status byte is zero
08026fa4  //  */
08026fa4  
08026fa4    int32_t cam_uart_status_probe()
08026fa4  {
08026fa4      uint8_t s[0x2];
08026fa4      int32_t entry_r7;
08026fa4      s = entry_r7;
08026fa8      cam_usart_init4(&s);
08026fa8      
08026fb6      if ((uint32_t)s[0] == (uint32_t)s[1])
08026fc8          return 4;
08026fc8      
08026fbe      if ((uint32_t)s[0])
08026fc4          return 0;
08026fc4      
08026fc0      return 1;
08026fa4  }
08026fcc    int32_t cam_usart_init2(int32_t arg1 @ r7)
08026fcc  {
08026fda      sub_8030026(&GPIOC, 0x200, 0xc02, 0);
08026fea      sub_8030026(&GPIOC, 0x100, 0xc02, 0);
08026fee      return arg1;
08026fcc  }
08026ff0    int32_t cam_usart_init3(char* arg1)
08026ff0  {
08026ffe      *(uint8_t*)arg1 = sub_803004c(&GPIOC, 0x200);
08027006      char result = sub_803004c(&GPIOC, 0x100);
0802700a      arg1[1] = result;
0802700c      return result;
08026ff0  }
0802700e                                            00 00                                                                ..
08027010  int32_t data_8027010 = 0x40020c00
08027014  int32_t data_8027014 = 0x40020800
08027018  // /**
08027018  //  * sub_8027018
08027018  //  * Returns a small code based on two status bytes produced by
08027018  // cam_usart_init3.
08027018  //  *
08027018  //  * Return codes:
08027018  //  *   6 : the two bytes differ (link/config mismatch)
08027018  //  *   0 : the bytes match but the value != 1 (unexpected/idle state)
08027018  //  *   1 : the bytes match and equal 1 (expected/OK state)
08027018  //  */
08027018  
08027018    int32_t cam_uart_init_check()
08027018  {
08027018      uint8_t s[0x2];
08027018      int32_t entry_r7;
08027018      s = entry_r7;
0802701c      cam_usart_init3(&s);
0802701c      
0802702a      if ((uint32_t)s[0] != (uint32_t)s[1])
0802702c          return 6;
0802702c      
08027036      if ((uint32_t)s[0] != 1)
0802703c          return 0;
0802703c      
08027038      return 1;
08027018  }
08027040    void SpeakerTask(void* arg)
08027040  {
08027042      uint32_t r4 = 0xa;
08027042      
08027066      while (true)
08027066      {
0802706a          switch ((uint32_t)__clz(beep_event_flags))
0802706a          {
08027068              case 1:
08027068              {
0802709a                  buzzer_set_tone(1, 2);
080270ac                  beep_event_flags &= 0xfffffff;
080270ae                  r4 = 0xa;
08027068                  break;
08027068              }
0802706c              case 2:
0802706c              {
080270b6                  buzzer_set_tone(2, 2);
080270c4                  beep_event_flags &= 0xfffffff;
080270c6                  r4 = 0xa;
0802706c                  break;
0802706c              }
08027070              case 3:
08027070              {
080270ce                  buzzer_set_tone(0xa, 2);
080270dc                  beep_event_flags &= 0xfffffff;
080270de                  r4 = 0xa;
08027070                  break;
08027070              }
08027074              case 4:
08027074              {
080270e6                  buzzer_set_tone(1, 2);
080270ee                  beep_event_flags = 0;
080270f0                  r4 = 0xa;
08027074                  break;
08027074              }
08027078              case 0x19:
08027078              {
0802704c                  buzzer_beep(5, 4, 0x64);
08027050                  r4 = 0x3e8;
08027078                  break;
08027078              }
0802707c              case 0x1a:
0802707c              {
0802714a                  buzzer_beep(2, 2, 0x23);
0802714e                  r4 = 0x3e8;
0802707c                  break;
0802707c              }
08027080              case 0x1b:
08027080              {
0802713a                  buzzer_beep(7, 2, 0xf);
0802713e                  r4 = 0x3e8;
08027080                  break;
08027080              }
08027084              case 0x1c:
08027084              {
0802712a                  buzzer_beep(8, 2, 0xc);
0802712e                  r4 = 0x3e8;
08027084                  break;
08027084              }
08027088              case 0x1d:
08027088              {
0802711a                  buzzer_beep(3, 2, 0x19);
0802711e                  r4 = 0x3e8;
08027088                  break;
08027088              }
0802708c              case 0x1e:
0802708c              {
0802710a                  buzzer_beep(9, 2, 0xa);
0802710e                  r4 = 0x3e8;
0802708c                  break;
0802708c              }
08027090              case 0x1f:
08027090              {
080270fa                  buzzer_beep(1, 2, 0x46);
080270fe                  r4 = 0x3e8;
08027090                  break;
08027090              }
0802706a          }
0802706a          
08027054          r4 = (uint32_t)(uint16_t)r4;
08027058          rtos_delay_ticks(r4);
08027066      }
08027040  }
08027154    int32_t createSpeakerTask()
08027154  {
08027162      gpio_config_af(0x40021000, 0x80, 0xc04, 2);
08027176      rtos_xTaskCreate(SpeakerTask, "SpeakerTask", 0x82, nullptr, 2, nullptr);
0802717a      return 2;
08027154  }
0802717c    int32_t sub_802717c()
0802717c  {
0802717c      int32_t r7;
0802717c      int32_t var_8 = r7;
08027184      gpio_write(0x40021000, 0x80, true);
0802718a      return 1;
0802717c  }
0802718c    int32_t sub_802718c()
0802718c  {
0802718c      int32_t r7;
0802718c      int32_t var_8 = r7;
08027194      gpio_write(0x40021000, 0x80, false);
0802719a      return 1;
0802718c  }
0802719c    int32_t doBeep(int32_t arg1)
0802719c  {
080271a0      data_2000e45a = 0;
080271aa      beep_event_flags |= arg1;
080271ae      return 1;
0802719c  }
080271b0    int32_t get_beep_event_flags()
080271b0  {
080271b4      return beep_event_flags;
080271b0  }
080271b6    int32_t sub_80271b6(int32_t arg1)
080271b6  {
080271ba      data_2000e384 = 0;
080271ba      
080271be      if (arg1)
080271d2          beep_event_flags &= ~arg1;
080271be      else
080271c4          beep_event_flags = 0;
080271c4      
080271d6      return 1;
080271b6  }
080271d8    int32_t sub_80271d8()
080271d8  {
080271d8      int32_t r7;
080271d8      int32_t var_8 = r7;
080271da      sub_802718c();
080271e0      rtos_delay_ticks(1);
080271e4      sub_802717c();
080271ea      rtos_delay_ticks(0xfa);
080271ee      sub_802718c();
080271f4      return 1;
080271d8  }
080271f6    int32_t sub_80271f6()
080271f6  {
080271f6      int32_t r7;
080271f6      int32_t var_8 = r7;
080271f8      sub_802718c();
080271fe      rtos_delay_ticks(1);
08027202      sub_802717c();
0802720a      rtos_delay_ticks(0x1f4);
0802720e      sub_802718c();
08027214      return 1;
080271f6  }
08027216    int32_t beep_enabled_set(char arg1)
08027216  {
08027218      beepbeep = arg1;
0802721c      return 1;
08027216  }
0802721e    uint32_t beep_enabled_get()
0802721e  {
08027222      return (uint32_t)beepbeep;
0802721e  }
08027224    int32_t sub_8027224(char arg1, char arg2, int32_t arg3, uint32_t arg4)
08027224  {
0802722c      uint32_t r5 = arg4;
08027234      uint32_t r7 = 0x3e8 / (arg3 << 1);
08027238      int32_t r8 = 0;
08027238      
08027274      while ((uint32_t)(uint8_t)r8 < (uint32_t)arg1)
08027274      {
0802723e          uint32_t r5_1 = (uint32_t)(uint8_t)r5;
0802723e          
08027242          if (r5_1 == 1)
08027244              sub_802c036();
08027244          
08027248          sub_802717c();
0802724e          rtos_delay_ticks(r7);
08027252          r5 = (uint32_t)(uint8_t)r5_1;
08027252          
08027256          if (r5 == 1)
08027258              sub_802c06e();
08027258          
0802725c          sub_802718c();
08027262          rtos_delay_ticks(r7);
08027266          r8 += 1;
08027274      }
08027274      
0802727a      if ((uint32_t)arg2 != 1)
08027282          return sub_802c06e();
08027282      
0802727c      return sub_802c036();
08027224  }
0802728a    int32_t sub_802728a(char arg1, char arg2, int32_t arg3, uint32_t arg4)
0802728a  {
08027292      uint32_t r5 = arg4;
0802729a      uint32_t r7 = 0x3e8 / (arg3 << 1);
0802729e      int32_t r8 = 0;
0802729e      
080272da      while ((uint32_t)(uint8_t)r8 < (uint32_t)arg1)
080272da      {
080272a4          uint32_t r5_1 = (uint32_t)(uint8_t)r5;
080272a4          
080272a8          if (r5_1 == 1)
080272aa              sub_802c052();
080272aa          
080272ae          sub_802717c();
080272b4          rtos_delay_ticks(r7);
080272b8          r5 = (uint32_t)(uint8_t)r5_1;
080272b8          
080272bc          if (r5 == 1)
080272be              sub_802c06e();
080272be          
080272c2          sub_802718c();
080272c8          rtos_delay_ticks(r7);
080272cc          r8 += 1;
080272da      }
080272da      
080272e0      if ((uint32_t)arg2 != 1)
080272e8          return sub_802c06e();
080272e8      
080272e2      return sub_802c052();
0802728a  }
080272f0    int32_t buzzer_set_tone(int32_t toneId, int32_t channel)
080272f0  {
080272f0      int32_t r3;
080272f0      int32_t var_10 = r3;
080272f2      char r4 = 0;
080272f6      data_2000e384 = toneId;
080272f6      
080272fa      if (!channel)
080272fc          return 0;
080272fc      
08027304      uint32_t r5_1 = 0x3e8 / channel;
08027304      
08027320      while (true)
08027320      {
08027320          uint32_t r4_1 = (uint32_t)r4;
08027320          
08027328          if (r4_1 >= data_2000e384)
08027328              break;
08027328          
0802730a          r4 = (uint8_t)r4_1 + 1;
0802730c          sub_802717c();
08027312          rtos_delay_ticks(r5_1 >> 1);
08027316          sub_802718c();
0802731c          rtos_delay_ticks(r5_1 >> 1);
08027320      }
08027320      
0802732a      return 1;
080272f0  }
0802732e    int32_t buzzer_beep(uint8_t toneId, uint8_t channel, uint16_t durationTicks)
0802732e  {
0802732e      int32_t r3;
0802732e      int32_t var_10 = r3;
08027336      uint32_t toneId_1 = (uint32_t)toneId;
0802733a      buzzer_set_tone(toneId_1, (uint32_t)channel);
08027346      data_2000e45a += 1;
08027346      
08027350      if ((uint32_t)(uint8_t)durationTicks < (uint32_t)data_2000e45a)
08027350      {
08027352          uint32_t r4_1 = (uint32_t)(uint8_t)toneId_1;
08027352          
08027356          if (r4_1 != 1)
08027356          {
08027366              uint32_t r4_2 = (uint32_t)(uint8_t)r4_1;
08027366              
0802736a              if (r4_2 != 9)
0802736a              {
0802737a                  uint32_t r4_3 = (uint32_t)(uint8_t)r4_2;
0802737a                  
0802737e                  if (r4_3 != 3)
0802737e                  {
0802738e                      uint32_t r4_4 = (uint32_t)(uint8_t)r4_3;
0802738e                      
08027392                      if (r4_4 != 8)
08027392                      {
080273a2                          uint32_t r4_5 = (uint32_t)(uint8_t)r4_4;
080273a2                          
080273a6                          if (r4_5 != 7)
080273a6                          {
080273b6                              uint32_t r4_6 = (uint32_t)(uint8_t)r4_5;
080273b6                              
080273ba                              if (r4_6 == 2)
080273c6                                  beep_event_flags &= 0xffffffdf;
080273ba                              else if ((uint32_t)(uint8_t)r4_6 == 5)
080273da                                  beep_event_flags &= 0xffffffbf;
080273a6                          }
080273a6                          else
080273b2                              beep_event_flags &= 0xffffffef;
08027392                      }
08027392                      else
0802739e                          beep_event_flags &= 0xfffffff7;
0802737e                  }
0802737e                  else
0802738a                      beep_event_flags &= 0xfffffffb;
0802736a              }
0802736a              else
08027376                  beep_event_flags &= 0xfffffffd;
08027356          }
08027356          else
08027362              beep_event_flags = beep_event_flags >> 1 << 1;
08027362          
080273e0          data_2000e45a = 0;
08027350      }
08027350      
080273e4      return 1;
0802732e  }
080273e6                    00 00                                                                                ..
080273e8  int32_t data_80273e8 = 0x2000e380
080273ec  int32_t data_80273ec = 0x40021000
080273f0  int32_t data_80273f0 = 0x803bfb4
080273f4  int32_t data_80273f4 = 0x8027041
080273f8  int32_t data_80273f8 = 0x2000e45a
080273fc  int32_t data_80273fc = 0x2000e384
08027400  int32_t data_8027400 = 0x2000e459
08027404    int32_t sub_8027404(int32_t arg1 @ r7)
08027404  {
0802740a      rcc_enable_by_code(0xc01);
08027416      sub_80304da(&GPIOB, 4, 0x40);
08027422      sub_80304da(&GPIOB, 4, 0x80);
08027430      gpio_config_mode_pull(&GPIOB, 2, 1, 0x40);
0802743e      gpio_config_otype_speed(&GPIOB, 1, 2, 0x40);
0802744c      gpio_config_mode_pull(&GPIOB, 2, 1, 0x80);
0802745a      gpio_config_otype_speed(&GPIOB, 1, 2, 0x80);
08027462      rcc_enable_by_code(0x1015);
08027470      sub_8031638(&data_40005400, 0x186a0, 0);
0802747e      sub_803172c(&data_40005400, 0, 0, 0xa0);
08027486      sub_8031792(&data_40005400);
08027490      sub_8031746(&data_40005400, 1);
08027494      return arg1;
08027404  }
08027496    int32_t sub_8027496(int32_t arg1, char arg2, char* arg3, int32_t arg4)
08027496  {
08027496      int32_t var_18 = arg4;
0802749c      char* r6 = arg3;
0802749e      int32_t r7 = arg4;
080274b0      uint32_t i;
080274b0      
080274b0      do
080274aa          i = sub_80317c0(&data_40005400, 0x80000002);
080274b0       while (i);
080274b6      sub_803179c(&data_40005400);
080274c6      uint32_t i_1;
080274c6      
080274c6      do
080274c0          i_1 = sub_80317c0(&data_40005400, 1);
080274c6       while (!i_1);
080274d4      sub_803177a(&data_40005400, (char)(arg1 << 1), 0xfffffffe);
080274e4      uint32_t i_2;
080274e4      
080274e4      do
080274de          i_2 = sub_80317c0(&data_40005400, 2);
080274e4       while (!i_2);
080274ec      sub_80317f6(&data_40005400, 2);
080274fc      uint32_t i_3;
080274fc      
080274fc      do
080274f6          i_3 = sub_80317c0(&data_40005400, 0x80);
080274fc       while (i_3 != 1);
08027506      sub_80317b0(&data_40005400, arg2);
08027516      uint32_t i_4;
08027516      
08027516      do
08027510          i_4 = sub_80317c0(&data_40005400, 4);
08027516       while (!i_4);
08027516      
08027518      while (true)
08027518      {
08027518          int32_t r0 = r7;
0802751a          r7 = r0 - 1;
0802751a          
0802751e          if (!r0)
0802751e              break;
0802751e          
08027526          sub_80317b0(&data_40005400, *(uint8_t*)r6);
0802752a          r6 = &r6[1];
08027538          uint32_t i_5;
08027538          
08027538          do
08027532              i_5 = sub_80317c0(&data_40005400, 4);
08027538           while (!i_5);
08027518      }
08027518      
08027540      sub_80317a6(&data_40005400);
08027540      
0802754a      while (data_40005400 << 0x16 < 0)
0802754a          /* nop */
0802754a      
08027550      return 1;
08027496  }
08027552    int32_t sub_8027552(int32_t arg1, char arg2, char* arg3, int32_t arg4)
08027552  {
0802755a      char* r6 = arg3;
0802755c      int32_t i = arg4;
0802755e      int32_t r8 = 0x2ff;
08027562      char r4_1 = (char)(arg1 << 1);
08027562      
0802756c      while (true)
0802756c      {
0802756c          uint32_t r0;
0802756c          int32_t r2;
0802756c          r0 = sub_80317c0(&data_40005400, 0x80000002);
0802756c          
08027572          if (!r0)
08027572              break;
08027572          
08027574          int32_t r0_1 = r8;
08027576          r8 = r0_1 - 1;
08027576          
0802757c          if (!r0_1)
0802757c          {
08027582              sub_80280a0(0x5ff, 0x80000002, r2, arg4);
08027586              return 0;
0802757c          }
0802756c      }
0802756c      
0802758c      if (i == 2)
08027594          sub_8031760(&data_40005400, 0);
08027594      
0802759c      sub_803179c(&data_40005400);
080275a0      int32_t r8_1 = 0x2ff;
080275a0      
080275aa      while (true)
080275aa      {
080275aa          uint32_t r0_3;
080275aa          int32_t r2_1;
080275aa          r0_3 = sub_80317c0(&data_40005400, 1);
080275aa          
080275b0          if (r0_3)
080275b0              break;
080275b0          
080275b2          int32_t r0_4 = r8_1;
080275b4          r8_1 = r0_4 - 1;
080275b4          
080275ba          if (!r0_4)
080275ba          {
080275c0              sub_80280a0(0x5ff, 1, r2_1, arg4);
080275c4              return 0;
080275ba          }
080275aa      }
080275aa      
080275d4      sub_803177a(&data_40005400, r4_1, 0xfffffffe);
080275d8      int32_t r8_2 = 0x2ff;
080275d8      
080275e2      while (true)
080275e2      {
080275e2          uint32_t r0_5;
080275e2          int32_t r2_2;
080275e2          r0_5 = sub_80317c0(&data_40005400, 2);
080275e2          
080275e8          if (r0_5)
080275e8              break;
080275e8          
080275ea          int32_t r0_6 = r8_2;
080275ec          r8_2 = r0_6 - 1;
080275ec          
080275f2          if (!r0_6)
080275f2          {
080275f8              sub_80280a0(0x5ff, 2, r2_2, arg4);
080275fc              return 0;
080275f2          }
080275e2      }
080275e2      
08027606      sub_80317f6(&data_40005400, 2);
0802760a      int32_t r8_3 = 0x2ff;
0802760a      
08027614      while (true)
08027614      {
08027614          uint32_t r0_7;
08027614          int32_t r2_3;
08027614          r0_7 = sub_80317c0(&data_40005400, 0x80);
08027614          
0802761a          if (r0_7 == 1)
0802761a              break;
0802761a          
0802761c          int32_t r0_8 = r8_3;
0802761e          r8_3 = r0_8 - 1;
0802761e          
08027624          if (!r0_8)
08027624          {
0802762a              sub_80280a0(0x5ff, 0x80, r2_3, arg4);
0802762e              return 0;
08027624          }
08027614      }
08027614      
08027636      sub_8031792(&data_40005400);
08027642      sub_80317b0(&data_40005400, arg2);
08027646      int32_t r8_4 = 0x2ff;
08027646      
08027650      while (true)
08027650      {
08027650          uint32_t r0_9;
08027650          int32_t r2_4;
08027650          r0_9 = sub_80317c0(&data_40005400, 4);
08027650          
08027656          if (r0_9)
08027656              break;
08027656          
08027658          int32_t r0_10 = r8_4;
0802765a          r8_4 = r0_10 - 1;
0802765a          
08027660          if (!r0_10)
08027660          {
08027666              sub_80280a0(0x5ff, 4, r2_4, arg4);
0802766a              return 0;
08027660          }
08027650      }
08027650      
08027672      sub_803179c(&data_40005400);
08027676      int32_t r8_5 = 0x2ff;
08027676      
08027680      while (true)
08027680      {
08027680          uint32_t r0_11;
08027680          int32_t r2_5;
08027680          r0_11 = sub_80317c0(&data_40005400, 1);
08027680          
08027686          if (r0_11)
08027686              break;
08027686          
08027688          int32_t r0_12 = r8_5;
0802768a          r8_5 = r0_12 - 1;
0802768a          
08027690          if (!r0_12)
08027690          {
08027696              sub_80280a0(0x5ff, 1, r2_5, arg4);
0802769a              return 0;
08027690          }
08027680      }
08027680      
080276a8      sub_803177a(&data_40005400, r4_1, 1);
080276ac      int32_t r8_6 = 0x2ff;
080276ac      
080276b2      if (i < 3)
080276ba          sub_8031746(&data_40005400, 0);
080276ba      
080276c4      while (true)
080276c4      {
080276c4          uint32_t r0_13;
080276c4          int32_t r2_6;
080276c4          r0_13 = sub_80317c0(&data_40005400, 2);
080276c4          
080276ca          if (r0_13)
080276ca              break;
080276ca          
080276cc          int32_t r0_14 = r8_6;
080276ce          r8_6 = r0_14 - 1;
080276ce          
080276d4          if (!r0_14)
080276d4          {
080276da              sub_80280a0(0x5ff, 2, r2_6, arg4);
080276de              return 0;
080276d4          }
080276c4      }
080276c4      
080276e8      int32_t r1_6;
080276e8      int32_t r2_7;
080276e8      r1_6 = sub_80317f6(&data_40005400, 2);
080276e8      
080276ee      if (i == 1)
080276f4          r1_6 = sub_80317a6(&data_40005400);
080276f4      
08027720      while (i)
08027720      {
08027724          if (i == 3)
08027724          {
08027726              int32_t r8_7 = 0x5ff;
08027726              
08027730              while (true)
08027730              {
08027730                  uint32_t r0_17;
08027730                  int32_t r2_8;
08027730                  r0_17 = sub_80317c0(&data_40005400, 4);
08027730                  
08027736                  if (r0_17)
08027736                  {
08027754                      sub_8031746(&data_40005400, 0);
08027754                      break;
08027736                  }
08027736                  
08027738                  int32_t r0_18 = r8_7;
0802773a                  r8_7 = r0_18 - 1;
0802773a                  
08027740                  if (!r0_18)
08027740                  {
08027746                      sub_80280a0(0x5ff, 4, r2_8, arg4);
0802774a                      return 0;
08027740                  }
08027730              }
08027724          }
08027724          
0802775a          if (i == 2)
0802775a          {
0802775c              int32_t r8_8 = 0x5ff;
0802775c              
08027766              while (true)
08027766              {
08027766                  uint32_t r0_19;
08027766                  int32_t r2_9;
08027766                  r0_19 = sub_80317c0(&data_40005400, 4);
08027766                  
0802776c                  if (r0_19)
0802776c                  {
080276fe                      sub_80317a6(&data_40005400);
080276fe                      break;
0802776c                  }
0802776c                  
0802776e                  int32_t r0_20 = r8_8;
08027770                  r8_8 = r0_20 - 1;
08027770                  
08027776                  if (!r0_20)
08027776                  {
0802777c                      sub_80280a0(0x5ff, 4, r2_9, arg4);
08027780                      return 0;
08027776                  }
08027766              }
0802775a          }
0802775a          
08027702          r1_6 = 0x40;
08027708          uint32_t r0_15;
08027708          r0_15 = sub_80317c0(&data_40005400, 0x40);
08027708          
0802770e          if (r0_15)
0802770e          {
08027718              *(uint8_t*)r6 = sub_80317b8(&data_40005400);
0802771a              r6 = &r6[1];
0802771c              i -= 1;
0802770e          }
08027720      }
08027720      
08027784      int32_t i_2 = 0x2ff;
0802779a      int32_t i_1;
0802779a      
0802779a      do
0802779a      {
08027790          if (data_40005400 << 0x16 >= 0)
08027790          {
080277ae              sub_8031746(&data_40005400, 1);
080277b8              sub_8031760(&data_40005400, 1);
080277bc              return 1;
08027790          }
08027790          
08027792          i_1 = i_2;
08027794          i_2 = i_1 - 1;
0802779a      } while (i_1);
080277a0      sub_80280a0(0x5ff, r1_6, r2_7, arg4);
080277a4      return 0;
08027552  }
080277c2    uint32_t sub_80277c2()
080277c2  {
080277cc      int16_t var_e = 0x1312;
080277d2      char var_10 = 0;
080277d8      int32_t r7;
080277d8      sub_8027404(r7);
080277dc      char r4 = 0;
080277dc      
080277e2      while (true)
080277e2      {
080277e2          uint32_t r4_1 = (uint32_t)r4;
080277e2          
080277e6          if (r4_1 >= 2)
080277e6              break;
080277e6          
080277ea          var_10 = 0;
080277f2          uint32_t r4_2 = (uint32_t)(uint8_t)r4_1;
080277fa          data_2000e084 = *(uint8_t*)(&var_e + r4_2);
080277fa          
08027808          if (!sub_8027e94(0, &var_10, 1))
08027810              sub_8027e94(0, &var_10, 1);
08027810          
08027820          data_2000e085 = var_10 >> 4;
08027820          
0802782a          if ((uint32_t)data_2000e085 == 9)
0802782a              break;
0802782a          
080277e0          r4 = (uint8_t)r4_2 + 1;
080277e2      }
080277e2      
08027834      char r0_8;
08027834      
08027834      if ((uint32_t)data_2000e085 != 9)
0802783c          r0_8 = 0;
08027834      else
08027836          r0_8 = sub_8027ec4();
08027836      
08027840      return (uint32_t)r0_8;
080277c2  }
08027842        00 00                                                                                        ..
08027844    int32_t sub_8027844(int32_t arg1, int32_t* arg2, int32_t* arg3, int128_t arg4 @ q4, dbl_bits arg5 @ q5)
08027844  {
08027844      int32_t r3;
08027844      int32_t var_18 = r3;
08027846      dbl_bits var_20;
08027846      var_20.lo = (uint32_t)arg4;
08027846      var_20.hi = *(uint32_t*)((char*)arg4)[4];
08027846      dbl_bits b;
08027846      b.lo = *(uint32_t*)((char*)arg4)[8];
08027846      b.hi = *(uint32_t*)((char*)arg4)[0xc];
08027846      dbl_bits a;
08027846      a.lo = arg5.lo;
08027846      a.hi = arg5.hi;
0802784a      int32_t r4 = arg1;
08027850      arg5.lo = 0;
08027854      *(uint32_t*)((char*)arg4)[8] = 0;
08027858      *(uint32_t*)((char*)arg4)[0xc] = 0;
0802785c      char r7 = 0;
0802785c      
0802789e      while (true)
0802789e      {
0802789e          uint32_t r7_1 = (uint32_t)r7;
080278a2          int32_t result;
080278a2          int96_t q0;
080278a2          
080278a2          if (r7_1 >= 5)
080278a2          {
080278b0              (uint32_t)q0 = 0x40a00000;
080278b4              (uint32_t)q0 = arg5.lo / 5f;
080278bc              *(uint32_t*)((char*)q0)[4] = data_2000e088;
080278c0              *(uint32_t*)((char*)q0)[4] = (float)*(uint32_t*)((char*)q0)[4];
080278c8              *(uint32_t*)((char*)q0)[8] = data_2000e288;
080278cc              *(uint32_t*)((char*)q0)[4] =
080278cc                  *(uint32_t*)((char*)q0)[4] * *(uint32_t*)((char*)q0)[8];
080278d0              *(uint32_t*)((char*)q0)[8] = 0x411ce80a;
080278d4              *(uint32_t*)((char*)q0)[4] = *(uint32_t*)((char*)q0)[4] / 9.80665016f;
080278d8              (uint32_t)q0 = 9.80665016f + *(uint32_t*)((char*)q0)[4];
080278dc              arg5.lo = -((uint32_t)q0);
080278e0              (uint32_t)q0 = 0x40a00000;
080278e4              (uint32_t)q0 = *(uint32_t*)((char*)arg4)[8] / 5f;
080278ec              *(uint32_t*)((char*)q0)[4] = data_2000e088;
080278f0              *(uint32_t*)((char*)q0)[4] = (float)*(uint32_t*)((char*)q0)[4];
080278f8              *(uint32_t*)((char*)q0)[8] = data_2000e28c;
080278fc              *(uint32_t*)((char*)q0)[4] =
080278fc                  *(uint32_t*)((char*)q0)[4] * *(uint32_t*)((char*)q0)[8];
08027900              *(uint32_t*)((char*)q0)[8] = 0x411ce80a;
08027904              *(uint32_t*)((char*)q0)[4] = *(uint32_t*)((char*)q0)[4] / 9.80665016f;
08027908              (uint32_t)q0 = 9.80665016f + *(uint32_t*)((char*)q0)[4];
0802790c              *(uint32_t*)((char*)arg4)[8] = -((uint32_t)q0);
08027910              (uint32_t)q0 = 0x40a00000;
08027914              (uint32_t)q0 = *(uint32_t*)((char*)arg4)[0xc] / 5f;
0802791c              *(uint32_t*)((char*)q0)[4] = data_2000e088;
08027920              *(uint32_t*)((char*)q0)[4] = (float)*(uint32_t*)((char*)q0)[4];
08027928              *(uint32_t*)((char*)q0)[8] = data_2000e290;
0802792c              *(uint32_t*)((char*)q0)[4] =
0802792c                  *(uint32_t*)((char*)q0)[4] * *(uint32_t*)((char*)q0)[8];
08027930              *(uint32_t*)((char*)q0)[8] = 0x411ce80a;
08027934              *(uint32_t*)((char*)q0)[4] = *(uint32_t*)((char*)q0)[4] / 9.80665016f;
08027938              *(uint32_t*)((char*)arg4)[0xc] = 9.80665016f + *(uint32_t*)((char*)q0)[4];
0802793c              (uint32_t)q0 = *(uint32_t*)((char*)arg4)[8] * *(uint32_t*)((char*)arg4)[8];
08027940              /* unimplemented  {vmla.f32.F32 s0, s20, s20} */
08027948              int32_t r0_4;
08027948              int32_t r1;
08027948              r0_4 = float32_process((uint32_t)q0);
0802794c              (uint64_t)q0 = (r1 << 32) | r0_4;
08027950              int128_t q0_1 = sub_8031818((uint64_t)q0);
08027954              (uint32_t)arg4 = (uint32_t)q0_1;
08027958              *(uint32_t*)((char*)arg4)[4] = *(uint32_t*)((char*)q0_1)[4];
08027960              int32_t r0_6;
08027960              int32_t r1_1;
08027960              r0_6 = float32_process(*(uint32_t*)((char*)arg4)[0xc]);
08027964              *(uint64_t*)((char*)q0_1)[8] = (r1_1 << 32) | r0_6;
08027968              (uint32_t)q0_1 = (uint32_t)arg4;
0802796c              *(uint32_t*)((char*)q0_1)[4] = *(uint32_t*)((char*)arg4)[4];
08027970              int64_t q0_2;
08027970              int96_t q4;
08027970              q0_2 = sub_80319f8(r7_1, q0_1);
08027980              soft_dadd(a, b);
0802798a              int32_t r0_8;
0802798a              int32_t r1_3;
0802798a              r0_8 = soft_dmul();
08027992              *(uint32_t*)r4 = sub_802ead0(r0_8, r1_3);
08027994              (uint32_t)q0_2 = *(uint32_t*)((char*)q4)[8] * *(uint32_t*)((char*)q4)[8];
08027998              /* unimplemented  {vmla.f32.F32 s0, s19, s19} */
080279a0              int32_t r0_11;
080279a0              int32_t r1_4;
080279a0              r0_11 = float32_process((uint32_t)q0_2);
080279a8              int64_t q0_3 = sub_8031818();
080279ac              (uint32_t)q4 = (uint32_t)q0_3;
080279b0              *(uint32_t*)((char*)q4)[4] = *(uint32_t*)((char*)q0_3)[4];
080279b8              float32_process(arg5.lo);
080279c0              int32_t r0_13;
080279c0              int32_t r1_5;
080279c0              r0_13 = soft_dadd();
080279c8              int64_t q0_4;
080279c8              int128_t q4_1;
080279c8              q0_4 = sub_8031ab8(r7_1, );
080279d6              soft_dmul();
080279e2              int32_t r0_15;
080279e2              int32_t r1_7;
080279e2              r0_15 = soft_dadd();
080279ea              *(uint32_t*)arg3 = sub_802ead0(r0_15, r1_7);
080279ec              (uint32_t)q0_4 =
080279ec                  *(uint32_t*)((char*)q4_1)[0xc] * *(uint32_t*)((char*)q4_1)[0xc];
080279f0              /* unimplemented  {vmla.f32.F32 s0, s20, s20} */
080279f8              int32_t r0_18;
080279f8              int32_t r1_8;
080279f8              r0_18 = float32_process((uint32_t)q0_4);
08027a00              int64_t q0_5 = sub_8031818();
08027a04              (uint32_t)q4_1 = (uint32_t)q0_5;
08027a08              *(uint32_t*)((char*)q4_1)[4] = *(uint32_t*)((char*)q0_5)[4];
08027a10              float32_process(*(uint32_t*)((char*)q4_1)[8]);
08027a18              int32_t r0_20;
08027a18              int32_t r1_9;
08027a18              r0_20 = soft_dadd();
08027a20              int64_t q0_6;
08027a20              q0_6 = sub_8031ab8(r7_1, );
08027a2e              soft_dmul();
08027a3a              int32_t r0_22;
08027a3a              int32_t r1_11;
08027a3a              r0_22 = soft_dadd();
08027a42              *(uint32_t*)arg2 = sub_802ead0(r0_22, r1_11);
08027a44              result = 1;
08027a46          label_8027a46:
08027a46              (uint32_t)arg4 = a.lo;
08027a46              *(uint32_t*)((char*)arg4)[4] = a.hi;
08027a46              *(uint32_t*)((char*)arg4)[8] = b.lo;
08027a46              *(uint32_t*)((char*)arg4)[0xc] = b.hi;
08027a46              arg5.lo = var_20.lo;
08027a46              arg5.hi = var_20.hi;
08027a4a              return result;
080278a2          }
080278a2          
080278a4          int32_t r0_2;
080278a4          r0_2 = sub_8027d7c(arg1);
080278a4          
080278aa          if (!r0_2)
080278aa          {
080278ac              result = 0;
080278ae              goto label_8027a46;
080278aa          }
080278aa          
08027868          (uint32_t)q0 = (int32_t)data_2000e094;
0802786c          (uint32_t)q0 = (float)(uint32_t)q0;
08027870          arg5.lo = (uint32_t)q0 + arg5.lo;
0802787c          (uint32_t)q0 = (int32_t)data_2000e096;
08027880          (uint32_t)q0 = (float)(uint32_t)q0;
08027884          *(uint32_t*)((char*)arg4)[8] = (uint32_t)q0 + *(uint32_t*)((char*)arg4)[8];
0802788c          arg1 = (int32_t)data_2000e098;
08027890          (uint32_t)q0 = arg1;
08027894          (uint32_t)q0 = (float)(uint32_t)q0;
08027898          *(uint32_t*)((char*)arg4)[0xc] = (uint32_t)q0 + *(uint32_t*)((char*)arg4)[0xc];
0802789c          r7 = (uint8_t)r7_1 + 1;
0802789e      }
08027844  }
08027a4c  int32_t data_8027a4c = 0x0
08027a50    int32_t sub_8027a50(int32_t arg1)
08027a50  {
08027a54      int16_t r5 = 0;
08027a5c      void* r0 = rtos_delay_ticks(0x1f4);
08027a5c      
08027a62      while (true)
08027a62      {
08027a62          int32_t r0_1;
08027a62          int64_t q0_1;
08027a62          r0_1 = sub_8027d7c(r0);
08027a62          
08027a68          if (!r0_1)
08027a6a              return 0;
08027a6a          
08027a74          int32_t r1_1;
08027a74          r0 = float32_process(data_2000e09c);
08027a78          int32_t r1_2 = r1_1 & 0x7fffffff;
08027a84          sub_8031ac8(r0, r1_2, 0xd9d7bdbb, 0x3ddb7cdf);
08027a84          
08027a88          if (r1_2 < 0)
08027a88          {
08027a90              int32_t r1_3;
08027a90              r0 = float32_process(data_2000e0a0);
08027a94              int32_t r1_4 = r1_3 & 0x7fffffff;
08027aa0              sub_8031ac8(r0, r1_4, 0xd9d7bdbb, 0x3ddb7cdf);
08027aa0              
08027aa4              if (r1_4 < 0)
08027aa4              {
08027aac                  int32_t r1_5;
08027aac                  r0 = float32_process(data_2000e0a4);
08027ab0                  int32_t r1_6 = r1_5 & 0x7fffffff;
08027abc                  sub_8031ac8(r0, r1_6, 0xd9d7bdbb, 0x3ddb7cdf);
08027abc                  
08027ac0                  if (r1_6 < 0)
08027ac0                      continue;
08027aa4              }
08027a88          }
08027a88          
08027ac2          uint32_t r5_1 = (uint32_t)r5;
08027ac2          
08027ac6          if (r5_1)
08027ac6          {
08027ada              uint32_t r5_2 = (uint32_t)(uint16_t)r5_1;
08027ada              
08027ae0              if (r5_2 >= 0x190)
08027ae0              {
08027b5e                  uint32_t r5_3 = (uint32_t)(uint16_t)r5_2;
08027b5e                  
08027b64                  if (r5_3 != 0x190)
08027b64                      break;
08027b64                  
08027b66                  char r6_9 = 0;
08027b66                  
08027ba0                  while (true)
08027ba0                  {
08027ba0                      uint32_t r6_12 = (uint32_t)r6_9;
08027ba0                      
08027ba4                      if (r6_12 >= 3)
08027ba4                          break;
08027ba4                      
08027b6a                      r5_3 = (uint32_t)(uint16_t)r5_3;
08027b6e                      (uint32_t)q0_1 = r5_3 - 1;
08027b72                      (uint32_t)q0_1 = (float)(uint32_t)q0_1;
08027b7a                      uint32_t r6_10 = (uint32_t)(uint8_t)r6_12;
08027b80                      *(uint32_t*)((char*)q0_1)[4] =
08027b80                          *(uint32_t*)(0x2000e294 + (r6_10 << 2));
08027b84                      (uint32_t)q0_1 = *(uint32_t*)((char*)q0_1)[4] / (uint32_t)q0_1;
08027b8c                      int32_t r0_13;
08027b8c                      int32_t r1_7;
08027b8c                      r0_13 = float32_process((uint32_t)q0_1);
08027b94                      r0 = sub_802ead0(r0_13, r1_7 ^ 0x80000000);
08027b98                      uint32_t r6_11 = (uint32_t)(uint8_t)r6_10;
08027b9a                      *(uint32_t*)(arg1 + (r6_11 << 2)) = r0;
08027b9e                      r6_9 = (uint8_t)r6_11 + 1;
08027ba0                  }
08027ba0                  
08027ba6                  r5 = (uint16_t)r5_3 + 1;
08027ae0              }
08027ae0              else
08027ae0              {
08027ae2                  char r6_1 = 0;
08027ae2                  
08027b16                  while (true)
08027b16                  {
08027b16                      uint32_t r6_5 = (uint32_t)r6_1;
08027b16                      
08027b1a                      if (r6_5 >= 3)
08027b1a                          break;
08027b1a                      
08027b1c                      uint32_t r6_6 = (uint32_t)(uint8_t)r6_5;
08027b20                      uint32_t r6_4;
08027b20                      
08027b20                      if (r6_6 != 2)
08027b20                      {
08027aea                          uint32_t r6_2 = (uint32_t)(uint8_t)r6_6;
08027af0                          (uint32_t)q0_1 = *(uint32_t*)(0x2000e294 + (r6_2 << 2));
08027af8                          uint32_t r6_3 = (uint32_t)(uint8_t)r6_2;
08027afe                          *(uint32_t*)((char*)q0_1)[4] = (&data_2000e09c)[r6_3];
08027b02                          (uint32_t)q0_1 = (uint32_t)q0_1 + *(uint32_t*)((char*)q0_1)[4];
08027b0a                          r6_4 = (uint32_t)(uint8_t)r6_3;
08027b0c                          r0 = 0x2000e294 + (r6_4 << 2);
08027b10                          *(uint32_t*)r0 = (uint32_t)q0_1;
08027b20                      }
08027b20                      else
08027b20                      {
08027b26                          uint32_t r6_7 = (uint32_t)(uint8_t)r6_6;
08027b2c                          (uint32_t)q0_1 = (&data_2000e09c)[r6_7];
08027b30                          *(uint32_t*)((char*)q0_1)[4] = 0xc11ce80a;
08027b34                          (uint32_t)q0_1 = (uint32_t)q0_1 + -9.80665016f;
08027b3c                          uint32_t r6_8 = (uint32_t)(uint8_t)r6_7;
08027b42                          *(uint32_t*)((char*)q0_1)[4] =
08027b42                              *(uint32_t*)(0x2000e294 + (r6_8 << 2));
08027b46                          (uint32_t)q0_1 = (uint32_t)q0_1 + *(uint32_t*)((char*)q0_1)[4];
08027b4e                          r6_4 = (uint32_t)(uint8_t)r6_8;
08027b50                          r0 = 0x2000e294 + (r6_4 << 2);
08027b54                          *(uint32_t*)r0 = (uint32_t)q0_1;
08027b20                      }
08027b20                      
08027b14                      r6_1 = (uint8_t)r6_4 + 1;
08027b16                  }
08027b16                  
08027b5a                  r5 = (uint16_t)r5_2 + 1;
08027ae0              }
08027ac6          }
08027ac6          else
08027ac6          {
08027ad2              r0 = memset16x2(0x2000e294, 0xc, 0);
08027ad6              r5 = (uint16_t)r5_1 + 1;
08027ac6          }
08027a62      }
08027a62      
08027baa      return 1;
08027a50  }
08027bae    int32_t sub_8027bae(int32_t* arg1)
08027bae  {
08027bb4      data_2000e288 = *(uint32_t*)arg1;
08027bbc      data_2000e28c = arg1[1];
08027bc2      int32_t result = arg1[2];
08027bc4      data_2000e290 = result;
08027bc6      return result;
08027bae  }
08027bc8  int32_t data_8027bc8 = 0x411ce80a
08027bcc    int32_t sub_8027bcc(int32_t* arg1, int32_t* arg2, int32_t* arg3)
08027bcc  {
08027bd4      int32_t r0;
08027bd4      int96_t q0;
08027bd4      r0 = sub_8027d7c(arg1);
08027bd4      
08027bda      if (!r0)
08027bdc          return 0;
08027bdc      
08027be8      (uint32_t)q0 = (int32_t)data_2000e094;
08027bec      (uint32_t)q0 = (float)(uint32_t)q0;
08027bf4      *(uint32_t*)((char*)q0)[4] = data_2000e088;
08027bf8      *(uint32_t*)((char*)q0)[4] = (float)*(uint32_t*)((char*)q0)[4];
08027c00      *(uint32_t*)((char*)q0)[8] = data_2000e288;
08027c04      *(uint32_t*)((char*)q0)[4] = *(uint32_t*)((char*)q0)[4] * *(uint32_t*)((char*)q0)[8];
08027c08      *(uint32_t*)((char*)q0)[8] = 0x411ce80a;
08027c0c      *(uint32_t*)((char*)q0)[4] = *(uint32_t*)((char*)q0)[4] / 9.80665016f;
08027c10      (uint32_t)q0 = 9.80665016f + *(uint32_t*)((char*)q0)[4];
08027c14      *(uint32_t*)arg1 = (uint32_t)q0;
08027c20      (uint32_t)q0 = (int32_t)data_2000e096;
08027c24      (uint32_t)q0 = (float)(uint32_t)q0;
08027c2c      *(uint32_t*)((char*)q0)[4] = data_2000e088;
08027c30      *(uint32_t*)((char*)q0)[4] = (float)*(uint32_t*)((char*)q0)[4];
08027c38      *(uint32_t*)((char*)q0)[8] = data_2000e28c;
08027c3c      *(uint32_t*)((char*)q0)[4] = *(uint32_t*)((char*)q0)[4] * *(uint32_t*)((char*)q0)[8];
08027c40      *(uint32_t*)((char*)q0)[8] = 0x411ce80a;
08027c44      *(uint32_t*)((char*)q0)[4] = *(uint32_t*)((char*)q0)[4] / 9.80665016f;
08027c48      (uint32_t)q0 = 9.80665016f + *(uint32_t*)((char*)q0)[4];
08027c4c      *(uint32_t*)arg2 = (uint32_t)q0;
08027c58      (uint32_t)q0 = (int32_t)data_2000e098;
08027c5c      (uint32_t)q0 = (float)(uint32_t)q0;
08027c64      *(uint32_t*)((char*)q0)[4] = data_2000e088;
08027c68      *(uint32_t*)((char*)q0)[4] = (float)*(uint32_t*)((char*)q0)[4];
08027c70      *(uint32_t*)((char*)q0)[8] = data_2000e290;
08027c74      *(uint32_t*)((char*)q0)[4] = *(uint32_t*)((char*)q0)[4] * *(uint32_t*)((char*)q0)[8];
08027c78      *(uint32_t*)((char*)q0)[8] = 0x411ce80a;
08027c7c      *(uint32_t*)((char*)q0)[4] = *(uint32_t*)((char*)q0)[4] / 9.80665016f;
08027c80      (uint32_t)q0 = 9.80665016f + *(uint32_t*)((char*)q0)[4];
08027c84      *(uint32_t*)arg3 = (uint32_t)q0;
08027c88      return 1;
08027bcc  }
08027c8c    int32_t sub_8027c8c(int32_t* arg1, int128_t arg2 @ q4)
08027c8c  {
08027c8e      int64_t var_10 = (uint64_t)arg2;
08027c8e      int64_t var_18 = *(uint64_t*)((char*)arg2)[8];
08027c92      (uint32_t)arg2 = 0xb5800000;
08027c96      *(uint32_t*)((char*)arg2)[4] = 0xb5800000;
08027c9a      *(uint32_t*)((char*)arg2)[8] = 0xb5800000;
08027c9e      char r4 = 0;
08027c9e      
08027cec      while (true)
08027cec      {
08027cec          uint32_t r4_1 = (uint32_t)r4;
08027cf0          int32_t result;
08027cf0          int64_t q0;
08027cf0          
08027cf0          if (r4_1 >= 5)
08027cf0          {
08027cfe              (uint32_t)q0 = 0x40a00000;
08027d02              (uint32_t)arg2 = (uint32_t)arg2 / 5f;
08027d06              (uint32_t)q0 = 0x40a00000;
08027d0a              *(uint32_t*)((char*)arg2)[4] = *(uint32_t*)((char*)arg2)[4] / 5f;
08027d0e              (uint32_t)q0 = 0x40a00000;
08027d12              (uint32_t)q0 = *(uint32_t*)((char*)arg2)[8] / 5f;
08027d16              *(uint32_t*)((char*)q0)[4] = 0xb51fc11c;
08027d1a              *(uint32_t*)((char*)arg2)[8] = (uint32_t)q0 + -5.95131269e-07f;
08027d22              int32_t r0_2;
08027d22              int32_t r1_1;
08027d22              r0_2 = float32_process((uint32_t)arg2);
08027d26              int32_t r1_2 = r1_1 & 0x7fffffff;
08027d32              sub_8031ac8(r0_2, r1_2, 0x9999999a, 0x3fc99999);
08027d32              
08027d36              if (r1_2 >= 0)
08027d70                  result = 0;
08027d36              else
08027d36              {
08027d3c                  int32_t r0_4;
08027d3c                  int32_t r1_3;
08027d3c                  r0_4 = float32_process(*(uint32_t*)((char*)arg2)[4]);
08027d40                  int32_t r1_4 = r1_3 & 0x7fffffff;
08027d4c                  sub_8031ac8(r0_4, r1_4, 0x9999999a, 0x3fc99999);
08027d4c                  
08027d50                  if (r1_4 >= 0)
08027d70                      result = 0;
08027d50                  else
08027d50                  {
08027d56                      int32_t r0_6;
08027d56                      int32_t r1_5;
08027d56                      r0_6 = float32_process(*(uint32_t*)((char*)arg2)[8]);
08027d5a                      int32_t r1_6 = r1_5 & 0x7fffffff;
08027d66                      sub_8031ac8(r0_6, r1_6, 0x9999999a, 0x3fc99999);
08027d66                      
08027d6a                      result = r1_6 >= 0 ? 0 : 1;
08027d50                  }
08027d36              }
08027d36              
08027d36              goto label_8027d72;
08027cf0          }
08027cf0          
08027cf2          int32_t r0;
08027cf2          r0 = sub_8027d7c(arg1);
08027cf2          
08027cf8          if (!r0)
08027cf8          {
08027cfa              result = 0;
08027d72          label_8027d72:
08027d72              (uint64_t)arg2 = var_18;
08027d72              *(uint64_t*)((char*)arg2)[8] = var_10;
08027d76              return result;
08027cf8          }
08027cf8          
08027ca6          (uint32_t)q0 = data_2000e09c;
08027cae          *(uint32_t*)((char*)q0)[4] = data_2000e288;
08027cb2          (uint32_t)q0 = (uint32_t)q0 + *(uint32_t*)((char*)q0)[4];
08027cb6          (uint32_t)arg2 = (uint32_t)q0 + (uint32_t)arg2;
08027cbe          (uint32_t)q0 = data_2000e0a0;
08027cc6          *(uint32_t*)((char*)q0)[4] = data_2000e28c;
08027cca          (uint32_t)q0 = (uint32_t)q0 + *(uint32_t*)((char*)q0)[4];
08027cce          *(uint32_t*)((char*)arg2)[4] = (uint32_t)q0 + *(uint32_t*)((char*)arg2)[4];
08027cd6          (uint32_t)q0 = data_2000e0a4;
08027cda          arg1 = &data_2000e288;
08027cde          *(uint32_t*)((char*)q0)[4] = data_2000e290;
08027ce2          (uint32_t)q0 = (uint32_t)q0 + *(uint32_t*)((char*)q0)[4];
08027ce6          *(uint32_t*)((char*)arg2)[8] = (uint32_t)q0 + *(uint32_t*)((char*)arg2)[8];
08027cea          r4 = (uint8_t)r4_1 + 1;
08027cec      }
08027c8c  }
08027d78  int32_t data_8027d78 = -0x3ee317f6
08027d7c    int32_t sub_8027d7c(int32_t arg1)
08027d7c  {
08027d7c      uint16_t r3;
08027d7c      uint16_t var_c = r3;
08027d7c      int32_t r2;
08027d7c      int32_t var_10 = r2;
08027d7c      int32_t r1;
08027d7c      int32_t var_14_1 = r1;
08027d7c      int32_t var_18 = arg1;
08027d84      var_18 = 0;
08027d84      int16_t var_14 = 0;
08027d8c      char r4 = 0;
08027d8c      
08027d92      while (true)
08027d92      {
08027d92          uint32_t r4_1 = (uint32_t)r4;
08027d96          int32_t r0_1;
08027d96          
08027d96          if (r4_1 < 0xa)
08027d9e              r0_1 = sub_8027e94(1, &var_18, 6);
08027d9e          
08027da4          if (r4_1 >= 0xa || r0_1)
08027da4          {
08027dc6              (uint16_t)var_10 = (uint16_t)(uint8_t)var_18
08027dc6                  | (int16_t)((uint32_t)*(uint8_t*)((char*)var_18)[1] << 8);
08027dd6              *(uint16_t*)((char*)var_10)[2] = (uint16_t)*(uint8_t*)((char*)var_18)[2]
08027dd6                  | (int16_t)((uint32_t)*(uint8_t*)((char*)var_18)[3] << 8);
08027df4              data_2000e094 = (uint16_t)var_10 >> 2;
08027e00              data_2000e096 = *(uint16_t*)((char*)var_10)[2] >> 2;
08027e0c              data_2000e098 = ((uint16_t)(uint8_t)var_14
08027e0c                  | (int16_t)((uint32_t)*(uint8_t*)((char*)var_14)[1] << 8)) >> 2;
08027e16              int64_t q0;
08027e16              (uint32_t)q0 = (int32_t)data_2000e094;
08027e1a              (uint32_t)q0 = (float)(uint32_t)q0;
08027e1e              *(uint32_t*)((char*)q0)[4] = 0xb580411c;
08027e22              (uint32_t)q0 = (uint32_t)q0 * -9.55569249e-07f;
08027e28              *(uint32_t*)((char*)q0)[4] = data_2000e088;
08027e2c              *(uint32_t*)((char*)q0)[4] = (float)*(uint32_t*)((char*)q0)[4];
08027e30              (uint32_t)q0 = (uint32_t)q0 / *(uint32_t*)((char*)q0)[4];
08027e36              data_2000e09c = (uint32_t)q0;
08027e40              (uint32_t)q0 = (int32_t)data_2000e096;
08027e44              (uint32_t)q0 = (float)(uint32_t)q0;
08027e48              *(uint32_t*)((char*)q0)[4] = 0x411ce80a;
08027e4c              (uint32_t)q0 = (uint32_t)q0 * 9.80665016f;
08027e52              *(uint32_t*)((char*)q0)[4] = data_2000e088;
08027e56              *(uint32_t*)((char*)q0)[4] = (float)*(uint32_t*)((char*)q0)[4];
08027e5a              (uint32_t)q0 = (uint32_t)q0 / *(uint32_t*)((char*)q0)[4];
08027e60              data_2000e0a0 = (uint32_t)q0;
08027e6a              (uint32_t)q0 = (int32_t)data_2000e098;
08027e6e              (uint32_t)q0 = (float)(uint32_t)q0;
08027e72              *(uint32_t*)((char*)q0)[4] = 0xb580411c;
08027e76              (uint32_t)q0 = (uint32_t)q0 * -9.55569249e-07f;
08027e7c              *(uint32_t*)((char*)q0)[4] = data_2000e088;
08027e80              *(uint32_t*)((char*)q0)[4] = (float)*(uint32_t*)((char*)q0)[4];
08027e84              (uint32_t)q0 = (uint32_t)q0 / *(uint32_t*)((char*)q0)[4];
08027e8a              data_2000e0a4 = (uint32_t)q0;
08027e8e              return 1;
08027da4          }
08027da4          
08027da6          uint32_t r4_2 = (uint32_t)(uint8_t)r4_1;
08027da6          
08027daa          if (r4_2 == 9)
08027daa              break;
08027daa          
08027d90          r4 = (uint8_t)r4_2 + 1;
08027d92      }
08027d92      
08027db2      int32_t r7;
08027db2      sub_802bd04(2, "read xyz read reg error!!!\n", r7);
08027db6      return 0;
08027d7c  }
08027e94    int32_t sub_8027e94(char arg1, char* arg2, int16_t arg3)
08027e94  {
08027e94      int32_t r7;
08027e94      int32_t var_8 = r7;
08027ea8      return sub_8027552((uint32_t)data_2000e084, arg1, arg2, (uint32_t)arg3);
08027e94  }
08027eaa    int32_t sub_8027eaa(char arg1)
08027eaa  {
08027ebc      int32_t __saved_r1;
08027ebc      return sub_8027496((uint32_t)data_2000e084, arg1, &__saved_r1, 1);
08027eaa  }
08027ebe                                                                                            00 00                                ..
08027ec0  int32_t data_8027ec0 = 0x411ce80a
08027ec4    int32_t sub_8027ec4()
08027ec4  {
08027ec4      int32_t r7;
08027ec4      int32_t var_8 = r7;
08027ec6      sub_8027f2a();
08027ece      sub_8027eaa(0x11);
08027ed6      sub_8027eaa(0x11);
08027ede      sub_8027eaa(0x4a);
08027ee6      sub_8027eaa(0x56);
08027eee      sub_8027eaa(0x5f);
08027efc      sub_8027eaa(0x5f);
08027f08      sub_8027f7e(4);
08027f0e      sub_8027fd4(0);
08027f14      sub_8027fe4(1);
08027f1e      sub_8027e94(9, &var_8, 4);
08027f22      sub_8028004();
08027f28      return 1;
08027ec4  }
08027f2a    int32_t sub_8027f2a()
08027f2a  {
08027f30      char var_10 = 0;
08027f3a      sub_8027eaa(0x36);
08027f48      sub_8027eaa(0x36);
08027f52      int32_t r4_1 = 0;
08027f52      
08027f78      do
08027f78      {
08027f5c          int32_t r0_1 = r4_1;
08027f5e          r4_1 = r0_1 + 1;
08027f5e          
08027f62          if (r0_1 >= 0x64)
08027f62              break;
08027f62          
08027f6a          sub_8027e94(0x33, &var_10, 1);
08027f78      } while (((uint32_t)var_10 & 5) != 5);
08027f78      
08027f7c      return 1;
08027f2a  }
08027f7e    int32_t sub_8027f7e(int32_t arg1)
08027f7e  {
08027f7e      int32_t r7;
08027f7e      int32_t var_8 = r7;
08027f7e      
08027f88      if (arg1 == 2)
08027f90          data_2000e088 = 0x800;
08027f88      else if (arg1 == 4)
08027f9e          data_2000e088 = 0x400;
08027f96      else if (arg1 == 8)
08027fac          data_2000e088 = 0x200;
08027fa4      else if (arg1 != 0xf)
08027fc4          data_2000e088 = 0x1000;
08027fb2      else
08027fba          data_2000e088 = 0x100;
08027fba      
08027fce      return sub_8027eaa(0xf);
08027f7e  }
08027fd0                                                  00 00                                                            ..
08027fd2  int32_t data_8027fd2 = -0x4a800000
08027fd4    int32_t sub_8027fd4(char arg1)
08027fd4  {
08027fd4      int32_t r7;
08027fd4      int32_t var_8 = r7;
08027fe2      return sub_8027eaa(0x10);
08027fd4  }
08027fe4    int32_t sub_8027fe4(int32_t arg1)
08027fe4  {
08027fe4      int32_t r7;
08027fe4      int32_t var_8 = r7;
08027ff4      return sub_8027eaa(0x11);
08027fe4  }
08028004    int32_t sub_8028004()
08028004  {
0802800a      char var_20 = 0;
08028016      char var_1c[0x14];
08028016      int32_t result = memcpy(&var_1c, 0x803bd60, 0x10);
08028016      
0802802e      for (int32_t i = 0; i < 0xe; i += 1)
08028026          result = sub_8027e94(var_1c[i], &var_20, 1);
08028026      
08028032      return result;
08028004  }
08028034  int32_t data_8028034 = 0x40020400
08028038    void sub_8028038(int32_t arg1) __pure
08028038  {
08028098      for (int32_t i = 0; i < arg1; i += 1)
08028098      {
08028092          for (int32_t j = 0; j < 0x3e8; j += 1)
08028092          {
08028092          }
08028098      }
08028038  }
080280a0    int32_t sub_80280a0(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
080280a0  {
080280a2      int32_t r4 = arg1;
080280a8      rcc_enable_by_code(0xc01);
080280b0      rcc_enable_by_code(0x1015);
080280b0      
080280ba      while (true)
080280ba      {
080280ba          sub_80304da(&GPIOB, 4, 0x40);
080280c4          sub_80304da(&GPIOB, 4, 0x80);
080280d0          gpio_config_mode_pull(&GPIOB, 2, 1, 0x40);
080280dc          gpio_config_otype_speed(&GPIOB, 1, 2, 0x40);
080280e8          gpio_config_mode_pull(&GPIOB, 2, 1, 0x80);
080280f4          gpio_config_otype_speed(&GPIOB, 1, 2, 0x80);
080280fc          sub_80304b2(&GPIOB, 0x40);
0802810a          sub_80304b2(&GPIOB, 0x80);
08028118          sub_80304ac(&GPIOB, 0x40);
08028126          sub_80304ac(&GPIOB, 0x80);
08028130          int32_t r0 = r4;
08028132          r4 = r0 - 1;
08028132          
08028136          if (!r0)
08028136              break;
08028136          
08028142          char r5_1;
08028142          
08028142          if (sub_80304ca(&GPIOB, 0x80))
08028148              r5_1 = 0;
08028142          else
08028144              r5_1 = 1;
08028144          
08028154          int32_t r0_3;
08028154          
08028154          if (sub_80304ca(&GPIOB, 0x40))
0802815a              r0_3 = 0;
08028154          else
08028156              r0_3 = 1;
08028156          
08028162          if (!((uint32_t)r5_1 & r0_3))
08028162          {
08028168              BN_CODE_start_0x80300a0_size_0x2(0x815);
08028170              sub_80300c8(0x815);
08028174              int32_t r7;
08028174              sub_8027404(r7);
08028174              break;
08028162          }
080280ba      }
080280ba      
08028178      return arg4;
080280a0  }
0802817a                                                                                00 00                                        ..
0802817c  int32_t data_802817c = 0x186a0
08028180  int32_t data_8028180 = 0x40005400
08028184  int32_t data_8028184 = -0x7ffffffe
08028188  int32_t data_8028188 = 0x80244ea
0802818c  int32_t data_802818c = 0x2000e084
08028190  int32_t data_8028190 = 0x2000e288
08028194  int32_t data_8028194 = 0x4d12d84a
08028198  int32_t data_8028198 = 0x400921fb
0802819c  int32_t data_802819c = 0x40668000
080281a0  int32_t data_80281a0 = -0x3f998000
080281a4  int32_t data_80281a4 = -0x26284245
080281a8  int32_t data_80281a8 = 0x3ddb7cdf
080281ac  int32_t data_80281ac = 0x2000e294
080281b0  int32_t data_80281b0 = -0x66666666
080281b4  int32_t data_80281b4 = 0x3fc99999
080281b8  int32_t data_80281b8 = 0x803b410
080281bc  int32_t data_80281bc = 0x803bd60
080281c0  int32_t data_80281c0 = 0x40020400
080281c4    int32_t sub_80281c4(int32_t arg1) __pure
080281c4  {
080281ca      int32_t i;
080281ca      
080281ca      do
080281ca      {
080281c4          i = arg1;
080281c6          arg1 = i - 1;
080281ca      } while (i);
080281cc      return arg1;
080281c4  }
080281ce                                            00 00                                                                ..
080281d0    int32_t moduleSensorInit()
080281d0  {
080281d4      sub_80277c2();
080281d8      sub_8028c74();
080281dc      cam_link_hw_init();
080281e6      data_2000e2c4 = 0;
080281ee      data_2000e2c6 = 0;
080281f6      data_2000e2c8 = 0;
080281fe      data_2000e2c8 = 0;
08028206      data_2000e2cc = 0;
08028210      data_2000e374 = 0x41b00000;
0802821a      data_2000e034 = 0x41b00000;
08028220      data_2000e034;
08028230      data_2000e038 = 0x40a00000 * 5f;
0802823c      data_2000e054 = 0x40000000;
08028242      data_2000e054;
08028252      data_2000e058 = 0x40a00000 * 5f;
0802825e      data_2000e03c = 0x41a00000;
08028264      data_2000e03c;
08028274      data_2000e040 = 0x40a00000 * 5f;
08028280      data_2000e044 = 0x40400000;
08028286      data_2000e044;
08028296      data_2000e048 = 0x41200000 * 10f;
080282b0      int32_t r2;
080282b0      int32_t r3;
080282b0      r2 = rtos_xTaskCreate(&*(int32_t*)((char*)data_802865e + 3), "SensorTask", 0x1f4, 
080282b0          nullptr, 5, nullptr);
080282ba      software_mutex(0, 0x1f4, r2, r3);
080282c0      return 1;
080281d0  }
080282c2    int32_t sub_80282c2(char arg1, char arg2)
080282c2  {
080282c6      if ((uint32_t)arg1)
080282cc          return data_2000e370;
080282cc      
080282d4      if (!(uint32_t)arg2)
080282de          return 0;
080282de      
080282da      return data_2000e36c;
080282c2  }
080282e2        00 00                                                                                        ..
080282e4    int32_t sub_80282e4(char arg1, char arg2, char arg3, int32_t arg4, int32_t arg5 @ r5)
080282e4  {
080282f0      int32_t r0 = TickType_t xTaskGetTickCount(void)();
080282f0      
08028302      if ((uint32_t)arg1 == (uint32_t)data_2000e2d0)
08028302      {
0802830c          int32_t r0_4;
0802830c          int32_t r1_1;
0802830c          r0_4 = sub_802e6b8(r0 / 0x3e8);
0802831a          float32_process(data_2000e2d4);
08028324          int32_t r0_6;
08028324          int32_t r1_2;
08028324          r0_6 = soft_dmul(arg4, arg5);
08028330          int32_t r0_8;
08028330          int32_t r1_4;
08028330          r0_8 = sub_802eb60(r0_4, r1_1, r0_6, r1_2);
08028338          int32_t r0_10 = sub_802ead0(r0_8, r1_4) & 0x7fffffff;
0802833c          int128_t q0;
0802833c          (uint32_t)q0 = r0_10;
08028340          *(uint32_t*)((char*)q0)[4] = 0x3f800001;
08028344          /* unimplemented  {vcmp.f32.F32 s0, s1} */
08028348          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08028348          
0802834c          if (r0_10 < 0)
0802834e              return 0;
08028302      }
08028302      
08028356      data_2000e2d0 = arg1;
0802835a      sub_802e6b8(r0);
08028364      soft_dadd(arg4, arg5);
0802836e      int32_t r0_13;
0802836e      int32_t r1_5;
0802836e      r0_13 = soft_dadd();
0802837a      data_2000e2d4 = sub_802ead0(r0_13, r1_5);
08028384      data_2000e2d8 = sub_8028bc6();
08028384      
0802838c      if ((uint32_t)arg3)
08028398          sub_8031c80(data_2000e36c, &data_2000e2d0);
08028398      
080283a0      if ((uint32_t)arg2)
080283ac          sub_8031c80(data_2000e370, &data_2000e2d0);
080283ac      
080283b0      return 1;
080282e4  }
080283b6    int32_t sub_80283b6(char arg1, char arg2)
080283b6  {
080283c4      void buf;
080283c4      j_sub_80168a8(&buf, 0xf0);
080283c4      
080283cc      if ((uint32_t)arg1)
080283cc      {
080283ce          char r5_1 = 0;
080283ce          
08028400          while (true)
08028400          {
08028400              uint32_t r5_3 = (uint32_t)r5_1;
08028400              
08028404              if (r5_3 >= 2)
08028404                  break;
08028404              
080283de              if (sub_8031d78(data_2000e370) != 1)
080283de              {
080283e2                  uint32_t r5_2 = (uint32_t)(uint8_t)r5_3;
080283ee                  r5_3 = (uint32_t)(uint8_t)r5_2;
080283fa                  sub_8031d88(data_2000e370, 1 - r5_3, &buf + 0xc * r5_2);
080283de              }
080283de              
080283fe              r5_1 = (uint8_t)r5_3 + 1;
08028400          }
08028400          
08028410          camera_link_send(0, 0x3000, 0x18, &buf);
080283cc      }
080283cc      
08028418      if ((uint32_t)arg2)
08028418      {
0802841a          char r5_4 = 0;
0802841a          
0802844c          while (true)
0802844c          {
0802844c              uint32_t r5_6 = (uint32_t)r5_4;
0802844c              
08028450              if (r5_6 >= 0x14)
08028450                  break;
08028450              
0802842a              if (sub_8031d78(data_2000e36c) != 1)
0802842a              {
0802842e                  uint32_t r5_5 = (uint32_t)(uint8_t)r5_6;
0802843a                  r5_6 = (uint32_t)(uint8_t)r5_5;
08028446                  sub_8031d88(data_2000e36c, 0x13 - r5_6, &buf + 0xc * r5_5);
0802842a              }
0802842a              
0802844a              r5_4 = (uint8_t)r5_6 + 1;
0802844c          }
0802844c          
0802845c          camera_link_send(0, 0x1000, 0xf0, &buf);
08028418      }
08028418      
08028464      return 1;
080283b6  }
08028466                    00 00                                                                                ..
08028468    int32_t sub_8028468(char arg1, char arg2)
08028468  {
08028478      int32_t var_20 = 0;
08028478      int32_t var_1c = 0;
08028478      int32_t var_18 = 0;
0802847c      uint32_t r4_1 = (uint32_t)arg1;
0802847c      
08028480      if (r4_1)
08028480      {
08028486          int32_t* r0;
08028486          int128_t q0_1;
08028486          r0 = sub_8031c54(2, 0xc);
0802848e          data_2000e370 = r0;
08028490          char r6_1 = 0;
08028490          
080284f0          while (true)
080284f0          {
080284f0              uint32_t r6_2 = (uint32_t)r6_1;
080284f0              
080284f4              if (r6_2 >= 2)
080284f4                  break;
080284f4              
080284a4              sub_8026ed4((char)r6_2 * 0xc, 0x3000, 0xc, &var_20);
080284a8              uint32_t r0_3 = (uint32_t)(uint8_t)var_20;
080284a8              
080284ae              if (r0_3 != 0xff)
080284ae              {
080284b0                  (uint32_t)q0_1 = var_1c;
080284b4                  *(uint32_t*)((char*)q0_1)[4] = 0x477fff00;
080284b8                  /* unimplemented  {vcmp.f32.F32 s0, s1} */
080284bc                  /* unimplemented  {vmrs apsr_nzcv, fpscr} */
080284bc                  
080284c0                  if (r0_3 < 0xff)
080284c0                  {
080284c2                      (uint32_t)q0_1 = var_18;
080284c6                      /* unimplemented  {vcmp.f32.F32 s0, #0} */
080284ca                      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
080284ca                      
080284ce                      if (r0_3 - 0xff >= 0)
080284ce                      {
080284d0                          (uint32_t)q0_1 = var_18;
080284d4                          *(uint32_t*)((char*)q0_1)[4] = 0x477fff00;
080284d8                          /* unimplemented  {vcmp.f32.F32 s0, s1} */
080284dc                          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
080284dc                          
080284e0                          if (r0_3 < 0xff)
080284ea                              sub_8031c80(data_2000e370, &var_20);
080284ce                      }
080284c0                  }
080284ae              }
080284ae              
080284ee              r6_1 = (uint8_t)r6_2 + 1;
080284f0          }
08028480      }
08028480      
080284f6      uint32_t r5_1 = (uint32_t)arg2;
080284f6      
080284fa      if (r5_1)
080284fa      {
08028500          int32_t* r0_5;
08028500          int128_t q0_2;
08028500          r0_5 = sub_8031c54(0x14, 0xc);
08028508          data_2000e36c = r0_5;
0802850a          char r6_3 = 0;
0802850a          
0802856a          while (true)
0802856a          {
0802856a              uint32_t r6_4 = (uint32_t)r6_3;
0802856a              
0802856e              if (r6_4 >= 0x14)
0802856e                  break;
0802856e              
0802851e              sub_8026ed4((char)r6_4 * 0xc, 0x1000, 0xc, &var_20);
08028522              uint32_t r0_8 = (uint32_t)(uint8_t)var_20;
08028522              
08028528              if (r0_8 != 0xff)
08028528              {
0802852a                  (uint32_t)q0_2 = var_1c;
0802852e                  *(uint32_t*)((char*)q0_2)[4] = 0xe92d437f;
08028532                  /* unimplemented  {vcmp.f32.F32 s0, s1} */
08028536                  /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08028536                  
0802853a                  if (r0_8 < 0xff)
0802853a                  {
0802853c                      (uint32_t)q0_2 = var_18;
08028540                      /* unimplemented  {vcmp.f32.F32 s0, #0} */
08028544                      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08028544                      
08028548                      if (r0_8 - 0xff >= 0)
08028548                      {
0802854a                          (uint32_t)q0_2 = var_18;
0802854e                          *(uint32_t*)((char*)q0_2)[4] = 0x477f;
08028552                          /* unimplemented  {vcmp.f32.F32 s0, s1} */
08028556                          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08028556                          
0802855a                          if (r0_8 < 0xff)
08028564                              sub_8031c80(data_2000e36c, &var_20);
08028548                      }
0802853a                  }
08028528              }
08028528              
08028568              r6_3 = (uint8_t)r6_4 + 1;
0802856a          }
080284fa      }
080284fa      
08028578      sub_80283b6((uint8_t)r4_1, (uint8_t)r5_1);
08028580      return 1;
08028468  }
08028582        00 00                                                                                        ..
08028584    int32_t sub_8028584(char arg1, int32_t arg2 @ r7)
08028584  {
08028586      /* tailcall */
08028586      return ui_led_heartbeat(arg1, arg1);
08028584  }
08028588    int32_t ui_led_heartbeat(char arg1, char arg2)
08028588  {
08028596      int32_t var_18 = 0;
08028596      int32_t var_14 = 0;
08028596      int32_t var_10 = 0;
08028596      
080285a0      if ((uint32_t)arg1)
080285a0      {
080285a2          char r5_1 = 0;
080285a2          
080285e6          while (true)
080285e6          {
080285e6              uint32_t r5_2 = (uint32_t)r5_1;
080285e6              
080285ea              if (r5_2 >= 2)
080285ea                  break;
080285ea              
080285b2              if (sub_8031d78(data_2000e370) != 1)
080285b2              {
080285b6                  r5_2 = (uint32_t)(uint8_t)r5_2;
080285c0                  sub_8031d88(data_2000e370, r5_2, &var_18);
080285b2              }
080285b2              
080285c6              int32_t r0_5;
080285c6              int32_t r1_1;
080285c6              r0_5 = float32_process(var_10);
080285d0              int32_t r0_7;
080285d0              int32_t r1_2;
080285d0              r0_7 = float32_process(var_14);
080285e0              logging_wrapper("[%d] %f %.2f\r\n", (uint32_t)(uint8_t)var_18, r0_7, r1_2, 
080285e0                  r0_5, r1_1);
080285e4              r5_1 = (uint8_t)r5_2 + 1;
080285e6          }
080285a0      }
080285a0      
080285f0      if ((uint32_t)arg2)
080285f0      {
080285f2          char r5_3 = 0;
080285f2          
08028636          while (true)
08028636          {
08028636              uint32_t r5_4 = (uint32_t)r5_3;
08028636              
0802863a              if (r5_4 >= 0x14)
0802863a                  break;
0802863a              
08028602              if (sub_8031d78(data_2000e36c) != 1)
08028602              {
08028606                  r5_4 = (uint32_t)(uint8_t)r5_4;
08028610                  sub_8031d88(data_2000e36c, r5_4, &var_18);
08028602              }
08028602              
08028616              int32_t r0_12;
08028616              int32_t r1_5;
08028616              r0_12 = float32_process(var_10);
08028620              int32_t r0_14;
08028620              int32_t r1_6;
08028620              r0_14 = float32_process(var_14);
08028630              logging_wrapper("[%d] %f %.2f\r\n", (uint32_t)(uint8_t)var_18, r0_14, r1_6, 
08028630                  r0_12, r1_5);
08028634              r5_3 = (uint8_t)r5_4 + 1;
08028636          }
080285f0      }
080285f0      
08028640      return 1;
08028588  }
08028642    int32_t sub_8028642(int32_t arg1)
08028642  {
08028642      int32_t buf = arg1;
0802864e      camera_link_send(0, 0x4000, 1, &buf);
08028654      return 1;
08028642  }
08028656                                                                    00 00                                                ..
08028658  int32_t data_8028658 = 0x477fff00
0802865a    int32_t sub_802865a()
0802865a  {
0802865e      int32_t r3;
0802865e      int32_t var_1c = r3;
0802865e      int32_t r2;
0802865e      int32_t var_20 = r2;
0802865e      int32_t r1;
0802865e      int32_t var_24 = r1;
0802865e      int32_t r0;
0802865e      int32_t var_28 = r0;
08028662      /* undefined */
0802865a  }
0802865c                                                                                      00 00                                    ..
08028666  // // Runs forever. Monitors tip/turnover/lean/lift/stop-button, camera UART
08028666  // health,
08028666  // // collision sensors, and a 3s/10s collision window. Commands motor
08028666  // brake/stop and
08028666  // // posts events as needed.
08028666  
08028666    void SafetyMonitorTask()
08028666  {
08028666      /* unimplemented  {ldc2 p0, c2, [r5, #-0]!} */
0802866e      char r5 = 0;
08028670      int32_t r4 = 0;
08028672      int32_t r7 = 0;
08028674      int32_t r6 = 0;
08028680      int32_t entry_r2;
08028680      int32_t entry_r3;
08028680      
08028680      while (!get_motion_state())
0802867c          entry_r2 = rtos_delay_ticks(0x32);
0802867c      
0802868c      while (true)
0802868c      {
0802868c          uint32_t r8_1 = get_current_mode_index();
08028694          software_mutex(0, 0x1f4, entry_r2, entry_r3);
0802869c          uint32_t safety_sensor_state = (uint32_t)get_multistate_safety_sensor();
0802869c          
080286a0          if (!safety_sensor_state)
080286a0          {
080286ba              data_2000e2c8 = 0;
080286c2              data_2000e2c9 = 0;
080286a0          }
080286a0          else if (safety_sensor_state == 2)
080286a4          {
080286ec              logging_wrapper("[debug]== lean TRIGGER ==\r\n");
080286f0              r8_1 = (uint32_t)(uint8_t)r8_1;
080286f0              
080286f8              if (r8_1 != 6)
080286f8              {
080286fa                  r8_1 = (uint32_t)(uint8_t)r8_1;
080286fa                  
08028702                  if (r8_1 != 7)
08028704                      motorBrake();
080286f8              }
080286f8              
08028708              motorStop();
08028710              safetyEventSet(1, 1);
080286a4          }
080286a4          else if (safety_sensor_state < 2)
080286a6          {
080286ca              logging_wrapper("[debug]== lean ERROR ==\r\n");
080286ce              motorBrake();
080286d2              motorStop();
080286da              safetyEventSet2(1, 1);
080286e2              safetyEventSet2(2, 1);
080286a6          }
080286a6          else if (safety_sensor_state == 4)
08028736              data_2000e2c8 = 1;
080286aa          else if (safety_sensor_state < 4)
080286ac          {
0802871a              logging_wrapper("[debug]== turnOver TRIGGER ==\r\n");
0802871e              motorBrake();
08028722              motorStop();
0802872a              safetyEventSet(2, 1);
080286ac          }
080286ac          else if (safety_sensor_state == 5)
080286b0          {
0802873a              motorStop();
08028744              data_2000e2c9 = 1;
080286b0          }
080286b0          
0802874c          uint32_t r9_2 = (uint32_t)cam_uart_init_check();
0802874c          
08028754          if (!r9_2)
08028766              r4 = 0;
08028754          else
08028754          {
0802875e              if ((uint32_t)(uint8_t)r9_2 != (uint32_t)r5)
08028760                  r4 = 0;
08028760              
08028762              r4 += 1;
08028754          }
08028754          
08028768          r5 = (uint8_t)r9_2;
08028776          sub_802929a((uint8_t)r9_2, (uint8_t)r4, (uint32_t)(uint8_t)r8_1);
0802877a          uint32_t r9_3 = (uint32_t)(uint8_t)r9_2;
0802877a          
08028782          if (r9_3 < 4)
08028782          {
08028788              safetyEventSet2(3, 0);
08028790              safetyEventSet2(4, 0);
08028790              
080287a6              if ((uint32_t)(uint8_t)r9_3 == 1 && r4 >= (uint32_t)data_20000de4)
080287a6              {
080287a8                  uint32_t r8_2 = (uint32_t)(uint8_t)r8_1;
080287a8                  
080287ba                  if (r8_2 != 6 && (uint32_t)(uint8_t)r8_2 != 7)
080287bc                      motorBrake();
080287bc                  
080287c0                  motorStop();
080287c8                  safetyEventSet(3, 1);
080287d0                  safetyEventSet(4, 1);
080287d8                  logging_wrapper("[debug]== lift TRIGGER ==\r\n");
080287a6              }
08028782          }
08028782          else if (r4 >= (uint32_t)data_20000de5)
080287e6          {
080287e8              uint32_t r9_5 = (uint32_t)(uint8_t)r9_3;
080287e8              
080287f0              if (r9_5 != 4)
080287f0              {
08028810                  uint32_t r9_6 = (uint32_t)(uint8_t)r9_5;
08028810                  
08028818                  if (r9_6 == 5)
08028818                  {
0802881a                      motorStop();
08028822                      safetyEventSet2(3, 0);
0802882a                      safetyEventSet2(4, 1);
08028832                      logging_wrapper(sub_803af88+0xbc);
08028818                  }
08028818                  else if ((uint32_t)(uint8_t)r9_6 == 6)
08028840                  {
08028842                      motorStop();
0802884a                      safetyEventSet2(3, 1);
08028852                      safetyEventSet2(4, 1);
0802885a                      logging_wrapper("[debug]== lift BREAKDOWN ==\r\n");
08028840                  }
080287f0              }
080287f0              else
080287f0              {
080287f2                  motorStop();
080287fa                  safetyEventSet2(3, 1);
08028802                  safetyEventSet2(4, 0);
0802880a                  logging_wrapper(sub_803af88+0x98);
080287f0              }
080287e6          }
080287e6          
08028862          uint32_t r0_12 = (uint32_t)cam_uart_status_probe();
08028862          
08028866          if (r0_12 == 1)
08028866          {
08028868              r7 += 1;
08028868              
0802886c              if (r7)
0802886c              {
0802886e                  r7 = 1;
08028870                  motorBrake();
08028874                  motorStop();
0802887c                  safetyEventSet(5, 1);
08028884                  logging_wrapper(sub_803af88+0xe0);
0802886c              }
08028866          }
08028866          else if ((uint32_t)(uint8_t)r0_12 != 4)
0802888e          {
080288ba              r6 = 0;
080288bc              r7 = 0;
0802888e          }
0802888e          else
0802888e          {
08028890              r6 += 1;
08028890              
08028894              if (r6 >= 2)
08028894              {
08028896                  r6 = 2;
08028898                  motorBrake();
0802889c                  motorStop();
080288a4                  safetyEventSet(5, 1);
080288ac                  safetyEventSet2(5, 1);
080288b4                  logging_wrapper("[debug]== stop button ERROR ==\r\n");
08028894              }
0802888e          }
0802888e          
080288be          int32_t r0_14 = TickType_t xTaskGetTickCount(void)();
080288cc          int32_t r9_8;
080288cc          
080288cc          if (r0_14 >= data_2000e368)
080288e6              r9_8 = r0_14 - data_2000e368;
080288cc          else
080288da              r9_8 = r0_14 + 0xffffffff - data_2000e368;
080288da          
080288f0          uint32_t arg_0 = (uint32_t)data_2000e2c4;
08028900          logging_wrapper("%d %d %d %d \r\n", data_2000e368, r0_14, r9_8);
08028906          int32_t r0_19 = sub_802a4cc(0);
0802890c          int32_t r0_20;
0802890c          
0802890c          if (r0_19 != 1)
08028910              r0_20 = sub_802a4cc(1);
08028910          
08028920          if (r0_19 == 1 || r0_20 == 1 || (uint32_t)data_2000e452 == 1)
08028920          {
08028922              motorBrake();
08028922              
0802892e              if ((uint32_t)data_2000e452 == 1)
08028934                  logging_wrapper("=========================================\r\n");
08028934              
0802893e              data_2000e452 = 0;
0802893e              
08028946              if (r9_8 >= 0xbb8)
08028946              {
08028950                  if (r9_8 - 0xbb8 >= 0x3e8)
08028950                  {
0802897e                      if (safetyCheck(0xa) != 1 || r9_8 - 0x2710 >= 0x3e8)
0802897e                      {
080289a2                          if (!safetyCheck(0xa))
080289a2                          {
080289a8                              data_2000e368 = r0_14;
080289b0                              logging_wrapper(&data_803b0f8);
080289a2                          }
0802897e                      }
0802897e                      else
0802897e                      {
08028984                          safetyEventSet(0xb, 1);
0802898c                          data_2000e368 = r0_14;
08028994                          logging_wrapper("MODULE_SENSOR_10S_COLLISION_SHIFT\r\n");
0802897e                      }
08028950                  }
08028950                  else
08028950                  {
08028952                      motorStop();
0802895a                      safetyEventSet(0xa, 1);
08028962                      logging_wrapper("MODULE_SENSOR_3S_COLLISION_SHIFT\r\n");
08028950                  }
08028946              }
08028946              
080289b8              safetyEventSet(0, 1);
080289c0              logging_wrapper(&data_803b11c);
08028920          }
08028920          else if (safetyCheck(0xa) == 1 && !safetyCheck(0xb) && r9_8 >= 0x2af9)
080289ce          {
080289e6              safetyEventSet(0xa, 0);
080289ee              logging_wrapper("MODULE_SENSOR_3S_COLLISION_SHIFT >>>>>>>>>>>>>\r\n");
080289ce          }
080289ce          
080289f2          sub_802923c();
080289f2          
080289fc          if (sub_802c5a4() == 1)
08028a02              safetyEventSet2(0xc, 1);
08028a02          
08028a08          entry_r2 = rtos_delay_ticks(0x64);
0802868c      }
08028666  }
08028a0e    int32_t sub_8028a0e()
08028a0e  {
08028a14      data_2000e452 = 1;
08028a16      return 1;
08028a0e  }
08028a18  // /**
08028a18  //  * Set or clear a safety/event flag bit.
08028a18  //  *
08028a18  //  * @param bit   Which bit index to modify (0..15)
08028a18  //  * @param on    1 = set, else = clear
08028a18  //  * @return      New 16-bit mask after modification
08028a18  //  */
08028a18  
08028a18    int32_t safetyEventSet(int32_t bit, char on)
08028a18  {
08028a1c      int32_t result;
08028a1c      
08028a1c      if ((uint32_t)on != 1)
08028a1c      {
08028a40          result = (uint32_t)data_2000e2c4 & ~(1 << bit);
08028a48          data_2000e2c4 = (int16_t)result;
08028a1c      }
08028a1c      else
08028a1c      {
08028a2a          result = 1 << bit | (uint32_t)data_2000e2c4;
08028a30          data_2000e2c4 = (int16_t)result;
08028a1c      }
08028a1c      
08028a4a      return result;
08028a18  }
08028a4c    int32_t safetyCheck(int32_t arg1)
08028a4c  {
08028a5c      if (!(((uint32_t)data_2000e2c4 & 1 << arg1) >> arg1))
08028a62          return 0;
08028a62      
08028a5e      return 1;
08028a4c  }
08028a66  // /**
08028a66  //  * Set or clear a secondary safety/event flag bit.
08028a66  //  *
08028a66  //  * @param bit   Which bit index to modify (0..15)
08028a66  //  * @param on    1 = set, else = clear
08028a66  //  * @return      New 16-bit mask after modification
08028a66  //  */
08028a66  
08028a66    int32_t safetyEventSet2(int32_t bit, char on)
08028a66  {
08028a6a      int32_t result;
08028a6a      
08028a6a      if ((uint32_t)on != 1)
08028a6a      {
08028a8e          result = (uint32_t)data_2000e2c6 & ~(1 << bit);
08028a96          data_2000e2c6 = (int16_t)result;
08028a6a      }
08028a6a      else
08028a6a      {
08028a78          result = 1 << bit | (uint32_t)data_2000e2c6;
08028a7e          data_2000e2c6 = (int16_t)result;
08028a6a      }
08028a6a      
08028a98      return result;
08028a66  }
08028a9a    int32_t safetyEvent2_isSet(int32_t bit)
08028a9a  {
08028aaa      if (!(((uint32_t)data_2000e2c6 & 1 << bit) >> bit))
08028ab0          return 0;
08028ab0      
08028aac      return 1;
08028a9a  }
08028ab4    uint16_t* safetyFlags_primary_ptr()
08028ab4  {
08028ab8      int128_t q0;
08028ab8      (uint32_t)q0 = data_2000e2cc;
08028abc      return &data_2000e2c4;
08028ab4  }
08028abe    uint32_t isFaultActive()
08028abe  {
08028acc      return (uint32_t)data_2000e2c4 & 0xfbff;
08028abe  }
08028ace    uint32_t sub_8028ace(int32_t arg1)
08028ace  {
08028ada      return (uint32_t)data_2000e2c4 & (uint32_t)(uint16_t)~arg1;
08028ace  }
08028adc    uint32_t sub_8028adc()
08028adc  {
08028ae2      return (uint32_t)data_2000e2c6;
08028adc  }
08028ae4    int32_t sub_8028ae4()
08028ae4  {
08028aea      int16_t result = data_2000e2c4 & 0xc00;
08028af2      data_2000e2c4 = result;
08028af4      return result;
08028ae4  }
08028af6    int32_t sub_8028af6()
08028af6  {
08028afc      data_2000e2c6 = 0;
08028afe      return 0;
08028af6  }
08028b00    uint32_t sub_8028b00()
08028b00  {
08028b06      return (uint32_t)data_2000e2c8;
08028b00  }
08028b08    uint32_t sub_8028b08()
08028b08  {
08028b0e      return (uint32_t)data_2000e2c9;
08028b08  }
08028b10  // /**
08028b10  //  * Run a synchronous sensor sanity check sequence.
08028b10  //  *
08028b10  //  * @param expectStopPressed  (arg1) whether the “stop/hold” input is
08028b10  // expected to be pressed (1) or not (0).
08028b10  //  *                           This is compared to safetyCheck(5).
08028b10  //  * @return SensorCheckResult as per enum above.
08028b10  //  *
08028b10  //  * HLIL: sub_8028b10
08028b10  //  */
08028b10  
08028b10    int32_t sensor_check_sequence(char expectStopPressed)
08028b10  {
08028b14      sub_8028ae4();
08028b1c      rtos_delay_ticks(0x1f4);
08028b28      int32_t r3 =
08028b28          logging_wrapper("[debug]checkSensor:[turnOver]:%d\r\n", (uint32_t)data_2000e2c4);
08028b34      int32_t r5;
08028b34      
08028b34      if (safetyCheck(2) == 1)
08028b34      {
08028b3c          sub_80282e4(0x52, 0, 1, r3, r5);
08028b40          return 1;
08028b34      }
08028b34      
08028b4e      if (safetyCheck(5) == (uint32_t)expectStopPressed)
08028b4e      {
08028b56          sub_80282e4(0x63, 0, 1, r3, r5);
08028b5a          return 2;
08028b4e      }
08028b4e      
08028b66      if (safetyCheck(1) == 1)
08028b66      {
08028b6e          sub_80282e4(0x54, 0, 1, r3, r5);
08028b72          return 3;
08028b66      }
08028b66      
08028b7e      if (safetyCheck(3) == 1 && safetyCheck(4) == 1)
08028b7e      {
08028b90          sub_80282e4(0x4c, 0, 1, r3, r5);
08028b94          return 4;
08028b7e      }
08028b7e      
08028ba0      if (safetyCheck(0) == 1)
08028ba2          return 5;
08028ba2      
08028bae      if (safetyCheck(6) != 1)
08028bae      {
08028bbe          sub_8028af6();
08028bc2          return 0;
08028bae      }
08028bae      
08028bb6      sub_80282e4(0x64, 0, 1, r3, r5);
08028bba      return 6;
08028b10  }
08028bc6    int32_t sub_8028bc6()
08028bc6  {
08028bc8      int128_t q0;
08028bc8      (uint32_t)q0 = data_2000e034;
08028bcc      return 0x2000e02c;
08028bc6  }
08028bce    int32_t sub_8028bce()
08028bce  {
08028bd2      int128_t q0;
08028bd2      (uint32_t)q0 = data_2000e374;
08028bd6      return &data_2000e374;
08028bce  }
08028bd8    int32_t sub_8028bd8()
08028bd8  {
08028bda      int128_t q0;
08028bda      (uint32_t)q0 = data_2000e054;
08028bde      return 0x2000e02c;
08028bd8  }
08028be0    int32_t sub_8028be0()
08028be0  {
08028be2      int128_t q0;
08028be2      (uint32_t)q0 = data_2000e03c;
08028be6      return 0x2000e02c;
08028be0  }
08028be8    int32_t sub_8028be8(char arg1)
08028be8  {
08028bec      data_2000e453 = arg1;
08028bf0      return 1;
08028be8  }
08028bf2    uint32_t sub_8028bf2()
08028bf2  {
08028bf8      return (uint32_t)data_2000e453;
08028bf2  }
08028bfa                                                                                00 00                                        ..
08028bfc  int32_t data_8028bfc = 0x2000e2c4
08028c00  int32_t data_8028c00 = 0x2000e374
08028c04  int32_t data_8028c04 = 0x41b00000
08028c08  int32_t data_8028c08 = 0x2000e02c
08028c0c  int32_t data_8028c0c = 0x41a00000
08028c10  int32_t data_8028c10 = 0x40400000
08028c14  int32_t data_8028c14 = 0x803bfa8
08028c18  int32_t data_8028c18 = 0x2000e370
08028c1c  int32_t data_8028c1c = 0x2000e36c
08028c20  int32_t data_8028c20 = 0x2000e2d0
08028c24  int32_t data_8028c24 = 0x404e0000
08028c28  int32_t data_8028c28 = 0x408f4000
08028c2c    int32_t sub_8028c2c()
08028c2c  {
08028c38      int32_t var_18 = 0;
08028c38      int32_t var_14 = 0;
08028c38      int32_t var_10 = 0;
08028c40      void buf;
08028c40      j_sub_80168a8(&buf, 0x10);
08028c46      sub_8027a50(&var_18);
08028c52      memcpy_(&buf, &var_18, 0xc);
08028c5e      char var_1c = sub_8029468(&buf, 0xc);
08028c72      return camera_link_send(0, 0x8000, 0xd, &buf);
08028c2c  }
08028c74    int32_t sub_8028c74()
08028c74  {
08028c7c      void var_28;
08028c7c      j_sub_80168a8(&var_28, 0x10);
08028c8a      int32_t var_18 = 0;
08028c8a      int32_t var_14 = 0;
08028c8a      int32_t var_10 = 0;
08028c98      sub_8026ed4(0, 0x8000, 0xd, &var_28);
08028ca4      memcpy_(&var_18, &var_28, 0xc);
08028cac      char r0_3 = sub_8029468(&var_28, 0xc);
08028cc0      char var_1c;
08028cc0      
08028cc0      if ((uint32_t)r0_3 != (uint32_t)var_1c || !(uint32_t)r0_3)
08028ccc          return 0;
08028ccc      
08028cc4      sub_8027bae(&var_18);
08028cc8      return 1;
08028c74  }
08028cd2                                                        00 00                                                        ..
08028cd4    int32_t get_multistate_safety_sensor()
08028cd4  {
08028cd4      int32_t r7;
08028cd4      int32_t var_8 = r7;
08028cd4      int32_t r6;
08028cd4      int32_t var_c = r6;
08028cd4      int32_t r5;
08028cd4      int32_t var_10 = r5;
08028cd8      var_10 = 0;
08028cdc      var_8 = 0;
08028ce0      var_c = 0;
08028ce8      int32_t r0_1;
08028ce8      int128_t q0;
08028ce8      int128_t q4;
08028ce8      dbl_bits q5;
08028ce8      r0_1 = sub_8027844(&var_10, &var_8, &var_c, q4, q5);
08028cec      bool v = r0_1 + 0;
08028cee      bool n;
08028cee      
08028cee      if (r0_1)
08028cee      {
08028d0c          n = false;
08028d12          data_2000e454 = 0;
08028cee      }
08028cee      else
08028cee      {
08028cfc          data_2000e454 += 1;
08028d02          uint32_t r0_4 = (uint32_t)data_2000e454;
08028d04          n = r0_4 - 6 < 0;
08028d04          v = r0_4 - 6;
08028d04          
08028d06          if (n == v)
08028d08              return 1;
08028cee      }
08028cee      
08028d1a      data_2000e2cc = var_c;
08028d1c      (uint32_t)q0 = var_10;
08028d20      *(uint32_t*)((char*)q0)[4] = 0x428c0001;
08028d24      /* unimplemented  {vcmp.f32.F32 s0, s1} */
08028d28      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08028d28      
08028d2c      if (n != v)
08028d2c      {
08028d54          (uint32_t)q0 = var_10;
08028d58          *(uint32_t*)((char*)q0)[4] = 0x41f00001;
08028d5c          /* unimplemented  {vcmp.f32.F32 s0, s1} */
08028d60          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08028d60          
08028d64          if (n != v)
08028d64          {
08028d86              (uint32_t)q0 = var_10;
08028d8a              *(uint32_t*)((char*)q0)[4] = 0xc1400000;
08028d8e              /* unimplemented  {vcmp.f32.F32 s0, s1} */
08028d92              /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08028d92              
08028d96              if (!n)
08028d96              {
08028dbe                  data_2000e455 = 0;
08028dc6                  data_2000e456 = 0;
08028dce                  data_2000e457 = 0;
08028d96              }
08028d96              else
08028d96              {
08028d9c                  uint32_t r0_12 = (uint32_t)data_2000e457;
08028d9e                  v = r0_12 + 1;
08028da4                  data_2000e457 = (uint8_t)r0_12 + 1;
08028dac                  data_2000e456 = 0;
08028db4                  data_2000e455 = 0;
08028d96              }
08028d64          }
08028d64          else
08028d64          {
08028d6a              uint32_t r0_10 = (uint32_t)data_2000e455;
08028d6c              v = r0_10 + 1;
08028d72              data_2000e455 = (uint8_t)r0_10 + 1;
08028d7a              data_2000e456 = 0;
08028d82              data_2000e457 = 0;
08028d64          }
08028d2c      }
08028d2c      else
08028d2c      {
08028d3a          data_2000e455 += 1;
08028d40          uint32_t r0_8 = (uint32_t)data_2000e456;
08028d42          v = r0_8 + 1;
08028d48          data_2000e456 = (uint8_t)r0_8 + 1;
08028d50          data_2000e457 = 0;
08028d2c      }
08028d2c      
08028dd6      (uint32_t)q0 = var_10;
08028dda      sub_8029334(data_2000e455);
08028dde      int128_t q0_1;
08028dde      (uint32_t)q0_1 = var_10;
08028de2      *(uint32_t*)((char*)q0_1)[4] = 0x1428c;
08028de6      /* unimplemented  {vcmp.f32.F32 s0, s1} */
08028dea      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08028dea      
08028dee      if (false != v)
08028dee      {
08028e28          (uint32_t)q0_1 = var_10;
08028e2c          *(uint32_t*)((char*)q0_1)[4] = 0x41f00001;
08028e30          /* unimplemented  {vcmp.f32.F32 s0, s1} */
08028e34          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08028e34          
08028e38          if (false != v)
08028e38          {
08028e64              (uint32_t)q0_1 = var_10;
08028e68              *(uint32_t*)((char*)q0_1)[4] = 0x41400001;
08028e6c              /* unimplemented  {vcmp.f32.F32 s0, s1} */
08028e70              /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08028e70              
08028e74              if (false == v)
08028e76                  return 4;
08028e76              
08028e7a              (uint32_t)q0_1 = var_8;
08028e7e              *(uint32_t*)((char*)q0_1)[4] = 0xc1400000;
08028e82              /* unimplemented  {vcmp.f32.F32 s0, s1} */
08028e86              /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08028eae              return 0;
08028e38          }
08028e38          
08028e40          data_2000e2c8 = 2;
08028e40          
08028e50          if ((uint32_t)data_2000e455 >= (uint32_t)data_20000de7)
08028e50          {
08028e5e              data_2000e455 -= 1;
08028e60              return 2;
08028e50          }
08028dee      }
08028dee      else
08028dee      {
08028df6          data_2000e2c8 = 2;
08028df6          
08028e06          if ((uint32_t)data_2000e456 >= (uint32_t)data_20000de6)
08028e06          {
08028e14              data_2000e456 -= 1;
08028e22              data_2000e455 -= 1;
08028e24              return 3;
08028e06          }
08028dee      }
08028dee      
08028eb2      return 0;
08028cd4  }
08028eb6                                                                    00 00                                                ..
08028eb8  // // ----------------------------------------------------------------
08028eb8  // // sub_8028eb8
08028eb8  // // Scales a 16-bit reading, applies a couple of FP transforms, then
08028eb8  // // updates a coarse “step/ramp” filter on the result. Returns arg2.
08028eb8  
08028eb8    int32_t update_scaled_filter_from_counts(int16_t counts, int32_t passthrough)
08028eb8  {
08028eba      int96_t q0;
08028eba      (uint32_t)q0 = 0xb5f80000;
08028ec0      sub_802e6b8((uint32_t)counts);
08028ecc      int32_t entry_a;
08028ecc      int32_t b;
08028ecc      soft_dmul(entry_a, b);
08028ed6      int32_t r0_1;
08028ed6      int32_t r1;
08028ed6      r0_1 = soft_dadd();
08028ede      (uint32_t)q0 = sub_802ead0(r0_1, r1);
08028ee6      float32_process((uint32_t)q0);
08028ef0      int32_t r0_4;
08028ef0      int32_t r1_1;
08028ef0      r0_4 = soft_dmul();
08028ef8      (uint32_t)q0 = sub_802ead0(r0_4, r1_1);
08028f00      data_2000e374 = (uint32_t)q0;
08028f08      *(uint32_t*)((char*)q0)[4] = data_2000e034;
08028f0c      *(uint32_t*)((char*)q0)[4] = (uint32_t)q0 - *(uint32_t*)((char*)q0)[4];
08028f10      *(uint32_t*)((char*)q0)[4] = fabsf(*(uint32_t*)((char*)q0)[4]);
08028f14      *(uint32_t*)((char*)q0)[8] = 0x3f800001;
08028f18      /* unimplemented  {vcmp.f32.F32 s1, s2} */
08028f1c      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08028f20      bool v;
08028f20      
08028f20      if (false != v)
08028f20      {
08028f40          *(uint32_t*)((char*)q0)[4] = data_2000e038;
08028f48          *(uint32_t*)((char*)q0)[8] = data_2000e034;
08028f4c          *(uint32_t*)((char*)q0)[4] =
08028f4c              *(uint32_t*)((char*)q0)[4] - *(uint32_t*)((char*)q0)[8];
08028f54          data_2000e038 = *(uint32_t*)((char*)q0)[4];
08028f5c          *(uint32_t*)((char*)q0)[4] = data_2000e038;
08028f60          (uint32_t)q0 = *(uint32_t*)((char*)q0)[4] + 1.00000012f;
08028f68          data_2000e038 = (uint32_t)q0;
08028f70          (uint32_t)q0 = data_2000e038;
08028f74          *(uint32_t*)((char*)q0)[4] = 0x40a00000;
08028f78          (uint32_t)q0 = (uint32_t)q0 / 5f;
08028f80          data_2000e034 = (uint32_t)q0;
08028f20      }
08028f20      else
08028f20      {
08028f22          *(uint32_t*)((char*)q0)[4] = 0x40a00000;
08028f26          *(uint32_t*)((char*)q0)[4] = 1.00000012f * 5f;
08028f2e          data_2000e038 = *(uint32_t*)((char*)q0)[4];
08028f36          data_2000e034 = 0x3f800001;
08028f20      }
08028f20      
08028f84      return entry_a;
08028eb8  }
08028f86    int32_t sub_8028f86(int16_t arg1, int32_t arg2 @ r7)
08028f86  {
08028f8a      sub_802e6b8((uint32_t)arg1);
08028f96      int32_t b;
08028f96      soft_dmul(arg2, b);
08028fa0      int32_t r0_1;
08028fa0      int32_t r1;
08028fa0      r0_1 = soft_dadd();
08028fa8      int96_t q0;
08028fa8      (uint32_t)q0 = sub_802ead0(r0_1, r1);
08028fb0      *(uint32_t*)((char*)q0)[4] = data_2000e058;
08028fb8      *(uint32_t*)((char*)q0)[8] = data_2000e054;
08028fbc      *(uint32_t*)((char*)q0)[4] = *(uint32_t*)((char*)q0)[4] - *(uint32_t*)((char*)q0)[8];
08028fc4      data_2000e058 = *(uint32_t*)((char*)q0)[4];
08028fcc      *(uint32_t*)((char*)q0)[4] = data_2000e058;
08028fd0      (uint32_t)q0 = *(uint32_t*)((char*)q0)[4] + (uint32_t)q0;
08028fd8      data_2000e058 = (uint32_t)q0;
08028fe0      (uint32_t)q0 = data_2000e058;
08028fe4      *(uint32_t*)((char*)q0)[4] = 0x40a00000;
08028fe8      (uint32_t)q0 = (uint32_t)q0 / 5f;
08028ff0      data_2000e054 = (uint32_t)q0;
08028ff4      return arg2;
08028f86  }
08028ff6                                                                    00 00                                                ..
08028ff8  int32_t data_8028ff8 = 0x428c0001
08028ffc  int32_t data_8028ffc = 0x41f00001
08029000  int32_t data_8029000 = 0x41400001
08029004              00 00                                                                                    ..
08029006  int32_t data_8029006 = -0x4a080000
08029008    int32_t sub_8029008(int16_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int128_t arg5 @ q4, dbl_bits arg6 @ q5)
08029008  {
08029008      int32_t r7;
08029008      int32_t var_8 = r7;
0802900a      int64_t var_20 = (uint64_t)arg5;
0802900a      dbl_bits b;
0802900a      b.lo = *(uint32_t*)((char*)arg5)[8];
0802900a      b.hi = *(uint32_t*)((char*)arg5)[0xc];
0802900a      dbl_bits a;
0802900a      a.lo = arg6.lo;
0802900a      a.hi = arg6.hi;
08029010      sub_802e6b8((uint32_t)arg1);
0802901c      soft_dmul(a, b);
08029026      int32_t r0_1;
08029026      int32_t r1;
08029026      r0_1 = soft_dadd();
0802902e      (uint32_t)arg5 = sub_802ead0(r0_1, r1);
08029032      int64_t q0;
08029032      (uint32_t)q0 = 0x41200000;
08029036      (uint32_t)q0 = (uint32_t)arg5 * 10f;
0802903e      int32_t r0_4;
0802903e      int32_t r1_1;
0802903e      r0_4 = float32_process((uint32_t)q0);
0802904a      int32_t r0_6;
0802904a      int32_t r1_2;
0802904a      r0_6 = float32_process((uint32_t)arg5);
0802905a      int32_t r0_7;
0802905a      int32_t r1_3;
0802905a      r0_7 = sub_802eb60(0x66666666, 0x400a6666, r0_6, r1_2);
08029066      int32_t r0_9;
08029066      int32_t r1_5;
08029066      r0_9 = soft_dadd();
0802906e      (uint32_t)q0 = sub_802ead0(r0_9, r1_5);
08029076      int32_t r0_12;
08029076      int32_t r1_6;
08029076      r0_12 = float32_process((uint32_t)q0);
0802907e      int128_t q0_1;
0802907e      int96_t q4;
0802907e      q0_1 = sub_802ece0(r7, );
0802908e      int32_t r0_14;
0802908e      int32_t r1_8;
0802908e      r0_14 = soft_dmul();
0802909a      int32_t r0_15;
0802909a      int32_t r1_9;
0802909a      r0_15 = sub_802ecf4(r0_14, r1_8, 0x76c8b439, 0x4056e7be);
080290a2      *(uint32_t*)((char*)q4)[8] = sub_802ead0(r0_15, r1_9);
080290a6      *(uint64_t*)((char*)q0_1)[8] = 0;
080290aa      (uint32_t)q4 = 0;
080290ae      *(uint32_t*)((char*)q4)[4] = 0;
080290b6      int32_t r0_18;
080290b6      int32_t r1_10;
080290b6      r0_18 = float32_process(*(uint32_t*)((char*)q4)[8]);
080290ba      (uint64_t)q0_1 = (r1_10 << 32) | r0_18;
080290be      *(uint32_t*)((char*)q0_1)[8] = 0;
080290c2      *(uint32_t*)((char*)q0_1)[0xc] = 0;
080290c6      int64_t q0_2;
080290c6      int128_t q4_1;
080290c6      q0_2 = sub_802f2a2(q0_1);
080290ca      (uint32_t)q4_1 = (uint32_t)q0_2;
080290ce      *(uint32_t*)((char*)q4_1)[4] = *(uint32_t*)((char*)q0_2)[4];
080290d6      int32_t r0_20;
080290d6      int32_t r1_11;
080290d6      r0_20 = float32_process(*(uint32_t*)((char*)q4_1)[8]);
080290e6      int32_t r0_22;
080290e6      int32_t r1_13;
080290e6      r0_22 = soft_dmul();
080290f6      soft_dmul();
080290fe      int32_t r0_24;
080290fe      int32_t r1_15;
080290fe      r0_24 = soft_dmul();
08029106      int32_t r0_25;
08029106      int32_t r1_16;
08029106      r0_25 = sub_802ecf4(r0_24, r1_15, r0_22, r1_13);
08029112      float32_process(*(uint32_t*)((char*)q4_1)[8]);
0802911a      int32_t r0_27;
0802911a      int32_t r1_17;
0802911a      r0_27 = soft_dmul();
08029122      int32_t r0_28;
08029122      int32_t r1_18;
08029122      r0_28 = sub_802ecf4(r0_27, r1_17, r0_25, r1_16);
0802912a      int32_t r0_29;
0802912a      int32_t r1_19;
0802912a      r0_29 = sub_802ecf4(r0_28, r1_18, 0x3afb7e91, 0xc00dce70);
08029132      (uint32_t)q4_1 = sub_802ead0(r0_29, r1_19);
0802913a      int32_t r0_32;
0802913a      int32_t r1_20;
0802913a      r0_32 = float32_process((uint32_t)q4_1);
0802913e      *(uint64_t*)((char*)q4_1)[8] = (r1_20 << 32) | r0_32;
08029146      int32_t r0_34;
08029146      int32_t r1_21;
08029146      r0_34 = float32_process(data_2000e040);
08029156      soft_dmul();
0802915e      int32_t r0_36;
0802915e      int32_t r1_23;
0802915e      r0_36 = soft_dmul();
0802916a      float32_process((uint32_t)q4_1);
08029172      int32_t r0_38;
08029172      int32_t r1_24;
08029172      r0_38 = soft_dmul();
0802917a      int32_t r0_39;
0802917a      int32_t r1_25;
0802917a      r0_39 = sub_802ecf4(r0_38, r1_24, r0_36, r1_23);
08029182      int32_t r0_40;
08029182      int32_t r1_26;
08029182      r0_40 = sub_802ecf4(r0_39, r1_25, 0x5f6fd220, 0x3f99ce07);
0802918a      int32_t r0_41;
0802918a      int32_t r1_27;
0802918a      r0_41 = sub_802ecf4(r0_40, r1_26, r0_34, r1_21);
08029194      data_2000e040 = sub_802ead0(r0_41, r1_27);
08029198      (uint32_t)q0_2 = data_2000e040;
0802919e      *(uint32_t*)((char*)q0_2)[4] = data_2000e03c;
080291a2      (uint32_t)q0_2 = (uint32_t)q0_2 - *(uint32_t*)((char*)q0_2)[4];
080291a8      data_2000e040 = (uint32_t)q0_2;
080291ae      (uint32_t)q0_2 = data_2000e040;
080291b2      *(uint32_t*)((char*)q0_2)[4] = 0x40a00000;
080291b6      (uint32_t)q0_2 = (uint32_t)q0_2 / 5f;
080291bc      data_2000e03c = (uint32_t)q0_2;
080291c0      (uint32_t)q4_1 = a.lo;
080291c0      *(uint32_t*)((char*)q4_1)[4] = a.hi;
080291c0      *(uint32_t*)((char*)q4_1)[8] = b.lo;
080291c0      *(uint32_t*)((char*)q4_1)[0xc] = b.hi;
080291c4      return arg4;
08029008  }
080291c6                    00 00                                                                                ..
080291c8    int32_t sub_80291c8(int32_t arg1, int32_t arg2 @ r7)
080291c8  {
080291ca      /* tailcall */
080291ca      return sub_80291cc((uint16_t)arg1, arg2 - 0x80);
080291c8  }
080291cc    int32_t sub_80291cc(int16_t arg1, int32_t arg2 @ r7)
080291cc  {
080291d0      sub_802e6b8((uint32_t)arg1);
080291da      int32_t b;
080291da      soft_dmul(arg2, b);
080291e2      int32_t r0_1;
080291e2      int32_t r1;
080291e2      r0_1 = soft_dadd();
080291ea      int64_t q0;
080291ea      (uint32_t)q0 = sub_802ead0(r0_1, r1);
080291f0      *(uint32_t*)((char*)q0)[4] = data_2000e048;
080291f4      (uint32_t)q0 = *(uint32_t*)((char*)q0)[4] + (uint32_t)q0;
080291fa      data_2000e048 = (uint32_t)q0;
08029200      (uint32_t)q0 = data_2000e048;
08029206      *(uint32_t*)((char*)q0)[4] = data_2000e044;
0802920a      (uint32_t)q0 = (uint32_t)q0 - *(uint32_t*)((char*)q0)[4];
08029210      data_2000e048 = (uint32_t)q0;
08029216      (uint32_t)q0 = data_2000e048;
0802921a      *(uint32_t*)((char*)q0)[4] = 0x41200000;
0802921e      (uint32_t)q0 = (uint32_t)q0 / 10f;
08029224      data_2000e044 = (uint32_t)q0;
08029228      return arg2;
080291cc  }
0802922a                                00 00                                                                        ..
0802922c  int32_t data_802922c = 0x803be90
08029230    int32_t sub_8029230(int32_t arg1, uint32_t arg2 @ r4, int16_t arg3, int16_t arg4, int16_t arg5, int32_t arg6)
08029230  {
08029230      /* unimplemented  {setend be} */
08029234      /* unimplemented  {cpsid none} */
08029236      uint32_t r3 = arg1 >> 0x20;
08029236      
08029238      if (arg1)
0802923a          /* tailcall */
0802923a          return sub_802923c();
0802923a      
08029292      for (; arg2 < 9; arg2 = (uint32_t)((uint8_t)arg2 + 1))
08029292      {
08029278          void arg_0;
08029278          int32_t entry_r2;
08029278          update_scaled_filter_from_counts(arg4, sub_802c0fa(&arg_0, 0, entry_r2, r3));
08029280          int32_t r1_3;
08029280          int32_t r2_1;
08029280          int32_t r3_2;
08029280          int32_t r7;
08029280          r1_3 = sub_8028f86(arg5, r7);
08029288          int128_t q4;
08029288          dbl_bits q5;
08029288          entry_r2 = sub_8029008(arg3, r1_3, r2_1, r3_2, q4, q5);
08029292      }
08029292      
08029298      return 1;
08029230  }
0802923c    int32_t sub_802923c()
0802923c  {
0802924c      void var_20;
0802924c      int16_t counts;
0802924c      int32_t entry_r2;
0802924c      int32_t entry_r3;
0802924c      update_scaled_filter_from_counts(counts, sub_802c0fa(&var_20, 1, entry_r2, entry_r3));
08029254      int16_t var_12;
08029254      int32_t r1_1;
08029254      int32_t r2;
08029254      int32_t r3;
08029254      int32_t r7;
08029254      r1_1 = sub_8028f86(var_12, r7);
0802925c      int16_t var_16;
0802925c      int128_t q4;
0802925c      int128_t q4_1;
0802925c      dbl_bits q5;
0802925c      dbl_bits q5_1;
0802925c      q4_1 = sub_8029008(var_16, r1_1, r2, r3, q4, q5);
08029264      int16_t var_10;
08029264      int32_t r2_1;
08029264      int32_t r3_1;
08029264      r2_1 = sub_80291cc(var_10, r7);
08029268      char r4 = 0;
08029268      
0802928e      while (true)
0802928e      {
0802928e          uint32_t r4_1 = (uint32_t)r4;
0802928e          
08029292          if (r4_1 >= 9)
08029292              break;
08029292          
08029278          update_scaled_filter_from_counts(counts, sub_802c0fa(&var_20, 0, r2_1, r3_1));
08029280          int32_t r1_3;
08029280          int32_t r2_2;
08029280          int32_t r3_2;
08029280          r1_3 = sub_8028f86(var_12, r7);
08029288          r2_1 = sub_8029008(var_16, r1_3, r2_2, r3_2, q4_1, q5_1);
0802928c          r4 = (uint8_t)r4_1 + 1;
0802928e      }
0802928e      
08029298      return 1;
0802923c  }
0802929a    int32_t sub_802929a(char arg1, char arg2, int32_t arg3)
0802929a  {
0802929c      char r4 = (uint8_t)arg3;
0802929c      
080292a2      if ((uint32_t)arg1 != 1)
080292a2      {
0802930e          if (safetyCheck(7) == 1)
0802930e          {
08029314              safetyEventSet(7, 0);
0802931a              sub_80271b6(2);
0802930e          }
080292a2      }
080292a2      else
080292a2      {
080292a8          if ((uint32_t)arg2 == 1)
080292b0              data_2000e360 = TickType_t xTaskGetTickCount(void)();
080292b0          
080292b2          int32_t r0_2 = TickType_t xTaskGetTickCount(void)();
080292bc          int32_t r0_3;
080292bc          
080292bc          if (r0_2 >= data_2000e360)
080292d0              r0_3 = r0_2 - data_2000e360;
080292bc          else
080292bc          {
080292c4              arg3 = data_2000e360;
080292c8              r0_3 = r0_2 + 0xffffffff - arg3;
080292bc          }
080292bc          
080292d8          uint32_t r4_1;
080292d8          
080292d8          if (r0_3 < 0x2711)
080292da              r4_1 = (uint32_t)r4;
080292da          
080292e4          if (r0_3 >= 0x2711 || !r4_1 || (uint32_t)(uint8_t)r4_1 == 8)
080292e4          {
080292e8              logging_wrapper("lift alarm\r\n", 0x2711, arg3);
080292e8              
080292f4              if (!safetyCheck(7))
080292f4              {
080292f8                  doBeep(2);
08029300                  safetyEventSet(7, 1);
080292f4              }
080292e4          }
080292a2      }
080292a2      
08029320      return 1;
0802929a  }
08029322        00 00                                                                                        ..
08029324  int32_t data_8029324 = 0x20000de4
08029328  int32_t data_8029328 = 0x803b694
0802932a    int32_t sub_802932a(int32_t arg1, char arg2)
0802932a  {
08029332      /* tailcall */
08029332      return sub_8029334((uint8_t)arg1 & arg2);
0802932a  }
08029334    int32_t sub_8029334(char arg1)
08029334  {
08029334      int32_t r7;
08029334      int32_t var_8 = r7;
08029336      int128_t q0;
08029336      *(uint32_t*)((char*)q0)[4] = 0xbea041f0;
0802933a      /* unimplemented  {vcmp.f32.F32 s0, s1} */
0802933e      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08029342      bool n;
08029342      bool v;
08029342      
08029342      if (n != v)
0802938e          safetyEventSet(8, 0);
08029342      else
08029342      {
08029348          if ((uint32_t)arg1 == 1)
08029350              data_2000e364 = TickType_t xTaskGetTickCount(void)();
08029350          
08029352          int32_t r0_2 = TickType_t xTaskGetTickCount(void)();
0802935c          int32_t r0_3;
0802935c          int32_t entry_r2;
0802935c          
0802935c          if (r0_2 >= data_2000e364)
08029370              r0_3 = r0_2 - data_2000e364;
0802935c          else
0802935c          {
08029364              entry_r2 = data_2000e364;
08029368              r0_3 = r0_2 + 0xffffffff - entry_r2;
0802935c          }
0802935c          
08029378          if (r0_3 >= 0x2711)
08029378          {
0802937c              logging_wrapper("lean 10s trigger\r\n", 0x2711, entry_r2);
08029384              safetyEventSet(8, 1);
08029378          }
08029342      }
08029342      
08029394      return 1;
08029334  }
08029396                                                                    00 00                                                ..
08029398  int32_t data_8029398 = 0x2000e2c4
0802939c    int32_t sub_802939c(int32_t arg1, int32_t arg2, int32_t arg3 @ r4)
0802939c  {
0802940c      /* tailcall */
0802940c      return sub_8029468(nullptr, arg2 & arg3);
0802939c  }
080293b6                                                                    00 20 01 00                                          . ..
080293ba  int32_t data_80293ba = -0x415fbe10
080293be                                                                                            03 08                                ..
080293c0  int32_t data_80293c0 = 0x2000e452
080293c4    void* sub_80293c4(int32_t* arg1, char* arg2, int32_t arg3, int32_t arg4 @ r4)
080293c4  {
080293d4      if (arg4)
080293d4      {
080293d8          /* unimplemented  {ldcl p8, c0, [r12, #8]} */
080293d8          
080293dc          if (!arg1)
080293dc          {
08028ca4              void var_3e0;
08028ca4              memcpy_(&var_3e0, arg2, arg3);
08028cac              int32_t var_3f0;
08028cac              char r0_4 = sub_8029468(&var_3f0, 0xc);
08028cc0              char var_3e4;
08028cc0              
08028cc0              if ((uint32_t)r0_4 != (uint32_t)var_3e4 || !(uint32_t)r0_4)
08028ccc                  return 0;
08028ccc              
08028cc4              sub_8027bae(&var_3e0);
08028cc8              return 1;
080293dc          }
080293d4      }
080293d4      
08029ace      if (arg1)
08029ace      {
08029ae8          sub_80323a4(arg1, data_2000e38c + 0x18);
08029af4          return sub_8029fdc(arg4, 1);
08029ace      }
08029ace      
08029ad2      __msr(basepri, 0x20);
08029ad6      __dsb_SY();
08029ada      __isb();
08029ada      
08029ade      while (true)
08029ade          /* nop */
080293c4  }
080293e2        00 20                                                                                        . 
080293e4  int32_t data_80293e4 = 0x2000e453
080293e8  int32_t data_80293e8 = 0x2000e454
080293ec  int32_t data_80293ec = 0x2000e455
080293f2                                                        00 20                                                        . 
080293f4  int32_t data_80293f4 = 0x2000e457
080293f8  int32_t data_80293f8 = 0x20000de6
080293fc  int32_t data_80293fc = 0x20000de7
08029400  int32_t data_8029400 = 0x400a6666
08029404  int32_t data_8029404 = 0x40affe00
0802940e                                            00 20                                                                . 
08029410  int32_t data_8029410 = 0x7ae147ae
08029414  int32_t data_8029414 = -0x3fc591ec
08029418  int32_t data_8029418 = 0x76c8b439
0802941c  int32_t data_802941c = 0x4056e7be
08029420  int32_t data_8029420 = -0x5f4a1273
08029424  int32_t data_8029424 = 0x3ee0c6f7
08029428  int32_t data_8029428 = -0x15b573eb
0802942c  int32_t data_802942c = 0x3f613404
08029430  int32_t data_8029430 = 0x1ff2e48f
08029434  int32_t data_8029434 = 0x3feb6fd2
08029438  int32_t data_8029438 = 0x3afb7e91
0802943c  int32_t data_802943c = -0x3ff23190
08029440  int32_t data_8029440 = 0x4d551d69
08029444  int32_t data_8029444 = 0x3eff7510
08029448  int32_t data_8029448 = 0x23a29c78
0802944c  int32_t data_802944c = 0x3feffcb9
08029450  int32_t data_8029450 = 0x5f6fd220
08029454  int32_t data_8029454 = 0x3f99ce07
08029458  int32_t data_8029458 = 0x2000e360
0802945c  int32_t data_802945c = 0x803beb0
08029460  int32_t data_8029460 = 0x2000e364
08029464  int32_t data_8029464 = 0x803bcc0
08029468    uint32_t sub_8029468(char* arg1, int32_t arg2)
08029468  {
0802946a      uint32_t r2 = 0;
0802946a      
0802946c      while (true)
0802946c      {
0802946c          int32_t r3_1 = arg2;
0802946e          arg2 = r3_1 - 1;
0802946e          
08029474          if (!(uint32_t)(uint16_t)r3_1)
08029474              break;
08029474          
08029478          r2 ^= (uint32_t)*(uint8_t*)arg1;
0802947a          arg1 = &arg1[1];
0802947c          char r3_4 = 0;
0802947c          
08029486          while (true)
08029486          {
08029486              uint32_t r3_5 = (uint32_t)r3_4;
08029486              
0802948a              if (r3_5 >= 8)
0802948a                  break;
0802948a              
0802948e              r2 = r2 << 0x1f >= 0 ? (uint32_t)(uint8_t)r2 >> 1
0802948e                  : (uint32_t)(uint8_t)r2 >> 1 ^ 0x8c;
0802948e              
08029484              r3_4 = (uint8_t)r3_5 + 1;
08029486          }
0802946c      }
0802946c      
080294a0      return (uint32_t)(uint8_t)r2;
08029468  }
080294a2        00 00                                                                                        ..
080294a4    BaseType_t rtos_xTaskCreate(TaskFunction_t pvTaskCode, char const* pcName, uint32_t uxStackDepthWords, void* pvParameters, UBaseType_t uxPriority, TaskHandle_t* pxCreatedTask)
080294a4  {
080294b2      uint32_t r6_1 = (uint32_t)(uint16_t)uxStackDepthWords;
080294b6      void* r0_1 = sub_8032108(r6_1 << 2);
080294c0      void** r8;
080294c0      
080294c0      if (!r0_1)
080294de          r8 = nullptr;
080294c0      else
080294c0      {
080294c8          r8 = sub_8032108(0x5c);
080294c8          
080294ce          if (!r8)
080294d8              sub_8032214(r0_1);
080294ce          else
080294d0              r8[0xc] = r0_1;
080294c0      }
080294c0      
080294e6      if (!r8)
08029510          return 0xffffffff;
08029510      
080294ea      int32_t var_24_1 = 0;
08029502      sub_802951a(pvTaskCode, pcName, (uint32_t)(uint16_t)r6_1, pvParameters, uxPriority, 
08029502          pxCreatedTask, r8);
08029508      sub_80295e0(r8);
0802950c      return 1;
080294a4  }
0802951a    int32_t sub_802951a(int32_t arg1, char* arg2, int32_t arg3, int32_t arg4, int32_t arg5, void** arg6, void** arg7)
0802951a  {
08029528      if (!arg2)
08029528      {
0802952c          __msr(basepri, 0x20);
08029530          __dsb_SY();
08029534          __isb();
08029534          
08029538          while (true)
08029538              /* nop */
08029538          
08029538          return;
08029528      }
08029528      
08029548      memset16x2(arg7[0xc], arg3 << 2, 0xa5);
0802955a      uint32_t r8_3 = (arg7[0xc] + (arg3 << 2) - 4) >> 3 << 3;
0802955a      
08029564      if (!(r8_3 & 7))
08029564      {
0802957e          for (int32_t i = 0; i < 0x10; i += 1)
0802957e          {
08029586              *(uint8_t*)((char*)arg7 + i + 0x34) = arg2[i];
08029586              
0802958e              if (!(uint32_t)arg2[i])
0802958e                  break;
0802957e          }
0802957e          
08029592          *(uint8_t*)((char*)arg7 + 0x43) = 0;
08029596          int32_t r7_1 = arg5;
08029596          
0802959a          if (r7_1 >= 8)
0802959c              r7_1 = 7;
0802959c          
0802959e          arg7[0xb] = r7_1;
080295a0          arg7[0x13] = r7_1;
080295a4          arg7[0x14] = 0;
080295a8          sub_8032386(&arg7[1]);
080295b0          sub_8032386(&arg7[6]);
080295b4          arg7[4] = arg7;
080295ba          arg7[6] = 8 - r7_1;
080295bc          arg7[9] = arg7;
080295c0          arg7[0x15] = 0;
080295c4          arg7[0x16] = 0;
080295d2          *(uint32_t*)arg7 = sub_8032400(r8_3, arg1, arg4);
080295d2          
080295d8          if (arg6)
080295da              *(uint32_t*)arg6 = arg7;
080295da          
080295dc          return arg4;
08029564      }
08029564      
08029568      __msr(basepri, 0x20);
0802956c      __dsb_SY();
08029570      __isb();
08029570      
08029574      while (true)
08029574          /* nop */
0802951a  }
080295e0    int32_t sub_80295e0(void* arg1)
080295e0  {
080295e4      sub_803253a();
080295f4      data_2000e39c += 1;
080295f4      
080295fe      if (!data_2000e38c)
080295fe      {
08029604          data_2000e38c = arg1;
08029604          
0802960e          if (data_2000e39c == 1)
08029610              sub_8029c6c();
080295fe      }
080295fe      else if (!data_2000e3a8
080295fe              && *(uint32_t*)((char*)arg1 + 0x2c) >= *(uint32_t*)(data_2000e38c + 0x2c))
08029632          data_2000e38c = arg1;
08029632      
08029640      data_2000e3b8 += 1;
08029648      *(uint32_t*)((char*)arg1 + 0x44) = data_2000e3b8;
0802965c      data_2000e3a4 |= 1 << *(uint32_t*)((char*)arg1 + 0x2c);
0802966c      sub_803238c(&(&data_2000dde0)[*(uint32_t*)((char*)arg1 + 0x2c) * 5], (char*)arg1 + 4);
08029670      sub_8032574();
08029678      int32_t result = data_2000e3a8;
08029678      
0802967c      if (result)
0802967c      {
08029684          result = *(uint32_t*)(data_2000e38c + 0x2c);
08029684          
0802968a          if (result < *(uint32_t*)((char*)arg1 + 0x2c))
0802968a          {
0802968c              result = 0x10000000;
08029694              *(uint32_t*)0xe000ed04 = 0x10000000;
08029696              __dsb_SY();
0802969a              __isb();
0802968a          }
0802967c      }
0802967c      
0802969e      return result;
080295e0  }
080296a0    int32_t sub_80296a0(void* arg1)
080296a0  {
080296a2      void* r4 = arg1;
080296a4      sub_803253a();
080296a4      
080296aa      if (!r4)
080296b0          r4 = data_2000e38c;
080296b0      
080296cc      if (!sub_80323da((char*)r4 + 4)
080296cc              && !(&data_2000dde0)[*(uint32_t*)((char*)r4 + 0x2c) * 5])
080296e0          data_2000e3a4 &= ~(1 << *(uint32_t*)((char*)r4 + 0x2c));
080296e0      
080296e6      if (*(uint32_t*)((char*)r4 + 0x28))
080296ec          sub_80323da((char*)r4 + 0x18);
080296ec      
080296fc      data_2000e3b8 += 1;
080296fc      
08029706      if (r4 != data_2000e38c)
08029706      {
0802972e          data_2000e39c -= 1;
08029732          sub_8029d0c(r4);
08029736          sub_8029d1e();
08029706      }
08029706      else
08029706      {
0802970e          sub_803238c(0x2000e1d4, (char*)r4 + 4);
0802971e          data_2000e398 += 1;
08029706      }
08029706      
0802973a      sub_8032574();
08029742      int32_t result = data_2000e3a8;
08029742      
08029746      if (result)
08029746      {
0802974c          result = data_2000e38c;
0802974c          
08029750          if (r4 == result)
08029750          {
0802975a              if (!data_2000e3c4)
0802975a              {
0802976c                  result = 0x10000000;
08029774                  *(uint32_t*)0xe000ed04 = 0x10000000;
08029776                  __dsb_SY();
0802977a                  __isb();
0802975a              }
0802975a              else
0802975a              {
0802975e                  __msr(basepri, 0x20);
08029762                  __dsb_SY();
08029766                  __isb();
08029766                  
0802976a                  while (true)
0802976a                      /* nop */
0802975a              }
08029750          }
08029746      }
08029746      
0802977e      return result;
080296a0  }
08029780    int32_t rtos_delay_ticks(int32_t arg1)
08029780  {
08029784      int32_t result = 0;
08029784      
08029788      if (arg1)
08029788      {
08029792          if (!data_2000e3c4)
08029792          {
080297a4              sub_8029834();
080297ac              sub_8029fdc(arg1, 0);
080297b0              result = sub_8029844();
08029792          }
08029792          else
08029792          {
08029796              __msr(basepri, 0x20);
0802979a              __dsb_SY();
0802979e              __isb();
0802979e              
080297a2              while (true)
080297a2                  /* nop */
08029792          }
08029788      }
08029788      
080297b6      if (!result)
080297b6      {
080297b8          result = 0x10000000;
080297c0          *(uint32_t*)0xe000ed04 = 0x10000000;
080297c2          __dsb_SY();
080297c6          __isb();
080297b6      }
080297b6      
080297ca      return result;
08029780  }
080297cc    void rtos_vTaskStartScheduler()
080297cc  {
080297e8      BaseType_t r0 = rtos_xTaskCreate(sub_8029c48, "IDLE", 0x200, nullptr, 0, 0x2000e3c0);
080297e8      
080297ee      if (r0 == 1)
080297ee      {
080297f2          __msr(basepri, 0x20);
080297f6          __dsb_SY();
080297fa          __isb();
08029806          data_2000e3bc = 0xffffffff;
0802980e          data_2000e3a8 = 1;
08029816          data_2000e3a0 = 0;
08029818          sub_8032452();
080297ee      }
080297ee      else if (r0 == 0xffffffff)
08029822      {
08029826          __msr(basepri, 0x20);
0802982a          __dsb_SY();
0802982e          __isb();
0802982e          
08029832          while (true)
08029832              /* nop */
08029822      }
080297cc  }
08029834    int32_t sub_8029834()
08029834  {
0802983a      int32_t result = data_2000e3c4 + 1;
08029840      data_2000e3c4 = result;
08029842      return result;
08029834  }
08029844    int32_t sub_8029844()
08029844  {
08029844      int32_t r3;
08029844      int32_t var_10 = r3;
08029846      void* r5 = nullptr;
08029848      int32_t result = 0;
08029848      
08029852      if (data_2000e3c4)
08029852      {
08029864          sub_803253a();
08029874          data_2000e3c4 -= 1;
08029874          
08029888          if (!data_2000e3c4 && data_2000e39c)
08029888          {
080298e6              while (data_2000e1c0)
080298e6              {
08029892                  r5 = *(uint32_t*)(data_2000e1cc + 0xc);
08029898                  sub_80323da((char*)r5 + 0x18);
0802989e                  sub_80323da((char*)r5 + 4);
080298b4                  data_2000e3a4 |= 1 << *(uint32_t*)((char*)r5 + 0x2c);
080298c4                  sub_803238c(&(&data_2000dde0)[*(uint32_t*)((char*)r5 + 0x2c) * 5], 
080298c4                      (char*)r5 + 4);
080298c4                  
080298d4                  if (*(uint32_t*)((char*)r5 + 0x2c) >= *(uint32_t*)(data_2000e38c + 0x2c))
080298dc                      data_2000e3b0 = 1;
080298e6              }
080298e6              
080298ea              if (r5)
080298ec                  sub_8029d1e();
080298ec              
080298f4              int32_t i = data_2000e3ac;
080298f4              
080298f8              if (i)
080298f8              {
0802990e                  do
0802990e                  {
08029900                      if (sub_8029946())
08029908                          data_2000e3b0 = 1;
08029908                      
0802990a                      i -= 1;
0802990e                  } while (i);
0802990e                  
08029916                  data_2000e3ac = 0;
080298f8              }
080298f8              
08029920              if (data_2000e3b0)
08029920              {
08029922                  result = 1;
0802992c                  *(uint32_t*)0xe000ed04 = 0x10000000;
0802992e                  __dsb_SY();
08029932                  __isb();
08029920              }
08029888          }
08029888          
08029936          sub_8032574();
0802993c          return result;
08029852      }
08029852      
08029856      __msr(basepri, 0x20);
0802985a      __dsb_SY();
0802985e      __isb();
0802985e      
08029862      while (true)
08029862          /* nop */
08029844  }
0802993e    int32_t TickType_t xTaskGetTickCount(void)()
0802993e  {
08029944      return data_2000e3a0;
0802993e  }
08029946    int32_t sub_8029946()
08029946  {
08029948      int32_t result = 0;
08029948      
08029950      if (data_2000e3c4)
08029a40          data_2000e3ac += 1;
08029950      else
08029950      {
08029956          int32_t r5_1 = data_2000e3a0 + 1;
0802995a          data_2000e3a0 = r5_1;
0802995a          
0802995e          if (!r5_1)
0802995e          {
0802996a              if (!**(uint32_t**)&data_2000e390)
0802996a              {
08029980                  int32_t r0_4 = data_2000e390;
0802998c                  data_2000e390 = data_2000e394;
08029992                  data_2000e394 = r0_4;
080299a0                  data_2000e3b4 += 1;
080299a2                  sub_8029d1e();
0802996a              }
0802996a              else
0802996a              {
0802996e                  __msr(basepri, 0x20);
08029972                  __dsb_SY();
08029976                  __isb();
08029976                  
0802997a                  while (true)
0802997a                      /* nop */
0802996a              }
0802995e          }
0802995e          
080299ae          if (r5_1 >= data_2000e3bc)
080299ae          {
080299fc              while (true)
080299fc              {
080299fc                  if (!**(uint32_t**)&data_2000e390)
080299fc                  {
08029a06                      data_2000e3bc = 0xffffffff;
08029a08                      break;
080299fc                  }
080299fc                  
08029a10                  void* r6_1 = *(uint32_t*)(*(uint32_t*)(data_2000e390 + 0xc) + 0xc);
08029a12                  int32_t r0_19 = *(uint32_t*)((char*)r6_1 + 4);
08029a12                  
08029a16                  if (r5_1 < r0_19)
08029a16                  {
08029a1c                      data_2000e3bc = r0_19;
08029a1c                      break;
08029a16                  }
08029a16                  
080299b4                  sub_80323da((char*)r6_1 + 4);
080299b4                  
080299bc                  if (*(uint32_t*)((char*)r6_1 + 0x28))
080299c2                      sub_80323da((char*)r6_1 + 0x18);
080299c2                  
080299d4                  data_2000e3a4 |= 1 << *(uint32_t*)((char*)r6_1 + 0x2c);
080299e2                  sub_803238c(&(&data_2000dde0)[*(uint32_t*)((char*)r6_1 + 0x2c) * 5], 
080299e2                      (char*)r6_1 + 4);
080299e2                  
080299f0                  if (*(uint32_t*)((char*)r6_1 + 0x2c)
080299f0                          >= *(uint32_t*)(data_2000e38c + 0x2c))
080299f2                      result = 1;
080299fc              }
080299ae          }
080299ae          
08029a2e          if ((&data_2000dde0)[*(uint32_t*)(data_2000e38c + 0x2c) * 5] >= 2)
08029a30              result = 1;
08029950      }
08029950      
08029a4a      if (!data_2000e3b0)
08029a50          return result;
08029a50      
08029a4c      return 1;
08029946  }
08029a52                                                        00 00                                                        ..
08029a54  int32_t data_8029a54 = 0x2000e39c
08029a58    int32_t sub_8029a58()
08029a58  {
08029a5e      int32_t result;
08029a5e      
08029a5e      if (!data_2000e3c4)
08029a5e      {
08029a70          data_2000e3b0 = 0;
08029a7a          int32_t r0_3 = 0x1f - __clz(data_2000e3a4);
08029a7a          
08029a8a          if ((&data_2000dde0)[r0_3 * 5])
08029a8a          {
08029aa8              (&data_2000dde4)[r0_3 * 5] = *(uint32_t*)((&data_2000dde4)[r0_3 * 5] + 4);
08029aa8              
08029ab2              if ((&data_2000dde4)[r0_3 * 5] == 0x14 * r0_3 + 0x2000dde8)
08029ab8                  (&data_2000dde4)[r0_3 * 5] = *(uint32_t*)((&data_2000dde4)[r0_3 * 5] + 4);
08029ab8              
08029abc              result = *(uint32_t*)((&data_2000dde4)[r0_3 * 5] + 0xc);
08029ac0              data_2000e38c = result;
08029a8a          }
08029a8a          else
08029a8a          {
08029a8e              __msr(basepri, 0x20);
08029a92              __dsb_SY();
08029a96              __isb();
08029a96              
08029a9a              while (true)
08029a9a                  /* nop */
08029a8a          }
08029a5e      }
08029a5e      else
08029a5e      {
08029a60          result = 1;
08029a66          data_2000e3b0 = 1;
08029a5e      }
08029a5e      
08029ac2      return result;
08029a58  }
08029ac4  int32_t data_8029ac4 = 0x2000e38c
08029ac8    void* sub_8029ac8(int32_t* arg1, int32_t arg2)
08029ac8  {
08029ace      if (arg1)
08029ace      {
08029ae8          sub_80323a4(arg1, data_2000e38c + 0x18);
08029af4          return sub_8029fdc(arg2, 1);
08029ace      }
08029ace      
08029ad2      __msr(basepri, 0x20);
08029ad6      __dsb_SY();
08029ada      __isb();
08029ada      
08029ade      while (true)
08029ade          /* nop */
08029ac8  }
08029af6                                                                    00 00                                                ..
08029af8  int32_t data_8029af8 = 0x2000e3a8
08029afc  int32_t data_8029afc = 0x2000e3b8
08029b00  int32_t data_8029b00 = 0x2000e3a4
08029b04  int32_t data_8029b04 = 0x2000dde0
08029b08    int32_t sub_8029b08(void* arg1)
08029b08  {
08029b0c      void* r4 = *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0xc) + 0xc);
08029b0c      
08029b10      if (r4)
08029b10      {
08029b26          sub_80323da((char*)r4 + 0x18);
08029b26          
08029b30          if (data_2000e3c4)
08029b68              sub_803238c(&data_2000e1c0, (char*)r4 + 0x18);
08029b30          else
08029b30          {
08029b34              sub_80323da((char*)r4 + 4);
08029b4a              data_2000e3a4 |= 1 << *(uint32_t*)((char*)r4 + 0x2c);
08029b5a              sub_803238c(&(&data_2000dde0)[*(uint32_t*)((char*)r4 + 0x2c) * 5], 
08029b5a                  (char*)r4 + 4);
08029b30          }
08029b30          
08029b78          if (*(uint32_t*)(data_2000e38c + 0x2c) >= *(uint32_t*)((char*)r4 + 0x2c))
08029b86              return 0;
08029b86          
08029b82          data_2000e3b0 = 1;
08029b88          return 1;
08029b10      }
08029b10      
08029b14      __msr(basepri, 0x20);
08029b18      __dsb_SY();
08029b1c      __isb();
08029b1c      
08029b20      while (true)
08029b20          /* nop */
08029b08  }
08029b8a                                00 00                                                                        ..
08029b8c  int32_t data_8029b8c = 0x2000e1d4
08029b90  int32_t data_8029b90 = 0x2000e398
08029b94  int32_t data_8029b94 = 0x2000e3c4
08029b98  int32_t data_8029b98 = 0x2000e3a0
08029b9c    void sub_8029b9c(int32_t* arg1)
08029b9c  {
08029ba2      *(uint32_t*)arg1 = data_2000e3b4;
08029baa      arg1[1] = data_2000e3a0;
08029b9c  }
08029bae                                            00 00                                                                ..
08029bb0  int32_t data_8029bb0 = -0x1fff12fc
08029bb4    int32_t sub_8029bb4(int32_t* arg1, int32_t* arg2)
08029bb4  {
08029bb4      int32_t r3;
08029bb4      int32_t var_10 = r3;
08029bb4      
08029bbc      if (!arg1)
08029bbc      {
08029bc0          __msr(basepri, 0x20);
08029bc4          __dsb_SY();
08029bc8          __isb();
08029bc8          
08029bcc          while (true)
08029bcc              /* nop */
08029bcc          
08029bcc          return;
08029bbc      }
08029bbc      
08029bd0      if (arg2)
08029bd0      {
08029be2          sub_803253a();
08029bea          int32_t r0 = data_2000e3a0;
08029bee          int32_t r1_1 = r0 - arg1[1];
08029bf6          int32_t result;
08029bf6          
08029bf6          if (*(uint32_t*)arg2 == 0xffffffff)
08029bf8              result = 0;
08029bf6          else if (data_2000e3b4 != *(uint32_t*)arg1 && r0 >= arg1[1])
08029c0e              result = 1;
08029c0c          else if (r1_1 >= *(uint32_t*)arg2)
08029c16          {
08029c2a              *(uint32_t*)arg2 = 0;
08029c2c              result = 1;
08029c16          }
08029c16          else
08029c16          {
08029c1c              *(uint32_t*)arg2 -= r1_1;
08029c20              sub_8029b9c(arg1);
08029c24              result = 0;
08029c16          }
08029c16          
08029c2e          sub_8032574();
08029c34          return result;
08029bd0      }
08029bd0      
08029bd4      __msr(basepri, 0x20);
08029bd8      __dsb_SY();
08029bdc      __isb();
08029bdc      
08029be0      while (true)
08029be0          /* nop */
08029bb4  }
08029c36    int32_t sub_8029c36()
08029c36  {
08029c3c      data_2000e3b0 = 1;
08029c3e      return 1;
08029c36  }
08029c40  int32_t data_8029c40 = 0x2000e390
08029c44  int32_t data_8029c44 = 0x2000e394
08029c48    void sub_8029c48() __noreturn
08029c48  {
08029c4a      while (true)
08029c4a      {
08029c4a          sub_8029cc4();
08029c4a          
08029c56          if (data_2000dde0 >= 2)
08029c56          {
08029c60              *(uint32_t*)0xe000ed04 = 0x10000000;
08029c62              __dsb_SY();
08029c66              __isb();
08029c56          }
08029c4a      }
08029c48  }
08029c6c    int32_t sub_8029c6c()
08029c6c  {
08029c86      for (int32_t i = 0; i < 8; i += 1)
08029c7e          sub_8032368(&(&data_2000dde0)[i * 5]);
08029c7e      
08029c8c      sub_8032368(0x2000e198);
08029c94      sub_8032368(0x2000e1ac);
08029c9a      sub_8032368(&data_2000e1c0);
08029ca2      sub_8032368(0x2000e1d4);
08029caa      sub_8032368(&data_2000e1e8);
08029cb6      data_2000e390 = 0x2000e198;
08029cc0      data_2000e394 = 0x2000e1ac;
08029cc2      return 0x2000e1ac;
08029c6c  }
08029cc4    int32_t sub_8029cc4()
08029cc4  {
08029d04      int32_t result;
08029d04      
08029d04      while (true)
08029d04      {
08029d04          result = data_2000e398;
08029d04          
08029d08          if (!result)
08029d08              break;
08029d08          
08029cc8          sub_803253a();
08029cd2          void* r4_1 = *(uint32_t*)(data_2000e1e0 + 0xc);
08029cd6          sub_80323da((char*)r4_1 + 4);
08029ce6          data_2000e39c -= 1;
08029cf4          data_2000e398 -= 1;
08029cf6          sub_8032574();
08029cfc          sub_8029d0c(r4_1);
08029d04      }
08029d04      
08029d0a      return result;
08029cc4  }
08029d0c    int32_t sub_8029d0c(void* arg1)
08029d0c  {
08029d12      sub_8032214(*(uint32_t*)((char*)arg1 + 0x30));
08029d1c      return sub_8032214(arg1);
08029d0c  }
08029d1e    int32_t sub_8029d1e()
08029d1e  {
08029d28      int32_t result;
08029d28      
08029d28      if (**(uint32_t**)&data_2000e390)
08029d28      {
08029d3e          result = *(uint32_t*)(*(uint32_t*)(*(uint32_t*)(data_2000e390 + 0xc) + 0xc) + 4);
08029d42          data_2000e3bc = result;
08029d28      }
08029d28      else
08029d28      {
08029d2a          result = 0xffffffff;
08029d30          data_2000e3bc = 0xffffffff;
08029d28      }
08029d28      
08029d44      return result;
08029d1e  }
08029d46    int32_t sub_8029d46()
08029d46  {
08029d4e      if (!data_2000e3a8)
08029d50          return 1;
08029d50      
08029d5c      if (data_2000e3c4)
08029d62          return 0;
08029d62      
08029d5e      return 2;
08029d46  }
08029d66    int32_t sub_8029d66(void* arg1)
08029d66  {
08029d6e      if (arg1)
08029d6e      {
08029d7c          if (*(uint32_t*)((char*)arg1 + 0x2c) < *(uint32_t*)(data_2000e38c + 0x2c))
08029d7c          {
08029d82              if (*(uint32_t*)((char*)arg1 + 0x18) >= 0)
08029d90                  *(uint32_t*)((char*)arg1 + 0x18) = 8 - *(uint32_t*)(data_2000e38c + 0x2c);
08029d90              
08029da2              if (*(uint32_t*)((char*)arg1 + 0x14) !=
08029da2                      &(&data_2000dde0)[*(uint32_t*)((char*)arg1 + 0x2c) * 5])
08029e0c                  *(uint32_t*)((char*)arg1 + 0x2c) = *(uint32_t*)(data_2000e38c + 0x2c);
08029da2              else
08029da2              {
08029dbc                  if (!sub_80323da((char*)arg1 + 4)
08029dbc                          && !(&data_2000dde0)[*(uint32_t*)((char*)arg1 + 0x2c) * 5])
08029dd0                      data_2000e3a4 &= ~(1 << *(uint32_t*)((char*)arg1 + 0x2c));
08029dd0                  
08029dda                  *(uint32_t*)((char*)arg1 + 0x2c) = *(uint32_t*)(data_2000e38c + 0x2c);
08029dee                  data_2000e3a4 |= 1 << *(uint32_t*)((char*)arg1 + 0x2c);
08029dfe                  sub_803238c(&(&data_2000dde0)[*(uint32_t*)((char*)arg1 + 0x2c) * 5], 
08029dfe                      (char*)arg1 + 4);
08029da2              }
08029da2              
08029e0e              return 1;
08029d7c          }
08029d7c          
08029e1e          if (*(uint32_t*)((char*)arg1 + 0x4c) < *(uint32_t*)(data_2000e38c + 0x2c))
08029e20              return 1;
08029d6e      }
08029d6e      
08029e22      return 0;
08029d66  }
08029e24    int32_t sub_8029e24(void* arg1)
08029e24  {
08029e2c      if (arg1)
08029e2c      {
08029e36          if (arg1 != data_2000e38c)
08029e36          {
08029e3a              __msr(basepri, 0x20);
08029e3e              __dsb_SY();
08029e42              __isb();
08029e42              
08029e46              while (true)
08029e46                  /* nop */
08029e36          }
08029e36          else if (*(uint32_t*)((char*)arg1 + 0x50))
08029e4c          {
08029e62              *(uint32_t*)((char*)arg1 + 0x50) -= 1;
08029e62              
08029e70              if (*(uint32_t*)((char*)arg1 + 0x2c) != *(uint32_t*)((char*)arg1 + 0x4c)
08029e70                  && !*(uint32_t*)((char*)arg1 + 0x50))
08029e70              {
08029e8a                  if (!sub_80323da((char*)arg1 + 4)
08029e8a                          && !(&data_2000dde0)[*(uint32_t*)((char*)arg1 + 0x2c) * 5])
08029e9e                      data_2000e3a4 &= ~(1 << *(uint32_t*)((char*)arg1 + 0x2c));
08029e9e                  
08029ea2                  *(uint32_t*)((char*)arg1 + 0x2c) = *(uint32_t*)((char*)arg1 + 0x4c);
08029eaa                  *(uint32_t*)((char*)arg1 + 0x18) = 8 - *(uint32_t*)((char*)arg1 + 0x2c);
08029ebe                  data_2000e3a4 |= 1 << *(uint32_t*)((char*)arg1 + 0x2c);
08029ece                  sub_803238c(&(&data_2000dde0)[*(uint32_t*)((char*)arg1 + 0x2c) * 5], 
08029ece                      (char*)arg1 + 4);
08029ed2                  return 1;
08029e70              }
08029e4c          }
08029e4c          else
08029e4c          {
08029e50              __msr(basepri, 0x20);
08029e54              __dsb_SY();
08029e58              __isb();
08029e58              
08029e5c              while (true)
08029e5c                  /* nop */
08029e4c          }
08029e2c      }
08029e2c      
08029ed4      return 0;
08029e24  }
08029ed6                                                                    00 00                                                ..
08029ed8  int32_t data_8029ed8 = 0x2000e1c0
08029edc  int32_t data_8029edc = 0x2000e3c0
08029ee0  int32_t data_8029ee0 = 0x803c0b8
08029ee4  int32_t data_8029ee4 = 0x2000e3bc
08029ee8    int32_t* sub_8029ee8(void* arg1, int32_t arg2)
08029ee8  {
08029eec      int32_t* result = 1;
08029eec      
08029ef0      if (arg1)
08029ef0      {
08029ef6          if (*(uint32_t*)((char*)arg1 + 0x50))
08029ef6          {
08029f0c              if (*(uint32_t*)((char*)arg1 + 0x4c) >= arg2)
08029f0e                  arg2 = *(uint32_t*)((char*)arg1 + 0x4c);
08029f0e              
08029f1a              if (*(uint32_t*)((char*)arg1 + 0x2c) != arg2
08029f1a                  && *(uint32_t*)((char*)arg1 + 0x50) == 1)
08029f1a              {
08029f24                  if (arg1 != data_2000e38c)
08029f24                  {
08029f36                      int32_t r0_1 = *(uint32_t*)((char*)arg1 + 0x2c);
08029f38                      *(uint32_t*)((char*)arg1 + 0x2c) = arg2;
08029f38                      
08029f3e                      if (*(uint32_t*)((char*)arg1 + 0x18) >= 0)
08029f44                          *(uint32_t*)((char*)arg1 + 0x18) = 8 - arg2;
08029f44                      
08029f50                      result = &(&data_2000dde0)[r0_1 * 5];
08029f50                      
08029f54                      if (*(uint32_t*)((char*)arg1 + 0x14) == result)
08029f54                      {
08029f6e                          if (!sub_80323da((char*)arg1 + 4) &&
08029f6e                                  !(&data_2000dde0)[*(uint32_t*)((char*)arg1 + 0x2c) * 5])
08029f82                              data_2000e3a4 &= ~(1 << *(uint32_t*)((char*)arg1 + 0x2c));
08029f82                          
08029f96                          data_2000e3a4 |= 1 << *(uint32_t*)((char*)arg1 + 0x2c);
08029fa4                          result = &(&data_2000dde0)[*(uint32_t*)((char*)arg1 + 0x2c) * 5];
08029fa6                          sub_803238c(result, (char*)arg1 + 4);
08029f54                      }
08029f24                  }
08029f24                  else
08029f24                  {
08029f28                      __msr(basepri, 0x20);
08029f2c                      __dsb_SY();
08029f30                      __isb();
08029f30                      
08029f34                      while (true)
08029f34                          /* nop */
08029f24                  }
08029f1a              }
08029ef6          }
08029ef6          else
08029ef6          {
08029efa              __msr(basepri, 0x20);
08029efe              __dsb_SY();
08029f02              __isb();
08029f02              
08029f06              while (true)
08029f06                  /* nop */
08029ef6          }
08029ef0      }
08029ef0      
08029faa      return result;
08029ee8  }
08029fac    int32_t sub_8029fac()
08029fac  {
08029fb4      if (data_2000e38c)
08029fb4      {
08029fba          void* r0_1 = data_2000e38c;
08029fc0          *(uint32_t*)((char*)r0_1 + 0x50) += 1;
08029fb4      }
08029fb4      
08029fc8      return data_2000e38c;
08029fac  }
08029fca                                00 00                                                                        ..
08029fcc  int32_t data_8029fcc = 0x2000e3ac
08029fd0  int32_t data_8029fd0 = 0x2000e3b0
08029fd4  int32_t data_8029fd4 = 0x2000e3b4
08029fd8  int32_t data_8029fd8 = 0x2000e3b0
08029fdc    void* sub_8029fdc(int32_t arg1, int32_t arg2)
08029fdc  {
08029fe4      int32_t r6 = data_2000e3a0;
08029fe4      
08029ff2      if (!sub_80323da(data_2000e38c + 4))
0802a00a          data_2000e3a4 &= ~(1 << *(uint32_t*)(data_2000e38c + 0x2c));
0802a00a      
0802a014      void* result;
0802a014      
0802a014      if (arg1 != 0xffffffff || !arg2)
0802a014      {
0802a024          int32_t r4_1 = arg1 + r6;
0802a02a          *(uint32_t*)(data_2000e38c + 4) = r4_1;
0802a02a          
0802a02e          if (r4_1 >= r6)
0802a02e          {
0802a04a              sub_80323a4(data_2000e390, data_2000e38c + 4);
0802a050              result = data_2000e3bc;
0802a050              
0802a054              if (r4_1 < result)
0802a054              {
0802a056                  result = &data_2000e3bc;
0802a058                  data_2000e3bc = r4_1;
0802a054              }
0802a02e          }
0802a02e          else
0802a02e          {
0802a038              result = data_2000e394;
0802a03a              sub_80323a4(result, data_2000e38c + 4);
0802a02e          }
0802a014      }
0802a014      else
0802a014      {
0802a01c          result = &data_2000e1e8;
0802a01e          sub_803238c(&data_2000e1e8, data_2000e38c + 4);
0802a014      }
0802a014      
0802a05a      return result;
08029fdc  }
0802a05c  int32_t data_802a05c = 0x2000e38c
0802a060  int32_t data_802a060 = 0x2000e3a4
0802a064  int32_t data_802a064 = 0x2000dde0
0802a068  int32_t data_802a068 = 0x2000e3c4
0802a06c  int32_t data_802a06c = 0x2000e3a0
0802a070  int32_t data_802a070 = -0x1fff12fc
0802a074  int32_t data_802a074 = 0x2000e198
0802a078  int32_t data_802a078 = 0x2000e1ac
0802a07c  int32_t data_802a07c = 0x2000e1d4
0802a080  int32_t data_802a080 = 0x2000e1e8
0802a084  int32_t data_802a084 = 0x2000e390
0802a088  int32_t data_802a088 = 0x2000e394
0802a08c  int32_t data_802a08c = 0x2000e39c
0802a090  int32_t data_802a090 = 0x2000e398
0802a094  int32_t data_802a094 = 0x2000e3a8
0802a098  int32_t data_802a098 = 0x2000e3bc
0802a09c    uint32_t sub_802a09c()
0802a09c  {
0802a0a2      return (uint32_t)data_2000e2b8;
0802a09c  }
0802a0a4    int32_t sub_802a0a4()
0802a0a4  {
0802a0a4      int32_t r7;
0802a0a4      int32_t var_8 = r7;
0802a0a8      sub_802a2b6(1, r7);
0802a0ae      return 1;
0802a0a4  }
0802a0b0    int32_t sub_802a0b0()
0802a0b0  {
0802a0b0      int32_t r7;
0802a0b0      int32_t var_8 = r7;
0802a0be      gpio_config_af(&GPIOA, 0x8000, 0xc00, 2);
0802a0c4      sub_802a0d8(0, r7);
0802a0ca      return 1;
0802a0b0  }
0802a0cc    void sub_802a0cc(char arg1)
0802a0cc  {
0802a0ce      data_2000e450 = arg1;
0802a0cc  }
0802a0d2    uint32_t sub_802a0d2()
0802a0d2  {
0802a0d6      return (uint32_t)data_2000e450;
0802a0d2  }
0802a0d8    int32_t sub_802a0d8(char arg1, int32_t arg2 @ r7)
0802a0d8  {
0802a0de      if ((uint32_t)arg1 != 1)
0802a0de      {
0802a0fc          gpio_write(&GPIOA, 0x8000, false);
0802a102          sub_802a0cc(0);
0802a0de      }
0802a0de      else
0802a0de      {
0802a0e8          gpio_write(&GPIOA, 0x8000, true);
0802a0ee          sub_802a0cc(1);
0802a0de      }
0802a0de      
0802a106      return arg2;
0802a0d8  }
0802a108    int32_t sub_802a108(int128_t arg1 @ q4)
0802a108  {
0802a10a      int64_t var_10 = (uint64_t)arg1;
0802a10a      int64_t var_18 = *(uint64_t*)((char*)arg1)[8];
0802a112      int32_t r7;
0802a112      *(uint32_t*)((char*)arg1)[4] = sub_802a324(r7);
0802a11a      (uint32_t)arg1 = sub_8028bc6();
0802a122      float32_process((uint32_t)arg1);
0802a12c      logging_wrapper("[BV]: %.2f \r\n");
0802a134      *(uint32_t*)((char*)arg1)[8] = sub_8028bd8();
0802a13c      float32_process(*(uint32_t*)((char*)arg1)[8]);
0802a146      logging_wrapper("[UV]: %.2f \r\n");
0802a150      uint32_t r4_1 = (uint32_t)sub_802a09c();
0802a152      bool n = r4_1 - 4 < 0;
0802a152      bool v = r4_1 - 4;
0802a152      
0802a154      if (r4_1 != 4)
0802a154      {
0802a156          r4_1 = (uint32_t)(uint8_t)r4_1;
0802a158          n = r4_1 - 0xa < 0;
0802a158          v = r4_1 - 0xa;
0802a158          
0802a15a          if (r4_1 == 0xa)
0802a15a              goto label_802a162;
0802a15a          
0802a15c          r4_1 = (uint32_t)(uint8_t)r4_1;
0802a15e          n = r4_1 - 1 < 0;
0802a15e          v = r4_1 - 1;
0802a15e          
0802a160          if (r4_1 != 1)
0802a160              goto label_802a1ac;
0802a160          
0802a160          goto label_802a162;
0802a154      }
0802a154      
0802a162  label_802a162:
0802a162      int128_t q0_3;
0802a162      (uint32_t)q0_3 = 0xcccd4282;
0802a166      /* unimplemented  {vcmp.f32.F32 s17, s0} */
0802a16a      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802a16a      
0802a16e      if (n != v)
0802a16e      {
0802a170          (uint32_t)q0_3 = 0xc0a00000;
0802a174          /* unimplemented  {vcmp.f32.F32 s17, s0} */
0802a178          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802a16e      }
0802a16e      
0802a17c      if (n != v && !n)
0802a17c      {
0802a1a6          n = false;
0802a1aa          data_2000e44f = 0;
0802a1ac      label_802a1ac:
0802a1ac          (uint32_t)q0_3 = 0x3faccccd;
0802a1b0          /* unimplemented  {vcmp.f32.F32 s18, s0} */
0802a1b4          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802a1b4          
0802a1b8          if (n)
0802a1b8          {
0802a1ba              (uint32_t)q0_3 = 0x4194;
0802a1be              /* unimplemented  {vcmp.f32.F32 s16, s0} */
0802a1c2              /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802a1b8          }
0802a1b8          
0802a1c6          if (!n || n != v)
0802a1c6          {
0802a1f4              data_2000e451 = 0;
0802a1f6          label_802a1f6:
0802a1f6              uint32_t r4_2 = (uint32_t)(uint8_t)r4_1;
0802a1f6              
0802a1fc              if (r4_2 == 1)
0802a1fc              {
0802a25c                  (uint32_t)q0_3 = 0x41940001;
0802a260                  /* unimplemented  {vcmp.f32.F32 s16, s0} */
0802a264                  /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802a264                  
0802a268                  if (r4_2 - 1 >= 0)
0802a28e                      data_2000e44e = 0;
0802a268                  else
0802a268                  {
0802a272                      data_2000e44e += 1;
0802a272                      
0802a27a                      if ((uint32_t)data_2000e44e >= 0x14)
0802a27a                      {
0802a27e                          sub_802a2b6(4, r7);
0802a282                          sub_802a2a0();
0802a27a                      }
0802a268                  }
0802a1fc              }
0802a1fc              else
0802a1fc              {
0802a1fe                  bool cond:4_1 = r4_2 - 4 < 0;
0802a1fe                  bool cond:5_1 = r4_2 - 4 >= 0;
0802a1fe                  
0802a200                  if (r4_2 == 4)
0802a200                  {
0802a20c                  label_802a20c:
0802a20c                      logging_wrapper("BATTERY_LOW\r\n");
0802a210                      int128_t q0_4;
0802a210                      (uint32_t)q0_4 = 0x41840000;
0802a214                      /* unimplemented  {vcmp.f32.F32 s16, s0} */
0802a218                      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802a218                      
0802a21c                      if (cond:4_1)
0802a21c                      {
0802a230                          if ((uint32_t)(uint8_t)r4_2 != 0xa)
0802a230                              goto label_802a23a;
0802a230                          
0802a258                          data_2000e41c = 0;
0802a21c                      }
0802a21c                      else
0802a21c                      {
0802a21e                          (uint32_t)q0_4 = 0x13fac;
0802a222                          /* unimplemented  {vcmp.f32.F32 s18, s0} */
0802a226                          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802a226                          
0802a230                          if (cond:5_1 || (uint32_t)(uint8_t)r4_2 == 0xa)
0802a258                              data_2000e41c = 0;
0802a230                          else
0802a230                          {
0802a23a                          label_802a23a:
0802a23a                              data_2000e41c += 1;
0802a23a                              
0802a242                              if ((uint32_t)data_2000e41c >= 0x15)
0802a242                              {
0802a246                                  sub_802a2b6(0xa, r7);
0802a24e                                  data_2000e41c = 0;
0802a242                              }
0802a230                          }
0802a21c                      }
0802a200                  }
0802a200                  else if (r4_2 == 5)
0802a294                      logging_wrapper("BATTERY_WORKING_ERROR\r\n");
0802a204                  else
0802a204                  {
0802a206                      cond:4_1 = r4_2 - 0xa < 0;
0802a206                      cond:5_1 = r4_2 - 0xa >= 0;
0802a206                      
0802a208                      if (r4_2 == 0xa)
0802a208                          goto label_802a20c;
0802a204                  }
0802a1fc              }
0802a1c6          }
0802a1c6          else
0802a1c6          {
0802a1d0              data_2000e451 += 1;
0802a1d0              
0802a1d8              if ((uint32_t)data_2000e451 < 0x3c)
0802a1d8                  goto label_802a1f6;
0802a1d8              
0802a1da              motorBrake();
0802a1de              motorStop();
0802a1e4              sub_802a2b6(5, r7);
0802a1e8              sub_802a2a0();
0802a1c6          }
0802a17c      }
0802a17c      else
0802a17c      {
0802a186          data_2000e44f += 1;
0802a18a          uint32_t r0_5 = (uint32_t)data_2000e44f;
0802a18c          n = r0_5 - 0x3c < 0;
0802a18c          v = r0_5 - 0x3c;
0802a18c          
0802a18e          if (n != v)
0802a18e              goto label_802a1ac;
0802a18e          
0802a190          motorBrake();
0802a194          motorStop();
0802a19a          sub_802a2b6(5, r7);
0802a19e          sub_802a2a0();
0802a17c      }
0802a17c      
0802a29a      (uint64_t)arg1 = var_18;
0802a29a      *(uint64_t*)((char*)arg1)[8] = var_10;
0802a29e      return 1;
0802a108  }
0802a2a0    int32_t sub_802a2a0()
0802a2a0  {
0802a2a4      data_2000e44f = 0;
0802a2aa      data_2000e44e = 0;
0802a2b0      data_2000e451 = 0;
0802a2b4      return 1;
0802a2a0  }
0802a2b6    int32_t sub_802a2b6(char arg1, int32_t arg2 @ r7)
0802a2b6  {
0802a2c2      if ((uint32_t)data_2000e2b8 != (uint32_t)arg1)
0802a2c2      {
0802a2c6          data_2000e2b8 = arg1;
0802a2ca          uint32_t r0 = (uint32_t)data_2000e2b8;
0802a2ca          
0802a2ce          if (r0 == 1)
0802a2f4              sub_802ce1a(3);
0802a2ce          else if (r0 == 3)
0802a306              sub_802ce1a(1);
0802a2d4          else if (r0 >= 3)
0802a2d6          {
0802a2da              if (r0 == 5)
0802a2fc                  sub_802ce1a(6);
0802a2da              else if (r0 < 5)
0802a316                  sub_802ce1a(4);
0802a2dc              else if (r0 == 7)
0802a2f4                  sub_802ce1a(3);
0802a2e0              else if (r0 < 7)
0802a30e                  sub_802ce1a(6);
0802a2e2              else if (r0 != 9)
0802a2e6              {
0802a2e8                  if (r0 < 9)
0802a31e                      sub_802ce1a(2);
0802a2e8                  else if (r0 == 0xa)
0802a316                      sub_802ce1a(4);
0802a2e6              }
0802a2d6          }
0802a2c2      }
0802a2c2      
0802a322      return arg2;
0802a2b6  }
0802a324    int32_t sub_802a324(int32_t arg1 @ r7)
0802a324  {
0802a32c      data_2000e2bc = sub_8028be0();
0802a334      float32_process(data_2000e2bc);
0802a33e      logging_wrapper("[BT]:%.2f \r\n");
0802a344      int128_t q0_1;
0802a344      (uint32_t)q0_1 = data_2000e2bc;
0802a348      return arg1;
0802a324  }
0802a34a                                00 00 01 00                                                                  ....
0802a34e  int32_t data_802a34e = -0x3332bd7e
0802a352  int32_t data_802a352 = 0x13fac
0802a356  int32_t data_802a356 = 0x4194
0802a35a                                                                                84 41                                        .A
0802a35c  int32_t data_802a35c = 0x2000e2b8
0802a360  int32_t data_802a360 = 0x40020000
0802a364  int32_t data_802a364 = 0x2000e450
0802a368  int32_t data_802a368 = 0x803be50
0802a36c  int32_t data_802a36c = 0x803be60
0802a370  int32_t data_802a370 = 0x2000e44f
0802a374  int32_t data_802a374 = 0x2000e451
0802a378  int32_t data_802a378 = 0x803be70
0802a37c  int32_t data_802a37c = 0x2000e41c
0802a380  int32_t data_802a380 = 0x2000e44e
0802a384  int32_t data_802a384 = 0x803b9d4
0802a388  int32_t data_802a388 = 0x803be80
0802a38c    void memcpy_(char* arg1, char* arg2, int32_t arg3)
0802a38c  {
0802a38c      if (!arg3)
0802a38c          return;
0802a38c      
0802a390      while (arg2 << 0x1e)
0802a390      {
0802a392          int32_t temp1_1 = arg3;
0802a392          arg3 -= 1;
0802a394          char r3_2 = *(uint8_t*)arg2;
0802a394          arg2 = &arg2[1];
0802a398          *(uint8_t*)arg1 = r3_2;
0802a398          arg1 = &arg1[1];
0802a398          
0802a39c          if (temp1_1 == 1)
0802a3e8              return;
0802a390      }
0802a390      
0802a3a6      if (!(arg1 << 0x1e))
0802a3aa          /* tailcall */
0802a3aa          return memcpy(arg1, arg2, arg3);
0802a3aa      
0802a3ea      int32_t i_1 = arg3 - 8;
0802a3ea      
0802a3ec      if (arg3 >= 8)
0802a3ec      {
0802a3fc          int32_t i;
0802a3fc          
0802a3fc          do
0802a3fc          {
0802a3ee              int32_t r3_8 = *(uint32_t*)arg2;
0802a3ee              int32_t r12_2 = *(uint32_t*)(arg2 + 4);
0802a3ee              arg2 = &arg2[8];
0802a3f2              i = i_1;
0802a3f2              i_1 -= 8;
0802a3f4              *(uint32_t*)arg1 = r3_8;
0802a3f8              *(uint32_t*)(arg1 + 4) = r12_2;
0802a3f8              arg1 = &arg1[8];
0802a3fc          } while (i >= 8);
0802a3ec      }
0802a3ec      
0802a3cc      if (i_1 << 0x1d < 0)
0802a3cc      {
0802a3ce          int32_t r3_6 = *(uint32_t*)arg2;
0802a3ce          arg2 = &arg2[4];
0802a3d2          *(uint32_t*)arg1 = r3_6;
0802a3d2          arg1 = &arg1[4];
0802a3cc      }
0802a3cc      
0802a3d8      if (TEST_BIT(i_1, 1))
0802a3d8      {
0802a3da          int16_t r2_2 = *(uint16_t*)arg2;
0802a3da          arg2 = &arg2[2];
0802a3de          *(uint16_t*)arg1 = r2_2;
0802a3de          arg1 = &arg1[2];
0802a3d8      }
0802a3d8      
0802a3e2      if (i_1 << 0x1f < 0)
0802a3e6          *(uint8_t*)arg1 = *(uint8_t*)arg2;
0802a38c  }
0802a3ac    void memcpy(int32_t* arg1, int32_t* arg2, int32_t arg3)
0802a3ac  {
0802a3ac      int32_t i_1 = arg3 - 0x10;
0802a3ac      
0802a3ae      if (arg3 >= 0x10)
0802a3ae      {
0802a3bc          int32_t i;
0802a3bc          
0802a3bc          do
0802a3bc          {
0802a3b2              int32_t r3_1 = *(uint32_t*)arg2;
0802a3b2              int32_t r4_1 = arg2[1];
0802a3b2              int32_t r5_1 = arg2[2];
0802a3b2              int32_t r12_1 = arg2[3];
0802a3b2              arg2 = &arg2[4];
0802a3b6              i = i_1;
0802a3b6              i_1 -= 0x10;
0802a3b8              *(uint32_t*)arg1 = r3_1;
0802a3b8              arg1[1] = r4_1;
0802a3b8              arg1[2] = r5_1;
0802a3b8              arg1[3] = r12_1;
0802a3b8              arg1 = &arg1[4];
0802a3bc          } while (i >= 0x10);
0802a3ae      }
0802a3ae      
0802a3c2      if (TEST_BIT(i_1, 3))
0802a3c2      {
0802a3c4          int32_t r3_3 = *(uint32_t*)arg2;
0802a3c4          int32_t r12_2 = arg2[1];
0802a3c4          arg2 = &arg2[2];
0802a3c8          *(uint32_t*)arg1 = r3_3;
0802a3c8          arg1[1] = r12_2;
0802a3c8          arg1 = &arg1[2];
0802a3c2      }
0802a3c2      
0802a3cc      if (i_1 << 0x1d < 0)
0802a3cc      {
0802a3ce          int32_t r3_4 = *(uint32_t*)arg2;
0802a3ce          arg2 = &arg2[1];
0802a3d2          *(uint32_t*)arg1 = r3_4;
0802a3d2          arg1 = &arg1[1];
0802a3cc      }
0802a3cc      
0802a3d8      if (TEST_BIT(i_1, 1))
0802a3d8      {
0802a3da          int16_t r2_1 = *(uint16_t*)arg2;
0802a3da          arg2 += 2;
0802a3de          *(uint16_t*)arg1 = r2_1;
0802a3de          arg1 += 2;
0802a3d8      }
0802a3d8      
0802a3e2      if (i_1 << 0x1f < 0)
0802a3e6          *(uint8_t*)arg1 = *(uint8_t*)arg2;
0802a3ac  }
0802a402        00 00                                                                                        ..
0802a404    int32_t console_printf(char const* fmt, ...)
0802a404  {
0802a404      int32_t r3;
0802a404      int32_t var_4 = r3;
0802a404      int32_t r2;
0802a404      int32_t var_8 = r2;
0802a404      int32_t entry_r1;
0802a404      int32_t var_c = entry_r1;
0802a40c      int32_t* va_list_ptr = &var_c;
0802a420      return tiny_printf(&*(uint32_t*)((char*)console_putc_stateful->putc)[1], 1, fmt, 
0802a420          &va_list_ptr);
0802a404  }
0802a424  int32_t data_802a424 = 0x11671
0802a428    GPIO_TypeDef* sub_802a428()
0802a428  {
0802a436      int32_t var_20;
0802a436      memcpy(&var_20, 0x20000138, 0x18);
0802a43c      int32_t* var_1c;
0802a43c      int32_t var_18;
0802a43c      int32_t var_14;
0802a43c      GPIO_TypeDef* result;
0802a43c      int32_t var_c;
0802a43c      int32_t r7;
0802a43c      sub_803343e((int16_t)var_20, var_1c, var_18, var_14, r7, result, (uint16_t)var_c);
0802a44a      memcpy(&var_20, 0x20000150, 0x18);
0802a450      sub_803343e((int16_t)var_20, var_1c, var_18, var_14, r7);
0802a454      return result;
0802a428  }
0802a456                                                                    00 00                                                ..
0802a458    int32_t sub_802a458(char arg1, int32_t arg2 @ r5)
0802a458  {
0802a458      int32_t r7;
0802a458      int32_t var_8_1 = r7;
0802a458      int32_t r6;
0802a458      int32_t var_c = r6;
0802a474      uint32_t var_8 = (uint32_t)((float)(0xb580457f * -9.55696919e-07f));
0802a488      int32_t var_20;
0802a488      memcpy(&var_20, 0x20000138 + 0x18 * (uint32_t)arg1, 0x18);
0802a48e      int32_t* var_1c;
0802a48e      int32_t var_18;
0802a48e      int16_t var_14;
0802a48e      sub_803348a(var_20, var_1c, var_18, r7, var_14);
0802a492      return arg2;
0802a458  }
0802a494    int32_t sub_802a494(int32_t arg1 @ r7)
0802a494  {
0802a4ac      sub_8030026(data_20000168, (int16_t)data_20000170, data_20000178, 0);
0802a4c6      sub_8030026(data_2000016c, (int16_t)data_20000174, data_2000017a, 0);
0802a4ca      return arg1;
0802a494  }
0802a4cc    int32_t sub_802a4cc(char arg1)
0802a4cc  {
0802a4cc      int32_t r7;
0802a4cc      int32_t var_8 = r7;
0802a4d2      uint32_t r0 = (uint32_t)arg1;
0802a4e6      return sub_803004c((&data_20000168)[(uint32_t)(uint8_t)r0], (&data_20000170)[r0]);
0802a4cc  }
0802a4e8    void* sub_802a4e8()
0802a4e8  {
0802a4f6      int32_t* var_28;
0802a4f6      memcpy(&var_28, &data_20000098, 0x20);
0802a4fc      int32_t var_24;
0802a4fc      int32_t var_20;
0802a4fc      int32_t r7;
0802a4fc      sub_80334a0(var_28, var_24, var_20, r7);
0802a50a      memcpy(&var_28, &data_200000b8, 0x20);
0802a510      sub_80334a0(var_28, var_24, var_20, r7);
0802a51e      memcpy(&var_28, &data_200000d8, 0x20);
0802a524      sub_80334a0(var_28, var_24, var_20, r7);
0802a532      memcpy(&var_28, &data_200000f8, 0x20);
0802a538      sub_80334a0(var_28, var_24, var_20, r7);
0802a546      memcpy(&var_28, &data_20000118, 0x20);
0802a54c      sub_80334a0(var_28, var_24, var_20, r7);
0802a556      sub_80334cc(data_20000098, r7);
0802a560      sub_80334cc(data_200000b8, r7);
0802a56a      sub_80334cc(data_200000d8, r7);
0802a574      sub_80334cc(data_200000f8, r7);
0802a580      sub_80334cc(data_20000118, r7);
0802a59a      sub_8030026(data_2000017c, (int16_t)data_20000184, data_2000018c, 0);
0802a5b4      sub_8030026(data_20000180, (int16_t)data_20000188, data_2000018e, 0);
0802a5ce      sub_8030026(data_20000190, (int16_t)data_20000198, data_200001a0, 0);
0802a5ee      return sub_8030026(data_20000194, (int16_t)data_2000019c, data_200001a2, 0);
0802a4e8  }
0802a5f0    int32_t sub_802a5f0()
0802a5f0  {
0802a5f0      int32_t r7;
0802a5f0      int32_t var_8 = r7;
0802a5f0      
0802a604      if (sub_803004c(data_2000017c, data_20000184) == 1
0802a604              && sub_803004c(data_20000180, data_20000188) == 1)
0802a61a          return 1;
0802a61a      
0802a61e      return 0;
0802a5f0  }
0802a622    int32_t sub_802a622()
0802a622  {
0802a622      int32_t r7;
0802a622      int32_t var_8 = r7;
0802a622      
0802a636      if (sub_803004c(data_20000190, data_20000198) == 1
0802a636              && sub_803004c(data_20000194, data_2000019c) == 1)
0802a64c          return 1;
0802a64c      
0802a650      return 0;
0802a622  }
0802a654    int32_t sub_802a654()
0802a654  {
0802a662      void* var_30;
0802a662      memcpy(&var_30, &data_20000020, 0x28);
0802a668      int32_t var_2c;
0802a668      int32_t var_28;
0802a668      int32_t var_24;
0802a668      sub_8033754(var_30, var_2c, var_28, var_24);
0802a676      memcpy(&var_30, 0x20000048, 0x28);
0802a67c      sub_8033754(var_30, var_2c, var_28, var_24);
0802a68a      memcpy(&var_30, 0x20000070, 0x28);
0802a696      return sub_8033754(var_30, var_2c, var_28, var_24);
0802a654  }
0802a698    int32_t sub_802a698(int32_t arg1 @ r7)
0802a698  {
0802a6a6      gpio_config_af(0x40021000, 8, 0xc04, 2);
0802a6b6      gpio_config_af(0x40021000, 4, 0xc04, 2);
0802a6ba      return arg1;
0802a698  }
0802a6bc    int32_t sub_802a6bc(char arg1)
0802a6bc  {
0802a6bc      int32_t r7;
0802a6bc      int32_t var_8 = r7;
0802a6c2      int128_t q0;
0802a6c2      
0802a6c2      if ((uint32_t)arg1)
0802a6c2      {
0802a6da          (uint32_t)q0 = 0xb5000000;
0802a6de          sub_802a770();
0802a6ea          gpio_write(0x40021000, 8, true);
0802a6c2      }
0802a6c2      else
0802a6c2      {
0802a6cc          gpio_write(0x40021000, 8, false);
0802a6d0          (uint32_t)q0 = 0x42c80000;
0802a6d4          sub_802a770();
0802a6c2      }
0802a6f0      return 1;
0802a6bc  }
0802a6f2                                                        00 00 00 40                                                  ...@
0802a6f6  int32_t data_802a6f6 = -0x4a7fbab2
0802a6f8    int32_t sub_802a6f8(char arg1, int32_t arg2 @ r7)
0802a6f8  {
0802a6fe      if ((uint32_t)arg1)
0802a716          gpio_write(0x40021000, 4, false);
0802a6fe      else
0802a708          gpio_write(0x40021000, 4, true);
0802a708      
0802a71a      return arg2;
0802a6f8  }
0802a71c    int32_t j_sub_800a720(int32_t arg1 @ r7)
0802a71c  {
0802a71c      /* tailcall */
0802a71c      return sub_802a720(arg1);
0802a71c  }
0802a71e  int32_t data_802a71e = -0x4a7fba81
0802a720    int32_t sub_802a720(int32_t arg1 @ r7)
0802a720  {
0802a722      sub_802a698(arg1);
0802a726      sub_802a4e8();
0802a72a      sub_802a654();
0802a72e      sub_802a428();
0802a732      sub_802a494(arg1);
0802a73a      sub_802a9e0(0, 0);
0802a742      sub_802a9e0(1, 0);
0802a748      sub_802a6bc(0);
0802a752      data_2000e244 = 0;
0802a75a      data_2000e245 = 0;
0802a762      data_2000e23c = 0;
0802a76a      data_2000e240 = 0;
0802a76c      return arg1;
0802a720  }
0802a76e                                            00 00                                                                ..
0802a770    int32_t sub_802a770()
0802a770  {
0802a786      int32_t* var_28;
0802a786      memcpy(&var_28, &data_20000118, 0x20);
0802a792      int16_t var_24;
0802a792      int32_t var_20;
0802a792      int32_t var_1c;
0802a792      int32_t r5;
0802a792      return sub_80334d4(var_28, var_24, var_20, var_1c, r5);
0802a770  }
0802a794    int32_t sub_802a794(char arg1)
0802a794  {
0802a794      int32_t r5;
0802a794      int32_t var_8 = r5;
0802a79e      uint32_t r4_1 = (uint32_t)arg1;
0802a7a0      uint32_t r0 = (uint32_t)*(uint8_t*)(&data_2000e238 + r4_1);
0802a7a0      
0802a7a4      if (!r0)
0802a7a6          return 0;
0802a7a6      
0802a7aa      int64_t q0;
0802a7aa      *(uint32_t*)((char*)q0)[4] = 0xb51042c8;
0802a7ae      /* unimplemented  {vcmp.f32.F32 s0, s1} */
0802a7b2      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802a7b2      
0802a7b6      if (r0 < 0)
0802a7b6      {
0802a7be          /* unimplemented  {vcmp.f32.F32 s0, #0} */
0802a7c2          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802a7c2          
0802a7c6          if (r0 < 0)
0802a7c8              (uint32_t)q0 = 0;
0802a7b6      }
0802a7b6      else
0802a7b8          (uint32_t)q0 = 0x42c80000;
0802a7b8      
0802a7d0      uint32_t r4_2 = (uint32_t)(uint8_t)r4_1;
0802a7d6      (&data_2000e23c)[r4_2] = (uint32_t)q0;
0802a7de      uint32_t r4_3 = (uint32_t)(uint8_t)r4_2;
0802a7e6      int32_t* var_30;
0802a7e6      int16_t var_2c;
0802a7e6      int32_t var_28;
0802a7e6      int32_t var_24;
0802a7e6      
0802a7e6      if ((uint32_t)(&data_2000e244)[r4_3])
0802a7e6      {
0802a8b2          uint32_t r4_12 = (uint32_t)(uint8_t)r4_3;
0802a8b2          
0802a8b6          if (r4_12)
0802a8b6          {
0802a91c              uint32_t r4_16 = (uint32_t)(uint8_t)r4_12;
0802a92c              memcpy(&var_30, 
0802a92c                  &(&data_20000098)[(uint32_t)*(uint8_t*)(&data_200001a4 + (r4_16 << 1))
0802a92c                      * 8], 
0802a92c                  0x20);
0802a932              (uint32_t)q0 = 0x42c8;
0802a936              sub_80334d4(var_30, var_2c, var_28, var_24, r5);
0802a93e              uint32_t r4_17 = (uint32_t)(uint8_t)r4_16;
0802a950              memcpy(&var_30, 
0802a950                  &(&data_20000098)[(uint32_t)*(uint8_t*)((r4_17 << 1) + 0x200001a5) * 8], 
0802a950                  0x20);
0802a956              int64_t q0_4;
0802a956              (uint32_t)q0_4 = 0x42c8;
0802a962              *(uint32_t*)((char*)q0_4)[4] = (&data_2000e23c)[(uint32_t)(uint8_t)r4_17];
0802a966              (uint32_t)q0_4 = 2.39565985e-41f - *(uint32_t*)((char*)q0_4)[4];
0802a96a              sub_80334d4(var_30, var_2c, var_28, var_24, &data_2000e238);
0802a8b6          }
0802a8b6          else
0802a8b6          {
0802a8c0              uint32_t r4_13 = (uint32_t)(uint8_t)r4_12;
0802a8d0              memcpy(&var_30, 
0802a8d0                  &(&data_20000098)[(uint32_t)*(uint8_t*)(&data_200001a4 + (r4_13 << 1))
0802a8d0                      * 8], 
0802a8d0                  0x20);
0802a8d6              (uint32_t)q0 = 0x42c8;
0802a8de              uint32_t r4_14 = (uint32_t)(uint8_t)r4_13;
0802a8e4              *(uint32_t*)((char*)q0)[4] = (&data_2000e23c)[r4_14];
0802a8e8              (uint32_t)q0 = 2.39565985e-41f - *(uint32_t*)((char*)q0)[4];
0802a8ec              sub_80334d4(var_30, var_2c, var_28, var_24, &data_2000e238 + (r4_14 << 2));
0802a908              memcpy(&var_30, 
0802a908                  &(&data_20000098)[(uint32_t)
0802a908                      *(uint8_t*)(((uint32_t)(uint8_t)r4_14 << 1) + 0x200001a5) * 8], 
0802a908                  0x20);
0802a90e              int128_t q0_3;
0802a90e              (uint32_t)q0_3 = 0x42c8;
0802a912              sub_80334d4(var_30, var_2c, var_28, var_24, &data_2000e238 + (r4_14 << 2));
0802a8b6          }
0802a7e6      }
0802a7e6      else
0802a7e6      {
0802a7e8          uint32_t r4_4 = (uint32_t)(uint8_t)r4_3;
0802a7e8          
0802a7ec          if (r4_4)
0802a7ec          {
0802a858              uint32_t r4_9 = (uint32_t)(uint8_t)r4_4;
0802a868              memcpy(&var_30, 
0802a868                  &(&data_20000098)[(uint32_t)*(uint8_t*)(&data_200001a4 + (r4_9 << 1))
0802a868                      * 8], 
0802a868                  0x20);
0802a86e              (uint32_t)q0 = 0x42c8;
0802a876              uint32_t r4_10 = (uint32_t)(uint8_t)r4_9;
0802a87c              *(uint32_t*)((char*)q0)[4] = (&data_2000e23c)[r4_10];
0802a880              (uint32_t)q0 = 2.39565985e-41f - *(uint32_t*)((char*)q0)[4];
0802a884              sub_80334d4(var_30, var_2c, var_28, var_24, &data_2000e238 + (r4_10 << 2));
0802a8a2              memcpy(&var_30, 
0802a8a2                  &(&data_20000098)[(uint32_t)
0802a8a2                      *(uint8_t*)(((uint32_t)(uint8_t)r4_10 << 1) + 0x200001a5) * 8], 
0802a8a2                  0x20);
0802a8a8              int128_t q0_2;
0802a8a8              (uint32_t)q0_2 = 0x42c80000;
0802a8ac              sub_80334d4(var_30, var_2c, var_28, var_24, &data_2000e238 + (r4_10 << 2));
0802a7ec          }
0802a7ec          else
0802a7ec          {
0802a7f6              uint32_t r4_5 = (uint32_t)(uint8_t)r4_4;
0802a806              memcpy(&var_30, 
0802a806                  &(&data_20000098)[(uint32_t)*(uint8_t*)(&data_200001a4 + (r4_5 << 1))
0802a806                      * 8], 
0802a806                  0x20);
0802a80c              (uint32_t)q0 = 0x42c80000;
0802a810              sub_80334d4(var_30, var_2c, var_28, var_24, r5);
0802a81c              uint32_t r4_6 = (uint32_t)(uint8_t)r4_5;
0802a82e              memcpy(&var_30, 
0802a82e                  &(&data_20000098)[(uint32_t)*(uint8_t*)((r4_6 << 1) + 0x200001a5) * 8], 
0802a82e                  0x20);
0802a834              int64_t q0_1;
0802a834              (uint32_t)q0_1 = 0x42c80000;
0802a842              *(uint32_t*)((char*)q0_1)[4] = (&data_2000e23c)[(uint32_t)(uint8_t)r4_6];
0802a846              (uint32_t)q0_1 = 100f - *(uint32_t*)((char*)q0_1)[4];
0802a84a              sub_80334d4(var_30, var_2c, var_28, var_24, &data_2000e238);
0802a7ec          }
0802a7e6      }
0802a96e      return 1;
0802a794  }
0802a974  int32_t data_802a974 = 0x42c80000
0802a978  int32_t data_802a978 = 0x0
0802a97c    int32_t sub_802a97c(char arg1, char arg2)
0802a97c  {
0802a984      int32_t* var_28;
0802a984      int16_t var_24;
0802a984      int32_t var_20;
0802a984      int32_t var_1c;
0802a984      int32_t r5;
0802a984      
0802a984      if ((uint32_t)arg2 != 1)
0802a984      {
0802a9bc          memcpy(&var_28, 
0802a9bc              &(&data_20000098)[(uint32_t)*(uint8_t*)(((uint32_t)arg1 << 1) + 0x200001a5)
0802a9bc                  * 8], 
0802a9bc              0x20);
0802a9c2          sub_80334d4(var_28, var_24, var_20, var_1c, r5);
0802a984      }
0802a984      else
0802a984      {
0802a99a          memcpy(&var_28, 
0802a99a              &(&data_20000098)[(uint32_t)
0802a99a                  *(uint8_t*)(&data_200001a4 + ((uint32_t)arg1 << 1)) * 8], 
0802a99a              0x20);
0802a9a0          sub_80334d4(var_28, var_24, var_20, var_1c, r5);
0802a984      }
0802a9ca      return 1;
0802a97c  }
0802a9cc    void* sub_802a9cc(char arg1, char arg2)
0802a9cc  {
0802a9d2      (&data_2000e244)[(uint32_t)arg1] = arg2;
0802a9d4      return (uint32_t)arg1 + &data_2000e238;
0802a9cc  }
0802a9d6    uint32_t sub_802a9d6(char arg1)
0802a9d6  {
0802a9de      return (uint32_t)(&data_2000e244)[(uint32_t)arg1];
0802a9d6  }
0802a9e0    int32_t sub_802a9e0(int32_t arg1, int32_t arg2)
0802a9e0  {
0802a9e0      int32_t var_14 = arg2;
0802a9e6      uint32_t r4_1 = (uint32_t)(uint8_t)arg1;
0802a9e8      *(uint8_t*)(&data_2000e238 + r4_1) = (char)arg2;
0802a9ee      int32_t* var_28;
0802a9ee      int16_t var_24;
0802a9ee      int32_t var_20;
0802a9ee      int32_t var_1c;
0802a9ee      int32_t r5;
0802a9ee      int128_t q0;
0802a9ee      
0802a9ee      if ((uint32_t)(uint8_t)arg2)
0802a9ee      {
0802aa3c          uint32_t r4_4 = (uint32_t)(uint8_t)r4_1;
0802aa4c          memcpy(&var_28, 
0802aa4c              &(&data_20000098)[(uint32_t)*(uint8_t*)(&data_200001a4 + (r4_4 << 1)) * 8], 
0802aa4c              0x20);
0802aa52          (uint32_t)q0 = 0x1380000;
0802aa56          sub_80334d4(var_28, var_24, var_20, var_1c, r5);
0802aa70          memcpy(&var_28, 
0802aa70              &(&data_20000098)[(uint32_t)
0802aa70                  *(uint8_t*)(((uint32_t)(uint8_t)r4_4 << 1) + 0x200001a5) * 8], 
0802aa70              0x20);
0802aa76          int128_t q0_2;
0802aa76          (uint32_t)q0_2 = 0x1380000;
0802aa7a          sub_80334d4(var_28, var_24, var_20, var_1c, r5);
0802a9ee      }
0802a9ee      else
0802a9ee      {
0802a9f4          uint32_t r4_2 = (uint32_t)(uint8_t)r4_1;
0802aa04          memcpy(&var_28, 
0802aa04              &(&data_20000098)[(uint32_t)*(uint8_t*)(&data_200001a4 + (r4_2 << 1)) * 8], 
0802aa04              0x20);
0802aa0a          (uint32_t)q0 = 0x42c8;
0802aa0e          sub_80334d4(var_28, var_24, var_20, var_1c, r5);
0802aa28          memcpy(&var_28, 
0802aa28              &(&data_20000098)[(uint32_t)
0802aa28                  *(uint8_t*)(((uint32_t)(uint8_t)r4_2 << 1) + 0x200001a5) * 8], 
0802aa28              0x20);
0802aa2e          int128_t q0_1;
0802aa2e          (uint32_t)q0_1 = 0x42c8;
0802aa32          sub_80334d4(var_28, var_24, var_20, var_1c, r5);
0802a9ee      }
0802aa7e      return arg1;
0802a9e0  }
0802aa80    uint32_t sub_802aa80(char arg1)
0802aa80  {
0802aa86      return (uint32_t)*(uint8_t*)(&data_2000e238 + (uint32_t)arg1);
0802aa80  }
0802aa88                          01 00                                                                            ..
0802aa8a  int32_t data_802aa8a = -0x4aefbd38
0802aa8c    int32_t sub_802aa8c(char arg1)
0802aa8c  {
0802aa96      int64_t q4;
0802aa96      (uint32_t)q4 = 0x1380000;
0802aa9c      uint32_t r4_1 = (uint32_t)arg1;
0802aaa8      void a;
0802aaa8      sub_8033a30(&a, *(uint32_t*)(&data_20000020 + 0x28 * r4_1));
0802aaac      int32_t b;
0802aaac      int32_t result = b;
0802aaac      
0802aab0      if (result >= 0x65)
0802aab0      {
0802aab6          if ((uint32_t)(uint8_t)r4_1 != 2)
0802aab6          {
0802aae6              int32_t r0_6;
0802aae6              int32_t r1_5;
0802aae6              r0_6 = sub_802e6b8(b);
0802aaf2              soft_dadd(a, b);
0802aafc              soft_dmul();
0802ab04              soft_dmul();
0802ab0c              int32_t r0_8;
0802ab0c              int32_t r1_7;
0802ab0c              r0_8 = soft_dmul();
0802ab10              result = sub_802ead0(r0_8, r1_7);
0802ab14              (uint32_t)q4 = result;
0802aab6          }
0802aab6          else
0802aab6          {
0802aaba              int32_t r0_2;
0802aaba              int32_t r1_2;
0802aaba              r0_2 = sub_802e6b8(b);
0802aac6              soft_dadd(a, b);
0802aace              soft_dadd();
0802aad6              int32_t r0_4;
0802aad6              int32_t r1_4;
0802aad6              r0_4 = soft_dmul();
0802aada              result = sub_802ead0(r0_4, r1_4);
0802aade              (uint32_t)q4 = result;
0802aab6          }
0802aab0      }
0802aab0      
0802ab18      int128_t q0;
0802ab18      (uint32_t)q0 = (uint32_t)q4;
0802ab22      return result;
0802aa8c  }
0802ab24              00 00                                                                                    ..
0802ab26  int32_t data_802ab26 = 0x42c8
0802ab2a  int32_t data_802ab2a = 0x1380000
0802ab2e                                            00 20                                                                . 
0802ab30  int32_t data_802ab30 = 0x20000150
0802ab34  int32_t data_802ab34 = 0x20000178
0802ab38  int32_t data_802ab38 = 0x20000170
0802ab3c  int32_t data_802ab3c = 0x20000168
0802ab40  int32_t data_802ab40 = 0x20000098
0802ab44  int32_t data_802ab44 = 0x200000b8
0802ab48  int32_t data_802ab48 = 0x200000d8
0802ab4c  int32_t data_802ab4c = 0x200000f8
0802ab50  int32_t data_802ab50 = 0x20000118
0802ab54  int32_t data_802ab54 = 0x2000018c
0802ab58  int32_t data_802ab58 = 0x20000184
0802ab5c  int32_t data_802ab5c = 0x2000017c
0802ab60  int32_t data_802ab60 = 0x200001a0
0802ab64  int32_t data_802ab64 = 0x20000198
0802ab68  int32_t data_802ab68 = 0x20000190
0802ab6c  int32_t data_802ab6c = 0x20000020
0802ab70  int32_t data_802ab70 = 0x20000048
0802ab74  int32_t data_802ab74 = 0x20000070
0802ab78  int32_t data_802ab78 = 0x40021000
0802ab7c  int32_t data_802ab7c = 0x2000e238
0802ab80  int32_t data_802ab80 = 0x200001a4
0802ab84  int32_t data_802ab84 = 0x41224f80
0802ab88  int32_t data_802ab88 = 0x40080000
0802ab8c  int32_t data_802ab8c = 0x404e0000
0802ab90  int32_t data_802ab90 = 0x410e8480
0802ab94  int32_t data_802ab94 = 0x4d12d84a
0802ab98  int32_t data_802ab98 = 0x400921fb
0802ab9c  int32_t data_802ab9c = 0x7e308787
0802aba0  int32_t data_802aba0 = 0x3ff2771a
0802aba4    int32_t sub_802aba4(int32_t arg1 @ r7)
0802aba4  {
0802abaa      sub_8026db2(&data_20000c64);
0802abae      return arg1;
0802aba4  }
0802abb0    int32_t sub_802abb0(int32_t arg1 @ r7)
0802abb0  {
0802abb6      sub_8026dfa(&data_20000c64);
0802abba      return arg1;
0802abb0  }
0802abbc    uint32_t sub_802abbc()
0802abbc  {
0802abc2      return (uint32_t)data_2000e46b;
0802abbc  }
0802abc4    int32_t sub_802abc4(int32_t arg1 @ r7)
0802abc4  {
0802abd4      gpio_config_af(&GPIOA, 0x100, 0xc00, 1);
0802abdc      camera_pa8_set(true, false);
0802abe0      return arg1;
0802abc4  }
0802abe2    int32_t vbCommMoudleInit()
0802abe2  {
0802abf0      int32_t var_2c;
0802abf0      memcpy(&var_2c, 0x20000c3c, 0x28);
0802abfc      int32_t var_28;
0802abfc      int32_t var_24;
0802abfc      usart_init(data_20000c34, var_2c, var_28, var_24);
0802ac04      sub_8026c14(&data_20000c64);
0802ac12      cam_comms_mutex = sub_8030938(1);
0802ac12      
0802ac1c      if (!cam_comms_mutex)
0802ac22          logging_wrapper("s_vbCommDataMutex error\r\n", &cam_comms_mutex);
0802ac22      
0802ac3e      int32_t r2_1;
0802ac3e      int32_t r3_1;
0802ac3e      r2_1 = rtos_xTaskCreate(cam_heartbeat_task, "VbCommTask", 0x258, nullptr, 7, 
0802ac3e          &data_2000e3f8);
0802ac48      software_mutex(1, 0x2710, r2_1, r3_1);
0802ac50      return 1;
0802abe2  }
0802ac52    int32_t sub_802ac52()
0802ac52  {
0802ac58      return data_2000e3ec;
0802ac52  }
0802ac5a    uint32_t sub_802ac5a(uint32_t arg1, char* arg2, int32_t arg3)
0802ac5a  {
0802ac5c      while (true)
0802ac5c      {
0802ac5c          int32_t r3_1 = arg3;
0802ac5e          arg3 = r3_1 - 1;
0802ac5e          
0802ac64          if (!(uint32_t)(uint16_t)r3_1)
0802ac64              break;
0802ac64          
0802ac68          arg1 ^= (uint32_t)*(uint8_t*)arg2;
0802ac6a          arg2 = &arg2[1];
0802ac6c          char r3_4 = 0;
0802ac6c          
0802ac76          while (true)
0802ac76          {
0802ac76              uint32_t r3_5 = (uint32_t)r3_4;
0802ac76              
0802ac7a              if (r3_5 >= 8)
0802ac7a                  break;
0802ac7a              
0802ac7e              arg1 = arg1 << 0x1f >= 0 ? (uint32_t)(uint8_t)arg1 >> 1
0802ac7e                  : (uint32_t)(uint8_t)arg1 >> 1 ^ 0x8c;
0802ac7e              
0802ac74              r3_4 = (uint8_t)r3_5 + 1;
0802ac76          }
0802ac5c      }
0802ac5c      
0802ac8e      return (uint32_t)(uint8_t)arg1;
0802ac5a  }
0802ac90    void sub_802ac90(char arg1)
0802ac90  {
0802ac94      data_2000e46e = arg1;
0802ac90  }
0802ac98    uint32_t sub_802ac98()
0802ac98  {
0802ac9e      return (uint32_t)data_2000e46e;
0802ac98  }
0802aca0    void cam_heartbeat_task(int32_t arg1 @ r8) __noreturn
0802aca0  {
0802aca0      int32_t var_c = arg1;
0802acaa      char comms_frame;
0802acaa      j_sub_80168a8(&comms_frame, 0x9c);
0802acb4      void byte_2;
0802acb4      j_sub_80168a8(&byte_2, 0x9c);
0802acbe      uint8_t byte;
0802acbe      j_sub_80168a8(&byte, 0x9c);
0802acc6      int32_t r7 = TickType_t xTaskGetTickCount(void)();
0802acc8      uint32_t r5 = 0;
0802accc      int32_t var_1f4 = 0;
0802accc      
0802ad1e      while (true)
0802ad1e      {
0802ad1e          int32_t r0_10 = TickType_t xTaskGetTickCount(void)();
0802ad24          int32_t r6_2;
0802ad24          
0802ad24          r6_2 = r0_10 >= r7 ? r0_10 - r7 : r0_10 + 0xffffffff - r7;
0802ad24          
0802ad32          r7 = r0_10;
0802ad3c          logging_wrapper("[vb]interval: %d %d\r\n", r6_2, arg1);
0802ad4a          memset16x2(&comms_frame, 0x9c, 0);
0802ad58          memset16x2(&byte_2, 0x9c, 0);
0802ad5e          comms_frame = 0x44;
0802ad64          char var_1d_1 = 0x16;
0802ad64          
0802ad78          if (rtos_dma_rx_wait_and_service(cam_comms_mutex, 0xffffffff) != 1)
0802ad7e              logging_wrapper("Mutex Error!!!\r\n");
0802ad7e          
0802ad86          uint32_t r0_15 = (uint32_t)data_20000deb;
0802ad86          
0802ad90          if (!r0_15 || r0_15 - 0x30 <= 2)
0802ad90          {
0802ad98              char var_b5_1 = data_20000deb;
0802ada0              uint32_t r0_19 = (uint32_t)get_current_mode_index();
0802ada0              
0802ada4              if (!r0_19)
0802adc8                  char var_b6_2 = 0;
0802ada4              else
0802ada4              {
0802ada6                  uint32_t r0_20 = (uint32_t)(uint8_t)r0_19;
0802ada6                  
0802adaa                  if (r0_20 == 1)
0802adc8                      var_b6_2 = 0;
0802adaa                  else
0802adaa                  {
0802adac                      uint32_t r0_21 = (uint32_t)(uint8_t)r0_20;
0802adac                      
0802adb0                      if (r0_21 == 8)
0802adc8                          var_b6_2 = 0;
0802adb0                      else
0802adb0                      {
0802adb2                          uint32_t r0_22 = (uint32_t)(uint8_t)r0_21;
0802adb2                          
0802adbc                          if (r0_22 == 9 || (uint32_t)(uint8_t)r0_22 == 0x10)
0802adc8                              var_b6_2 = 0;
0802adbc                          else
0802adc0                              char var_b6_1 = 6;
0802adb0                      }
0802adaa                  }
0802ada4              }
0802ad90          }
0802ad90          
0802ade2          if (sub_8030954(cam_comms_mutex, nullptr, 0, 0) != 1)
0802ade8              logging_wrapper("Mutex Error!!!\r\n");
0802ade8          
0802adee          char var_b7 = 2;
0802ae00          char var_1e = sub_802ac5a(0, &var_b7, 3);
0802ae10          memcpy_(&byte_2, &comms_frame, 4);
0802ae26          void var_150;
0802ae26          memcpy_(&var_150, &var_1e, 2);
0802ae3a          sub_8026c3a(data_20000c34, &data_20000c64);
0802ae4c          int32_t var_208;
0802ae4c          char var_1ee;
0802ae4c          
0802ae4c          for (arg1 = 0; arg1 < 0x32; arg1 += 1)
0802ae4c          {
0802ae58              memset16x2(&byte, 0x9c, 0);
0802ae66              memset16x2(&byte_2, 0x9c, 0);
0802ae6c              var_208 = 2;
0802ae7c              cam_uart_tx_start(data_20000c34, &data_20000c64, &byte);
0802ae7c              
0802ae86              if ((uint32_t)byte == 0x44)
0802ae86              {
0802ae8a                  int32_t var_208_1 = 2;
0802ae9c                  char byte_1;
0802ae9c                  cam_uart_tx_start(data_20000c34, &data_20000c64, &byte_1);
0802aea2                  var_208 = 2;
0802aeb6                  cam_uart_tx_start(data_20000c34, &data_20000c64, &byte_2);
0802aec6                  memcpy_(&var_1ee, &byte_2, (uint32_t)byte_1);
0802aeda                  char var_156;
0802aeda                  memcpy_(&var_156, (uint32_t)byte_1 + &byte_2, 2);
0802aee4                  char var_155;
0802aee4                  
0802aee4                  if ((uint32_t)var_155 == 0x16)
0802aee4                  {
0802aef4                      char r0_41;
0802aef4                      int32_t r2_8;
0802aef4                      int32_t r3_5;
0802aef4                      r0_41 = sub_802ac5a(0, &byte_1, (uint32_t)((uint16_t)byte_1 + 1));
0802aef4                      
0802af00                      if ((uint32_t)r0_41 == (uint32_t)var_156)
0802af00                      {
0802af02                          r5 = 1;
0802af0a                          software_mutex(1, 0x7d0, r2_8, r3_5);
0802af0a                          break;
0802af00                      }
0802aee4                  }
0802ae86              }
0802ae4c          }
0802ae4c          
0802af16          if (!sub_8031c0c(1))
0802af16          {
0802af1e              data_2000e46b = 0;
0802af20              sub_802b564(r7);
0802af16          }
0802af16          
0802af24          r5 = (uint32_t)(uint8_t)r5;
0802af24          
0802af28          if (r5 == 1)
0802af28          {
0802af2c              r5 = 0;
0802af2c              
0802af3e              if (rtos_dma_rx_wait_and_service(cam_comms_mutex, 0xffffffff) != 1)
0802af44                  logging_wrapper("Mutex Error!!!\r\n");
0802af44              
0802af48              char var_1ed;
0802af48              uint32_t r0_46 = (uint32_t)var_1ed;
0802af4e              uint32_t var_204;
0802af4e              uint32_t var_200;
0802af4e              uint32_t var_1fc;
0802af4e              uint32_t var_1f8;
0802af4e              char var_1ec;
0802af4e              char var_1eb;
0802af4e              char var_1ea;
0802af4e              void var_1e9;
0802af4e              
0802af4e              if (!r0_46)
0802af4e              {
0802af62                  if ((uint32_t)var_1ee == 5)
0802af64                      sub_802b564(r7);
0802af64                  
0802af70                  data_2000e46b = var_1ee;
0802af70                  
0802af78                  if ((uint32_t)var_1ec != 1)
0802af90                      data_2000e3ec = (uint32_t)var_1eb;
0802af78                  else
0802af84                      data_2000e3ec = 0 - (uint32_t)var_1eb;
0802af84                  
0802af9a                  data_20000dec = var_1ea;
0802afa8                  memcpy_(&var_1f4, &var_1e9, 4);
0802afae                  var_208 = var_1f4;
0802afc4                  int32_t r2_10;
0802afc4                  int32_t r3_7;
0802afc4                  r2_10 = logging_wrapper("[++VBS]:BS:%d Temp:%dC BC:%d Pici:%d\r\n", 
0802afc4                      (uint32_t)var_1ee, data_2000e3ec, (uint32_t)data_20000dec, var_208, 
0802afc4                      var_204, var_200, var_1fc, var_1f8);
0802afc4                  
0802afd0                  if ((uint32_t)data_2000e46c == 1)
0802afd8                      data_20000deb = 0x30;
0802afd0                  else if ((uint32_t)data_2000e46d == 1)
0802afe4                  {
0802afec                      data_20000deb = 0x31;
0802aff4                      software_mutex(1, 0x2710, r2_10, r3_7);
0802afe4                  }
0802afe4                  else if ((uint32_t)data_20000deb != 0x32)
0802b00a                      data_20000deb = 0;
0802af4e              }
0802af4e              else if (r0_46 == 0xa3)
0802af52              {
0802b016                  data_2000e46b = var_1ee;
0802b016                  
0802b01e                  if ((uint32_t)var_1ec != 1)
0802b036                      data_2000e3ec = (uint32_t)var_1eb;
0802b01e                  else
0802b02a                      data_2000e3ec = 0 - (uint32_t)var_1eb;
0802b02a                  
0802b040                  data_20000dec = var_1ea;
0802b056                  logging_wrapper("[++VBS]:%d %d C %d\n", (uint32_t)var_1ee, data_2000e3ec, 
0802b056                      (uint32_t)data_20000dec, var_208, var_204, var_200, var_1fc, var_1f8);
0802b060                  data_2000e46d = 2;
0802b068                  data_20000deb = 0;
0802b06e                  logging_wrapper("delete pics done\r\n", &data_20000deb);
0802af52              }
0802af52              else if (r0_46 == 0xa4)
0802af56              {
0802b07a                  if ((uint32_t)var_1ee == 5)
0802b07c                      sub_802b564(r7);
0802b07c                  
0802b088                  data_2000e46b = var_1ee;
0802b088                  
0802b090                  if ((uint32_t)var_1ec != 1)
0802b0a8                      data_2000e3ec = (uint32_t)var_1eb;
0802b090                  else
0802b09c                      data_2000e3ec = 0 - (uint32_t)var_1eb;
0802b09c                  
0802b0b2                  data_20000dec = var_1ea;
0802b0c0                  memcpy_(&var_1f4, &var_1e9, 4);
0802b0d8                  void var_1e5;
0802b0d8                  camera_send_4B_token(&data_2000e3f0, 
0802b0d8                      memcpy_(&data_2000e3f0, &var_1e5, 4));
0802b0e2                  data_20000deb = 0;
0802b0ea                  var_1f8 = (uint32_t)data_2000e3f3;
0802b0f2                  var_1fc = (uint32_t)data_2000e3f2;
0802b0fa                  var_200 = (uint32_t)data_2000e3f1;
0802b102                  var_204 = (uint32_t)data_2000e3f0;
0802b106                  var_208 = var_1f4;
0802b11c                  logging_wrapper("[++VBS]:%d %d C %d pici:%d FWV:%d_%d_%d_%d\r\n", 
0802b11c                      (uint32_t)var_1ee, data_2000e3ec, (uint32_t)data_20000dec, var_208, 
0802b11c                      var_204, var_200, var_1fc, var_1f8);
0802af56              }
0802af56              
0802ace2              if (sub_8030954(cam_comms_mutex, nullptr, 0, 0) != 1)
0802ace8                  logging_wrapper("Mutex Error!!!\r\n");
0802ace8              
0802acf2              if ((uint32_t)var_1ee != 1 && sub_802d0b8() == 1 && sub_8033b3e())
0802acf2              {
0802ad0a                  data_2000e46e = 1;
0802ad0c                  motorBrake();
0802acf2              }
0802acf2              
0802ad12              if (r6_2 < 0x32)
0802ad1a                  rtos_delay_ticks(0x32 - r6_2);
0802af28          }
0802ad1e      }
0802aca0  }
0802b122  // // This toggles PA8 (mask 0x0100). If `level` is true it sets PA8 high and
0802b122  // returns immediately.
0802b122  // // If `level` is false it drives PA8 low; unless `return_immediately` is
0802b122  // true, it then waits 1000 ticks.
0802b122  
0802b122    int32_t camera_pa8_set(bool level, bool return_immediately)
0802b122  {
0802b12a      if ((uint32_t)level == 1)
0802b136          return gpio_write(&GPIOA, 0x100, true);
0802b136      
0802b146      int32_t result = gpio_write(&GPIOA, 0x100, false);
0802b146      
0802b14e      if ((uint32_t)return_immediately)
0802b158          return result;
0802b158      
0802b154      return rtos_delay_ticks(0x3e8);
0802b122  }
0802b15a  // //
0802b15a  // ---------------------------------------------------------------------------
0802b15a  // // sub_802b15a
0802b15a  // // Tiny wrapper that sends a 4-byte token “arg1” to camera link at base
0802b15a  // 0xE000,
0802b15a  // // then returns the r7 register/input (arg2) unchanged.
0802b15a  // // In practice this looks like a “poke 4 bytes to camera control space”
0802b15a  // helper.
0802b15a  // //
0802b15a  // ---------------------------------------------------------------------------
0802b15a  
0802b15a    int32_t camera_send_4B_token(void const* token4B, int32_t passthrough_ret)
0802b15a  {
0802b166      camera_link_send(0, 0xe000, 4, token4B);
0802b16a      int32_t entry_result;
0802b16a      return entry_result;
0802b15a  }
0802b16c    int32_t sub_802b16c(char* arg1)
0802b16c  {
0802b176      int32_t result = 0;
0802b182      sub_8026ed4(0, 0xe000, 4, &result);
0802b18c      memcpy_(arg1, &result, 4);
0802b190      return result;
0802b16c  }
0802b192    bool upload_camera_firmware_cam_wdr(char const* path)
0802b192  {
0802b1a0      if (data_2000e3f8)
0802b1a8          sub_80296a0(data_2000e3f8);
0802b1a8      
0802b1b4      sub_8027224(5, 1, 1, 1);
0802b1ba      uint32_t bytes_read = 0;
0802b1be      uint32_t bytes_read_1 = 0;
0802b1c2      int32_t r4 = 0;
0802b1c4      int32_t r5 = 0;
0802b1c6      uint32_t r6 = 1;
0802b1c8      int32_t r7 = 0;
0802b1ca      int32_t r8 = 0;
0802b1ce      int16_t r9 = 0;
0802b1d8      void* buff = nullptr;
0802b1da      char r11 = 1;
0802b1ea      buff = sub_8034da8(0x70, 0, nullptr);
0802b1ea      
0802b1f0      if (!buff)
0802b1f2          return 0;
0802b1f2      
0802b204      if (f_open(0x2000d020, path, 1))
0802b204      {
0802b20a          console_printf("error\r\n");
0802b20e          return 0;
0802b204      }
0802b204      
0802b216      console_printf("success\r\n");
0802b224      int32_t var_a8;
0802b224      __builtin_strncpy(&var_a8, "Cam_WDR0", 0xc);
0802b238      int32_t r0_8;
0802b238      uint32_t r2_2;
0802b238      int32_t r3_1;
0802b238      r0_8 =
0802b238          sub_802b72a(0, &var_a8, sub_8035580(&var_a8, "Cam_WDR0", 0x5f6d6143, 0x30524457));
0802b238      
0802b23e      if (!r0_8)
0802b23e      {
0802b244          console_printf("\r\n FW Tag ERROR");
0802b24c          f_close(0x2000d020);
0802b250          return 0;
0802b23e      }
0802b23e      
0802b262      if (!sub_802b7e8(0, data_2000d02c, r2_2, r3_1))
0802b262      {
0802b268          console_printf("[Update] Direct Read File CRC Error\r\n");
0802b270          f_close(0x2000d020);
0802b274          return 0;
0802b262      }
0802b262      
0802b27e      sub_8021bf8(0x2000d020, 0);
0802b27e      
0802b2d4      do
0802b2d4      {
0802b288          if (!sub_802fca8())
0802b288          {
0802b28e              f_close(0x2000d020);
0802b292              return 0;
0802b288          }
0802b288          
0802b2a6          void buff_1;
0802b2a6          
0802b2a6          if (ff_f_read(0x2000d020, &buff_1, 0x70, &bytes_read))
0802b2a6          {
0802b2ac              console_printf("f_read error\r\n");
0802b2b4              f_close(0x2000d020);
0802b2b8              return 0;
0802b2a6          }
0802b2a6          
0802b2ca          r9 = sub_802ac5a((uint32_t)(uint8_t)r9, &buff_1, (uint32_t)(uint16_t)bytes_read);
0802b2ce          r5 += bytes_read;
0802b2d4      } while (bytes_read >= 0x70);
0802b2d4      
0802b2dc      sub_8021bf8(0x2000d020, 0);
0802b2ec      console_printf("fwSize %x  checkSum %x\r\n", r5, (uint32_t)r9);
0802b2ec      
0802b2f8      if (!sub_802b930())
0802b2f8      {
0802b2fe          f_close(0x2000d020);
0802b302          return 0;
0802b2f8      }
0802b2f8      
0802b30c      sub_8021bf8(0x2000d020, 0);
0802b30c      
0802b316      while (true)
0802b316      {
0802b316          r6 = (uint32_t)(uint8_t)r6;
0802b316          
0802b31a          if (r6 != 1)
0802b3ba              return 1;
0802b3ba          
0802b31c          r8 += 1;
0802b31c          
0802b324          if (r8 == 0xa)
0802b326              sub_802c036();
0802b324          else if (r8 == 0x14)
0802b330          {
0802b332              sub_802c06e();
0802b336              r8 = 0;
0802b330          }
0802b330          
0802b340          if (!sub_802fca8())
0802b340          {
0802b346              f_close(0x2000d020);
0802b34a              return 0;
0802b340          }
0802b340          
0802b356          uint32_t btr;
0802b356          
0802b356          btr = r4 + 0x70 >= r5 ? r5 - r4 : 0x70;
0802b356          
0802b36c          if (ff_f_read(0x2000d020, buff, btr, &bytes_read_1))
0802b36c          {
0802b372              f_close(0x2000d020);
0802b376              return 0;
0802b36c          }
0802b36c          
0802b37e          r4 += bytes_read_1;
0802b380          r7 += 1;
0802b380          
0802b38a          if (r5 < 0x70 * r7)
0802b38a          {
0802b392              if (!sub_802fca8())
0802b394                  return 0;
0802b394              
0802b39a              r6 = 0;
0802b38a          }
0802b38a          
0802b3b2          if (!sub_802b990(buff, r7, r5, 7, (uint32_t)r11))
0802b3b2              break;
0802b3b2          
0802b312          r11 = 0;
0802b316      }
0802b316      
0802b3b4      return 0;
0802b192  }
0802b3c2    bool upload_camera_model_L(char const* path, uint8_t type_must_be_8)
0802b3c2  {
0802b3d0      if (data_2000e3f8)
0802b3d8          sub_80296a0(data_2000e3f8);
0802b3d8      
0802b3e4      sub_8027224(5, 1, 1, 1);
0802b3e8      uint32_t r4 = 1;
0802b3ee      uint32_t bytes_read = 0;
0802b3f2      char r6 = 1;
0802b3f4      int32_t r7 = 0;
0802b3fe      int32_t r9 = 0;
0802b402      int32_t r10 = 0;
0802b402      
0802b40c      if ((uint32_t)type_must_be_8 != 8)
0802b430          return 0;
0802b430      
0802b414      void var_50;
0802b414      sub_80355b8(&var_50, "Model_L", 0);
0802b424      char* buff = sub_8034da8(0x70, 0, nullptr);
0802b424      
0802b42a      if (!buff)
0802b42c          return 0;
0802b42c      
0802b442      if (f_open(0x2000d020, path, 1))
0802b444          return 0;
0802b444      
0802b454      int32_t r0_9;
0802b454      uint32_t r2_2;
0802b454      int32_t r3_1;
0802b454      r0_9 = sub_802b72a(0, &var_50, sub_8035580(&var_50));
0802b454      
0802b45a      if (!r0_9)
0802b45a      {
0802b460          f_close(0x2000d020);
0802b464          return 0;
0802b45a      }
0802b45a      
0802b476      if (!sub_802b7e8(0, data_2000d02c, r2_2, r3_1))
0802b476      {
0802b47c          f_close(0x2000d020);
0802b480          return 0;
0802b476      }
0802b476      
0802b48a      int32_t r11_1 = data_2000d02c - 0x22;
0802b494      sub_8021bf8(0x2000d020, 0);
0802b494      
0802b4a0      if (!sub_802b930())
0802b4a0      {
0802b4a6          f_close(0x2000d020);
0802b4aa          return 0;
0802b4a0      }
0802b4a0      
0802b4b4      sub_8021bf8(0x2000d020, 0);
0802b4b4      
0802b4bc      while (true)
0802b4bc      {
0802b4bc          r4 = (uint32_t)(uint8_t)r4;
0802b4bc          
0802b4c0          if (r4 != 1)
0802b55a              return 1;
0802b55a          
0802b4c2          r10 += 1;
0802b4c2          
0802b4ca          if (r10 == 0xa)
0802b4cc              sub_802c036();
0802b4ca          else if (r10 == 0x14)
0802b4d6          {
0802b4d8              sub_802c06e();
0802b4dc              r10 = 0;
0802b4d6          }
0802b4d6          
0802b4e6          if (!sub_802fca8())
0802b4e6          {
0802b4ec              f_close(0x2000d020);
0802b4f0              return 0;
0802b4e6          }
0802b4e6          
0802b4fa          uint32_t btr;
0802b4fa          
0802b4fa          btr = r7 + 0x70 >= r11_1 ? r11_1 - r7 : 0x70;
0802b4fa          
0802b512          if (ff_f_read(0x2000d020, buff, btr, &bytes_read))
0802b512          {
0802b518              f_close(0x2000d020);
0802b51c              return 0;
0802b512          }
0802b512          
0802b522          r7 += bytes_read;
0802b524          r9 += 1;
0802b524          
0802b530          if (r11_1 < 0x70 * r9)
0802b530          {
0802b538              if (!sub_802fca8())
0802b53a                  return 0;
0802b53a              
0802b53e              r4 = 0;
0802b530          }
0802b530          
0802b554          if (!sub_802b990(buff, r9, r11_1, type_must_be_8, (uint32_t)r6))
0802b554              break;
0802b554          
0802b4ba          r6 = 0;
0802b4bc      }
0802b4bc      
0802b556      return 0;
0802b3c2  }
0802b562        00 00                                                                                        ..
0802b564    int32_t sub_802b564(int32_t arg1 @ r7)
0802b564  {
0802b56e      int64_t q4;
0802b56e      (uint32_t)q4 = sub_8028be0();
0802b57c      bool cond:0 = float32_process((uint32_t)q4) >= 0;
0802b582      logging_wrapper("[PCBT]:%.4f\r\n");
0802b586      int128_t q0_1;
0802b586      (uint32_t)q0_1 = 0xc644284;
0802b58a      /* unimplemented  {vcmp.f32.F32 s16, s0} */
0802b58e      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802b58e      
0802b592      if (!cond:0)
0802b592      {
0802b598          camera_pa8_set(false, false);
0802b5a0          int32_t r2_1;
0802b5a0          int32_t r3_1;
0802b5a0          r2_1 = camera_pa8_set(true, false);
0802b5aa          software_mutex(1, 0x4e20, r2_1, r3_1);
0802b5b0          sub_8031c1e(1);
0802b592      }
0802b592      
0802b5b8      return arg1;
0802b564  }
0802b5ba    int32_t sub_802b5ba(char* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
0802b5ba  {
0802b5c0      *(uint8_t*)arg1 = 0x44;
0802b5c4      arg1[0x9b] = 0x16;
0802b5d4      memcpy_(0x2000de80, arg1, (uint32_t)arg1[1] + 2);
0802b5ea      memcpy_((uint32_t)arg1[1] + 0x2000de82, &arg1[0x9a], 2);
0802b5f6      sub_802b68c(0x2000de80, (uint32_t)arg1[1] + 4);
0802b5fa      return arg4;
0802b5ba  }
0802b5fc    int32_t sub_802b5fc(char* arg1, int32_t arg2)
0802b5fc  {
0802b5fc      int32_t r3;
0802b5fc      int32_t var_10_1 = r3;
0802b5fc      int32_t r2;
0802b5fc      int32_t var_14_1 = r2;
0802b5fc      int32_t var_18 = arg2;
0802b606      int32_t r3_1 = 0;
0802b608      var_18 = 0;
0802b608      int32_t var_14 = 0;
0802b608      int32_t var_10 = 0;
0802b60c      int32_t r5 = 0;
0802b60c      
0802b614      while (true)
0802b614      {
0802b614          if (r5)
0802b688              return 0;
0802b688          
0802b61e          r3_1 = sub_802b6b6(arg1, 1, 0xf4240, r3_1);
0802b61e          
0802b626          if ((uint32_t)*(uint8_t*)arg1 == 0x44)
0802b626              break;
0802b626          
0802b610          r5 += 1;
0802b614      }
0802b614      
0802b630      int32_t r3_2 = sub_802b6b6(&arg1[1], 1, 0xf4240, r3_1);
0802b63e      sub_802b6b6(&var_18, (uint32_t)arg1[1] + 2, 0xf4240, r3_2);
0802b64a      memcpy_(&arg1[2], &var_18, (uint32_t)arg1[1]);
0802b65c      memcpy_(&arg1[0x9a], (uint32_t)arg1[1] + &var_18, 2);
0802b65c      
0802b666      if ((uint32_t)arg1[0x9b] == 0x16
0802b666              && (uint32_t)sub_802ac5a(0, &arg1[1], (uint32_t)((uint16_t)arg1[1] + 1))
0802b666              == (uint32_t)arg1[0x9a])
0802b680          return 1;
0802b680      
0802b684      return 0;
0802b5fc  }
0802b68c    void sub_802b68c(int32_t arg1, int32_t arg2)
0802b68c  {
0802b68e      int32_t r4 = arg1;
0802b68e      
0802b6b2      for (int32_t i = 0; i < arg2; i += 1)
0802b6b2      {
0802b69c          usart_write_dr(data_20000c34, (uint32_t)*(uint8_t*)(r4 + i));
0802b69c          
0802b6ac          do
0802b6a6              arg1 = usart_check_flag(data_20000c34, 7);
0802b6ac           while (!arg1);
0802b6b2      }
0802b68c  }
0802b6b6    int32_t sub_802b6b6(char* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
0802b6b6  {
0802b6bc      int32_t r6 = arg3;
0802b6bc      
0802b6d0      for (int32_t i = 0; i < arg2; i += 1)
0802b6d0      {
0802b6d8          while (!usart_check_flag(data_20000c34, 5))
0802b6d8          {
0802b6e0              int32_t r0_4 = r6;
0802b6e2              r6 = r0_4 - 1;
0802b6e2              
0802b6e6              if (!r0_4)
0802b6ea                  return arg4;
0802b6d8          }
0802b6d8          
0802b6ca          arg1[i] = sub_803075e(data_20000c34);
0802b6d0      }
0802b6d0      
0802b6ea      return arg4;
0802b6b6  }
0802b6ec    int32_t sub_802b6ec(char arg1, char arg2, int32_t arg3, char* arg4, int32_t arg5, void* arg6)
0802b6ec  {
0802b6ec      int32_t result = arg3;
0802b6f2      *(uint8_t*)((char*)arg6 + 3) = arg1;
0802b6f4      *(uint8_t*)((char*)arg6 + 2) = arg2;
0802b6fe      memcpy_((char*)arg6 + 4, &result, 4);
0802b70e      memcpy_((char*)arg6 + 8, arg4, arg5);
0802b714      *(uint8_t*)((char*)arg6 + 1) = (uint8_t)arg5 + 6;
0802b724      *(uint8_t*)((char*)arg6 + 0x9a) = sub_802ac5a(0, (char*)arg6 + 1, 
0802b724          (uint32_t)((uint16_t)*(uint8_t*)((char*)arg6 + 1) + 1));
0802b728      return result;
0802b6ec  }
0802b72a    int32_t sub_802b72a(int32_t arg1, int32_t arg2, int32_t arg3)
0802b72a  {
0802b732      int32_t r5 = arg3;
0802b738      char buff[0x24];
0802b738      j_sub_80168a8(&buff, 0x20);
0802b73e      uint32_t bytes_read = 0;
0802b73e      
0802b742      if (arg1 != 1)
0802b766          sub_8021bf8(0x2000d020, data_2000d02c - 0x1e);
0802b742      else
0802b752          sub_8021bf8(0x2000d020, data_2000d02c - 0x123);
0802b752      
0802b77a      if (ff_f_read(0x2000d020, &buff, 0x1e, &bytes_read))
0802b77c          return 0;
0802b77c      
0802b786      sub_8021bf8(0x2000d020, 0);
0802b78a      char r0_5 = 0;
0802b78a      
0802b790      while (true)
0802b790      {
0802b790          uint32_t r0_6 = (uint32_t)r0_5;
0802b790          
0802b794          if (r0_6 >= r5)
0802b794              break;
0802b794          
0802b798          uint32_t r0_7 = (uint32_t)(uint8_t)r0_6;
0802b79c          uint32_t r0_8 = (uint32_t)(uint8_t)r0_7;
0802b79c          
0802b7a2          if ((uint32_t)buff[r0_7] != (uint32_t)*(uint8_t*)(arg2 + r0_8))
0802b7a4              return 0;
0802b7a4          
0802b78e          r0_5 = (uint8_t)r0_8 + 1;
0802b790      }
0802b790      
0802b7ac      while (true)
0802b7ac      {
0802b7ac          uint32_t r5_1 = (uint32_t)(uint8_t)r5;
0802b7ac          
0802b7b0          if (r5_1 >= 0x1d)
0802b7c8              return 1;
0802b7c8          
0802b7b4          uint32_t r5_2 = (uint32_t)(uint8_t)r5_1;
0802b7ba          uint32_t r5_3 = (uint32_t)(uint8_t)r5_2;
0802b7ba          
0802b7c2          if ((uint32_t)buff[r5_2] != (uint32_t)buff[r5_3 + 1])
0802b7c2              break;
0802b7c2          
0802b7aa          r5 = r5_3 + 1;
0802b7ac      }
0802b7ac      
0802b7c4      return 0;
0802b72a  }
0802b7ce                                            00 00 00 00                                                          ....
0802b7d2  int32_t data_802b7d2 = 0xc644284
0802b7d6                                                                    00 20                                                . 
0802b7d8  int32_t data_802b7d8 = 0x20000c3c
0802b7dc  int32_t data_802b7dc = 0x20000c34
0802b7e0  int32_t data_802b7e0 = 0x2000e3f4
0802b7e4  int32_t data_802b7e4 = 0x803b774
0802b7e8    int32_t sub_802b7e8(int32_t arg1, int32_t arg2, uint32_t arg3, int32_t arg4)
0802b7e8  {
0802b7e8      int32_t buff = arg4;
0802b7e8      uint32_t bytes_read = arg3;
0802b7ee      int32_t r5 = 0xffffffff;
0802b7f6      buff = 0xffffffff;
0802b7f8      uint32_t r6 = 1;
0802b7fa      uint32_t r7 = 0;
0802b7fe      bytes_read = 0;
0802b804      int32_t r9 = 0;
0802b80e      int32_t r4_1;
0802b80e      
0802b80e      r4_1 = arg1 != 1 ? arg2 - 0x22 : arg2 - 0x127;
0802b80e      
0802b81e      sub_8021bf8(0x2000d020, 0);
0802b830      void* buff_1 = sub_8034da8(0x1000, 0, nullptr);
0802b830      
0802b836      if (!buff_1)
0802b838          return 0;
0802b838      
0802b84e      while (true)
0802b84e      {
0802b84e          r6 = (uint32_t)(uint8_t)r6;
0802b84e          
0802b852          if (r6 != 1)
0802b852              break;
0802b852          
0802b856          r7 = (uint32_t)((uint16_t)r7 + 1);
0802b862          uint32_t btr;
0802b862          
0802b862          if (0x1000 * r7 < r4_1)
0802b87a              btr = 0x1000;
0802b862          else
0802b862          {
0802b864              r6 = 0;
0802b866              r7 = (uint32_t)(uint16_t)r7;
0802b874              btr = r4_1 - (0x1000 * r7 - 0x1000);
0802b862          }
0802b862          
0802b88c          if (ff_f_read(0x2000d020, buff_1, btr, &bytes_read))
0802b88e              return 0;
0802b88e          
0802b848          r5 = sub_802b8d4(r5, buff_1, btr >> 2);
0802b84a          r9 += btr;
0802b84e      }
0802b84e      
0802b896      sub_8021bf8(0x2000d020, r9);
0802b896      
0802b8a8      if (ff_f_read(0x2000d020, &buff, 4, &bytes_read))
0802b8aa          return 0;
0802b8aa      
0802b8b0      sub_803505e(buff_1);
0802b8bc      sub_8021bf8(0x2000d020, 0);
0802b8bc      
0802b8c4      if (buff == r5)
0802b8ca          return 1;
0802b8ca      
0802b8c6      return 0;
0802b7e8  }
0802b8d0  int32_t data_802b8d0 = 0x2000e3f8
0802b8d4    void sub_802b8d4(int32_t arg1, int32_t arg2, int32_t arg3)
0802b8d4  {
0802b8de      for (int32_t i = 0; i < arg3; i += 1)
0802b8de      {
0802b8e0          int32_t r5_1 = *(uint32_t*)(arg2 + (i << 2));
0802b8e0          
0802b8f0          for (int32_t j = 0; j < 0x20; j += 1)
0802b8f0          {
0802b8f8              arg1 = (r5_1 ^ arg1) >= 0 ? arg1 << 1 : 0x4c11db7 ^ arg1 << 1;
0802b8f8              
0802b8ea              r5_1 <<= 1;
0802b8f0          }
0802b8de      }
0802b8d4  }
0802b906                    00 00                                                                                ..
0802b908  int32_t data_802b908 = 0x2000e46b
0802b90c  int32_t data_802b90c = 0x40020000
0802b910  int32_t data_802b910 = 0x803c020
0802b914  int32_t data_802b914 = 0x2000e3ec
0802b918  int32_t data_802b918 = 0x2000e46c
0802b91c  int32_t data_802b91c = 0x2000e46d
0802b920  int32_t data_802b920 = 0x2000e46e
0802b924  int32_t data_802b924 = 0x803bd24
0802b928  int32_t data_802b928 = 0x803ba7c
0802b92c  int32_t data_802b92c = 0x20000deb
0802b930    int32_t sub_802b930()
0802b930  {
0802b934      int32_t r4 = 0x64;
0802b936      char r0;
0802b936      char var_a9 = r0;
0802b93c      char var_aa = 0x14;
0802b942      char var_ab = 2;
0802b94e      char r0_1;
0802b94e      int32_t r1_1;
0802b94e      int32_t r2;
0802b94e      int32_t r3;
0802b94e      r0_1 = sub_802ac5a(0, &var_ab, 3);
0802b952      char var_12 = r0_1;
0802b958      char var_145 = 0;
0802b958      
0802b97c      while (true)
0802b97c      {
0802b97c          if ((uint32_t)var_145 == 0xa0)
0802b98a              return 1;
0802b98a          
0802b97e          int32_t r0_6 = r4;
0802b980          r4 = r0_6 - 1;
0802b980          
0802b984          if (!r0_6)
0802b984              break;
0802b984          
0802b960          void var_ac;
0802b960          sub_802b5ba(&var_ac, r1_1, r2, r3);
0802b972          void var_148;
0802b972          r1_1 = sub_802b5fc(&var_148, memset16x2(&var_148, 0x9c, 0));
0802b97c      }
0802b97c      
0802b986      return 0;
0802b930  }
0802b990    int32_t sub_802b990(char* arg1, int32_t arg2, int32_t arg3, char arg4, int32_t arg5)
0802b990  {
0802b990      int32_t var_1c = arg3;
0802b99a      int32_t i = 0;
0802b99a      
0802b9a6      if (arg5 == 1)
0802b9a6      {
0802b9ac          data_2000e3fc = 0;
0802b9b2          data_2000e400 = 0;
0802b9b8          data_2000e404 = 0;
0802b9ba          i = 0;
0802b9c0          data_2000e40c = 0;
0802b9c6          data_2000e426 = 0;
0802b9a6      }
0802b9a6      
0802b9c8      uint32_t r3 = (uint32_t)arg4;
0802b9cc      char r6_1;
0802b9cc      char r8_1;
0802b9cc      
0802b9cc      if (r3 != 7)
0802b9cc      {
0802b9f4          if ((uint32_t)(uint8_t)r3 != 8)
0802b9fe              return 0;
0802b9fe          
0802b9f6          r8_1 = 0x23;
0802b9fa          r6_1 = 0x24;
0802b9cc      }
0802b9cc      else
0802b9cc      {
0802b9ce          r8_1 = 0x21;
0802b9d2          r6_1 = 0x22;
0802b9cc      }
0802b9cc      
0802b9de      if (0x70 * arg2 < var_1c)
0802ba06          data_2000e404 = 0x70;
0802b9de      else
0802b9ec          data_2000e404 = var_1c - 0x70 * arg2 + 0x70;
0802b9ec      
0802ba1c      data_2000e426 = sub_802ac5a((uint32_t)(uint8_t)data_2000e426, arg1, 
0802ba1c          (uint32_t)(uint16_t)data_2000e404);
0802ba34      void var_bc;
0802ba34      sub_802b6ec(r8_1, 0x14, data_2000e3fc, arg1, data_2000e404, &var_bc);
0802ba3a      char var_155_1 = 0;
0802ba3a      
0802baa6      do
0802baa6      {
0802ba50          void var_158;
0802ba50          char var_154;
0802ba50          
0802ba50          if ((uint32_t)var_155_1 == 0xa1 && data_2000e400 == data_2000e3fc)
0802ba50          {
0802bab8              data_2000e3fc += data_2000e404;
0802bab8              
0802bac4              if (0x70 * arg2 >= var_1c)
0802bac4              {
0802bac6                  char var_b9_1 = r6_1;
0802bacc                  char var_ba_1 = 0x14;
0802bad2                  char var_bb = 8;
0802bade                  void var_b8;
0802bade                  memcpy_(&var_b8, &var_1c, 4);
0802baea                  void var_b4;
0802baea                  memcpy_(&var_b4, &data_2000e426, 2);
0802baf6                  char r0_27;
0802baf6                  int32_t r1_10;
0802baf6                  int32_t r2_4;
0802baf6                  int32_t r3_4;
0802baf6                  r0_27 = sub_802ac5a(0, &var_bb, 9);
0802bafa                  char var_22_1 = r0_27;
0802bb00                  char var_155_2 = 0;
0802bb00                  
0802bb0a                  while ((uint32_t)var_155_2 != 0xa2)
0802bb0a                  {
0802bb0e                      sub_802b5ba(&var_bc, r1_10, r2_4, r3_4);
0802bb1a                      memset16x2(&var_158, 0x9c, 0);
0802bb26                      data_2000e40c += 1;
0802bb2a                      int32_t r0_34;
0802bb2a                      r0_34 = sub_802b5fc(&var_158, &data_2000e40c);
0802bb2a                      
0802bb38                      if (!r0_34 || (uint32_t)var_155_2 != 0xa2)
0802bb3a                          i += 1;
0802bb3a                      
0802bb3e                      if (i >= 0x65)
0802bb40                          return 0;
0802bb0a                  }
0802bb0a                  
0802bb4a                  if ((uint32_t)var_154)
0802bb4c                      return 0;
0802bac4              }
0802bac4              
0802bb58              data_2000e408 += i;
0802bb58              
0802bb60              if (data_2000e408 < 0x65)
0802bb66                  return 1;
0802bb66              
0802bb62              return 0;
0802ba50          }
0802ba50          
0802ba54          var_155_1 = 0;
0802ba60          int32_t r2_3;
0802ba60          int32_t r3_3;
0802ba60          r2_3 = memset16x2(&var_158, 0x9c, 0);
0802ba6c          data_2000e40c += 1;
0802ba6c          
0802ba84          if (!sub_802b5fc(&var_158, sub_802b5ba(&var_bc, &data_2000e40c, r2_3, r3_3))
0802ba84                  || (uint32_t)var_155_1 != 0xa1)
0802ba86              i += 1;
0802ba84          else
0802ba84          {
0802ba92              memcpy_(&data_2000e400, &var_154, 4);
0802ba92              
0802baa0              if (data_2000e3fc != data_2000e400)
0802baa2                  i += 1;
0802ba84          }
0802baa6      } while (i < 0xb);
0802baa6      
0802baa8      return 0;
0802b990  }
0802bb6e                                            00 00                                                                ..
0802bb70  int32_t data_802bb70 = 0x20000dec
0802bb74  int32_t data_802bb74 = 0x803af18
0802bb78  int32_t data_802bb78 = 0x803bd38
0802bb7c  int32_t data_802bb7c = 0x803bd4c
0802bb80  int32_t data_802bb80 = 0x2000e3f0
0802bb84  int32_t data_802bb84 = 0x803acf8
0802bb88  int32_t data_802bb88 = 0x2000d020
0802bb8c  int32_t data_802bb8c = 0x803c120
0802bb90  int32_t data_802bb90 = 0x803c02c
0802bb94  int32_t data_802bb94 = 0x803c038
0802bb98  int32_t data_802bb98 = 0x803bf20
0802bb9c  int32_t data_802bb9c = 0x803af40
0802bba0  int32_t data_802bba0 = 0x803bf30
0802bba4  int32_t data_802bba4 = 0x803b790
0802bba8  int32_t data_802bba8 = 0x803c128
0802bbac  int32_t data_802bbac = 0x803bf40
0802bbb0  int32_t data_802bbb0 = 0x2000de80
0802bbb4  int32_t data_802bbb4 = 0xf4240
0802bbb8  int32_t data_802bbb8 = 0x4c11db7
0802bbbc  int32_t data_802bbbc = 0x2000e3fc
0802bbc0  int32_t data_802bbc0 = 0x2000e400
0802bbc4  int32_t data_802bbc4 = 0x2000e404
0802bbc8  int32_t data_802bbc8 = 0x2000e40c
0802bbcc  int32_t data_802bbcc = 0x2000e426
0802bbd0  int32_t data_802bbd0 = 0x2000e408
0802bbd4    uint8_t sub_802bbd4(char arg1)
0802bbd4  {
0802bbd8      uint8_t result;
0802bbd8      
0802bbd8      if ((uint32_t)arg1 != 1)
0802bbd8      {
0802bbec          result = logging_level_mask & 0xfd;
0802bbf2          logging_level_mask = result;
0802bbd8      }
0802bbd8      else
0802bbd8      {
0802bbde          result = logging_level_mask | 2;
0802bbe4          logging_level_mask = result;
0802bbd8      }
0802bbd8      
0802bbf4      return result;
0802bbd4  }
0802bbf6  // // Reads a short command from the camera UART into a 10-byte buffer and
0802bbf6  // // adjusts logging runtime controls:
0802bbf6  // //   LOFF | DE | IN | WA | ER | on | off | ver
0802bbf6  // // Echoes the input line via console_printf.
0802bbf6  // // Returns 0 on "ver" match (strncmp style), otherwise a nonzero status.
0802bbf6  
0802bbf6    int32_t logging_cli_poll_and_handle()
0802bbf6  {
0802bc02      char buf[0xa];
0802bc02      memset16x2(&buf, 0xa, 0);
0802bc0a      cam_uart_tx_followup(&buf, 5);
0802bc12      console_printf("\r\n%s", &buf);
0802bc22      int32_t result;
0802bc22      
0802bc22      if (strncmp_local(&buf, "LOFF", 4))
0802bc22      {
0802bc38          if (strncmp_local(&buf, "DE", 2))
0802bc38          {
0802bc54              if (strncmp_local(&buf, "IN", 2))
0802bc54              {
0802bc70                  if (strncmp_local(&buf, "WA", 2))
0802bc70                  {
0802bc8c                      if (strncmp_local(&buf, "ER", 2))
0802bc8c                      {
0802bca8                          if (strncmp_local(&buf, "off", 3))
0802bca8                          {
0802bcbe                              if (strncmp_local(&buf, "on", 2))
0802bcbe                              {
0802bcce                                  result = strncmp_local(&buf, "ver", 3);
0802bcce                                  
0802bcd4                                  if (!result)
0802bce6                                      return console_printf("Version : %d.%d.%d.%d.%d\n", 
0802bce6                                          1, 0, 1, 0, 2);
0802bcbe                              }
0802bcbe                              else
0802bcbe                              {
0802bcc0                                  result = 1;
0802bcc4                                  logging_enabled = 1;
0802bcbe                              }
0802bca8                          }
0802bca8                          else
0802bca8                          {
0802bcaa                              result = 0;
0802bcae                              logging_enabled = 0;
0802bca8                          }
0802bc8c                      }
0802bc8c                      else
0802bc8c                      {
0802bc92                          result = (uint32_t)logging_level_mask | 0x10;
0802bc98                          logging_level_mask = (char)result;
0802bc8c                      }
0802bc70                  }
0802bc70                  else
0802bc70                  {
0802bc76                      result = (uint32_t)logging_level_mask | 8;
0802bc7c                      logging_level_mask = (char)result;
0802bc70                  }
0802bc54              }
0802bc54              else
0802bc54              {
0802bc5a                  result = (uint32_t)logging_level_mask | 4;
0802bc60                  logging_level_mask = (char)result;
0802bc54              }
0802bc38          }
0802bc38          else
0802bc38          {
0802bc3e              result = (uint32_t)logging_level_mask | 2;
0802bc44              logging_level_mask = (char)result;
0802bc38          }
0802bc22      }
0802bc22      else
0802bc22      {
0802bc24          result = 0;
0802bc28          logging_level_mask = 0;
0802bc22      }
0802bc22      
0802bcec      return result;
0802bbf6  }
0802bcee    int32_t logging_wrapper(char const* fmt, ...)
0802bcee  {
0802bcee      int32_t r3;
0802bcee      int32_t var_4 = r3;
0802bcee      int32_t r2;
0802bcee      int32_t var_8 = r2;
0802bcee      int32_t r1;
0802bcee      int32_t var_c = r1;
0802bcee      
0802bcf8      if ((uint32_t)logging_enabled != 1)
0802bd00          return fmt;
0802bd00      
0802bcfc      return logging_wrapper2(fmt);
0802bcee  }
0802bd04    int32_t sub_802bd04(int32_t arg1, char* arg2, int32_t arg3 @ r7)
0802bd04  {
0802bd04      int32_t r3;
0802bd04      int32_t var_4 = r3;
0802bd04      int32_t r2;
0802bd04      int32_t var_8 = r2;
0802bd04      
0802bd12      if ((uint32_t)logging_level_mask >> arg1 << 0x1f < 0)
0802bd18          logging_wrapper2(arg2);
0802bd18      
0802bd1e      return arg3;
0802bd04  }
0802bd22        00 00                                                                                        ..
0802bd24  data_802bd24:
0802bd24              44 45 00 00                                                                              DE..
0802bd28  data_802bd28:
0802bd28                          49 4e 00 00                                                                      IN..
0802bd2c  data_802bd2c:
0802bd2c                                      57 41 00 00                                                              WA..
0802bd30  data_802bd30:
0802bd30                                                  45 52 00 00                                                      ER..
0802bd34  data_802bd34:
0802bd34                                                              6f 66 66 00                                              off.
0802bd38  data_802bd38:
0802bd38                                                                          6f 6e 00 00                                      on..
0802bd3c  data_802bd3c:
0802bd3c                                                                                      76 65 72 00                              ver.
0802bd40  int32_t data_802bd40 = 0x2000e442
0802bd44  int32_t data_802bd44 = 0x2000e443
0802bd48  int32_t data_802bd48 = 0x803c090
0802bd4c  int32_t data_802bd4c = 0x803c098
0802bd50  int32_t data_802bd50 = 0x803b560
0802bd54    int32_t sub_802bd54(int32_t arg1 @ r7)
0802bd54  {
0802bd62      sub_8030026(&GPIOA, 0x400, 0xc00, 0);
0802bd66      return arg1;
0802bd54  }
0802bd68    int32_t sub_802bd68(int32_t arg1 @ r7)
0802bd68  {
0802bd76      sub_8030026(0x40020c00, 0x4000, 0xc03, 0);
0802bd7a      return arg1;
0802bd68  }
0802bd7c    int32_t sub_802bd7c(int32_t arg1 @ r7)
0802bd7c  {
0802bd8a      gpio_config_af(0x40020c00, 0x4000, 0xc03, 2);
0802bd8e      return arg1;
0802bd7c  }
0802bd90    int32_t sub_802bd90(char arg1, int32_t arg2 @ r7)
0802bd90  {
0802bd96      if ((uint32_t)arg1 != 1)
0802bd9e          sub_802bd7c(arg2);
0802bd96      else
0802bd98          sub_802bd68(arg2);
0802bd98      
0802bda2      return arg2;
0802bd90  }
0802bda4    int32_t sub_802bda4(int32_t arg1 @ r7)
0802bda4  {
0802bdb2      sub_8030026(0x40020c00, 0x4000, 0xc03, 0);
0802bdb6      return arg1;
0802bda4  }
0802bdb8    int32_t sub_802bdb8()
0802bdb8  {
0802bdb8      int32_t r7;
0802bdb8      int32_t var_8 = r7;
0802bdb8      
0802bdc6      if (sub_803004c(0x40020c00, 0x4000) != 1)
0802bdcc          return 0;
0802bdcc      
0802bdc8      return 1;
0802bdb8  }
0802bdd0    int32_t sub_802bdd0(int32_t arg1 @ r7)
0802bdd0  {
0802bdde      sub_8030026(0x40020c00, 0x8000, 0xc03, 0);
0802bde2      return arg1;
0802bdd0  }
0802bde4    int32_t sub_802bde4(int32_t arg1 @ r7)
0802bde4  {
0802bdf2      gpio_config_af(0x40020c00, 0x8000, 0xc03, 2);
0802bdf6      return arg1;
0802bde4  }
0802bdf8    int32_t sub_802bdf8(char arg1, int32_t arg2 @ r7)
0802bdf8  {
0802bdfe      if ((uint32_t)arg1 != 1)
0802be06          sub_802bde4(arg2);
0802bdfe      else
0802be00          sub_802bdd0(arg2);
0802be00      
0802be0a      return arg2;
0802bdf8  }
0802be0c    int32_t sub_802be0c(int32_t arg1 @ r7)
0802be0c  {
0802be10      sub_802bdf8(1, arg1);
0802be16      sub_802bd90(1, arg1);
0802be1a      return arg1;
0802be0c  }
0802be1c    int32_t sub_802be1c(int32_t arg1) __pure
0802be1c  {
0802be1e      int32_t result = 0xa * arg1;
0802be30      int32_t i;
0802be30      
0802be30      do
0802be30      {
0802be2a          i = result;
0802be2c          result = i - 1;
0802be30      } while (i);
0802be32      return result;
0802be1c  }
0802be34    int32_t sub_802be34(int32_t arg1 @ r7)
0802be34  {
0802be38      sub_802bdf8(1, arg1);
0802be3e      sub_802bd90(1, arg1);
0802be4a      sub_802bd90(0, arg1);
0802be56      sub_802bdf8(0, arg1);
0802be5a      return arg1;
0802be34  }
0802be5c    int32_t sub_802be5c(int32_t arg1 @ r7)
0802be5c  {
0802be60      sub_802bd90(0, arg1);
0802be6c      sub_802bdf8(1, arg1);
0802be78      sub_802bd90(1, arg1);
0802be84      sub_802bdf8(0, arg1);
0802be8a      sub_802bd90(0, arg1);
0802be8e      return arg1;
0802be5c  }
0802be90    int32_t sub_802be90(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
0802be90  {
0802be92      int32_t r4 = arg1;
0802be96      int32_t r7;
0802be96      sub_802bdf8(0, r7);
0802be9a      char r5 = 0;
0802be9a      
0802bec0      while (true)
0802bec0      {
0802bec0          uint32_t r5_1 = (uint32_t)r5;
0802bec0          
0802bec4          if (r5_1 >= 8)
0802bec4              break;
0802bec4          
0802bed0          if (!(uint32_t)((uint8_t)r4 >> 7))
0802bea0              sub_802bd90(0, r7);
0802bed0          else
0802bed4              sub_802bd90(1, r7);
0802bed4          
0802beac          sub_802bdf8(1, r7);
0802beb8          sub_802bdf8(0, r7);
0802bebc          r4 <<= 1;
0802bebe          r5 = (uint8_t)r5_1 + 1;
0802bec0      }
0802bec0      
0802bedc      sub_802bd90(1, r7);
0802bee8      sub_802bdf8(1, r7);
0802bef4      sub_802bdf8(0, r7);
0802befe      return arg4;
0802be90  }
0802bf00    uint32_t sub_802bf00()
0802bf00  {
0802bf00      int32_t r3;
0802bf00      int32_t var_10 = r3;
0802bf02      int32_t r5 = 0;
0802bf06      int32_t r7;
0802bf06      sub_802bd90(1, r7);
0802bf0a      sub_802bda4(r7);
0802bf0e      char r4 = 0;
0802bf0e      
0802bf3e      while (true)
0802bf3e      {
0802bf3e          uint32_t r4_1 = (uint32_t)r4;
0802bf3e          
0802bf42          if (r4_1 >= 8)
0802bf42              break;
0802bf42          
0802bf14          sub_802bdf8(1, r7);
0802bf20          sub_802bdf8(1, r7);
0802bf24          r5 <<= 1;
0802bf24          
0802bf2c          if (sub_802bdb8() == 1)
0802bf2e              r5 += 1;
0802bf2e          
0802bf32          sub_802bdf8(0, r7);
0802bf3c          r4 = (uint8_t)r4_1 + 1;
0802bf3e      }
0802bf3e      
0802bf46      sub_802bd90(0, r7);
0802bf52      sub_802bdf8(1, r7);
0802bf5e      sub_802bdf8(0, r7);
0802bf6c      return (uint32_t)(uint8_t)r5;
0802bf00  }
0802bf6e    uint32_t sub_802bf6e()
0802bf6e  {
0802bf70      int32_t r1;
0802bf70      int32_t r2;
0802bf70      int32_t r3;
0802bf70      int32_t r7;
0802bf70      r1 = sub_802be34(r7);
0802bf76      sub_802be90(0x49, r1, r2, r3);
0802bf7a      char r0 = sub_802bf00();
0802bf80      sub_802be5c(r7);
0802bf88      return (uint32_t)r0;
0802bf6e  }
0802bf8a    int32_t sub_802bf8a(char arg1, char arg2, int32_t arg3, int32_t arg4)
0802bf8a  {
0802bf90      int32_t r1;
0802bf90      int32_t r2;
0802bf90      int32_t r3;
0802bf90      int32_t r7;
0802bf90      r1 = sub_802be34(r7);
0802bf98      int32_t r1_1;
0802bf98      int32_t r2_1;
0802bf98      int32_t r3_1;
0802bf98      r1_1 = sub_802be90((uint32_t)arg1, r1, r2, r3);
0802bfa0      sub_802be90((uint32_t)arg2, r1_1, r2_1, r3_1);
0802bfa4      sub_802be5c(r7);
0802bfa8      return arg4;
0802bf8a  }
0802bfaa    uint32_t sub_802bfaa()
0802bfaa  {
0802bfae      int32_t r4 = 0;
0802bfb4      uint32_t r0_2 = (uint32_t)sub_802bf6e();
0802bfb4      
0802bfb8      if (r0_2 == 0x44)
0802bfd2          r4 = 8;
0802bfb8      else if (r0_2 == 0x4c)
0802bfce          r4 = 4;
0802bfbc      else if (r0_2 == 0x64)
0802bfca          r4 = 2;
0802bfc0      else if (r0_2 == 0x74)
0802bfc6          r4 = 1;
0802bfc6      
0802bfe0      if (!sub_803004c(&GPIOA, 0x400))
0802bfe2          r4 |= 0x10;
0802bfe2      
0802bfec      return (uint32_t)(uint8_t)r4;
0802bfaa  }
0802bfee                                            00 00                                                                ..
0802bff0  int32_t data_802bff0 = 0x40020000
0802bff4  int32_t data_802bff4 = 0x40020c00
0802bff8    int32_t sub_802bff8(char* arg1)
0802bff8  {
0802c000      int32_t entry_r2;
0802c000      int32_t r2;
0802c000      int32_t entry_r3;
0802c000      int32_t r3;
0802c000      r2 = sub_802bf8a(0x68, *(uint8_t*)arg1, entry_r2, entry_r3);
0802c00c      return sub_802bf8a(0x6a, arg1[1], r2, r3);
0802bff8  }
0802c00e    int32_t sub_802c00e(int32_t arg1 @ r7)
0802c00e  {
0802c014      int32_t entry_r2;
0802c014      int32_t entry_r3;
0802c014      sub_802bf8a(0x48, 1, entry_r2, entry_r3);
0802c018      return arg1;
0802c00e  }
0802c01a    int32_t sub_802c01a(int32_t arg1 @ r7)
0802c01a  {
0802c01c      sub_802be0c(arg1);
0802c022      rtos_delay_ticks(0xa);
0802c02c      sub_802c00e(arg1);
0802c030      sub_802bd54(arg1);
0802c034      return arg1;
0802c01a  }
0802c036    int32_t sub_802c036()
0802c036  {
0802c036      int32_t result_1;
0802c036      int32_t result = result_1;
0802c03a      (uint16_t)result = 0;
0802c040      (uint8_t)result = 8;
0802c046      *(uint8_t*)((char*)result)[1] = 8;
0802c04c      sub_802bff8(&result);
0802c050      return result;
0802c036  }
0802c052    int32_t sub_802c052()
0802c052  {
0802c052      int32_t result_1;
0802c052      int32_t result = result_1;
0802c056      (uint16_t)result = 0;
0802c05c      (uint8_t)result = 4;
0802c062      *(uint8_t*)((char*)result)[1] = 4;
0802c068      sub_802bff8(&result);
0802c06c      return result;
0802c052  }
0802c06e    int32_t sub_802c06e()
0802c06e  {
0802c06e      int32_t result_1;
0802c06e      int32_t result = result_1;
0802c072      (uint16_t)result = 0;
0802c078      (uint8_t)result = 0;
0802c07e      *(uint8_t*)((char*)result)[1] = 0;
0802c084      sub_802bff8(&result);
0802c088      return result;
0802c06e  }
0802c08a                                00 00                                                                        ..
0802c08c    int32_t sub_802c08c()
0802c08c  {
0802c08c      int32_t result_1;
0802c08c      int32_t result = result_1;
0802c094      dma_andnot_bits(0x40026400, 2, 0x10);
0802c09a      nvic_disable_irq(0x3a);
0802c0a2      dma_stream_disable(0x40026400, 2);
0802c0ac      dma_clear_flags(0x40026400, 2, 0x20);
0802c0b6      sub_8030aea(data_2000e304, &result);
0802c0b6      
0802c0be      if (result)
0802c0be      {
0802c0c6          *(uint32_t*)0xe000ed04 = 0x10000000;
0802c0c8          __dsb_SY();
0802c0cc          __isb();
0802c0be      }
0802c0be      
0802c0d0      return result;
0802c08c  }
0802c0d2    int32_t sub_802c0d2(int32_t arg1 @ r7)
0802c0d2  {
0802c0d4      sub_802c160(arg1);
0802c0d8      sub_802c21c(arg1);
0802c0e8      data_2000e304 = sub_80308ae(1, 0, 3);
0802c0e8      
0802c0f0      if (!data_2000e304)
0802c0f4          logging_wrapper("Create Semaphore Error!\r\n", &data_2000e304);
0802c0f4      
0802c0f8      return arg1;
0802c0d2  }
0802c0fa    int32_t sub_802c0fa(char* arg1, char arg2, int32_t arg3, int32_t arg4)
0802c0fa  {
0802c102      uint32_t r5_1 = (uint32_t)arg2;
0802c102      
0802c106      if (r5_1 == 1)
0802c106      {
0802c110          gpio_config_mode_pull(&GPIOB, 3, 0, 2);
0802c116          rtos_delay_ticks(5);
0802c106      }
0802c106      
0802c11a      int32_t r7;
0802c11a      sub_802c2ec(r7);
0802c11a      
0802c12c      if (rtos_dma_rx_wait_and_service(data_2000e304, 0xffffffff) != 1)
0802c130          logging_wrapper("xSemaphoreTake Error\r\n");
0802c130      
0802c13a      memcpy_(arg1, 0x2000e134, 0x12);
0802c146      memset16x2(0x2000e134, 9, 0);
0802c146      
0802c14e      if ((uint32_t)(uint8_t)r5_1 == 1)
0802c15a          gpio_config_af(&GPIOB, 2, 0xc01, 2);
0802c15a      
0802c15e      return arg4;
0802c0fa  }
0802c160    int32_t sub_802c160(int32_t arg1 @ r7)
0802c160  {
0802c166      rcc_enable_by_code(0xc00);
0802c172      gpio_config_mode_pull(&GPIOA, 3, 0, 0x47);
0802c17a      rcc_enable_by_code(0xc01);
0802c186      gpio_config_mode_pull(&GPIOB, 3, 0, 2);
0802c18e      rcc_enable_by_code(0xc02);
0802c19a      gpio_config_mode_pull(&GPIOC, 3, 0, 0xf);
0802c19e      return arg1;
0802c160  }
0802c1a0    int32_t sub_802c1a0()
0802c1a0  {
0802c1a8      rcc_enable_by_code(0xc16);
0802c1b0      dma_stream_reset_and_clear_flags(0x40026400, 2);
0802c1b6      int32_t var_2c = 0x4001214c;
0802c1ba      int32_t var_28 = 1;
0802c1be      int32_t var_24 = 0x2000e134;
0802c1c2      int32_t var_20 = 0;
0802c1c8      int32_t var_1c = 0x800;
0802c1cc      int32_t var_18 = 1;
0802c1d0      int32_t var_14 = 0;
0802c1d4      int32_t var_10 = 9;
0802c1da      int32_t var_c = 0x20000;
0802c1e4      uint32_t par;
0802c1e4      memcpy(&par, &var_2c, 0x24);
0802c1ee      uint32_t m0ar;
0802c1ee      dma_stream_config(0x40026400, 2, par, m0ar);
0802c1f8      dma_set_priority(0x40026400, 2, 1);
0802c200      dma_stream_enable(0x40026400, 2);
0802c20a      dma_or_bits(0x40026400, 2, 0x10);
0802c21a      return nvic_enable_irq_with_priority(0x3a, 2, 0);
0802c1a0  }
0802c21c    int32_t sub_802c21c(int32_t arg1 @ r7)
0802c21c  {
0802c222      rcc_enable_by_code(0x1109);
0802c22a      sub_8035750(0x10000);
0802c234      sub_8035770(0x40012100, 0, 9);
0802c23e      sub_80356ce(0x40012100, 0, 1);
0802c248      sub_80356ce(0x40012100, 4, 0);
0802c254      sub_803585c(0x40012100, 0, 0xa, 6);
0802c260      sub_803585c(0x40012100, 1, 0xb, 6);
0802c26c      sub_803585c(0x40012100, 2, 0xc, 6);
0802c278      sub_803585c(0x40012100, 3, 0xd, 6);
0802c284      sub_803585c(0x40012100, 4, 0, 6);
0802c290      sub_803585c(0x40012100, 5, 6, 6);
0802c29c      sub_803585c(0x40012100, 6, 1, 6);
0802c2a8      sub_803585c(0x40012100, 7, 2, 6);
0802c2b4      sub_803585c(0x40012100, 8, 9, 6);
0802c2be      sub_80357d2(0x40012100, 0, 0);
0802c2c6      sub_803565a(0x40012100, 0);
0802c2ce      sub_8035680(0x40012100, 0);
0802c2d4      sub_8035640(0x40012100);
0802c2da      sub_8035698(0x40012100);
0802c2e0      sub_803594c(0x40012100);
0802c2e6      sub_803595c(0x40012100);
0802c2ea      return arg1;
0802c21c  }
0802c2ec    int32_t sub_802c2ec(int32_t arg1 @ r7)
0802c2ec  {
0802c2ee      sub_802c1a0();
0802c2f6      sub_8035820(0x40012100, 0);
0802c2fe      sub_803584e(0x40012100, 2);
0802c302      return arg1;
0802c2ec  }
0802c304  int32_t data_802c304 = 0x40026400
0802c308  int32_t data_802c308 = 0x2000e304
0802c30c  int32_t data_802c30c = -0x1fff12fc
0802c310  int32_t data_802c310 = 0x803b42c
0802c314  int32_t data_802c314 = 0x40020400
0802c318  int32_t data_802c318 = 0x803b7dc
0802c31c  int32_t data_802c31c = 0x2000e134
0802c320  int32_t data_802c320 = 0x40020000
0802c324  int32_t data_802c324 = 0x40020800
0802c328  int32_t data_802c328 = 0x4001214c
0802c32c  int32_t data_802c32c = 0x40012100
0802c330    int32_t sub_802c330(int32_t arg1 @ r7)
0802c330  {
0802c336      sub_8026db2(&data_20000590);
0802c33a      return arg1;
0802c330  }
0802c33c    int32_t sub_802c33c(int32_t arg1 @ r7)
0802c33c  {
0802c342      sub_8026dfa(&data_20000590);
0802c346      return arg1;
0802c33c  }
0802c348    int32_t sub_802c348()
0802c348  {
0802c34a      int32_t r4 = 0;
0802c356      int32_t result = sub_8030804(data_20000560, 0x305);
0802c356      
0802c35c      if (result)
0802c35c      {
0802c368          result = usart_check_flag(data_20000560, 5);
0802c368          
0802c36e          if (result)
0802c36e          {
0802c378              uint32_t r0_3 = sub_803075e(data_20000560);
0802c378              
0802c384              if (!(uint32_t)data_2000e420)
0802c386                  r0_3 = (uint32_t)(uint8_t)r0_3;
0802c386              
0802c38a              if (!(uint32_t)data_2000e420 && r0_3 == 0x43)
0802c38a              {
0802c3b6                  *(uint8_t*)(&data_2000e248 + (uint32_t)data_2000e420) = (char)r0_3;
0802c3c2                  data_2000e420 += 1;
0802c38a              }
0802c38a              else
0802c38a              {
0802c394                  if ((uint32_t)data_2000e420 == 1)
0802c396                      r0_3 = (uint32_t)(uint8_t)r0_3;
0802c396                  
0802c39a                  if ((uint32_t)data_2000e420 == 1 && r0_3 == 0x6c)
0802c39a                  {
0802c3b6                      *(uint8_t*)(&data_2000e248 + (uint32_t)data_2000e420) = (char)r0_3;
0802c3c2                      data_2000e420 += 1;
0802c39a                  }
0802c39a                  else
0802c39a                  {
0802c3a4                      if ((uint32_t)data_2000e420 == 2)
0802c3a6                          r0_3 = (uint32_t)(uint8_t)r0_3;
0802c3a6                      
0802c3aa                      if ((uint32_t)data_2000e420 == 2 && r0_3 == 0x65)
0802c3aa                      {
0802c3b6                          *(uint8_t*)(&data_2000e248 + (uint32_t)data_2000e420) =
0802c3b6                              (char)r0_3;
0802c3c2                          data_2000e420 += 1;
0802c3aa                      }
0802c3aa                      else if ((uint32_t)data_2000e420 >= 3)
0802c3cc                      {
0802c3d4                          *(uint8_t*)(&data_2000e248 + (uint32_t)data_2000e420) =
0802c3d4                              (char)r0_3;
0802c3de                          data_2000e420 += 1;
0802c3cc                      }
0802c39a                  }
0802c38a              }
0802c38a              
0802c3e2              result = (uint32_t)data_2000e420;
0802c3e2              
0802c3e6              if (result == 0xe)
0802c3e6              {
0802c3ea                  char r0_8 = 0;
0802c3ea                  
0802c404                  while (true)
0802c404                  {
0802c404                      uint32_t r0_10 = (uint32_t)r0_8;
0802c404                      
0802c408                      if (r0_10 >= 0xe)
0802c408                          break;
0802c408                      
0802c3ee                      uint32_t r0_9 = (uint32_t)(uint8_t)r0_10;
0802c3ee                      
0802c3f2                      if (r0_9 != 0xa)
0802c3f2                      {
0802c3f4                          r0_9 = (uint32_t)(uint8_t)r0_9;
0802c3f4                          
0802c3f8                          if (r0_9 != 0xb)
0802c3f8                          {
0802c3fc                              r0_9 = (uint32_t)(uint8_t)r0_9;
0802c400                              r4 += (uint32_t)*(uint8_t*)(&data_2000e248 + r0_9);
0802c3f8                          }
0802c3f2                      }
0802c3f2                      
0802c402                      r0_8 = (uint8_t)r0_9 + 1;
0802c404                  }
0802c404                  
0802c426                  if ((uint32_t)((uint16_t)r4 >> 8) == (uint32_t)data_2000e252
0802c426                      || (uint32_t)(uint8_t)r4 == (uint32_t)data_2000e253)
0802c426                  {
0802c438                      data_2000e2fe =
0802c438                          (uint16_t)data_2000e24c | (int16_t)((uint32_t)data_2000e24b << 8);
0802c448                      data_2000e2fc =
0802c448                          (uint16_t)data_2000e24e | (int16_t)((uint32_t)data_2000e24d << 8);
0802c450                      data_2000e3c9 = data_2000e24f;
0802c458                      data_2000e3c8 = data_2000e250;
0802c458                      
0802c460                      if ((uint32_t)data_2000e251 == 1)
0802c460                      {
0802c468                          if ((uint32_t)data_2000e45b != 5)
0802c468                          {
0802c47a                              data_2000e45b += 1;
0802c480                              data_2000e45c = 0;
0802c486                              data_2000e45d = 0;
0802c468                          }
0802c468                          else
0802c46e                              data_2000e3cb = 1;
0802c46e                          
0802c48c                          data_2000e3c9 = 1;
0802c460                      }
0802c460                      else if ((uint32_t)data_2000e251 == 2)
0802c496                      {
0802c49e                          if ((uint32_t)data_2000e45c != 5)
0802c49e                          {
0802c4ac                              data_2000e45b = 0;
0802c4b6                              data_2000e45c += 1;
0802c4bc                              data_2000e45d = 0;
0802c49e                          }
0802c49e                          else
0802c4a4                              data_2000e3ca = 1;
0802c4a4                          
0802c4c2                          data_2000e3c8 = 1;
0802c496                      }
0802c496                      else if ((uint32_t)data_2000e251 != 3)
0802c4cc                      {
0802c50c                          data_2000e3ca = 0;
0802c512                          data_2000e3cb = 0;
0802c518                          data_2000e45b = 0;
0802c51e                          data_2000e45c = 0;
0802c524                          data_2000e45d = 0;
0802c4cc                      }
0802c4cc                      else
0802c4cc                      {
0802c4d4                          if ((uint32_t)data_2000e45d != 5)
0802c4d4                          {
0802c4e8                              data_2000e45b = 0;
0802c4ee                              data_2000e45c = 0;
0802c4f8                              data_2000e45d += 1;
0802c4d4                          }
0802c4d4                          else
0802c4d4                          {
0802c4da                              data_2000e3ca = 1;
0802c4e0                              data_2000e3cb = 1;
0802c4d4                          }
0802c4d4                          
0802c4fe                          data_2000e3c8 = 1;
0802c504                          data_2000e3c9 = 1;
0802c4cc                      }
0802c4cc                      
0802c52c                      data_2000e3cc = TickType_t xTaskGetTickCount(void)();
0802c426                  }
0802c426                  
0802c52e                  result = 0;
0802c532                  data_2000e420 = 0;
0802c3e6              }
0802c36e          }
0802c35c      }
0802c35c      
0802c534      return result;
0802c348  }
0802c536    int32_t sub_802c536()
0802c536  {
0802c542      int32_t var_2c;
0802c542      memcpy(&var_2c, 0x20000568, 0x28);
0802c54c      int32_t var_28;
0802c54c      int32_t var_24;
0802c54c      usart_init(data_20000560, var_2c, var_28, var_24);
0802c552      sub_8026c14(&data_20000590);
0802c55a      data_2000e3ca = 0;
0802c560      data_2000e3cb = 0;
0802c566      data_20000de8 = 1;
0802c568      sub_802c572();
0802c570      return 1;
0802c536  }
0802c572    int32_t sub_802c572()
0802c572  {
0802c578      data_2000e420 = 0;
0802c580      nvic_enable_irq_with_priority(0x47, 0, 0);
0802c58a      data_2000e3cc = TickType_t xTaskGetTickCount(void)();
0802c594      memset16x2(&data_2000e248, 0xe, 0);
0802c5a2      return sub_80307aa(data_20000560, 0x10000020);
0802c572  }
0802c5a4    int32_t sub_802c5a4()
0802c5a4  {
0802c5a8      int32_t r4 = data_2000e3cc;
0802c5aa      int32_t r0 = TickType_t xTaskGetTickCount(void)();
0802c5b0      int32_t r0_1;
0802c5b0      
0802c5b0      r0_1 = r0 >= r4 ? r0 - r4 : r0 + 0xffffffff - r4;
0802c5b0      
0802c5c0      if (r0_1 < 0x65)
0802c5c6          return 0;
0802c5c6      
0802c5c2      return 1;
0802c5a4  }
0802c5ca    int32_t sub_802c5ca(int16_t* arg1)
0802c5ca  {
0802c5ce      *(uint16_t*)arg1 = data_2000e2fc;
0802c5d4      arg1[1] = data_2000e2fe;
0802c5d8      return 1;
0802c5ca  }
0802c5da    int32_t sub_802c5da(char arg1)
0802c5da  {
0802c5dc      data_20000de8 = arg1;
0802c5e0      return 1;
0802c5da  }
0802c5e2    uint32_t sub_802c5e2()
0802c5e2  {
0802c5e6      return (uint32_t)data_20000de8;
0802c5e2  }
0802c5e8  int32_t data_802c5e8 = 0x20000590
0802c5ec  int32_t data_802c5ec = 0x20000560
0802c5f0  int32_t data_802c5f0 = 0x2000e420
0802c5f4  int32_t data_802c5f4 = 0x2000e248
0802c5f8  int32_t data_802c5f8 = 0x2000e2fc
0802c5fc  int32_t data_802c5fc = 0x2000e3c8
0802c600  int32_t data_802c600 = 0x2000e45b
0802c604  int32_t data_802c604 = 0x2000e45c
0802c608  int32_t data_802c608 = 0x2000e45d
0802c60c  int32_t data_802c60c = 0x2000e3cc
0802c610  int32_t data_802c610 = 0x20000568
0802c614  int32_t data_802c614 = 0x20000de8
0802c618  int32_t data_802c618 = 0x10000020
0802c61c    uint32_t get_motion_state()
0802c61c  {
0802c624      return (uint32_t)motion_state;
0802c61c  }
0802c626    int32_t set_motion_state(char arg1)
0802c626  {
0802c628      motion_state = arg1;
0802c62c      return 1;
0802c626  }
0802c62e    void system_bootstrap() __noreturn
0802c62e  {
0802c62e      int32_t r3;
0802c62e      int32_t var_10 = r3;
0802c630      char r5 = 0;
0802c632      sub_8031af8();
0802c636      int128_t q4;
0802c636      int64_t q5;
0802c636      q4 = SystemBringUp_AndMaybeRunBoardTest();
0802c63a      sub_802c7f4();
0802c63e      sub_802d0c8();
0802c642      sub_802a0b0();
0802c646      createSpeakerTask();
0802c64e      int32_t r4 = TickType_t xTaskGetTickCount(void)();
0802c662      int32_t r7;
0802c662      
0802c662      while (sub_802cea6() != 0x10)
0802c662      {
0802c66c          rtos_delay_ticks(1);
0802c66c          
0802c676          if (sub_802cea6() == 0x18)
0802c676          {
0802c654              sub_802a0d8(1, r7);
0802c65a              sub_8025bfa(1);
0802c65e              q4 = sub_8025510(q4, q5);
0802c676          }
0802c676          else if (sub_802cea6() == 0x14)
0802c67e          {
0802c680              int32_t r0_4 = TickType_t xTaskGetTickCount(void)();
0802c686              int32_t r0_5;
0802c686              
0802c686              r0_5 = r0_4 >= r4 ? r0_4 - r4 : r0_4 + 0xffffffff - r4;
0802c686              
0802c69e              if (r0_5 / 0x3e8 >= 6)
0802c69e              {
0802c6a2                  sub_802a0d8(1, r7);
0802c6a8                  sub_8025bfa(1);
0802c6ac                  q4 = sub_8025510(q4, q5);
0802c69e              }
0802c67e          }
0802c662      }
0802c662      
0802c6b4      while (true)
0802c6b4      {
0802c6ba          if (sub_802cea6() != 0x10)
0802c6b2              r5 = 0;
0802c6ba          else
0802c6ba          {
0802c6c0              if (!(uint32_t)r5)
0802c6c6                  r4 = TickType_t xTaskGetTickCount(void)();
0802c6c6              
0802c6c8              r5 = 1;
0802c6ca              int32_t r0_9 = TickType_t xTaskGetTickCount(void)();
0802c6d0              int32_t r0_10;
0802c6d0              
0802c6d0              r0_10 = r0_9 >= r4 ? r0_9 - r4 : r0_9 + 0xffffffff - r4;
0802c6d0              
0802c6e2              if (r0_10 >= 0x3e8)
0802c6e2                  break;
0802c6ba          }
0802c6b4      }
0802c6b4      
0802c6e4      sub_80271d8();
0802c6ea      sub_802a0d8(1, r7);
0802c6ee      sub_802abc4(r7);
0802c6f2      int32_t r0_11 = TickType_t xTaskGetTickCount(void)();
0802c6f8      cam_usart_init1();
0802c6fc      sub_8035970();
0802c702      sub_802cdf6(1);
0802c702      
0802c70e      while (true)
0802c70e      {
0802c70e          int32_t r0_12 = TickType_t xTaskGetTickCount(void)();
0802c714          int32_t r0_13;
0802c714          
0802c714          r0_13 = r0_12 >= r0_11 ? r0_12 - r0_11 : r0_12 + 0xffffffff - r0_11;
0802c714          
0802c72c          if (r0_13 / 0x3e8 >= 0x10)
0802c72c              break;
0802c72c          
0802c70a          rtos_delay_ticks(0x64);
0802c70e      }
0802c70e      
0802c730      sub_802cdf6(0);
0802c734      sub_802a0a4();
0802c73c      sub_8028468(0, 1);
0802c740      int32_t r0_15;
0802c740      int32_t r2;
0802c740      int32_t r3_1;
0802c740      r0_15 = device_init_all();
0802c740      
0802c746      if (r0_15 != 1)
0802c74a          r2 = logging_wrapper("device init fail\r\n");
0802c74a      
0802c752      int32_t r2_1;
0802c752      int32_t r3_2;
0802c752      r2_1 = sub_8033e90(1, 1, r2, r3_1);
0802c75a      sub_8033e90(2, 1, r2_1, r3_2);
0802c75e      CreateModeTask();
0802c764      set_motion_state(1);
0802c76c      doBeep(&turnTable);
0802c774      sub_80302c6(0x1d00);
0802c782      uint32_t i;
0802c782      
0802c782      do
0802c77c          i = sub_8030160(0x1d00);
0802c782       while (i != 1);
0802c78a      sub_8035c04(0x1f4, 4);
0802c78e      sub_8035bfa();
0802c78e      
0802c792      while (true)
0802c792          logging_cli_poll_and_handle();
0802c62e  }
0802c798    int32_t device_init_all()
0802c798  {
0802c798      int32_t r7;
0802c798      int32_t var_8 = r7;
0802c798      
0802c7a0      if (!moduleBorderInit())
0802c7a0      {
0802c7a4          logging_wrapper("moduleBorderInit\r\n");
0802c7a8          return 0;
0802c7a0      }
0802c7a0      
0802c7b2      if (!moduleSensorInit())
0802c7b2      {
0802c7b6          logging_wrapper("moduleSensorInit\r\n");
0802c7ba          return 0;
0802c7b2      }
0802c7b2      
0802c7c4      if (!vbCommMoudleInit())
0802c7c4      {
0802c7c8          logging_wrapper("vbCommMoudleInit\r\n");
0802c7cc          return 0;
0802c7c4      }
0802c7c4      
0802c7d6      if (createUsbTask())
0802c7dc          return 1;
0802c7dc      
0802c7d8      return 0;
0802c798  }
0802c7e0  int32_t data_802c7e0 = 0x2000e444
0802c7e4  int32_t data_802c7e4 = 0x803bc20
0802c7e8  int32_t data_802c7e8 = 0x803bc34
0802c7ec  int32_t data_802c7ec = 0x803bc48
0802c7f0  int32_t data_802c7f0 = 0x803bc5c
0802c7f4    int32_t sub_802c7f4()
0802c7f4  {
0802c7fe      data_2000e34c = 0;
0802c806      data_2000e34d = 0;
0802c80e      data_2000e34e = 0;
0802c816      data_2000e34f = 0;
0802c818      sub_802ce86();
0802c826      data_2000e350 = sub_8030938(1);
0802c826      
0802c830      if (!data_2000e350)
0802c830      {
0802c836          logging_wrapper("s_hmiLedMutex error\r\n", &data_2000e350);
0802c83a          return 0;
0802c830      }
0802c830      
0802c848      data_2000e354 = sub_8030938(1);
0802c848      
0802c852      if (!data_2000e354)
0802c852      {
0802c858          logging_wrapper("s_hmiKeyMutex error\r\n", &data_2000e354);
0802c85c          return 0;
0802c852      }
0802c852      
0802c860      int32_t r7;
0802c860      sub_802c01a(r7);
0802c872      gpio_config_af(0x40021000, 0x8000, 0xc04, 1);
0802c884      gpio_config_af(0x40021000, 0x4000, 0xc04, 2);
0802c896      gpio_config_af(0x40021000, 0x2000, 0xc04, 1);
0802c8a8      gpio_config_af(0x40021000, 0x1000, 0xc04, 2);
0802c8ae      int32_t var_c = 0;
0802c8b2      int32_t var_10 = 3;
0802c8c2      rtos_xTaskCreate(sub_802c99c, "HmiTask", 0x100, nullptr, 3, nullptr);
0802c8c6      return 1;
0802c7f4  }
0802c8ca    int32_t sub_802c8ca()
0802c8ca  {
0802c8ca      int32_t r7;
0802c8ca      int32_t var_8 = r7;
0802c8ca      
0802c8de      if (rtos_dma_rx_wait_and_service(data_2000e350, 0xffffffff) == 1)
0802c8ec          return 1;
0802c8ec      
0802c8e4      logging_wrapper("s_hmiLedMutex Error!!!\r\n");
0802c8e8      return 0;
0802c8ca  }
0802c8f0    int32_t sub_802c8f0()
0802c8f0  {
0802c8f0      int32_t r7;
0802c8f0      int32_t var_8 = r7;
0802c8f0      
0802c906      if (sub_8030954(data_2000e350, nullptr, 0, 0) == 1)
0802c914          return 1;
0802c914      
0802c90c      logging_wrapper("s_hmiLedMutex Error!!!\r\n");
0802c910      return 0;
0802c8f0  }
0802c918    int32_t sub_802c918()
0802c918  {
0802c918      int32_t r7;
0802c918      int32_t var_8 = r7;
0802c918      
0802c92c      if (rtos_dma_rx_wait_and_service(data_2000e354, 0xffffffff) == 1)
0802c93a          return 1;
0802c93a      
0802c932      logging_wrapper("s_hmiKeyMutex Error!!!\r\n");
0802c936      return 0;
0802c918  }
0802c93e    int32_t sub_802c93e()
0802c93e  {
0802c93e      int32_t r7;
0802c93e      int32_t var_8 = r7;
0802c93e      
0802c954      if (sub_8030954(data_2000e354, nullptr, 0, 0) == 1)
0802c962          return 1;
0802c962      
0802c95a      logging_wrapper("s_hmiKeyMutex Error!!!\r\n");
0802c95e      return 0;
0802c93e  }
0802c966    int32_t sub_802c966(int32_t arg1 @ r7)
0802c966  {
0802c970      sub_803001e(0x40021000, 0x8000, arg1);
0802c97c      sub_803001e(0x40021000, 0x4000, arg1);
0802c988      sub_803001e(0x40021000, 0x2000, arg1);
0802c994      sub_803001e(0x40021000, 0x1000, arg1);
0802c998      return arg1;
0802c966  }
0802c99a                                                                                00 00                                        ..
0802c99c    void sub_802c99c() __noreturn
0802c99c  {
0802c9a2      int16_t var_18 = 0;
0802c9a6      uint32_t r4 = 1;
0802c9a6      
0802c9ee      while (true)
0802c9ee      {
0802c9ee          int32_t r7;
0802c9ee          sub_802c966(r7);
0802c9ee          
0802c9f6          r4 = (uint32_t)(uint8_t)r4 ? 0 : 1;
0802c9f6          
0802c9fe          int32_t r0_8 = sub_802cf34();
0802ca04          uint32_t r0_9 = (uint32_t)(uint8_t)r0_8;
0802ca04          
0802ca0a          if (!r0_9)
0802ca2c              (uint8_t)var_18 &= 0xf3;
0802ca0a          else if (r0_9 == 2)
0802ca0e          {
0802cada              r4 = (uint32_t)(uint8_t)r4;
0802cada              
0802cade              if (r4 != 1)
0802caf6                  (uint8_t)var_18 |= 0xc;
0802cade              else
0802cae8                  (uint8_t)var_18 &= 0xf3;
0802ca0e          }
0802ca0e          else if (r0_9 < 2)
0802ca3a              (uint8_t)var_18 |= 0xc;
0802ca10          else if (r0_9 == 4)
0802ca5e              (uint8_t)var_18 = ((uint8_t)var_18 & 0xf3) | 4;
0802ca14          else if (r0_9 < 4)
0802ca4c              (uint8_t)var_18 = ((uint8_t)var_18 & 0xf3) | 8;
0802ca16          else if (r0_9 == 6)
0802ca1a          {
0802ca8a              r4 = (uint32_t)(uint8_t)r4;
0802ca8a              
0802ca8e              if (r4 != 1)
0802caaa                  (uint8_t)var_18 &= 0xf3;
0802ca8e              else
0802ca9c                  (uint8_t)var_18 = ((uint8_t)var_18 & 0xf3) | 4;
0802ca1a          }
0802ca1a          else if (r0_9 < 6)
0802ca1c          {
0802ca64              r4 = (uint32_t)(uint8_t)r4;
0802ca64              
0802ca68              if (r4 != 1)
0802ca84                  (uint8_t)var_18 &= 0xf3;
0802ca68              else
0802ca76                  (uint8_t)var_18 = ((uint8_t)var_18 & 0xf3) | 8;
0802ca1c          }
0802ca1c          else if (r0_9 == 7)
0802ca20          {
0802cab0              r4 = (uint32_t)(uint8_t)r4;
0802cab0              
0802cab4              if (r4 != 1)
0802cad4                  (uint8_t)var_18 = ((uint8_t)var_18 & 0xf3) | 4;
0802cab4              else
0802cac2                  (uint8_t)var_18 = ((uint8_t)var_18 & 0xf3) | 8;
0802ca20          }
0802ca20          
0802cafa          uint32_t r0_40 = (uint32_t)*(uint8_t*)((char*)r0_8)[1];
0802cafa          
0802cb00          if (!r0_40)
0802cb22              *(uint8_t*)((char*)var_18)[1] &= 0xf3;
0802cb00          else if (r0_40 == 2)
0802cb04          {
0802cbd0              r4 = (uint32_t)(uint8_t)r4;
0802cbd0              
0802cbd4              if (r4 != 1)
0802cbec                  *(uint8_t*)((char*)var_18)[1] |= 0xc;
0802cbd4              else
0802cbde                  *(uint8_t*)((char*)var_18)[1] &= 0xf3;
0802cb04          }
0802cb04          else if (r0_40 < 2)
0802cb30              *(uint8_t*)((char*)var_18)[1] |= 0xc;
0802cb06          else if (r0_40 == 4)
0802cb54              *(uint8_t*)((char*)var_18)[1] = (*(uint8_t*)((char*)var_18)[1] & 0xf3) | 4;
0802cb0a          else if (r0_40 < 4)
0802cb42              *(uint8_t*)((char*)var_18)[1] = (*(uint8_t*)((char*)var_18)[1] & 0xf3) | 8;
0802cb0c          else if (r0_40 == 6)
0802cb10          {
0802cb80              r4 = (uint32_t)(uint8_t)r4;
0802cb80              
0802cb84              if (r4 != 1)
0802cba0                  *(uint8_t*)((char*)var_18)[1] &= 0xf3;
0802cb84              else
0802cb92                  *(uint8_t*)((char*)var_18)[1] =
0802cb92                      (*(uint8_t*)((char*)var_18)[1] & 0xf3) | 4;
0802cb10          }
0802cb10          else if (r0_40 < 6)
0802cb12          {
0802cb5a              r4 = (uint32_t)(uint8_t)r4;
0802cb5a              
0802cb5e              if (r4 != 1)
0802cb7a                  *(uint8_t*)((char*)var_18)[1] &= 0xf3;
0802cb5e              else
0802cb6c                  *(uint8_t*)((char*)var_18)[1] =
0802cb6c                      (*(uint8_t*)((char*)var_18)[1] & 0xf3) | 8;
0802cb12          }
0802cb12          else if (r0_40 == 7)
0802cb16          {
0802cba6              r4 = (uint32_t)(uint8_t)r4;
0802cba6              
0802cbaa              if (r4 != 1)
0802cbca                  *(uint8_t*)((char*)var_18)[1] =
0802cbca                      (*(uint8_t*)((char*)var_18)[1] & 0xf3) | 4;
0802cbaa              else
0802cbb8                  *(uint8_t*)((char*)var_18)[1] =
0802cbb8                      (*(uint8_t*)((char*)var_18)[1] & 0xf3) | 8;
0802cb16          }
0802cb16          
0802cbf0          uint32_t r0_71 = (uint32_t)*(uint8_t*)((char*)r0_8)[2];
0802cbf0          
0802cbf6          if (!r0_71)
0802cc18              *(uint8_t*)((char*)var_18)[1] &= 0x5f;
0802cbf6          else if (r0_71 == 2)
0802cbfa          {
0802ccc6              r4 = (uint32_t)(uint8_t)r4;
0802ccc6              
0802ccca              if (r4 != 1)
0802cce2                  *(uint8_t*)((char*)var_18)[1] |= 0xa0;
0802ccca              else
0802ccd4                  *(uint8_t*)((char*)var_18)[1] &= 0x5f;
0802cbfa          }
0802cbfa          else if (r0_71 < 2)
0802cc26              *(uint8_t*)((char*)var_18)[1] |= 0xa0;
0802cbfc          else if (r0_71 == 4)
0802cc4a              *(uint8_t*)((char*)var_18)[1] = (*(uint8_t*)((char*)var_18)[1] & 0x5f) | 0x20;
0802cc00          else if (r0_71 < 4)
0802cc38              *(uint8_t*)((char*)var_18)[1] = (*(uint8_t*)((char*)var_18)[1] & 0x5f) | 0x80;
0802cc02          else if (r0_71 == 6)
0802cc06          {
0802cc76              r4 = (uint32_t)(uint8_t)r4;
0802cc76              
0802cc7a              if (r4 != 1)
0802cc96                  *(uint8_t*)((char*)var_18)[1] &= 0x5f;
0802cc7a              else
0802cc88                  *(uint8_t*)((char*)var_18)[1] =
0802cc88                      (*(uint8_t*)((char*)var_18)[1] & 0x5f) | 0x20;
0802cc06          }
0802cc06          else if (r0_71 < 6)
0802cc08          {
0802cc50              r4 = (uint32_t)(uint8_t)r4;
0802cc50              
0802cc54              if (r4 != 1)
0802cc70                  *(uint8_t*)((char*)var_18)[1] &= 0x5f;
0802cc54              else
0802cc62                  *(uint8_t*)((char*)var_18)[1] =
0802cc62                      (*(uint8_t*)((char*)var_18)[1] & 0x5f) | 0x80;
0802cc08          }
0802cc08          else if (r0_71 == 7)
0802cc0c          {
0802cc9c              r4 = (uint32_t)(uint8_t)r4;
0802cc9c              
0802cca0              if (r4 != 1)
0802ccc0                  *(uint8_t*)((char*)var_18)[1] =
0802ccc0                      (*(uint8_t*)((char*)var_18)[1] & 0x5f) | 0x20;
0802cca0              else
0802ccae                  *(uint8_t*)((char*)var_18)[1] =
0802ccae                      (*(uint8_t*)((char*)var_18)[1] & 0x5f) | 0x80;
0802cc0c          }
0802cc0c          
0802cce6          uint32_t r0_102 = (uint32_t)*(uint8_t*)((char*)r0_8)[3];
0802cce6          
0802ccec          if (!r0_102)
0802cd0e              (uint8_t)var_18 &= 0x5f;
0802ccec          else if (r0_102 == 2)
0802ccf0          {
0802cdbc              r4 = (uint32_t)(uint8_t)r4;
0802cdbc              
0802cdc0              if (r4 != 1)
0802cdd8                  (uint8_t)var_18 |= 0xa0;
0802cdc0              else
0802cdca                  (uint8_t)var_18 &= 0x5f;
0802ccf0          }
0802ccf0          else if (r0_102 < 2)
0802cd1c              (uint8_t)var_18 |= 0xa0;
0802ccf2          else if (r0_102 == 4)
0802cd40              (uint8_t)var_18 = ((uint8_t)var_18 & 0x5f) | 0x20;
0802ccf6          else if (r0_102 < 4)
0802cd2e              (uint8_t)var_18 = ((uint8_t)var_18 & 0x5f) | 0x80;
0802ccf8          else if (r0_102 == 6)
0802ccfc          {
0802cd6c              r4 = (uint32_t)(uint8_t)r4;
0802cd6c              
0802cd70              if (r4 != 1)
0802cd8c                  (uint8_t)var_18 &= 0x5f;
0802cd70              else
0802cd7e                  (uint8_t)var_18 = ((uint8_t)var_18 & 0x5f) | 0x20;
0802ccfc          }
0802ccfc          else if (r0_102 < 6)
0802ccfe          {
0802cd46              r4 = (uint32_t)(uint8_t)r4;
0802cd46              
0802cd4a              if (r4 != 1)
0802cd66                  (uint8_t)var_18 &= 0x5f;
0802cd4a              else
0802cd58                  (uint8_t)var_18 = ((uint8_t)var_18 & 0x5f) | 0x80;
0802ccfe          }
0802ccfe          else if (r0_102 == 7)
0802cd02          {
0802cd92              r4 = (uint32_t)(uint8_t)r4;
0802cd92              
0802cd96              if (r4 != 1)
0802cdb6                  (uint8_t)var_18 = ((uint8_t)var_18 & 0x5f) | 0x20;
0802cd96              else
0802cda4                  (uint8_t)var_18 = ((uint8_t)var_18 & 0x5f) | 0x80;
0802cd02          }
0802cd02          
0802cde2          int16_t r5_2;
0802cde2          
0802cde2          if (!(uint32_t)data_2000e43e)
0802cdee              r5_2 = 0x1f4;
0802cde2          else
0802cde2          {
0802cde6              sub_802d032(&var_18);
0802cdea              r5_2 = 0xfa;
0802cde2          }
0802cde2          
0802cdf2          char r0_3 = 0;
0802cdf2          
0802c9be          while (true)
0802c9be          {
0802c9be              uint32_t r0_4 = (uint32_t)r0_3;
0802c9be              
0802c9c2              if (r0_4 >= 2)
0802c9c2                  break;
0802c9c2              
0802c9b0              uint32_t r0_1 = (uint32_t)(uint8_t)r0_4;
0802c9b8              uint32_t r0_2 = (uint32_t)(uint8_t)r0_1;
0802c9ba              *(uint8_t*)(&data_2000e416 + r0_2) = *(uint8_t*)(&var_18 + r0_1);
0802c9bc              r0_3 = (uint8_t)r0_2 + 1;
0802c9be          }
0802c9be          
0802c9c4          sub_802c8ca();
0802c9ce          sub_802c00e(r7);
0802c9ce          
0802c9d8          if (sub_8025c0e() != 1)
0802c9de              sub_802bff8(&data_2000e416);
0802c9de          
0802c9e2          sub_802c8f0();
0802c9ea          rtos_delay_ticks((uint32_t)r5_2);
0802c9ee      }
0802c99c  }
0802cdf6    int32_t sub_802cdf6(char arg1)
0802cdf6  {
0802cdfa      uint32_t r4_1 = (uint32_t)arg1;
0802cdfa      
0802cdfe      if (!r4_1)
0802cdfe      {
0802ce02          sub_802ce1a(0);
0802ce08          sub_802ce62(0);
0802ce0e          sub_802ce3e(0);
0802cdfe      }
0802cdfe      
0802ce14      data_2000e43e = (char)r4_1;
0802ce18      return 1;
0802cdf6  }
0802ce1a    int32_t sub_802ce1a(char arg1)
0802ce1a  {
0802ce28      if ((uint32_t)data_2000e34c != (uint32_t)arg1)
0802ce28      {
0802ce2e          sub_802c8ca();
0802ce34          data_2000e34c = arg1;
0802ce36          sub_802c8f0();
0802ce28      }
0802ce28      
0802ce3c      return 1;
0802ce1a  }
0802ce3e    int32_t sub_802ce3e(char arg1)
0802ce3e  {
0802ce4c      if ((uint32_t)data_2000e34d != (uint32_t)arg1)
0802ce4c      {
0802ce52          sub_802c8ca();
0802ce58          data_2000e34d = arg1;
0802ce5a          sub_802c8f0();
0802ce4c      }
0802ce4c      
0802ce60      return 1;
0802ce3e  }
0802ce62    int32_t sub_802ce62(char arg1)
0802ce62  {
0802ce70      if ((uint32_t)data_2000e34e != (uint32_t)arg1)
0802ce70      {
0802ce76          sub_802c8ca();
0802ce7c          data_2000e34e = arg1;
0802ce7e          sub_802c8f0();
0802ce70      }
0802ce70      
0802ce84      return 1;
0802ce62  }
0802ce86    int32_t sub_802ce86()
0802ce86  {
0802ce8a      data_2000e2ac = 0;
0802ce90      data_2000e2ae = 0;
0802ce96      data_2000e2b0 = 0;
0802ce9c      data_2000e2b2 = 0;
0802cea2      data_2000e2b4 = 0;
0802cea4      return 0;
0802ce86  }
0802cea6    uint32_t sub_802cea6()
0802cea6  {
0802ceac      sub_802c918();
0802ceb0      char r0 = sub_802bfaa();
0802ceb8      sub_802c93e();
0802cebc      int32_t r0_1 = TickType_t xTaskGetTickCount(void)();
0802cec6      int16_t r4_1;
0802cec6      
0802cec6      if (r0_1 >= data_2000e358)
0802ceda          r4_1 = (uint16_t)r0_1 - (int16_t)data_2000e358;
0802cec6      else
0802ced2          r4_1 = (uint16_t)r0_1 + -1 - (int16_t)data_2000e358;
0802ced2      
0802cede      data_2000e358 = r0_1;
0802cede      
0802cee6      if ((uint32_t)r0 >= 0xc9)
0802cee6      {
0802ceec          data_2000e43d = 1;
0802ceee          return 0;
0802cee6      }
0802cee6      
0802cefa      sub_802cf6a((uint32_t)r0, r4_1);
0802cf06      sub_802cf92((uint32_t)r0, r4_1);
0802cf12      sub_802cfba((uint32_t)r0, r4_1);
0802cf1e      sub_802cfe2((uint32_t)r0, r4_1);
0802cf2a      sub_802d00a((uint32_t)r0, r4_1);
0802cf2e      return (uint32_t)r0;
0802cea6  }
0802cf34    int32_t sub_802cf34()
0802cf34  {
0802cf36      sub_802c8ca();
0802cf3c      int32_t result = (*(uint32_t*)data_2000e34c);
0802cf3e      sub_802c8f0();
0802cf44      return result;
0802cf34  }
0802cf46    uint32_t sub_802cf46()
0802cf46  {
0802cf4a      return (uint32_t)data_2000e43d;
0802cf46  }
0802cf4c    uint32_t sub_802cf4c()
0802cf4c  {
0802cf50      return (uint32_t)data_2000e2ac;
0802cf4c  }
0802cf52    uint32_t sub_802cf52()
0802cf52  {
0802cf56      return (uint32_t)data_2000e2ae;
0802cf52  }
0802cf58    uint32_t sub_802cf58()
0802cf58  {
0802cf5c      return (uint32_t)data_2000e2b0;
0802cf58  }
0802cf5e    uint32_t sub_802cf5e()
0802cf5e  {
0802cf62      return (uint32_t)data_2000e2b2;
0802cf5e  }
0802cf64    uint32_t sub_802cf64()
0802cf64  {
0802cf68      return (uint32_t)data_2000e2b4;
0802cf64  }
0802cf6a    int32_t sub_802cf6a(int32_t arg1, int16_t arg2)
0802cf6a  {
0802cf6c      int16_t result;
0802cf6c      
0802cf6c      if (arg1 << 0x1f >= 0)
0802cf6c      {
0802cf8a          result = 0;
0802cf8e          data_2000e2ac = 0;
0802cf6c      }
0802cf6c      else if (!(uint32_t)data_2000e2ac)
0802cf74      {
0802cf82          result = 1;
0802cf86          data_2000e2ac = 1;
0802cf74      }
0802cf74      else
0802cf74      {
0802cf7a          result = arg2 + data_2000e2ac;
0802cf7e          data_2000e2ac = result;
0802cf74      }
0802cf74      
0802cf90      return result;
0802cf6a  }
0802cf92    int32_t sub_802cf92(int32_t arg1, int16_t arg2)
0802cf92  {
0802cf94      int16_t result;
0802cf94      
0802cf94      if (arg1 << 0x1e >= 0)
0802cf94      {
0802cfb2          result = 0;
0802cfb6          data_2000e2ae = 0;
0802cf94      }
0802cf94      else if (!(uint32_t)data_2000e2ae)
0802cf9c      {
0802cfaa          result = 1;
0802cfae          data_2000e2ae = 1;
0802cf9c      }
0802cf9c      else
0802cf9c      {
0802cfa2          result = arg2 + data_2000e2ae;
0802cfa6          data_2000e2ae = result;
0802cf9c      }
0802cf9c      
0802cfb8      return result;
0802cf92  }
0802cfba    int32_t sub_802cfba(int32_t arg1, int16_t arg2)
0802cfba  {
0802cfbc      int16_t result;
0802cfbc      
0802cfbc      if (arg1 << 0x1d >= 0)
0802cfbc      {
0802cfda          result = 0;
0802cfde          data_2000e2b0 = 0;
0802cfbc      }
0802cfbc      else if (!(uint32_t)data_2000e2b0)
0802cfc4      {
0802cfd2          result = 1;
0802cfd6          data_2000e2b0 = 1;
0802cfc4      }
0802cfc4      else
0802cfc4      {
0802cfca          result = arg2 + data_2000e2b0;
0802cfce          data_2000e2b0 = result;
0802cfc4      }
0802cfc4      
0802cfe0      return result;
0802cfba  }
0802cfe2    int32_t sub_802cfe2(int32_t arg1, int16_t arg2)
0802cfe2  {
0802cfe4      int16_t result;
0802cfe4      
0802cfe4      if (arg1 << 0x1b >= 0)
0802cfe4      {
0802d002          result = 0;
0802d006          data_2000e2b2 = 0;
0802cfe4      }
0802cfe4      else if (!(uint32_t)data_2000e2b2)
0802cfec      {
0802cffa          result = 1;
0802cffe          data_2000e2b2 = 1;
0802cfec      }
0802cfec      else
0802cfec      {
0802cff2          result = arg2 + data_2000e2b2;
0802cff6          data_2000e2b2 = result;
0802cfec      }
0802cfec      
0802d008      return result;
0802cfe2  }
0802d00a    int32_t sub_802d00a(int32_t arg1, int16_t arg2)
0802d00a  {
0802d00c      int16_t result;
0802d00c      
0802d00c      if (arg1 << 0x1c >= 0)
0802d00c      {
0802d02a          result = 0;
0802d02e          data_2000e2b4 = 0;
0802d00c      }
0802d00c      else if (!(uint32_t)data_2000e2b4)
0802d014      {
0802d022          result = 1;
0802d026          data_2000e2b4 = 1;
0802d014      }
0802d014      else
0802d014      {
0802d01a          result = arg2 + data_2000e2b4;
0802d01e          data_2000e2b4 = result;
0802d014      }
0802d014      
0802d030      return result;
0802d00a  }
0802d032    int32_t sub_802d032(char* arg1)
0802d032  {
0802d038      if ((uint32_t)data_2000e43f == 1)
0802d038      {
0802d03c          *(uint8_t*)arg1 = 8;
0802d040          arg1[1] = 0;
0802d038      }
0802d038      else if ((uint32_t)data_2000e43f == 2)
0802d04a      {
0802d04e          arg1[1] = 0x80;
0802d052          *(uint8_t*)arg1 = 0;
0802d04a      }
0802d04a      else if ((uint32_t)data_2000e43f == 3)
0802d05c      {
0802d060          arg1[1] = 8;
0802d064          *(uint8_t*)arg1 = 0;
0802d06a          data_2000e43f = 0;
0802d05c      }
0802d05c      
0802d074      data_2000e43f += 1;
0802d078      return 1;
0802d032  }
0802d07a                                                                                00 00                                        ..
0802d07c  int32_t data_802d07c = 0x2000e34c
0802d080  int32_t data_802d080 = 0x2000e350
0802d084  int32_t data_802d084 = 0x803b8e4
0802d088  int32_t data_802d088 = 0x2000e354
0802d08c  int32_t data_802d08c = 0x803b8fc
0802d090  int32_t data_802d090 = 0x40021000
0802d094  int32_t data_802d094 = 0x803c070
0802d098  int32_t data_802d098 = 0x803b49c
0802d09c  int32_t data_802d09c = 0x803b4b8
0802d0a0  int32_t data_802d0a0 = 0x2000e416
0802d0a4  int32_t data_802d0a4 = 0x2000e43e
0802d0a8  int32_t data_802d0a8 = 0x2000e2ac
0802d0ac  int32_t data_802d0ac = 0x2000e358
0802d0b0  int32_t data_802d0b0 = 0x2000e43d
0802d0b4  int32_t data_802d0b4 = 0x2000e43f
0802d0b8    uint32_t sub_802d0b8()
0802d0b8  {
0802d0be      return (uint32_t)data_2000e448;
0802d0b8  }
0802d0c0    void sub_802d0c0(char arg1)
0802d0c0  {
0802d0c4      data_2000e448 = arg1;
0802d0c0  }
0802d0c8    int32_t sub_802d0c8()
0802d0c8  {
0802d0cc      int32_t r7;
0802d0cc      sub_802a720(r7);
0802d0d6      data_2000df1c = 0;
0802d0dc      sub_802a9cc(0, 0);
0802d0e6      data_2000df20 = 0;
0802d0ee      data_2000df24 = 0;
0802d0f6      data_2000df28 = 0;
0802d0fe      data_2000df44 = 1;
0802d108      data_2000df45 = 1;
0802d112      data_2000df48 = 0;
0802d11a      sub_802a9cc(1, 0);
0802d124      data_2000df4c = 0;
0802d12c      data_2000df50 = 0;
0802d134      data_2000df54 = 0;
0802d13c      data_2000df70 = 1;
0802d146      data_2000df71 = 1;
0802d150      data_2000df74 = 0;
0802d156      sub_802da4c(0, r7);
0802d160      data_2000df78 = 0;
0802d168      data_2000df7c = 0;
0802d170      data_2000df80 = 0;
0802d178      data_2000df9c = 1;
0802d182      data_2000df9d = 1;
0802d186      sub_802db3a();
0802d190      data_2000df2c = 0;
0802d198      data_2000df30 = 0;
0802d1a0      data_2000df58 = 0;
0802d1aa      data_2000df5c = 0;
0802d1b2      data_2000df84 = 0;
0802d1bc      data_2000df88 = 0;
0802d1c0      sub_802db76(0);
0802d1c6      sub_802db76(1);
0802d1cc      sub_802db76(2);
0802d1d2      sub_802a6bc(0);
0802d1d6      motorStop();
0802d1f0      int32_t r2;
0802d1f0      int32_t r3;
0802d1f0      r2 = rtos_xTaskCreate(&*(int32_t*)((char*)data_802d726 + 3), "MotorCtrlTask", 0x1f4, 
0802d1f0          nullptr, 6, nullptr);
0802d1fa      software_mutex(2, 0x1f4, r2, r3);
0802d200      return 1;
0802d0c8  }
0802d202    void* sub_802d202(char arg1, char arg2)
0802d202  {
0802d20e      (&data_2000df44)[0x2c * (uint32_t)arg1] = arg2;
0802d212      return &(&data_2000df1c)[0x2c * (uint32_t)arg1];
0802d202  }
0802d214    uint32_t sub_802d214(char arg1)
0802d214  {
0802d224      return (uint32_t)(&data_2000df44)[0x2c * (uint32_t)arg1];
0802d214  }
0802d226    int32_t sub_802d226(int64_t arg1 @ q0)
0802d226  {
0802d226      int32_t r7;
0802d226      int32_t var_8 = r7;
0802d22c      dbl_bits q4;
0802d22c      q4.lo = (uint32_t)arg1;
0802d230      q4.hi = *(uint32_t*)((char*)arg1)[4];
0802d238      uint32_t r0_1 = (uint32_t)driveSubsystemState();
0802d238      
0802d23c      if (r0_1 != 3)
0802d23c      {
0802d23e          uint32_t r0_2 = (uint32_t)(uint8_t)r0_1;
0802d23e          
0802d242          if (r0_2 != 4)
0802d242          {
0802d248              uint32_t r0_3 = (uint32_t)(uint8_t)r0_2;
0802d248              
0802d24c              if (!r0_3)
0802d24c              {
0802d254              label_802d254:
0802d254                  *(uint32_t*)((char*)arg1)[4] = q4.hi;
0802d258                  (uint32_t)arg1 = q4.lo;
0802d25c                  sub_802dd0c(arg1, q4);
0802d24c              }
0802d24c              else if (r0_3 == 2)
0802d250              {
0802d262                  *(uint32_t*)((char*)arg1)[4] = q4.hi;
0802d266                  (uint32_t)arg1 = q4.lo;
0802d26a                  sub_802de60(arg1, q4);
0802d250              }
0802d250              else if (r0_3 < 2)
0802d252                  goto label_802d254;
0802d252              
0802d26e              return 1;
0802d242          }
0802d23c      }
0802d23c      
0802d244      return 0;
0802d226  }
0802d276    int32_t motorBrake()
0802d276  {
0802d276      int32_t r7;
0802d276      int32_t var_8 = r7;
0802d27c      uint32_t r0_1 = (uint32_t)driveSubsystemState();
0802d27c      
0802d280      if (r0_1 != 3)
0802d280      {
0802d282          uint32_t r0_2 = (uint32_t)(uint8_t)r0_1;
0802d282          
0802d286          if (r0_2 != 4)
0802d286          {
0802d290              if (!(uint32_t)(uint8_t)r0_2 && !sub_802aa80(0) && !sub_802aa80(1))
0802d2a6                  return 1;
0802d2a6              
0802d2ac              sub_802da3a(0);
0802d2b2              sub_802da3a(1);
0802d2ba              sub_802a9e0(0, 0);
0802d2c2              sub_802a9e0(1, 0);
0802d2ca              sub_802d598(0, 0);
0802d2d2              sub_802d598(1, 0);
0802d2da              sub_802d202(0, 1);
0802d2e2              sub_802d202(1, 1);
0802d2ec              data_2000df45 = 1;
0802d2f6              data_2000df71 = 1;
0802d2f6              
0802d302              if ((uint32_t)data_2000e05c)
0802d30a                  data_2000e05c = 0;
0802d30a              
0802d312              data_2000e448 = 0;
0802d314              return 1;
0802d286          }
0802d280      }
0802d280      
0802d288      return 0;
0802d276  }
0802d318    int32_t sub_802d318()
0802d318  {
0802d318      int32_t r7;
0802d318      int32_t var_8 = r7;
0802d31e      uint32_t r0_1 = (uint32_t)driveSubsystemState();
0802d31e      
0802d322      if (r0_1 != 3)
0802d322      {
0802d324          uint32_t r0_2 = (uint32_t)(uint8_t)r0_1;
0802d324          
0802d328          if (r0_2 != 4)
0802d328          {
0802d332              if (!(uint32_t)(uint8_t)r0_2)
0802d334                  return 1;
0802d334              
0802d33a              sub_802da3a(0);
0802d340              sub_802da3a(1);
0802d348              sub_802a9e0(0, 1);
0802d350              sub_802a9e0(1, 1);
0802d35a              data_2000df45 = 0;
0802d364              data_2000df71 = 0;
0802d36c              sub_802d598(0, 0);
0802d374              sub_802d598(1, 0);
0802d37c              sub_802d202(0, 1);
0802d384              sub_802d202(1, 1);
0802d384              
0802d390              if ((uint32_t)data_2000e05c)
0802d398                  data_2000e05c = 0;
0802d398              
0802d3a0              data_2000e448 = 0;
0802d3a2              return 1;
0802d328          }
0802d322      }
0802d322      
0802d32a      return 0;
0802d318  }
0802d3a6    int32_t commandMotion(int32_t arg1, int32_t arg2, int32_t arg3, int128_t arg4 @ q0)
0802d3a6  {
0802d3a6      int32_t r3;
0802d3a6      int32_t var_c_1 = r3;
0802d3a6      int32_t var_10 = arg3;
0802d3a6      int32_t var_14_1 = arg2;
0802d3a6      int32_t var_18 = arg1;
0802d3aa      *(uint32_t*)((char*)arg4)[0xc] = *(uint32_t*)((char*)arg4)[4];
0802d3ae      *(uint32_t*)((char*)arg4)[4] = *(uint32_t*)((char*)arg4)[8];
0802d3b8      var_10 = 0;
0802d3b8      int32_t var_c = 0;
0802d3c6      var_18 = 0x40000000;
0802d3c6      int32_t var_14 = 0;
0802d3ca      uint32_t r4_1 = (uint32_t)(uint8_t)arg1;
0802d3ca      
0802d3ce      if (r4_1 == 1)
0802d3ce      {
0802d3e2          *(uint32_t*)((char*)arg4)[4] = *(uint32_t*)((char*)arg4)[0xc];
0802d3e6          sub_802dfac(&var_10, &var_18, (uint64_t)arg4);
0802d3ce      }
0802d3ce      else if (r4_1 >= 1)
0802d3d0      {
0802d3d4          if (r4_1 == 3)
0802d3fe              sub_802dfd8(&var_10, &var_18, 0x40000000, 0, (uint64_t)arg4);
0802d3d4          else if (r4_1 < 3)
0802d3d6          {
0802d3f0              *(uint32_t*)((char*)arg4)[4] = *(uint32_t*)((char*)arg4)[0xc];
0802d3f4              sub_802dfbe(&var_10, &var_18, (uint64_t)arg4);
0802d3d6          }
0802d3d6          else if (r4_1 == 4)
0802d408              sub_802e0c4(&var_10, &var_18, 0x40000000, 0, (uint64_t)arg4);
0802d3d0      }
0802d3d0      
0802d40e      sub_802e196(0);
0802d414      sub_802e196(1);
0802d41e      data_2000e06c = var_10;
0802d426      data_2000e070 = var_c;
0802d42e      data_2000e074 = var_18;
0802d436      data_2000e078 = var_14;
0802d43c      data_2000e05c = (char)r4_1;
0802d442      *(uint32_t*)((char*)arg4)[4] = data_2000e070;
0802d44a      (uint32_t)arg4 = data_2000e06c;
0802d44e      sub_802d226((uint64_t)arg4);
0802d456      return 1;
0802d3a6  }
0802d458    int32_t beeper_config_apply(int32_t arg1 @ q0)
0802d458  {
0802d458      int32_t r7;
0802d458      int32_t var_8 = r7;
0802d45e      int64_t q4;
0802d45e      (uint32_t)q4 = arg1;
0802d45e      
0802d46a      if (!isDriveSubsystemReady(2))
0802d46a      {
0802d472          char r0_2;
0802d472          
0802d472          if (sub_802da5c())
0802d478              r0_2 = 0;
0802d472          else
0802d474              r0_2 = 1;
0802d474          
0802d47c          sub_802da4c(r0_2, r7);
0802d46a      }
0802d46a      
0802d484      sub_802d598(2, 2);
0802d48a      sub_802a6bc(1);
0802d48e      int128_t q0;
0802d48e      (uint32_t)q0 = (uint32_t)q4;
0802d492      sub_802a770();
0802d49c      return 1;
0802d458  }
0802d49e                                                                                            00 00                                ..
0802d4a0    int32_t motorStop()
0802d4a0  {
0802d4a0      int32_t r7;
0802d4a0      int32_t var_8 = r7;
0802d4a8      uint32_t r0_1 = (uint32_t)isDriveSubsystemReady(2);
0802d4a8      
0802d4ac      if (r0_1 != 3)
0802d4ac      {
0802d4ae          uint32_t r0_2 = (uint32_t)(uint8_t)r0_1;
0802d4ae          
0802d4b2          if (r0_2 != 4)
0802d4b2          {
0802d4bc              if (!(uint32_t)(uint8_t)r0_2)
0802d4be                  return 1;
0802d4be              
0802d4c2              int128_t q0;
0802d4c2              (uint32_t)q0 = 0;
0802d4c6              sub_802a770();
0802d4cc              sub_802a6bc(0);
0802d4d4              sub_802d598(2, 0);
0802d4dc              sub_802d202(2, 1);
0802d4e6              didWeBeep = 0;
0802d4e8              return 1;
0802d4b2          }
0802d4ac      }
0802d4ac      
0802d4b4      return 0;
0802d4a0  }
0802d4ec    uint32_t beep_guard_get()
0802d4ec  {
0802d4f2      return (uint32_t)didWeBeep;
0802d4ec  }
0802d4f4    void beep_guard_set(char arg1)
0802d4f4  {
0802d4f8      didWeBeep = arg1;
0802d4f4  }
0802d4fc    int32_t sub_802d4fc()
0802d4fc  {
0802d4fc      int32_t r7;
0802d4fc      int32_t var_8 = r7;
0802d504      char r0_1;
0802d504      
0802d504      if (sub_802da5c())
0802d50a          r0_1 = 0;
0802d504      else
0802d506          r0_1 = 1;
0802d506      
0802d50e      sub_802da4c(r0_1, r7);
0802d512      int128_t q0;
0802d512      (uint32_t)q0 = 0x142c8;
0802d516      sub_802a770();
0802d51e      rtos_delay_ticks(0x3e8);
0802d522      int128_t q0_1;
0802d522      (uint32_t)q0_1 = 0;
0802d526      sub_802a770();
0802d52e      sub_802d202(2, 1);
0802d534      return 1;
0802d4fc  }
0802d536    int32_t driveSubsystemState()
0802d536  {
0802d53a      char r0 = isDriveSubsystemReady(0);
0802d542      char r0_1 = isDriveSubsystemReady(1);
0802d546      uint32_t r4_1 = (uint32_t)r0;
0802d546      
0802d54a      if (r4_1 != 3)
0802d54a      {
0802d54c          uint32_t r0_2 = (uint32_t)r0_1;
0802d54c          
0802d550          if (r0_2 != 3)
0802d550          {
0802d556              uint32_t r4_2 = (uint32_t)(uint8_t)r4_1;
0802d556              
0802d55a              if (r4_2 != 4)
0802d55a              {
0802d55c                  uint32_t r0_3 = (uint32_t)(uint8_t)r0_2;
0802d55c                  
0802d560                  if (r0_3 != 4)
0802d560                  {
0802d566                      uint32_t r4_3 = (uint32_t)(uint8_t)r4_2;
0802d566                      
0802d56a                      if (r4_3 != 1)
0802d56a                      {
0802d56c                          uint32_t r0_4 = (uint32_t)(uint8_t)r0_3;
0802d56c                          
0802d570                          if (r0_4 != 1)
0802d570                          {
0802d580                              if ((uint32_t)(uint8_t)r4_3 != 2
0802d580                                      && (uint32_t)(uint8_t)r0_4 != 2)
0802d586                                  return 0;
0802d586                              
0802d582                              return 2;
0802d570                          }
0802d56a                      }
0802d56a                      
0802d572                      return 1;
0802d560                  }
0802d55a              }
0802d55a              
0802d562              return 4;
0802d550          }
0802d54a      }
0802d54a      
0802d552      return 3;
0802d536  }
0802d58a    uint32_t isDriveSubsystemReady(char id)
0802d58a  {
0802d596      return (uint32_t)(&data_2000df1c)[0x2c * (uint32_t)id];
0802d58a  }
0802d598    int32_t sub_802d598(char arg1, char arg2)
0802d598  {
0802d5a0      int32_t result = 0x2c * (uint32_t)arg1;
0802d5a2      (&data_2000df1c)[result] = arg2;
0802d5a4      return result;
0802d598  }
0802d5a6    void* sub_802d5a6(char arg1)
0802d5a6  {
0802d5b2      int128_t q0;
0802d5b2      (uint32_t)q0 = (&data_2000df20)[(uint32_t)arg1 * 0xb];
0802d5b6      return &(&data_2000df1c)[0x2c * (uint32_t)arg1];
0802d5a6  }
0802d5b8    void* sub_802d5b8(char arg1, int32_t arg2 @ q0)
0802d5b8  {
0802d5c4      (&data_2000df20)[(uint32_t)arg1 * 0xb] = arg2;
0802d5c8      return &(&data_2000df1c)[0x2c * (uint32_t)arg1];
0802d5b8  }
0802d5ca    void* reduceSpeedOrGuard(char arg1)
0802d5ca  {
0802d5d6      int128_t q0;
0802d5d6      (uint32_t)q0 = (&data_2000df24)[(uint32_t)arg1 * 0xb];
0802d5da      return &(&data_2000df1c)[0x2c * (uint32_t)arg1];
0802d5ca  }
0802d5dc    void* sub_802d5dc(char arg1, int32_t arg2 @ q0)
0802d5dc  {
0802d5e8      (&data_2000df24)[(uint32_t)arg1 * 0xb] = arg2;
0802d5ec      return &(&data_2000df1c)[0x2c * (uint32_t)arg1];
0802d5dc  }
0802d5ee    void* sub_802d5ee(char arg1)
0802d5ee  {
0802d5fa      int128_t q0;
0802d5fa      (uint32_t)q0 = (&data_2000df30)[(uint32_t)arg1 * 0xb];
0802d5fe      return &(&data_2000df1c)[0x2c * (uint32_t)arg1];
0802d5ee  }
0802d600    int32_t sub_802d600(int32_t arg1)
0802d600  {
0802d602      bool n = arg1 < 0;
0802d604      float q0 = 0x42c80001;
0802d608      /* unimplemented  {vcmp.f32.F32 s0, s1} */
0802d60c      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802d610      bool v;
0802d610      
0802d610      if (n != v)
0802d610      {
0802d618          /* unimplemented  {vcmp.f32.F32 s0, #0} */
0802d61c          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802d61c          
0802d620          if (n)
0802d622              q0 = 0f;
0802d610      }
0802d610      else
0802d612          q0 = -6.86425096e-07f;
0802d612      
0802d62a      uint32_t r4_1 = (uint32_t)(uint8_t)arg1;
0802d634      (&data_2000df30)[r4_1 * 0xb] = q0;
0802d638      uint32_t r4_2 = (uint32_t)(uint8_t)r4_1;
0802d638      
0802d63c      if (r4_2 == 2)
0802d63c      {
0802d64c          (&data_2000df30)[(uint32_t)(uint8_t)r4_2 * 0xb];
0802d650          return sub_802a770();
0802d63c      }
0802d63c      
0802d668      int32_t r7;
0802d668      sub_802bd04(1, "pwm %d %d\r\n", r7);
0802d670      uint32_t r4_5 = (uint32_t)(uint8_t)r4_2;
0802d67a      int128_t q0_1;
0802d67a      (uint32_t)q0_1 = (&data_2000df30)[r4_5 * 0xb];
0802d682      return sub_802a794((uint8_t)r4_5);
0802d600  }
0802d688    int32_t sub_802d688(int32_t arg1 @ r7, int32_t arg2 @ q0)
0802d688  {
0802d68e      int64_t q4;
0802d68e      (uint32_t)q4 = arg2;
0802d698      uint32_t r0_1 = (uint32_t)isDriveSubsystemReady(2);
0802d698      
0802d69c      if (r0_1 != 3)
0802d69c      {
0802d69e          uint32_t r0_2 = (uint32_t)(uint8_t)r0_1;
0802d6a0          bool cond:0_1 = r0_2 >= 0;
0802d6a2          uint32_t r0_3;
0802d6a2          
0802d6a2          if (r0_2)
0802d6a2          {
0802d6a4              r0_3 = (uint32_t)(uint8_t)r0_2;
0802d6a6              cond:0_1 = r0_3 - 1 >= 0;
0802d6a2          }
0802d6a2          
0802d6a8          if (!r0_2 || r0_3 == 1)
0802d6a8          {
0802d6ae              /* unimplemented  {vcmp.f32.F32 s16, s0} */
0802d6b2              /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802d6b2              
0802d6b6              if (!cond:0_1)
0802d6b6              {
0802d6c0                  if ((uint32_t)data_2000e44a == 4)
0802d6c0                  {
0802d6c8                      sub_802d600(2);
0802d6d2                      sub_802bd04(1, "moduleMotorStopCutterEndlogic\r\n", arg1);
0802d6e2                      data_2000e44a += 1;
0802d6c0                  }
0802d6c0                  else if ((uint32_t)data_2000e44a < 4)
0802d6fc                      data_2000e44a += 1;
0802d6b6              }
0802d6a8          }
0802d6a8          else if ((uint32_t)data_2000e44a)
0802d710              data_2000e44a = 0;
0802d69c      }
0802d69c      
0802d716      return arg1;
0802d688  }
0802d718                                                                          00 00                                            ..
0802d71a  int32_t data_802d71a = 0x0
0802d71e    void sub_802d71e(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int128_t arg5 @ q4) __noreturn
0802d71e  {
0802d720      int32_t r1 = arg1;
0802d728      int32_t var_10 = arg4;
0802d72a      int64_t var_18 = (uint64_t)arg5;
0802d72a      int64_t var_20 = *(uint64_t*)((char*)arg5)[8];
0802d734      int32_t r4 = TickType_t xTaskGetTickCount(void)();
0802d736      char r5 = 0;
0802d7a0      int32_t var_2c;
0802d7a0      int32_t var_28;
0802d7a0      
0802d7a0      while (true)
0802d7a0      {
0802d7a0          uint32_t r5_1 = (uint32_t)r5;
0802d7a0          
0802d7a4          if (r5_1 >= 4)
0802d7a4              break;
0802d7a4          
0802d73a          int64_t q0;
0802d73a          *(uint32_t*)((char*)q0)[4] = *(uint32_t*)((char*)arg5)[4];
0802d73e          (uint32_t)q0 = var_2c;
0802d744          int32_t r0_1;
0802d744          int32_t r1_1;
0802d744          int32_t r2;
0802d744          int32_t r3;
0802d744          r0_1 = sub_802e254(0, r1, arg3, arg4, q0, (uint64_t)arg5);
0802d74a          int32_t r0_2;
0802d74a          
0802d74a          if (r0_1 == 1)
0802d74a          {
0802d74c              *(uint32_t*)((char*)q0)[4] = *(uint32_t*)((char*)arg5)[8];
0802d750              (uint32_t)q0 = var_28;
0802d756              r0_2 = sub_802e254(1, r1_1, r2, r3, q0, (uint64_t)arg5);
0802d74a          }
0802d74a          
0802d75c          if (r0_1 != 1 || r0_2 != 1)
0802d75c          {
0802d75e              int32_t r0_3;
0802d75e              r0_3 = driveSubsystemState();
0802d75e              
0802d764              if (r0_3 == 3)
0802d764              {
0802d766                  (uint32_t)q0 = 0xb5100000;
0802d76e                  sub_802a97c(0, 1);
0802d772                  int128_t q0_1;
0802d772                  (uint32_t)q0_1 = 0xb5100000;
0802d77a                  sub_802a97c(0, 2);
0802d77e                  int128_t q0_2;
0802d77e                  (uint32_t)q0_2 = 0xb5100000;
0802d786                  sub_802a97c(1, 1);
0802d78a                  int128_t q0_3;
0802d78a                  (uint32_t)q0_3 = 0xb5100000;
0802d792                  arg4 = sub_802a97c(1, 2);
0802d79a                  r1 = safetyEventSet2(0, 1);
0802d764              }
0802d75c          }
0802d75c          
0802d79e          r5 = (uint8_t)r5_1 + 1;
0802d7a0      }
0802d7a0      
0802d7ac      while (true)
0802d7ac      {
0802d7ac          software_mutex(2, 0x1f4, arg3, arg4);
0802d7b2          rtos_delay_ticks(0x64);
0802d7b8          int32_t q0_4;
0802d7b8          int64_t q4;
0802d7b8          q0_4 = sub_802aa8c(0);
0802d7bc          *(uint32_t*)((char*)q4)[4] = q0_4;
0802d7c8          int32_t a;
0802d7c8          int32_t b;
0802d7c8          
0802d7c8          if (sub_802a9d6(0) == 1)
0802d7c8          {
0802d7ce              float32_process(*(uint32_t*)((char*)q4)[4]);
0802d7d8              int32_t r0_6;
0802d7d8              int32_t r1_2;
0802d7d8              r0_6 = soft_dmul(a, b);
0802d7e0              *(uint32_t*)((char*)q4)[4] = sub_802ead0(r0_6, r1_2);
0802d7c8          }
0802d7c8          
0802d7e6          int32_t q0_5;
0802d7e6          int96_t q4_1;
0802d7e6          q0_5 = sub_802aa8c(1);
0802d7ea          *(uint32_t*)((char*)q4_1)[8] = q0_5;
0802d7ea          
0802d7f6          if (sub_802a9d6(1) == 1)
0802d7f6          {
0802d7fc              float32_process(*(uint32_t*)((char*)q4_1)[8]);
0802d806              int32_t r0_10;
0802d806              int32_t r1_3;
0802d806              r0_10 = soft_dmul(a, b);
0802d80e              *(uint32_t*)((char*)q4_1)[8] = sub_802ead0(r0_10, r1_3);
0802d7f6          }
0802d7f6          
0802d814          int32_t q0_6;
0802d814          int128_t q4_2;
0802d814          q0_6 = sub_802aa8c(2);
0802d818          (uint32_t)q4_2 = q0_6;
0802d81c          int32_t r0_12 = TickType_t xTaskGetTickCount(void)();
0802d81c          
0802d822          if (r0_12 >= r4)
0802d834              *(uint32_t*)((char*)q4_2)[0xc] = r0_12 - r4;
0802d822          else
0802d82c              *(uint32_t*)((char*)q4_2)[0xc] = r0_12 + 0xffffffff - r4;
0802d82c          
0802d838          r4 = r0_12;
0802d83a          int32_t var_30_1 = *(uint32_t*)((char*)q4_2)[0xc];
0802d842          int32_t b_1;
0802d842          int32_t r1_7;
0802d842          b_1 = float32_process((uint32_t)q4_2);
0802d846          b = b_1;
0802d846          int32_t var_34_1 = r1_7;
0802d84e          int32_t a_1;
0802d84e          int32_t r1_8;
0802d84e          a_1 = float32_process(*(uint32_t*)((char*)q4_2)[8]);
0802d852          a = a_1;
0802d852          int32_t var_3c_1 = r1_8;
0802d85a          int32_t r0_16;
0802d85a          int32_t r1_9;
0802d85a          r0_16 = float32_process(*(uint32_t*)((char*)q4_2)[4]);
0802d868          int32_t r7;
0802d868          sub_802bd04(1, "A%.2f B%.2f C%.2f t %d\r\n", r7);
0802d86c          int32_t r3_4;
0802d86c          int64_t q0_7;
0802d86c          int96_t q4_3;
0802d86c          r3_4 = sub_802e498(r7);
0802d870          (uint32_t)q0_7 = *(uint32_t*)((char*)q4_3)[4];
0802d876          sub_802d5dc(0, (uint32_t)q0_7);
0802d87a          (uint32_t)q0_7 = *(uint32_t*)((char*)q4_3)[8];
0802d880          sub_802d5dc(1, (uint32_t)q0_7);
0802d884          (uint32_t)q0_7 = (uint32_t)q4_3;
0802d88a          sub_802d5dc(2, (uint32_t)q0_7);
0802d88e          *(uint32_t*)((char*)q0_7)[4] = *(uint32_t*)((char*)q4_3)[4];
0802d892          (uint32_t)q0_7 = var_2c;
0802d898          int32_t r0_17;
0802d898          int32_t r1_10;
0802d898          int32_t r2_4;
0802d898          int32_t r3_5;
0802d898          int64_t q0_8;
0802d898          int96_t q4_4;
0802d898          r0_17 = sub_802e254(0, &data_2000df1c, 0x2c, r3_4, q0_7, (uint64_t)q4_3);
0802d898          
0802d89e          if (r0_17 == 1)
0802d89e          {
0802d8a2              *(uint32_t*)((char*)q0_8)[4] = *(uint32_t*)((char*)q4_4)[8];
0802d8a6              (uint32_t)q0_8 = var_28;
0802d8ac              int32_t r0_18;
0802d8ac              int128_t q4_5;
0802d8ac              r0_18 = sub_802e254(1, r1_10, r2_4, r3_5, q0_8, (uint64_t)q4_4);
0802d8ac              
0802d8b2              if (r0_18 == 1)
0802d8b2              {
0802d8b6                  (uint32_t)q0_8 = (float)*(uint32_t*)((char*)q4_5)[0xc];
0802d8ba                  (uint32_t)q0_8 = (uint32_t)q0_8 * *(uint32_t*)((char*)q4_5)[8];
0802d8c2                  float32_process((uint32_t)q0_8);
0802d8ce                  soft_dmul(a, b);
0802d8da                  int32_t r0_20;
0802d8da                  int32_t r1_11;
0802d8da                  r0_20 = soft_dmul();
0802d8e6                  *(uint32_t*)((char*)q0_8)[4] = sub_802ead0(r0_20, r1_11) & 0x7fffffff;
0802d8ea                  (uint32_t)q4_5 = *(uint32_t*)((char*)q0_8)[4];
0802d8ee                  (uint32_t)q0_8 = (float)*(uint32_t*)((char*)q4_5)[0xc];
0802d8f2                  (uint32_t)q0_8 = (uint32_t)q0_8 * *(uint32_t*)((char*)q4_5)[4];
0802d8fa                  float32_process((uint32_t)q0_8);
0802d906                  soft_dmul();
0802d912                  int32_t r0_24;
0802d912                  int32_t r1_12;
0802d912                  r0_24 = soft_dmul();
0802d91e                  (uint32_t)q0_8 = sub_802ead0(r0_24, r1_12) & 0x7fffffff;
0802d922                  *(uint32_t*)((char*)q0_8)[4] = (uint32_t)q4_5;
0802d922                  
0802d92c                  if (sub_802e1ac() == 1)
0802d92e                      sub_802d318();
0802d92e                  
0802d934                  int64_t q0_9;
0802d934                  int96_t q4_6;
0802d934                  arg3 = sub_802da68(&var_2c);
0802d93c                  uint32_t r0_29 = (uint32_t)data_2000df2c;
0802d940                  int32_t r6;
0802d940                  
0802d940                  if (r0_29 == 1)
0802d940                  {
0802d942                      *(uint32_t*)((char*)q0_9)[4] = var_2c;
0802d946                      (uint32_t)q0_9 = *(uint32_t*)((char*)q4_6)[4];
0802d94c                      sub_802dbbe(0, q0_9);
0802d956                      (uint32_t)q4_6 = sub_802dc5c(0, r4, r6);
0802d95e                      /* unimplemented  {vcmp.f32.F32 s16, s0} */
0802d962                      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802d962                      
0802d966                      if (false == r0_29 - 1)
0802d968                          (uint32_t)q4_6 = 0x41200000;
0802d968                      
0802d96e                      sub_802d5ee(0);
0802d978                      arg3 = sub_802d600(0);
0802d940                  }
0802d940                  
0802d980                  uint32_t r0_30 = (uint32_t)data_2000df58;
0802d980                  
0802d986                  if (r0_30 != 1)
0802d986                      continue;
0802d986                  else
0802d986                  {
0802d98a                      *(uint32_t*)((char*)q0_9)[4] = var_28;
0802d98e                      (uint32_t)q0_9 = *(uint32_t*)((char*)q4_6)[8];
0802d994                      sub_802dbbe(1, q0_9);
0802d99e                      (uint32_t)q4_6 = sub_802dc5c(1, r4, r6);
0802d9a6                      /* unimplemented  {vcmp.f32.F32 s16, s0} */
0802d9aa                      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802d9aa                      
0802d9ae                      if (false == r0_30 - 1)
0802d9b0                          (uint32_t)q4_6 = 0x41200000;
0802d9b0                      
0802d9b6                      sub_802d5ee(1);
0802d9c0                      arg3 = sub_802d600(1);
0802d9c4                      continue;
0802d986                  }
0802d8b2              }
0802d89e          }
0802d89e          
0802d9cc          if (driveSubsystemState() != 3)
0802d9cc          {
0802da08              arg4 = motorBrake();
0802da0c              sub_8028a0e();
0802da14              arg3 = safetyEventSet(0, 1);
0802d9cc          }
0802d9cc          else
0802d9cc          {
0802d9ce              (uint32_t)q0_8 = 0xb5100000;
0802d9d6              sub_802a97c(0, 1);
0802d9da              int128_t q0_14;
0802d9da              (uint32_t)q0_14 = 0xb5100000;
0802d9e2              sub_802a97c(0, 2);
0802d9e6              int128_t q0_15;
0802d9e6              (uint32_t)q0_15 = 0xb5100000;
0802d9ee              sub_802a97c(1, 1);
0802d9f2              int128_t q0_16;
0802d9f2              (uint32_t)q0_16 = 0xb5100000;
0802d9fa              arg4 = sub_802a97c(1, 2);
0802da02              arg3 = safetyEventSet2(0, 1);
0802d9cc          }
0802d7ac      }
0802d71e  }
0802da1a    int32_t sub_802da1a(char arg1)
0802da1a  {
0802da22      sub_802db76(arg1);
0802da36      (&data_2000df2c)[0x2c * (uint32_t)arg1] = 1;
0802da38      return 1;
0802da1a  }
0802da3a    void* sub_802da3a(char arg1)
0802da3a  {
0802da48      (&data_2000df2c)[0x2c * (uint32_t)arg1] = 0;
0802da4a      return &(&data_2000df1c)[0x2c * (uint32_t)arg1];
0802da3a  }
0802da4c    int32_t sub_802da4c(char arg1, int32_t arg2 @ r7)
0802da4c  {
0802da52      data_2000e447 = arg1;
0802da56      sub_802a6f8(arg1, arg2);
0802da5a      return arg2;
0802da4c  }
0802da5c    uint32_t sub_802da5c()
0802da5c  {
0802da62      return (uint32_t)data_2000e447;
0802da5c  }
0802da64              00 00                                                                                    ..
0802da66  int32_t data_802da66 = -0x4af00000
0802da68    uint16_t* sub_802da68(int32_t* arg1)
0802da68  {
0802da6a      int64_t q4;
0802da6a      int64_t var_10 = q4;
0802da70      int128_t q0;
0802da70      (uint32_t)q0 = 0;
0802da76      uint32_t r0 = isDriveSubsystemReady(0);
0802da7c      uint32_t r0_1;
0802da7c      bool v_1;
0802da7c      
0802da7c      if (r0 == 2)
0802da7c      {
0802da80          r0_1 = isDriveSubsystemReady(1);
0802da84          v_1 = r0_1 - 2;
0802da7c      }
0802da7c      
0802da86      uint16_t* result;
0802da86      
0802da86      if (r0 == 2 && r0_1 == 2)
0802da86      {
0802da98          (uint32_t)q4 = sub_802d5a6(0);
0802daa2          *(uint32_t*)((char*)q4)[4] = sub_802d5a6(1);
0802daa6          float q0_3;
0802daa6          result = safetyFlags_primary_ptr();
0802daaa          *(uint32_t*)arg1 = (uint32_t)q4;
0802daae          arg1[1] = *(uint32_t*)((char*)q4)[4];
0802daba          /* unimplemented  {vcmp.f32.F32 s1, s2} */
0802dabe          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802dabe          
0802dac2          if (false == v_1)
0802dac2          {
0802dac4              /* unimplemented  {vcmp.f32.F32 s16, #0} */
0802dac8              /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802dac8              
0802dacc              if (false == v_1)
0802dacc              {
0802dace                  /* unimplemented  {vcmp.f32.F32 s17, #0} */
0802dad2                  /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802dad2                  
0802dad6                  if (false == v_1)
0802dad6                  {
0802dad8                      /* unimplemented  {vcmp.f32.F32 s0, #0} */
0802dadc                      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802dadc                      
0802dae0                      if (false != v_1)
0802dae0                      {
0802db0e                          /* unimplemented  {vcmp.f32.F32 s0, s1} */
0802db12                          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802db2c                          /* unimplemented  {vmla.f32.F32 s16, s0, s1} */
0802db30                          *(uint32_t*)arg1 = (uint32_t)q4;
0802dae0                      }
0802dae0                      else
0802dae0                      {
0802dae6                          /* unimplemented  {vcmp.f32.F32 s0, s1} */
0802daea                          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802db00                          /* unimplemented  {vmla.f32.F32 s17, s0, s1} */
0802db04                          arg1[1] = *(uint32_t*)((char*)q4)[4];
0802dae0                      }
0802dad6                  }
0802dacc              }
0802dac2          }
0802da86      }
0802da86      else
0802da86      {
0802da8a          *(uint32_t*)arg1 = 0;
0802da8c          result = nullptr;
0802da8e          arg1[1] = 0;
0802da86      }
0802da86      
0802db38      return result;
0802da68  }
0802db3a    int32_t sub_802db3a()
0802db3a  {
0802db40      data_2000e05c = 0;
0802db48      __builtin_memset(&data_2000e06c, 0, 0x18);
0802db74      return 1;
0802db3a  }
0802db76    void* sub_802db76(char arg1)
0802db76  {
0802db7a      uint32_t r0 = (uint32_t)arg1;
0802db86      *(uint32_t*)(0x2c * r0 + 0x2000df3c) = 0;
0802db8c      uint32_t r0_1 = (uint32_t)(uint8_t)r0;
0802db98      *(uint32_t*)(0x2c * r0_1 + 0x2000df38) = 0;
0802db9e      uint32_t r0_2 = (uint32_t)(uint8_t)r0_1;
0802dbaa      *(uint32_t*)(0x2c * r0_2 + 0x2000df34) = 0;
0802dbba      *(uint32_t*)(0x2c * (uint32_t)(uint8_t)r0_2 + 0x2000df40) = 0;
0802dbbc      return &(&data_2000df1c)[0x2c * (uint32_t)(uint8_t)r0_2];
0802db76  }
0802dbbe    void* sub_802dbbe(char arg1, int64_t arg2 @ q0)
0802dbbe  {
0802dbc6      uint32_t r4_1 = (uint32_t)arg1;
0802dbd4      uint32_t r4_2 = (uint32_t)(uint8_t)r4_1;
0802dbe0      *(uint32_t*)(0x2c * r4_1 + 0x2000df38) = *(uint32_t*)(0x2c * r4_2 + 0x2000df34);
0802dbe2      *(uint32_t*)((char*)arg2)[4] = fabsf(*(uint32_t*)((char*)arg2)[4]);
0802dbe6      (uint32_t)arg2 = fabsf((uint32_t)arg2);
0802dbea      (uint32_t)arg2 = *(uint32_t*)((char*)arg2)[4] - (uint32_t)arg2;
0802dbf2      float32_process((uint32_t)arg2);
0802dbfc      soft_dadd();
0802dc04      int32_t r0_2;
0802dc04      int32_t r1_3;
0802dc04      r0_2 = soft_dmul();
0802dc10      uint32_t r4_3 = (uint32_t)(uint8_t)r4_2;
0802dc1a      *(uint32_t*)(0x2c * r4_3 + 0x2000df34) = sub_802ead0(r0_2, r1_3);
0802dc20      uint32_t r4_4 = (uint32_t)(uint8_t)r4_3;
0802dc2a      (uint32_t)arg2 = *(uint32_t*)(0x2c * r4_4 + 0x2000df40);
0802dc32      uint32_t r4_5 = (uint32_t)(uint8_t)r4_4;
0802dc3c      *(uint32_t*)((char*)arg2)[4] = *(uint32_t*)(0x2c * r4_5 + 0x2000df34);
0802dc40      (uint32_t)arg2 = (uint32_t)arg2 + *(uint32_t*)((char*)arg2)[4];
0802dc52      *(uint32_t*)(0x2c * (uint32_t)(uint8_t)r4_5 + 0x2000df40) = (uint32_t)arg2;
0802dc56      return &(&data_2000df1c)[0x2c * (uint32_t)(uint8_t)r4_5];
0802dbbe  }
0802dc58                                                                          01 00                                            ..
0802dc5a  int32_t data_802dc5a = -0x4a8fbee0
0802dc5c    int32_t sub_802dc5c(char arg1, int32_t arg2 @ r4, int32_t arg3 @ r6)
0802dc5c  {
0802dc62      uint32_t r6_1 = (uint32_t)arg1;
0802dc6e      float32_process(*(uint32_t*)(0x2c * r6_1 + 0x2000df34));
0802dc7a      int32_t r0_2;
0802dc7a      int32_t r1_1;
0802dc7a      r0_2 = soft_dmul(arg2, arg3);
0802dc84      uint32_t r6_2 = (uint32_t)(uint8_t)r6_1;
0802dc90      float32_process(*(uint32_t*)(0x2c * r6_2 + 0x2000df40));
0802dc9c      int32_t r0_5;
0802dc9c      int32_t r1_3;
0802dc9c      r0_5 = soft_dmul();
0802dca4      int32_t r0_6;
0802dca4      int32_t r1_4;
0802dca4      r0_6 = sub_802ecf4(r0_5, r1_3, r0_2, r1_1);
0802dcae      uint32_t r6_3 = (uint32_t)(uint8_t)r6_2;
0802dcb8      int64_t q0;
0802dcb8      (uint32_t)q0 = *(uint32_t*)(0x2c * r6_3 + 0x2000df34);
0802dcc8      *(uint32_t*)((char*)q0)[4] =
0802dcc8          *(uint32_t*)(0x2c * (uint32_t)(uint8_t)r6_3 + 0x2000df38);
0802dccc      (uint32_t)q0 = (uint32_t)q0 - *(uint32_t*)((char*)q0)[4];
0802dcd4      float32_process((uint32_t)q0);
0802dce0      int32_t r0_10;
0802dce0      int32_t r1_7;
0802dce0      r0_10 = soft_dmul();
0802dce8      int32_t r0_11;
0802dce8      int32_t r1_8;
0802dce8      r0_11 = sub_802ecf4(r0_10, r1_7, r0_6, r1_4);
0802dcec      int32_t result = sub_802ead0(r0_11, r1_8);
0802dcf0      (uint32_t)q0 = result;
0802dcf4      return result;
0802dc5c  }
0802dcf6                                                                    00 00                                                ..
0802dcf8  int32_t data_802dcf8 = 0x2000e448
0802dcfc  int32_t data_802dcfc = 0x2000df1c
0802dd00  int32_t data_802dd00 = 0x0
0802dd04              01 00                                                                                    ..
0802dd06  int32_t data_802dd06 = 0x140a0
0802dd0a  int32_t data_802dd0a = -0x4ac7be60
0802dd0c    int32_t sub_802dd0c(int64_t arg1 @ q0, dbl_bits arg2 @ q4)
0802dd0c  {
0802dd0c      int32_t r5;
0802dd0c      int32_t var_8 = r5;
0802dd0c      int32_t r3;
0802dd0c      int32_t var_10 = r3;
0802dd0e      dbl_bits __saved_q4;
0802dd0e      __saved_q4.lo = arg2.lo;
0802dd0e      __saved_q4.hi = arg2.hi;
0802dd14      arg2.hi = (uint32_t)arg1;
0802dd18      arg2.lo = *(uint32_t*)((char*)arg1)[4];
0802dd1c      (uint32_t)arg1 = arg2.hi;
0802dd22      sub_802d5b8(0, (uint32_t)arg1);
0802dd26      (uint32_t)arg1 = arg2.lo;
0802dd2c      sub_802d5b8(1, (uint32_t)arg1);
0802dd30      /* unimplemented  {vcmp.f32.F32 s17, #0} */
0802dd34      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802dd38      bool v;
0802dd38      
0802dd38      if (false != v)
0802dd48          sub_802a9cc(0, 1);
0802dd38      else
0802dd3e          sub_802a9cc(0, 0);
0802dd3e      
0802dd4c      /* unimplemented  {vcmp.f32.F32 s16, #0} */
0802dd50      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802dd64      sub_802a9cc(1, 1);
0802dd68      (uint32_t)arg1 = 0x44fa0000;
0802dd6e      sub_802a458(0, r5);
0802dd72      int128_t q0;
0802dd72      (uint32_t)q0 = 0x44fa;
0802dd78      sub_802a458(1, r5);
0802dd80      sub_802d598(0, 2);
0802dd88      sub_802d598(1, 2);
0802dd90      sub_802a9e0(0, 1);
0802dd98      sub_802a9e0(1, 1);
0802dd9e      int32_t a;
0802dd9e      sub_802da68(&a);
0802dda2      int32_t q4 = 0x142c8;
0802dda6      int128_t q0_1;
0802dda6      (uint32_t)q0_1 = a;
0802ddaa      *(uint32_t*)((char*)q0_1)[4] = 0x435c;
0802ddae      /* unimplemented  {vcmp.f32.F32 s0, s1} */
0802ddb2      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802ddb6      int32_t var_1c;
0802ddb6      
0802ddb6      if (false != v)
0802ddb6      {
0802ddb8          (uint32_t)q0_1 = var_1c;
0802ddbc          *(uint32_t*)((char*)q0_1)[4] = 0x435c0001;
0802ddc0          /* unimplemented  {vcmp.f32.F32 s0, s1} */
0802ddc4          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802ddb6      }
0802ddb6      
0802ddc8      if (false == v || false == v)
0802ddca          q4 = 0xd00042a0;
0802ddca      
0802ddd0      float32_process(a);
0802ddda      int32_t r0_2;
0802ddda      int32_t r1;
0802ddda      r0_2 = soft_dadd(a, __saved_q4);
0802dde6      float32_process(q4);
0802ddee      int32_t r0_4;
0802ddee      int32_t r1_1;
0802ddee      r0_4 = soft_dmul();
0802ddfa      (uint32_t)q0_1 = sub_802ead0(r0_4, r1_1) & 0x7fffffff;
0802de00      sub_802d600(0);
0802de06      float32_process(var_1c);
0802de10      int32_t r0_8;
0802de10      int32_t r1_2;
0802de10      r0_8 = soft_dadd();
0802de1c      float32_process(q4);
0802de24      int32_t r0_10;
0802de24      int32_t r1_3;
0802de24      r0_10 = soft_dmul();
0802de30      int128_t q0_2;
0802de30      (uint32_t)q0_2 = sub_802ead0(r0_10, r1_3) & 0x7fffffff;
0802de36      sub_802d600(1);
0802de3c      sub_802da1a(0);
0802de42      sub_802da1a(1);
0802de4e      return 1;
0802dd0c  }
0802de50  int32_t data_802de50 = 0x42180000
0802de54  int32_t data_802de54 = 0x803be40
0802de58  int32_t data_802de58 = 0x2000df1c
0802de5c  int32_t data_802de5c = 0x2000e05c
0802de60    int32_t sub_802de60(int64_t arg1 @ q0, dbl_bits arg2 @ q4)
0802de60  {
0802de60      int32_t r7;
0802de60      int32_t var_8 = r7;
0802de62      dbl_bits __saved_q4;
0802de62      __saved_q4.lo = arg2.lo;
0802de62      __saved_q4.hi = arg2.hi;
0802de68      arg2.hi = (uint32_t)arg1;
0802de6c      arg2.lo = *(uint32_t*)((char*)arg1)[4];
0802de72      sub_802da3a(0);
0802de78      sub_802da3a(1);
0802de7c      (uint32_t)arg1 = arg2.hi;
0802de82      sub_802d5b8(0, (uint32_t)arg1);
0802de86      (uint32_t)arg1 = arg2.lo;
0802de8c      sub_802d5b8(1, (uint32_t)arg1);
0802de90      /* unimplemented  {vcmp.f32.F32 s17, #0} */
0802de94      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802de98      bool v;
0802de98      
0802de98      if (false != v)
0802de98      {
0802dec0          if (sub_802a9d6(0) != 1)
0802dec0          {
0802dec2              (uint32_t)arg1 = 0xb5000000;
0802dec8              sub_802d600(0);
0802dec0          }
0802dec0          
0802ded0          sub_802a9cc(0, 1);
0802de98      }
0802de98      else
0802de98      {
0802dea2          if (sub_802a9d6(0))
0802dea2          {
0802dea4              (uint32_t)arg1 = 0;
0802deaa              sub_802d600(0);
0802dea2          }
0802dea2          
0802deb2          sub_802a9cc(0, 0);
0802de98      }
0802de98      
0802ded4      /* unimplemented  {vcmp.f32.F32 s16, #0} */
0802ded8      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802ded8      
0802df04      if (sub_802a9d6(1) != 1)
0802df04      {
0802df06          (uint32_t)arg1 = 0xb5000000;
0802df0c          sub_802d600(1);
0802df04      }
0802df04      
0802df14      sub_802a9cc(1, 1);
0802df18      (uint32_t)arg1 = 0x44fa0000;
0802df1e      int32_t r5;
0802df1e      sub_802a458(0, r5);
0802df22      int128_t q0;
0802df22      (uint32_t)q0 = 0x44fa;
0802df28      sub_802a458(1, r5);
0802df30      sub_802d598(0, 2);
0802df38      sub_802d598(1, 2);
0802df3e      int32_t a;
0802df3e      sub_802da68(&a);
0802df44      float32_process(a);
0802df4c      soft_dadd(a, __saved_q4);
0802df54      int32_t r0_6;
0802df54      int32_t r1;
0802df54      r0_6 = soft_dmul();
0802df60      int128_t q0_1;
0802df60      (uint32_t)q0_1 = sub_802ead0(r0_6, r1) & 0x7fffffff;
0802df66      sub_802d600(0);
0802df6c      int32_t var_14;
0802df6c      float32_process(var_14);
0802df74      soft_dadd();
0802df7c      int32_t r0_10;
0802df7c      int32_t r1_1;
0802df7c      r0_10 = soft_dmul();
0802df88      int128_t q0_2;
0802df88      (uint32_t)q0_2 = sub_802ead0(r0_10, r1_1) & 0x7fffffff;
0802df8e      sub_802d600(1);
0802df94      sub_802da1a(0);
0802df9a      sub_802da1a(1);
0802dfa6      return 1;
0802de60  }
0802dfa8  int32_t data_802dfa8 = 0x40590000
0802dfac    void sub_802dfac(int32_t* arg1, int32_t* arg2, int64_t arg3 @ q0)
0802dfac  {
0802dfac      *(uint32_t*)arg2 = *(uint32_t*)((char*)arg3)[4];
0802dfb0      arg2[1] = *(uint32_t*)((char*)arg3)[4];
0802dfb4      *(uint32_t*)arg1 = (uint32_t)arg3;
0802dfb8      arg1[1] = (uint32_t)arg3;
0802dfac  }
0802dfbe    void sub_802dfbe(int32_t* arg1, int32_t* arg2, int64_t arg3 @ q0)
0802dfbe  {
0802dfbe      *(uint32_t*)arg2 = *(uint32_t*)((char*)arg3)[4];
0802dfc2      arg2[1] = *(uint32_t*)((char*)arg3)[4];
0802dfc6      *(uint32_t*)((char*)arg3)[4] = -((uint32_t)arg3);
0802dfca      *(uint32_t*)arg1 = *(uint32_t*)((char*)arg3)[4];
0802dfce      (uint32_t)arg3 = -((uint32_t)arg3);
0802dfd2      arg1[1] = (uint32_t)arg3;
0802dfbe  }
0802dfd8    int32_t sub_802dfd8(float* arg1, int32_t* arg2, int32_t arg3, int32_t arg4, int64_t arg5 @ q0)
0802dfd8  {
0802dfe0      int64_t q4;
0802dfe0      (uint32_t)q4 = (uint32_t)arg5;
0802dfe4      *(uint32_t*)((char*)q4)[4] = *(uint32_t*)((char*)arg5)[4];
0802dff0      int32_t a;
0802dff0      int32_t r1;
0802dff0      a = float32_process(*(uint32_t*)((char*)q4)[4]);
0802dff4      int32_t var_2c = r1;
0802dffc      float32_process((uint32_t)q4);
0802e008      logging_wrapper("1 left speed %f angle %f \r\n");
0802e010      float32_process(*(uint32_t*)((char*)q4)[4]);
0802e01c      int32_t b;
0802e01c      soft_dmul(a, b);
0802e026      int32_t r0_3;
0802e026      int32_t r1_1;
0802e026      r0_3 = soft_dadd();
0802e02e      *(uint32_t*)((char*)q4)[4] = sub_802ead0(r0_3, r1_1);
0802e036      float32_process(*(uint32_t*)((char*)q4)[4]);
0802e042      int32_t r0_6;
0802e042      int32_t r1_2;
0802e042      r0_6 = soft_dmul();
0802e04a      *(uint32_t*)arg2 = sub_802ead0(r0_6, r1_2);
0802e050      float32_process(*(uint32_t*)((char*)q4)[4]);
0802e05c      int32_t r0_9;
0802e05c      int32_t r1_3;
0802e05c      r0_9 = soft_dmul();
0802e064      arg2[1] = sub_802ead0(r0_9, r1_3);
0802e06a      *(uint32_t*)arg1 = -((uint32_t)q4);
0802e06e      arg1[1] = (uint32_t)q4;
0802e074      int32_t r0_12;
0802e074      int32_t r1_4;
0802e074      r0_12 = float32_process(arg2[1]);
0802e078      int32_t var_20 = r0_12;
0802e078      int32_t var_1c = r1_4;
0802e07e      int32_t r0_14;
0802e07e      int32_t r1_5;
0802e07e      r0_14 = float32_process(*(uint32_t*)arg2);
0802e082      int32_t var_28 = r0_14;
0802e082      int32_t var_24 = r1_5;
0802e088      int32_t r0_16;
0802e088      int32_t r1_6;
0802e088      r0_16 = float32_process(arg1[1]);
0802e08c      int32_t var_30_1 = r0_16;
0802e08c      int32_t var_2c_1 = r1_6;
0802e092      float32_process(*(uint32_t*)arg1);
0802e09e      logging_wrapper("2 left tarspeed %f %f tarDist %f %f\r\n");
0802e0a8      return arg4;
0802dfd8  }
0802e0aa                                00 00                                                                        ..
0802e0ac  int32_t data_802e0ac = 0x44fa0000
0802e0b0                                                  00 00                                                            ..
0802e0b2  int32_t data_802e0b2 = 0x142c8
0802e0b6  int32_t data_802e0b6 = 0x435c
0802e0ba  int32_t data_802e0ba = -0x2fffbd60
0802e0be                                                                                            81 40                                .@
0802e0c0  int32_t data_802e0c0 = 0x803c0a8
0802e0c4    int32_t sub_802e0c4(int32_t* arg1, int32_t* arg2, int32_t arg3, int32_t arg4, int64_t arg5 @ q0)
0802e0c4  {
0802e0cc      int64_t q4;
0802e0cc      (uint32_t)q4 = (uint32_t)arg5;
0802e0d0      *(uint32_t*)((char*)q4)[4] = *(uint32_t*)((char*)arg5)[4];
0802e0dc      int32_t a;
0802e0dc      int32_t r1;
0802e0dc      a = float32_process(*(uint32_t*)((char*)q4)[4]);
0802e0e0      int32_t var_2c = r1;
0802e0e8      float32_process((uint32_t)q4);
0802e0f4      logging_wrapper("1 right speed %f angle %f \r\n");
0802e0fc      float32_process(*(uint32_t*)((char*)q4)[4]);
0802e108      int32_t b;
0802e108      soft_dmul(a, b);
0802e112      int32_t r0_3;
0802e112      int32_t r1_1;
0802e112      r0_3 = soft_dadd();
0802e11a      *(uint32_t*)((char*)q4)[4] = sub_802ead0(r0_3, r1_1);
0802e122      float32_process(*(uint32_t*)((char*)q4)[4]);
0802e12e      int32_t r0_6;
0802e12e      int32_t r1_2;
0802e12e      r0_6 = soft_dmul();
0802e136      *(uint32_t*)arg2 = sub_802ead0(r0_6, r1_2);
0802e13c      float32_process(*(uint32_t*)((char*)q4)[4]);
0802e148      int32_t r0_9;
0802e148      int32_t r1_3;
0802e148      r0_9 = soft_dmul();
0802e150      arg2[1] = sub_802ead0(r0_9, r1_3);
0802e152      *(uint32_t*)arg1 = (uint32_t)q4;
0802e15a      arg1[1] = -((uint32_t)q4);
0802e160      int32_t r0_12;
0802e160      int32_t r1_4;
0802e160      r0_12 = float32_process(arg2[1]);
0802e164      int32_t var_20 = r0_12;
0802e164      int32_t var_1c = r1_4;
0802e16a      int32_t r0_14;
0802e16a      int32_t r1_5;
0802e16a      r0_14 = float32_process(*(uint32_t*)arg2);
0802e16e      int32_t var_28 = r0_14;
0802e16e      int32_t var_24 = r1_5;
0802e174      int32_t r0_16;
0802e174      int32_t r1_6;
0802e174      r0_16 = float32_process(arg1[1]);
0802e178      int32_t var_30_1 = r0_16;
0802e178      int32_t var_2c_1 = r1_6;
0802e17e      float32_process(*(uint32_t*)arg1);
0802e18a      logging_wrapper("2 right tarspeed %f %f tarcount %f %f\r\n");
0802e194      return arg4;
0802e0c4  }
0802e196    void* sub_802e196(char arg1)
0802e196  {
0802e1a2      (&data_2000e07c)[(uint32_t)arg1] = 0;
0802e1a4      return &(&data_2000e05c)[(uint32_t)arg1 << 2];
0802e196  }
0802e1a6                    00 00                                                                                ..
0802e1a8  int32_t data_802e1a8 = 0x0
0802e1ac    int32_t sub_802e1ac()
0802e1ac  {
0802e1b4      uint32_t r0 = (uint32_t)data_2000e05c;
0802e1b4      
0802e1b8      if (!r0)
0802e1ba          return 0;
0802e1ba      
0802e1c2      int96_t q0;
0802e1c2      *(uint32_t*)((char*)q0)[8] = data_2000e07c;
0802e1c6      (uint32_t)q0 = *(uint32_t*)((char*)q0)[8] + (uint32_t)q0;
0802e1ce      data_2000e07c = (uint32_t)q0;
0802e1d6      (uint32_t)q0 = data_2000e080;
0802e1da      (uint32_t)q0 = (uint32_t)q0 + *(uint32_t*)((char*)q0)[4];
0802e1e2      data_2000e080 = (uint32_t)q0;
0802e1ea      (uint32_t)q0 = data_2000e07c;
0802e1f2      *(uint32_t*)((char*)q0)[4] = data_2000e074;
0802e1f6      /* unimplemented  {vcmp.f32.F32 s0, s1} */
0802e1fa      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802e1fa      
0802e1fe      if (r0 < 0)
0802e1fe      {
0802e204          (uint32_t)q0 = data_2000e080;
0802e20c          *(uint32_t*)((char*)q0)[4] = data_2000e078;
0802e210          /* unimplemented  {vcmp.f32.F32 s0, s1} */
0802e214          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802e214          
0802e218          if (r0 < 0)
0802e242              return 0;
0802e1fe      }
0802e1fe      
0802e220      int32_t r0_3;
0802e220      int32_t r1_1;
0802e220      r0_3 = float32_process(data_2000e080);
0802e224      int32_t var_10 = r0_3;
0802e224      int32_t var_c = r1_1;
0802e22e      float32_process(data_2000e07c);
0802e23a      logging_wrapper(sub_803af88+0x74);
0802e23e      return 1;
0802e1ac  }
0802e246                    00 00                                                                                ..
0802e248  int32_t data_802e248 = 0x2000e449
0802e24c  int32_t data_802e24c = 0x803bf9c
0802e250  int32_t data_802e250 = 0x803b310
0802e254    int32_t sub_802e254(uint32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int64_t arg5 @ q0, dbl_bits arg6 @ q4)
0802e254  {
0802e256      dbl_bits __saved_q4;
0802e256      __saved_q4.lo = arg6.lo;
0802e256      __saved_q4.hi = arg6.hi;
0802e25a      uint32_t r6 = arg1;
0802e25c      arg6.lo = (uint32_t)arg5;
0802e260      arg6.hi = *(uint32_t*)((char*)arg5)[4];
0802e266      int32_t r4 = 0;
0802e26c      uint32_t r0_2 = isDriveSubsystemReady((uint8_t)r6);
0802e272      uint32_t r0_5;
0802e272      bool c_1;
0802e272      
0802e272      if (r0_2 == 2)
0802e272      {
0802e27a          r0_5 = sub_802d214((uint8_t)r6);
0802e27e          c_1 = r0_5 >= 1;
0802e272      }
0802e272      
0802e280      if (r0_2 != 2 || r0_5 != 1)
0802e280      {
0802e38e          uint32_t r0_23 = isDriveSubsystemReady((uint8_t)r6);
0802e394          uint32_t r0_25;
0802e394          
0802e394          if (!r0_23)
0802e394          {
0802e398              r6 = (uint32_t)(uint8_t)r6;
0802e3a2              r0_25 = (uint32_t)(&data_2000df45)[0x2c * r6];
0802e394          }
0802e394          
0802e3a8          if (r0_23 || r0_25 != 1)
0802e3a8          {
0802e46e              uint32_t r6_22 = (uint32_t)(uint8_t)r6;
0802e470              *(uint32_t*)(&data_2000e2f4 + (r6_22 << 2)) = 0;
0802e478              uint32_t r6_23 = (uint32_t)(uint8_t)r6_22;
0802e47a              *(uint8_t*)(&data_2000e418 + r6_23) = 0;
0802e482              *(uint8_t*)(&data_2000e41a + (uint32_t)(uint8_t)r6_23) = 0;
0802e3a8          }
0802e3a8          else
0802e3a8          {
0802e3aa              (uint32_t)arg5 = 0xdf1c3f80;
0802e3ae              /* unimplemented  {vcmp.f32.F32 s17, s0} */
0802e3b2              /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802e3b6              uint32_t r6_15;
0802e3b6              
0802e3b6              if (r0_25 < 1)
0802e3b6              {
0802e3cc                  r6_15 = (uint32_t)(uint8_t)r6;
0802e3ce                  *(uint8_t*)(&data_2000e418 + r6_15) = 0;
0802e3b6              }
0802e3b6              else
0802e3b6              {
0802e3ba                  uint32_t r6_14 = (uint32_t)(uint8_t)r6;
0802e3c2                  r6_15 = (uint32_t)(uint8_t)r6_14;
0802e3c4                  *(uint8_t*)(&data_2000e418 + r6_15) =
0802e3c4                      *(uint8_t*)(&data_2000e418 + r6_14) + 1;
0802e3b6              }
0802e3b6              
0802e3d2              uint32_t r6_17 = (uint32_t)(uint8_t)r6_15;
0802e3d2              
0802e3d8              if ((uint32_t)*(uint8_t*)(&data_2000e418 + r6_17) >= 6)
0802e3d8              {
0802e3de                  uint32_t r6_16 = (uint32_t)(uint8_t)r6_17;
0802e3e0                  *(uint8_t*)(&data_2000e418 + r6_16) = 0;
0802e3e8                  sub_802d598((uint8_t)r6_16, 3);
0802e3ec                  return 0;
0802e3d8              }
0802e3d8              
0802e3f0              char r5_2 = 0;
0802e3f0              
0802e3f8              while (true)
0802e3f8              {
0802e3f8                  uint32_t r5_3 = (uint32_t)r5_2;
0802e3f8                  
0802e3fc                  if (r5_3 >= 5)
0802e3fc                      break;
0802e3fc                  
0802e400                  rtos_delay_ticks(2);
0802e404                  r6_17 = (uint32_t)(uint8_t)r6_17;
0802e404                  
0802e408                  if (r6_17)
0802e408                  {
0802e41a                      r6_17 = (uint32_t)(uint8_t)r6_17;
0802e41a                      
0802e41e                      if (r6_17 == 1)
0802e41e                      {
0802e426                          if (sub_802a622())
0802e3f4                              r4 = 0;
0802e426                          else
0802e428                              r4 += 1;
0802e41e                      }
0802e408                  }
0802e408                  else if (sub_802a5f0())
0802e416                      r4 = 0;
0802e410                  else
0802e412                      r4 += 1;
0802e412                  
0802e3f6                  r5_2 = (uint8_t)r5_3 + 1;
0802e3f8              }
0802e3f8              
0802e430              uint32_t r6_19;
0802e430              
0802e430              if (!(uint32_t)(uint8_t)r4)
0802e430              {
0802e446                  r6_19 = (uint32_t)(uint8_t)r6_17;
0802e448                  *(uint8_t*)(&data_2000e41a + r6_19) = 0;
0802e430              }
0802e430              else
0802e430              {
0802e434                  uint32_t r6_18 = (uint32_t)(uint8_t)r6_17;
0802e43c                  r6_19 = (uint32_t)(uint8_t)r6_18;
0802e43e                  *(uint8_t*)(&data_2000e41a + r6_19) =
0802e43e                      *(uint8_t*)(&data_2000e41a + r6_18) + 1;
0802e430              }
0802e430              
0802e44c              uint32_t r6_20 = (uint32_t)(uint8_t)r6_19;
0802e44c              
0802e452              if ((uint32_t)*(uint8_t*)(&data_2000e41a + r6_20) >= 6)
0802e452              {
0802e458                  uint32_t r6_21 = (uint32_t)(uint8_t)r6_20;
0802e45a                  *(uint8_t*)(&data_2000e41a + r6_21) = 0;
0802e462                  sub_802d598((uint8_t)r6_21, 3);
0802e466                  return 0;
0802e452              }
0802e3a8          }
0802e280      }
0802e280      else
0802e280      {
0802e28a          uint32_t r6_1 = (uint32_t)(uint8_t)r6;
0802e28c          *(uint8_t*)(&data_2000e41a + r6_1) = 0;
0802e28e          arg6.lo = fabsf(arg6.lo);
0802e292          arg6.hi = fabsf(arg6.hi);
0802e296          (uint32_t)arg5 = 0xa9fc42c8;
0802e29a          /* unimplemented  {vcmp.f32.F32 s16, s0} */
0802e29e          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802e2b2          (uint32_t)arg5 = 0x3f800000;
0802e2b6          /* unimplemented  {vcmp.f32.F32 s17, s0} */
0802e2ba          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802e2da          uint32_t r6_4 = (uint32_t)(uint8_t)r6_1;
0802e2dc          *(uint8_t*)(&data_2000e418 + r6_4) = 0;
0802e2e2          float32_process(arg6.lo);
0802e2ec          int32_t r0_10;
0802e2ec          int32_t r1;
0802e2ec          r0_10 = soft_dmul(__saved_q4, arg4);
0802e2fc          int32_t r0_12;
0802e2fc          int32_t r1_1;
0802e2fc          r0_12 = float32_process(arg6.hi);
0802e304          sub_8031ac8(r0_12, r1_1, r0_10, r1);
0802e308          uint32_t r6_6;
0802e308          
0802e308          if (c_1)
0802e308          {
0802e322              r6_6 = (uint32_t)(uint8_t)r6_4;
0802e324              *(uint32_t*)(&data_2000e2f4 + (r6_6 << 2)) = 0;
0802e308          }
0802e308          else
0802e308          {
0802e30c              uint32_t r6_5 = (uint32_t)(uint8_t)r6_4;
0802e316              r6_6 = (uint32_t)(uint8_t)r6_5;
0802e318              *(uint32_t*)(&data_2000e2f4 + (r6_6 << 2)) =
0802e318                  *(uint32_t*)(&data_2000e2f4 + (r6_5 << 2)) + 1;
0802e308          }
0802e308          
0802e32a          uint32_t r6_7 = (uint32_t)(uint8_t)r6_6;
0802e32c          *(uint32_t*)(&data_2000e2f4 + (r6_7 << 2));
0802e338          sub_802bd04(1, "motorCtrlErrorTimes %d %d\n", 3);
0802e33e          uint32_t r6_9 = (uint32_t)(uint8_t)r6_7;
0802e33e          
0802e346          if (*(uint32_t*)(&data_2000e2f4 + (r6_9 << 2)) >= 0x65)
0802e346          {
0802e34c              uint32_t r6_10 = (uint32_t)(uint8_t)r6_9;
0802e34e              *(uint32_t*)(&data_2000e2f4 + (r6_10 << 2)) = 0;
0802e356              uint32_t r6_11 = (uint32_t)(uint8_t)r6_10;
0802e358              *(uint8_t*)(&data_2000e418 + r6_11) = 0;
0802e360              sub_802d598((uint8_t)r6_11, 1);
0802e364              return 0;
0802e346          }
0802e346          
0802e36a          uint32_t r6_12 = (uint32_t)(uint8_t)r6_9;
0802e36a          
0802e370          if (3 < (uint32_t)*(uint8_t*)(&data_2000e418 + r6_12))
0802e370          {
0802e378              uint32_t r6_13 = (uint32_t)(uint8_t)r6_12;
0802e37a              *(uint8_t*)(&data_2000e418 + r6_13) = 0;
0802e382              sub_802d598((uint8_t)r6_13, 1);
0802e386              return 0;
0802e370          }
0802e280      }
0802e280      
0802e484      return 1;
0802e254  }
0802e48c  int32_t data_802e48c = 0x2000e44a
0802e490  int32_t data_802e490 = -0x40100000
0802e494  int32_t data_802e494 = 0x803b608
0802e496    int32_t sub_802e496(int32_t arg1)
0802e496  {
0802e496      int32_t r7;
0802e496      /* tailcall */
0802e496      return sub_802e498(r7);
0802e496  }
0802e498    int32_t sub_802e498(int32_t arg1 @ r7)
0802e498  {
0802e4a4      int64_t q4;
0802e4a4      (uint32_t)q4 = reduceSpeedOrGuard(2);
0802e4b4      int32_t r0;
0802e4b4      int128_t q0_2;
0802e4b4      int32_t q4_2;
0802e4b4      r0 = sub_802e4e4(sub_802d688(arg1, (uint32_t)q4));
0802e4b4      
0802e4ba      if (r0)
0802e4ba      {
0802e4d4          if (isDriveSubsystemReady(2) == 2)
0802e4d4          {
0802e4d6              (uint32_t)q0_2 = q4_2;
0802e4da              sub_802e5b8(arg1);
0802e4d4          }
0802e4ba      }
0802e4ba      else if (isDriveSubsystemReady(2) == 3)
0802e4c6          sub_802d4fc();
0802e4c6      
0802e4e2      return arg1;
0802e498  }
0802e4e4    int32_t sub_802e4e4(int32_t arg1 @ q0)
0802e4e4  {
0802e4e4      int32_t r7;
0802e4e4      int32_t var_8 = r7;
0802e4ea      int64_t q4;
0802e4ea      (uint32_t)q4 = arg1;
0802e4ea      
0802e4f6      if (isDriveSubsystemReady(2) != 2)
0802e4f6      {
0802e546          uint32_t r0_5 = isDriveSubsystemReady(2);
0802e546          
0802e54c          if (!r0_5)
0802e54c          {
0802e552              data_2000e44b = 0;
0802e558              /* unimplemented  {vcmp.f32.F32 s16, s0} */
0802e55c              /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802e55c              
0802e560              if (false != r0_5 + 0)
0802e57e                  data_2000e44c = 0;
0802e560              else
0802e560              {
0802e56a                  data_2000e44c += 1;
0802e56e                  data_2000e44c;
0802e574                  sub_802bd04(4, "Cutter STOPPED %d\r\n", r7);
0802e560              }
0802e560              
0802e586              if ((uint32_t)data_2000e44c >= 6)
0802e586              {
0802e58c                  data_2000e44c = 0;
0802e592                  sub_802d598(2, 3);
0802e596                  return 0;
0802e586              }
0802e54c          }
0802e4f6      }
0802e4f6      else
0802e4f6      {
0802e4fc          data_2000e44c = 0;
0802e502          /* unimplemented  {vcmp.f32.F32 s16, s0} */
0802e506          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802e528          data_2000e44b = 0;
0802e528          
0802e530          if ((uint32_t)data_2000e44b >= 0x15)
0802e530          {
0802e536              data_2000e44b = 0;
0802e53c              sub_802d598(2, 1);
0802e540              return 0;
0802e530          }
0802e4f6      }
0802e4f6      
0802e59a      return 1;
0802e4e4  }
0802e5a2        00 00                                                                                        ..
0802e5a4  int32_t data_802e5a4 = 0x42c80000
0802e5a8  int32_t data_802e5a8 = -0x2d0e5604
0802e5ac  int32_t data_802e5ac = 0x3f50624d
0802e5b0  int32_t data_802e5b0 = -0x66666666
0802e5b4  int32_t data_802e5b4 = 0x3fb99999
0802e5b8    int32_t sub_802e5b8(int32_t arg1 @ r7)
0802e5b8  {
0802e5ba      int128_t q0;
0802e5ba      *(uint32_t*)((char*)q0)[4] = 0x453b;
0802e5be      /* unimplemented  {vcmp.f32.F32 s0, s1} */
0802e5c2      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0802e5c6      bool n;
0802e5c6      
0802e5c6      if (!n)
0802e5c6      {
0802e5d4          (uint32_t)q0 = 0x42b00000;
0802e5da          sub_802d600(2);
0802e5c6      }
0802e5c6      else
0802e5c6      {
0802e5c8          (uint32_t)q0 = 0x42ba0000;
0802e5ce          sub_802d600(2);
0802e5c6      }
0802e5c6      
0802e5de      return arg1;
0802e5b8  }
0802e5e0  01 00                                                                                            ..
0802e5e2  int32_t data_802e5e2 = -0x20e3c080
0802e5e6                    00 20                                                                                . 
0802e5e8  int32_t data_802e5e8 = 0x2000e447
0802e5ec                                      00 80                                                                    ..
0802e5ee  int32_t data_802e5ee = 0x453b
0802e5f2                                                        ba 42                                                        .B
0802e5f4  int32_t data_802e5f4 = 0x42b00000
0802e5f8  int32_t data_802e5f8 = 0x2000e05c
0802e5fc  int32_t data_802e5fc = 0x3fb66666
0802e600  int32_t data_802e600 = 0x3f40624d
0802e604  int32_t data_802e604 = 0x47ae147b
0802e608  int32_t data_802e608 = 0x3f847ae1
0802e60c  int32_t data_802e60c = 0x4081d000
0802e610  int32_t data_802e610 = 0x803b624
0802e614  int32_t data_802e614 = -0x3fe4f25d
0802e618  int32_t data_802e618 = 0x408c13f6
0802e61c  int32_t data_802e61c = 0x40768000
0802e620  int32_t data_802e620 = 0x803ae78
0802e624  int32_t data_802e624 = 0x803b330
0802e628  int32_t data_802e628 = 0x803aea0
0802e62c  int32_t data_802e62c = 0x803affc
0802e630  int32_t data_802e630 = 0x2000e41a
0802e634  int32_t data_802e634 = 0x2000e418
0802e638  int32_t data_802e638 = 0x3fe00000
0802e63c  int32_t data_802e63c = 0x2000e2f4
0802e640  int32_t data_802e640 = 0x803b640
0802e644  int32_t data_802e644 = 0x2000e44c
0802e648  int32_t data_802e648 = 0x2000e44b
0802e64c  int32_t data_802e64c = 0x803bc98
0802e650  int32_t data_802e650 = 0x803bcac
0802e654    int32_t float32_process(int32_t arg1)
0802e654  {
0802e658      int32_t r1 = 0xff & arg1 >> 0x17;
0802e658      
0802e65c      if (r1)
0802e660          /* tailcall */
0802e660          return float32_process_normal(arg1);
0802e660      
0802e660      /* tailcall */
0802e660      return float32_process_subnormal_or_zero(arg1, r1);
0802e654  }
0802e662    int32_t float32_process_normal(int32_t arg1) __pure
0802e662  {
0802e66e      return arg1 << 0x1d;
0802e662  }
0802e670    int32_t float32_process_subnormal_or_zero(int32_t arg1, int32_t arg2)
0802e670  {
0802e670      if (arg2)
0802e6a0          return 0;
0802e6a0      
0802e676      int32_t result = arg1 << 8;
0802e676      
0802e678      if (!result)
0802e690          return result;
0802e690      
0802e68e      return result << __clz(result) << 0x15;
0802e670  }
0802e6a2        00 00                                                                                        ..
0802e6a4    int32_t sub_802e6a4(int32_t arg1)
0802e6a4  {
0802e6a6      if (arg1 >= 0)
0802e6a6          /* tailcall */
0802e6a6          return sub_802e6bc(arg1);
0802e6a6      
0802e6ae      int32_t result;
0802e6ae      int32_t r1_1;
0802e6ae      result = sub_802e6bc(0 - arg1);
0802e6b6      return result;
0802e6a4  }
0802e6b8    int32_t sub_802e6b8(int32_t arg1)
0802e6b8  {
0802e6ba      /* tailcall */
0802e6ba      return sub_802e6bc(arg1);
0802e6b8  }
0802e6bc    void sub_802e6bc(int32_t arg1)
0802e6bc  {
0802e6bc      bool z;
0802e6bc      
0802e6bc      if (!z)
0802e6be          __clz(arg1);
0802e6bc  }
0802e6d4    dbl_bits soft_dmul(dbl_bits a, dbl_bits b)
0802e6d4  {
0802e6e2      int32_t entry_r1;
0802e6e2      int32_t r4 = 0x7ff & entry_r1 >> 0x14;
0802e6e6      int32_t entry_result;
0802e6e6      int32_t entry_r2;
0802e6e6      int32_t entry_r3;
0802e6e6      int32_t entry_r4;
0802e6e6      int32_t entry_r5;
0802e6e6      int32_t entry_r7;
0802e6e6      int32_t lr;
0802e6e6      
0802e6e6      if (r4)
0802e6f0          /* tailcall */
0802e6f0          return mul_normalised(entry_result, entry_r1, entry_r2, entry_r3, entry_r4, 
0802e6f0              entry_r5, entry_r7, lr);
0802e6f0      
0802e76c      if (r4 != 0x7ff)
0802e770          /* tailcall */
0802e770          return mul_non_normalised(entry_result, entry_r1, entry_r2, entry_r3, entry_r4, 
0802e770              entry_r5, entry_r7, lr);
0802e770      
0802e7fa      if (!(entry_result | entry_r1 << 1))
0802e800          entry_r1 = 0xffffffff;
0802e800      
0802e808      int32_t temp0 = entry_r3 << 1;
0802e808      
0802e80c      if (0x200000 != -(temp0) && 0x200000 + temp0 < 0x200000)
0802e782          return entry_result;
0802e782      
0802e810      /* tailcall */
0802e810      return mul_nan_inf(entry_result, entry_r1, entry_r2, entry_r3, entry_r4);
0802e6d4  }
0802e6f2  // // Core multiply for *normalized* inputs (no zeros, no denorms, no
0802e6f2  // NaNs/Infs).
0802e6f2  // // The dispatcher has already extracted the fields.
0802e6f2  // // ea, eb: unbiased exponents of a and b (0 < ea,eb < 0x7FF).
0802e6f2  // // all1: just the constant 0x7FF (kept to match original tailcall interface).
0802e6f2  // // sign_xor: (a.hi ^ b.hi) & 0x80000000 (sign of the result).
0802e6f2  
0802e6f2    dbl_bits mul_normalised(uint32_t a_lo, uint32_t a_hi, uint32_t b_lo, uint32_t b_hi, uint32_t ea, uint32_t all1, uint32_t eb, uint32_t sign_xor)
0802e6f2  {
0802e6f8      int32_t entry_r5;
0802e6f8      int32_t r3_1 = (b_hi & ~(entry_r5 << 0x15)) | 0x100000;
0802e702      int32_t lr = a_hi << 0xb | 0x80000000 | a_lo >> 0x15;
0802e706      uint32_t r7 = a_lo << 0xb;
0802e71c      int32_t r1_4;
0802e71c      int32_t r2_2;
0802e71c      r1_4 = HIGHD(r7 * r3_1 + b_lo * lr + r7 * b_lo);
0802e71c      r2_2 = LOWD(r7 * r3_1 + b_lo * lr + r7 * b_lo);
0802e720      int32_t r0;
0802e720      
0802e720      if (r0)
0802e722          r2_2 |= 1;
0802e722      
0802e72c      int32_t r0_2;
0802e72c      int32_t r0_4;
0802e72c      uint32_t r1_6;
0802e72c      r1_6 = HIGHD(lr * r3_1 + );
0802e72c      r0_4 = LOWD(lr * r3_1 + );
0802e734      bool c_1 = TEST_BIT(r1_6, 0x14);
0802e734      
0802e736      if (!c_1)
0802e736      {
0802e738          int32_t temp2_1 = r2_2;
0802e738          r2_2 <<= 1;
0802e738          bool c_2 = TEST_BIT(temp2_1, 0x1f);
0802e73a          int32_t temp3_1 = r0_4;
0802e73a          int32_t temp4_1 = r0_4;
0802e73a          r0_4 = temp3_1 + temp4_1;
0802e73a          bool c_3 = temp3_1 + temp4_1 < temp3_1 || (c_2 && temp3_1 + temp4_1 == temp3_1);
0802e73c          uint32_t temp5_1 = r1_6;
0802e73c          uint32_t temp6_1 = r1_6;
0802e73c          r1_6 = temp5_1 + temp6_1;
0802e73c          c_1 = temp5_1 + temp6_1 < temp5_1 || (c_3 && temp5_1 + temp6_1 == temp5_1);
0802e736      }
0802e736      
0802e73e      bool v = /* bool v = unimplemented  {adcs r4, r4, #1} */;
0802e742      int32_t entry_r4;
0802e742      int32_t entry_r7;
0802e742      
0802e742      if (entry_r4 + entry_r7 - 0x400 + 1 && entry_r4 + entry_r7 - 0x400 + 1 < 0 == v)
0802e742      {
0802e744          bool c_4 = TEST_BIT(r0_4, 0);
0802e746          bool cond:5 = ~c_4;
0802e746          bool c_5 = r2_2 + 0x80000000 < r2_2 || (r2_2 + 0x80000000 == r2_2 && c_4);
0802e74a          int32_t result = r0_4 + 0;
0802e74e          int32_t r1_7 = r1_6 + ((entry_r4 + entry_r7 - 0x400 + 1) << 0x14);
0802e74e          
0802e756          if (r1_7 >= 0)
0802e75c              return result;
0802e75c          
0802e75c          int32_t entry_r12;
0802e75c          /* tailcall */
0802e75c          return sub_802e75e(entry_r5, entry_r12, result, r1_7 - 0x100000, 
0802e75c              r2_2 + 0x80000000);
0802e742      }
0802e742      
0802e826      uint32_t r2_4;
0802e826      int32_t r4_1;
0802e826      bool c_8;
0802e826      
0802e826      if (1 - r4_1 >= 0x20)
0802e826      {
0802e84a          if (1 - r4_1 > 0x35)
0802e782              return 0;
0802e782          
0802e854          uint32_t r2_6 = r0_4 >> (1 - r4_1 - 0x20);
0802e854          
0802e858          if (r2_2 | r0_4 << 1)
0802e85a              r2_6 |= 1;
0802e85a          
0802e85e          r0_4 = r1_6 >> (1 - r4_1 - 0x20);
0802e864          r2_4 = r2_6 | r1_6 << (0x20 * 2 - (1 - r4_1));
0802e864          c_8 = /* c_8 = unimplemented  {orrs r2, r1} */;
0802e826      }
0802e826      else
0802e826      {
0802e82c          r2_4 = r2_2 >> 1;
0802e82c          
0802e82e          if (TEST_BIT(r2_2, 0))
0802e830              r2_4 |= 1;
0802e830          
0802e834          c_8 = TEST_BIT(r0_4, 0x20 * 0 + 1 - r4_1);
0802e83e          r2_4 |= r0_4 << (0x20 - (1 - r4_1));
0802e842          r0_4 = r0_4 >> (1 - r4_1) | r1_6 << (0x20 - (1 - r4_1));
0802e826      }
0802e826      
0802e868      bool cond:7 = ~c_8;
0802e874      return r0_4 + 0;
0802e6f2  }
0802e75e    int32_t sub_802e75e(int32_t arg1 @ r5, int32_t arg2 @ r12, int32_t arg3, int32_t arg4, int32_t arg5) __pure
0802e75e  {
0802e764      return 0;
0802e75e  }
0802e772  // // Path for cases where *at least one* operand is subnormal (or zero).
0802e772  // // It left-shifts the subnormal significand until normalized, adjusts the
0802e772  // // working exponent accordingly, then reuses the same significand multiply/
0802e772  // // normalization logic as sub_802e6f2.
0802e772  
0802e772    dbl_bits mul_non_normalised(uint32_t a_lo, uint32_t a_hi, uint32_t b_lo, uint32_t b_hi, uint32_t ea, uint32_t all1, uint32_t eb, uint32_t sign_xor)
0802e772  {
0802e776      int32_t entry_r4;
0802e776      
0802e776      if (a_lo | a_hi << 1)
0802e776      {
0802e788          int32_t r3_1;
0802e788          int32_t r4_2;
0802e788          int32_t entry_r5;
0802e788          int32_t entry_r7;
0802e788          uint32_t r7_3;
0802e788          uint32_t lr_3;
0802e788          
0802e788          if (entry_r4)
0802e788          {
0802e7c2              int32_t r3_2 = b_hi & 0x7fffffff;
0802e7c6              int32_t r7_4 = __clz(r3_2);
0802e7c6              
0802e7ca              if (!r3_2)
0802e7d0                  r7_4 += __clz(b_lo);
0802e7d0              
0802e7d6              uint32_t lr_5 = r7_4 - 0x2b;
0802e7d6              
0802e7da              if (r7_4 - 0xb >= 0x20)
0802e7dc                  r3_1 = b_lo << lr_5;
0802e7da              else
0802e7da              {
0802e7e0                  r3_1 = r3_2 << (r7_4 - 0xb);
0802e7e6                  lr_5 = b_lo >> (0x20 - (r7_4 - 0xb));
0802e7da              }
0802e7da              
0802e7ea              if (r7_4 - 0xb < 0x20)
0802e7ec                  r3_1 |= lr_5;
0802e7ec              
0802e7f0              b_lo <<= r7_4 - 0xb;
0802e7f2              r4_2 = entry_r4 + entry_r7 - (r7_4 - 0xb) + 1;
0802e702              lr_3 = a_hi << 0xb | 0x80000000 | a_lo >> 0x15;
0802e706              r7_3 = a_lo << 0xb;
0802e70a          label_802e70a:
0802e71c              int32_t r1_9;
0802e71c              int32_t r2_6;
0802e71c              r1_9 = HIGHD(r7_3 * r3_1 + b_lo * lr_3 + r7_3 * b_lo);
0802e71c              r2_6 = LOWD(r7_3 * r3_1 + b_lo * lr_3 + r7_3 * b_lo);
0802e720              int32_t r0_5;
0802e720              
0802e720              if (r0_5)
0802e722                  r2_6 |= 1;
0802e722              
0802e72c              int32_t r0_3;
0802e72c              int32_t r0_7;
0802e72c              uint32_t r1_2;
0802e72c              r1_2 = HIGHD(lr_3 * r3_1 + );
0802e72c              r0_3 = LOWD(lr_3 * r3_1 + );
0802e734              bool c_6 = TEST_BIT(r1_2, 0x14);
0802e734              
0802e736              if (!c_6)
0802e736              {
0802e738                  int32_t temp2_1 = r2_6;
0802e738                  r2_6 <<= 1;
0802e738                  bool c_7 = TEST_BIT(temp2_1, 0x1f);
0802e73a                  int32_t temp3_1 = r0_3;
0802e73a                  int32_t temp4_1 = r0_3;
0802e73a                  r0_3 = temp3_1 + temp4_1;
0802e73a                  bool c_8 =
0802e73a                      temp3_1 + temp4_1 < temp3_1 || (c_7 && temp3_1 + temp4_1 == temp3_1);
0802e73c                  uint32_t temp5_1 = r1_2;
0802e73c                  uint32_t temp6_1 = r1_2;
0802e73c                  r1_2 = temp5_1 + temp6_1;
0802e73c                  c_6 =
0802e73c                      temp5_1 + temp6_1 < temp5_1 || (c_8 && temp5_1 + temp6_1 == temp5_1);
0802e736              }
0802e736              
0802e73e              bool v_1 = /* bool v_1 = unimplemented  {adcs r4, r4, #1} */;
0802e73e              
0802e742              if (r4_2 - 0x400 + 1 && r4_2 - 0x400 + 1 < 0 == v_1)
0802e742              {
0802e744                  bool c_9 = TEST_BIT(r0_3, 0);
0802e746                  bool cond:8 = ~c_9;
0802e746                  bool c_10 =
0802e746                      r2_6 + 0x80000000 < r2_6 || (r2_6 + 0x80000000 == r2_6 && c_9);
0802e74a                  int32_t result = r0_3 + 0;
0802e74e                  int32_t r1_11 = r1_2 + ((r4_2 - 0x400 + 1) << 0x14);
0802e74e                  
0802e756                  if (r1_11 >= 0)
0802e75c                      return result;
0802e75c                  
0802e75c                  int32_t entry_r12;
0802e75c                  /* tailcall */
0802e75c                  return sub_802e75e(entry_r5, entry_r12, result, r1_11 - 0x100000, 
0802e75c                      r2_6 + 0x80000000);
0802e742              }
0802e742              
0802e826              uint32_t r2;
0802e826              int32_t r4_8;
0802e826              bool c_2;
0802e826              bool cond:10;
0802e826              
0802e826              if (1 - r4_8 < 0x20)
0802e826              {
0802e82c                  r2 = r2_6 >> 1;
0802e82c                  
0802e82e                  if (TEST_BIT(r2_6, 0))
0802e830                      r2 |= 1;
0802e830                  
0802e834                  c_2 = TEST_BIT(r0_3, 0x20 * 0 + 1 - r4_8);
0802e83e                  r2 |= r0_3 << (0x20 - (1 - r4_8));
0802e868                  cond:10 = ~c_2;
0802e874                  return (r0_3 >> (1 - r4_8) | r1_2 << (0x20 - (1 - r4_8))) + 0;
0802e826              }
0802e826              
0802e84a              if (1 - r4_8 <= 0x35)
0802e84a              {
0802e854                  uint32_t r2_2 = r0_3 >> (1 - r4_8 - 0x20);
0802e854                  
0802e858                  if (r2_6 | r0_3 << 1)
0802e85a                      r2_2 |= 1;
0802e85a                  
0802e864                  r2 = r2_2 | r1_2 << (0x20 * 2 - (1 - r4_8));
0802e864                  c_2 = /* c_2 = unimplemented  {orrs r2, r1} */;
0802e868                  cond:10 = ~c_2;
0802e874                  return (r1_2 >> (1 - r4_8 - 0x20)) + 0;
0802e84a              }
0802e788          }
0802e788          else
0802e788          {
0802e78a              int32_t lr_1 = entry_r7;
0802e78a              
0802e78e              if (lr_1)
0802e78e              {
0802e790                  uint32_t a_lo_1 = a_hi << 0xc;
0802e790                  
0802e792                  if (!a_lo_1)
0802e792                  {
0802e794                      a_lo_1 = a_lo;
0802e796                      a_lo = 0;
0802e798                      lr_1 -= 0x14;
0802e792                  }
0802e792                  
0802e79c                  int32_t r7_1 = __clz(a_lo_1);
0802e7a0                  r4_2 = lr_1 - r7_1;
0802e7ae                  r7_3 = a_lo << (r7_1 + 0xc);
0802e7b4                  lr_3 = a_lo_1 << r7_1 | a_lo >> (0x20 - (r7_1 + 0xc));
0802e7bc                  r3_1 = (b_hi & ~(entry_r5 << 0x15)) | 0x100000;
0802e7c0                  goto label_802e70a;
0802e78e              }
0802e788          }
0802e776      }
0802e782      return 0;
0802e772  }
0802e816  // // NaN/Inf resolver for multiply. The dispatcher calls this when an operand
0802e816  // // had exponent==0x7FF. It returns the correct IEEE-754 result (qNaN
0802e816  // // propagation, sNaN->qNaN, Inf*0 -> qNaN, Inf*finite -> Inf with sign).
0802e816  // //
0802e816  // // Note: the original call site only passes (a_lo,a_hi,b_lo); b_hi is known
0802e816  // // to be “special” already. Keep this signature to reflect the binary.
0802e816  
0802e816    dbl_bits mul_nan_inf(uint32_t exp_all_ones, uint32_t sign_xor, uint32_t a_lo, uint32_t a_hi, uint32_t b_lo) __pure
0802e816  {
0802e81c      return 0;
0802e816  }
0802e876                                                                    00 00                                                ..
0802e878    dbl_bits soft_dadd(dbl_bits a, dbl_bits b)
0802e878  {
0802e888      int32_t entry_r1;
0802e888      int32_t r4 = 0x7ff & entry_r1 >> 0x14;
0802e88c      int32_t entry_r0;
0802e88c      int32_t entry_r2;
0802e88c      int32_t entry_r3;
0802e88c      int32_t entry_r4;
0802e88c      int32_t entry_r5;
0802e88c      int32_t entry_r6;
0802e88c      int32_t entry_r7;
0802e88c      int32_t entry_r8;
0802e88c      
0802e88c      if (r4)
0802e896          /* tailcall */
0802e896          return sub_802e898(entry_r0, entry_r1, entry_r2, entry_r3, r4, 
0802e896              0x7ff & entry_r3 >> 0x14, (entry_r1 ^ entry_r3) & 0x80000000, entry_r4, 
0802e896              entry_r5, entry_r6, entry_r7, entry_r8);
0802e896      
0802ea6e      if (r4 != 0x7ff)
0802ea76          /* tailcall */
0802ea76          return sub_802ea78(entry_r0, entry_r1, entry_r2, entry_r3);
0802ea76      
0802eaa8      int32_t temp0 = entry_r1 << 1;
0802eaa8      bool z = 0x200000 == -(temp0);
0802eaa8      bool c = 0x200000 + temp0 < 0x200000;
0802eaa8      
0802eaac      if (z || !c)
0802eaac      {
0802eaae          int32_t temp1_1 = entry_r3 << 1;
0802eaae          z = 0x200000 == -(temp1_1);
0802eaae          c = 0x200000 + temp1_1 < 0x200000;
0802eaac      }
0802eaac      
0802eab2      if (z)
0802eab4          c = 0x200000 + (entry_r1 << 1) < 0x200000;
0802eab4      
0802eab8      if (c)
0802eaca          return 0;
0802eaca      
0802eabc      /* jump -> &data_802eabe */
0802e878  }
0802e898    int32_t sub_802e898(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5 @ r4, int32_t arg6 @ r7, int32_t arg7 @ r12, int32_t arg8, int32_t arg9, int32_t arg10, int32_t arg11, int32_t arg12)
0802e898  {
0802e898      bool c;
0802e898      int32_t r4 = arg5 - arg6;
0802e89a      int32_t r1 = arg2 & 0xfffff;
0802e89e      int32_t r3 = arg4 & 0xfffff;
0802e8a2      int32_t r0 = arg1 - arg3;
0802e8a2      bool c_1 = arg1 >= arg3;
0802e8a4      bool cond:0 = ~c_1;
0802e8a4      int32_t r1_1 = r1 - r3;
0802e8a6      int32_t r3_1 = r3 | 0x100000;
0802e8a6      
0802e8aa      if (r1 - r3 >= r1 && (r1 - r3 != r1 || !c_1))
0802e8aa      {
0802e8ac          r4 -= 1;
0802e8ae          int32_t r0_1 = r0 << 1;
0802e8b0          int32_t r1_2 = r1_1 + r1_1;
0802e8b2          r0 = r0_1 + arg3;
0802e8b4          r1_1 = r1_2 + r3_1;
0802e8aa      }
0802e8aa      
0802e8b8      int32_t r1_4 = r1_1 << 0xb | r0 >> 0x15;
0802e8bc      uint32_t r6 = r1_4 / r3_1;
0802e8c0      int32_t r1_5 = r1_4 % r3_1;
0802e8c4      int32_t r5;
0802e8c4      int32_t r7;
0802e8c4      r5 = HIGHD(arg3 * r6);
0802e8c4      r7 = LOWD(arg3 * r6);
0802e8c8      int32_t r0_2 = (r0 << 0xb) - r7;
0802e8c8      bool c_5 = r0 << 0xb >= r7;
0802e8cc      bool cond:1 = ~c_5;
0802e8cc      int32_t r1_6 = r1_5 - r5;
0802e8cc      
0802e8ce      if (r1_5 - r5 >= r1_5 && (r1_5 - r5 != r1_5 || !c_5))
0802e8ce      {
0802e8d0          r6 -= 1;
0802e8d2          int32_t temp8_1 = r0_2;
0802e8d2          r0_2 += arg3;
0802e8d4          r1_6 = r1_6 + r3_1;
0802e8ce      }
0802e8ce      
0802e8d8      int32_t r1_8 = r1_6 << 0xb | r0_2 >> 0x15;
0802e8dc      uint32_t lr = r1_8 / r3_1;
0802e8e0      int32_t r1_9 = r1_8 % r3_1;
0802e8e4      int32_t r5_1;
0802e8e4      int32_t r7_1;
0802e8e4      r5_1 = HIGHD(arg3 * lr);
0802e8e4      r7_1 = LOWD(arg3 * lr);
0802e8e8      int32_t r0_3 = (r0_2 << 0xb) - r7_1;
0802e8e8      bool c_8 = r0_2 << 0xb >= r7_1;
0802e8ec      bool cond:2 = ~c_8;
0802e8ec      int32_t r1_10 = r1_9 - r5_1;
0802e8ec      
0802e8ee      if (r1_9 - r5_1 >= r1_9 && (r1_9 - r5_1 != r1_9 || !c_8))
0802e8ee      {
0802e8f0          lr -= 1;
0802e8f4          int32_t temp11_1 = r0_3;
0802e8f4          r0_3 += arg3;
0802e8f6          r1_10 = r1_10 + r3_1;
0802e8ee      }
0802e8ee      
0802e8fa      int32_t r1_12 = r1_10 << 0xa | r0_3 >> 0x16;
0802e904      uint32_t r6_2 = r1_12 / r3_1;
0802e908      int32_t r1_13 = r1_12 % r3_1;
0802e90c      int32_t r5_2;
0802e90c      int32_t r7_2;
0802e90c      r5_2 = HIGHD(arg3 * r6_2);
0802e90c      r7_2 = LOWD(arg3 * r6_2);
0802e910      int32_t r0_4 = (r0_3 << 0xa) - r7_2;
0802e910      bool c_11 = r0_3 << 0xa >= r7_2;
0802e914      bool cond:3 = ~c_11;
0802e914      int32_t r1_14 = r1_13 - r5_2;
0802e914      
0802e916      if (r1_13 - r5_2 >= r1_13 && (r1_13 - r5_2 != r1_13 || !c_11))
0802e916      {
0802e918          r6_2 -= 1;
0802e91a          int32_t temp14_1 = r0_4;
0802e91a          r0_4 += arg3;
0802e91c          r1_14 = r1_14 + r3_1;
0802e916      }
0802e916      
0802e920      int32_t r1_16 = r1_14 << 0xb | r0_4 >> 0x15;
0802e924      int32_t lr_2 = r6 << 0x15 | lr << 0xa | r6_2;
0802e928      uint32_t r6_3 = r1_16 / r3_1;
0802e92c      int32_t r1_17 = r1_16 % r3_1;
0802e930      int32_t r5_3;
0802e930      int32_t r7_3;
0802e930      r5_3 = HIGHD(arg3 * r6_3);
0802e930      r7_3 = LOWD(arg3 * r6_3);
0802e934      int32_t r0_5 = (r0_4 << 0xb) - r7_3;
0802e934      bool c_14 = r0_4 << 0xb >= r7_3;
0802e938      bool cond:4 = ~c_14;
0802e938      int32_t r1_18 = r1_17 - r5_3;
0802e938      
0802e93a      if (r1_17 - r5_3 >= r1_17 && (r1_17 - r5_3 != r1_17 || !c_14))
0802e93a      {
0802e93c          r6_3 -= 1;
0802e93e          int32_t temp17_1 = r0_5;
0802e93e          r0_5 += arg3;
0802e940          r1_18 = r1_18 + r3_1;
0802e93a      }
0802e93a      
0802e944      int32_t r1_20 = r1_18 << 0xb | r0_5 >> 0x15;
0802e948      uint32_t r7_4 = r1_20 / r3_1;
0802e94c      int32_t r1_21 = r1_20 % r3_1;
0802e950      int32_t r3_2;
0802e950      int32_t r5_4;
0802e950      r5_4 = HIGHD(arg3 * r7_4);
0802e950      r3_2 = LOWD(arg3 * r7_4);
0802e954      bool c_17 = r0_5 << 0xb >= r3_2;
0802e958      bool cond:5 = ~c_17;
0802e95a      int32_t r7_5 = r7_4 - 0;
0802e95a      
0802e95e      if (r1_21 - r5_4)
0802e962          r7_5 |= 1;
0802e962      
0802e966      int32_t r7_6 = (r7_5 & 0xffc007ff) | (r6_3 & 0x7ff) << 0xb;
0802e96a      uint32_t r1_23 = lr_2 >> 0xc;
0802e96e      uint32_t r0_6 = r7_6 >> 2;
0802e96e      
0802e974      if (r4 > 0xfffffc00)
0802e974      {
0802e976          int32_t r5_5 = r7_6 << 0x1e;
0802e976          bool c_19 = TEST_BIT(r7_6, 2);
0802e978          bool cond:6 = ~c_19;
0802e978          bool c_20 = r5_5 + 0x80000000 < r5_5 || (r5_5 + 0x80000000 == r5_5 && c_19);
0802e97c          int32_t temp20 = lr_2 << 0x14;
0802e97c          int32_t result = r0_6 + temp20;
0802e980          int32_t r1_24 = r1_23 + ((r4 + 0x400) << 0x14);
0802e980          
0802e988          if (r1_24 + 0x100000 >= 0)
0802e98e              return result;
0802e98e          
0802e98e          /* tailcall */
0802e98e          return sub_802e992(arg7, result, r1_24, r5_5 + 0x80000000, r3_2, arg8);
0802e974      }
0802e974      
0802e9a2      uint32_t r5_8 = r7_6 << 0x1e >> 1;
0802e9a4      int32_t r0_8 = r0_6 | lr_2 << 0x14;
0802e9a8      int32_t r1_27 = r1_23 | 0x100000;
0802e9b4      int32_t r0_10;
0802e9b4      int32_t r5_9;
0802e9b4      bool c_22;
0802e9b4      
0802e9b4      if (1 - (r4 + 0x400) >= 0x20)
0802e9b4      {
0802e9ce          if (1 - (r4 + 0x400) > 0x34)
0802ea00              return 0;
0802ea00          
0802e9e0          r0_10 = r1_27 >> (1 - (r4 + 0x400) - 0x20);
0802e9e6          r5_9 = (r5_8 | r0_8 << 1) >> 1 | r0_8 >> (1 - (r4 + 0x400) - 0x20)
0802e9e6              | r1_27 << (0x20 * 2 - (1 - (r4 + 0x400)));
0802e9e6          c_22 = /* c_22 = unimplemented  {orrs r5, r1} */;
0802e9b4      }
0802e9b4      else
0802e9b4      {
0802e9c4          r0_10 = r0_8 >> (1 - (r4 + 0x400)) | r1_27 << (0x20 - (1 - (r4 + 0x400)));
0802e9c8          r5_9 = r5_8 | r0_8 << (0x20 - (1 - (r4 + 0x400)));
0802e9c8          c_22 = /* c_22 = unimplemented  {orrs r5, r2} */;
0802e9b4      }
0802e9b4      
0802e9ea      bool cond:8 = ~c_22;
0802e9f6      return r0_10 + 0;
0802e898  }
0802e992    int32_t sub_802e992(int32_t arg1 @ r12, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6) __pure
0802e992  {
0802e99c      return 0;
0802e992  }
0802ea04    int32_t sub_802ea04(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5 @ r4, int32_t arg6 @ r7, int32_t arg7 @ r12, int32_t arg8, int32_t arg9, int32_t arg10, int32_t arg11, int32_t arg12)
0802ea04  {
0802ea04      int32_t r4_1;
0802ea04      int32_t r7_1;
0802ea04      
0802ea04      if (arg6)
0802ea04      {
0802ea3a          r7_1 = 0 - arg6;
0802ea3c      label_802ea3c:
0802ea3c          int32_t r1 = arg2 & 0x7fffffff;
0802ea40          int32_t r4_2 = __clz(r1);
0802ea40          
0802ea44          if (!r1)
0802ea4a              r4_2 += __clz(arg1);
0802ea4a          
0802ea4e          uint32_t r6_5 = r4_2 - 0x2b;
0802ea4e          
0802ea52          if (r4_2 - 0xb >= 0x20)
0802ea54              arg2 = arg1 << r6_5;
0802ea52          else
0802ea52          {
0802ea58              arg2 = r1 << (r4_2 - 0xb);
0802ea5e              r6_5 = arg1 >> (0x20 - (r4_2 - 0xb));
0802ea52          }
0802ea52          
0802ea62          if (r4_2 - 0xb < 0x20)
0802ea64              arg2 |= r6_5;
0802ea64          
0802ea66          arg1 <<= r4_2 - 0xb;
0802ea68          r4_1 = r7_1 - (r4_2 - 0xb);
0802ea04      }
0802ea04      else
0802ea04      {
0802ea06          int32_t r2 = arg3 * 2;
0802ea08          int32_t r3 = arg4 + arg4;
0802ea0a          int32_t r7 = __clz(r3);
0802ea0a          
0802ea0e          if (!r3)
0802ea14              r7 += __clz(r2);
0802ea14          
0802ea16          r7_1 = r7 - 0xb;
0802ea18          uint32_t r6_2 = r7_1 - 0x20;
0802ea18          
0802ea1c          if (r7_1 >= 0x20)
0802ea1e              arg4 = r2 << r6_2;
0802ea1c          else
0802ea1c          {
0802ea22              arg4 = r3 << r7_1;
0802ea28              r6_2 = r2 >> (0x20 - r7_1);
0802ea1c          }
0802ea1c          
0802ea2c          if (r7_1 < 0x20)
0802ea2e              arg4 |= r6_2;
0802ea2e          
0802ea30          arg3 = r2 << r7_1;
0802ea30          
0802ea32          if (!arg5)
0802ea32              goto label_802ea3c;
0802ea32          
0802ea36          r4_1 = arg5 + r7_1 - 1;
0802ea04      }
0802e89a      int32_t r1_1 = arg2 & 0xfffff;
0802e89e      int32_t r3_1 = arg4 & 0xfffff;
0802e8a2      int32_t r0 = arg1 - arg3;
0802e8a2      bool c_2 = arg1 >= arg3;
0802e8a4      bool cond:4 = ~c_2;
0802e8a4      int32_t r1_2 = r1_1 - r3_1;
0802e8a6      int32_t r3_2 = r3_1 | 0x100000;
0802e8a6      
0802e8aa      if (r1_1 - r3_1 >= r1_1 && (r1_1 - r3_1 != r1_1 || !c_2))
0802e8aa      {
0802e8ac          r4_1 -= 1;
0802e8ae          int32_t r0_1 = r0 << 1;
0802e8b0          int32_t r1_3 = r1_2 + r1_2;
0802e8b2          r0 = r0_1 + arg3;
0802e8b4          r1_2 = r1_3 + r3_2;
0802e8aa      }
0802e8aa      
0802e8b8      int32_t r1_5 = r1_2 << 0xb | r0 >> 0x15;
0802e8bc      uint32_t r6_7 = r1_5 / r3_2;
0802e8c0      int32_t r1_6 = r1_5 % r3_2;
0802e8c4      int32_t r5;
0802e8c4      int32_t r7_2;
0802e8c4      r5 = HIGHD(arg3 * r6_7);
0802e8c4      r7_2 = LOWD(arg3 * r6_7);
0802e8c8      int32_t r0_2 = (r0 << 0xb) - r7_2;
0802e8c8      bool c_6 = r0 << 0xb >= r7_2;
0802e8cc      bool cond:5 = ~c_6;
0802e8cc      int32_t r1_7 = r1_6 - r5;
0802e8cc      
0802e8ce      if (r1_6 - r5 >= r1_6 && (r1_6 - r5 != r1_6 || !c_6))
0802e8ce      {
0802e8d0          r6_7 -= 1;
0802e8d2          int32_t temp10_1 = r0_2;
0802e8d2          r0_2 += arg3;
0802e8d4          r1_7 = r1_7 + r3_2;
0802e8ce      }
0802e8ce      
0802e8d8      int32_t r1_9 = r1_7 << 0xb | r0_2 >> 0x15;
0802e8dc      uint32_t lr = r1_9 / r3_2;
0802e8e0      int32_t r1_10 = r1_9 % r3_2;
0802e8e4      int32_t r5_1;
0802e8e4      int32_t r7_3;
0802e8e4      r5_1 = HIGHD(arg3 * lr);
0802e8e4      r7_3 = LOWD(arg3 * lr);
0802e8e8      int32_t r0_3 = (r0_2 << 0xb) - r7_3;
0802e8e8      bool c_9 = r0_2 << 0xb >= r7_3;
0802e8ec      bool cond:6 = ~c_9;
0802e8ec      int32_t r1_11 = r1_10 - r5_1;
0802e8ec      
0802e8ee      if (r1_10 - r5_1 >= r1_10 && (r1_10 - r5_1 != r1_10 || !c_9))
0802e8ee      {
0802e8f0          lr -= 1;
0802e8f4          int32_t temp13_1 = r0_3;
0802e8f4          r0_3 += arg3;
0802e8f6          r1_11 = r1_11 + r3_2;
0802e8ee      }
0802e8ee      
0802e8fa      int32_t r1_13 = r1_11 << 0xa | r0_3 >> 0x16;
0802e904      uint32_t r6_9 = r1_13 / r3_2;
0802e908      int32_t r1_14 = r1_13 % r3_2;
0802e90c      int32_t r5_2;
0802e90c      int32_t r7_4;
0802e90c      r5_2 = HIGHD(arg3 * r6_9);
0802e90c      r7_4 = LOWD(arg3 * r6_9);
0802e910      int32_t r0_4 = (r0_3 << 0xa) - r7_4;
0802e910      bool c_12 = r0_3 << 0xa >= r7_4;
0802e914      bool cond:7 = ~c_12;
0802e914      int32_t r1_15 = r1_14 - r5_2;
0802e914      
0802e916      if (r1_14 - r5_2 >= r1_14 && (r1_14 - r5_2 != r1_14 || !c_12))
0802e916      {
0802e918          r6_9 -= 1;
0802e91a          int32_t temp16_1 = r0_4;
0802e91a          r0_4 += arg3;
0802e91c          r1_15 = r1_15 + r3_2;
0802e916      }
0802e916      
0802e920      int32_t r1_17 = r1_15 << 0xb | r0_4 >> 0x15;
0802e924      int32_t lr_2 = r6_7 << 0x15 | lr << 0xa | r6_9;
0802e928      uint32_t r6_10 = r1_17 / r3_2;
0802e92c      int32_t r1_18 = r1_17 % r3_2;
0802e930      int32_t r5_3;
0802e930      int32_t r7_5;
0802e930      r5_3 = HIGHD(arg3 * r6_10);
0802e930      r7_5 = LOWD(arg3 * r6_10);
0802e934      int32_t r0_5 = (r0_4 << 0xb) - r7_5;
0802e934      bool c_15 = r0_4 << 0xb >= r7_5;
0802e938      bool cond:8 = ~c_15;
0802e938      int32_t r1_19 = r1_18 - r5_3;
0802e938      
0802e93a      if (r1_18 - r5_3 >= r1_18 && (r1_18 - r5_3 != r1_18 || !c_15))
0802e93a      {
0802e93c          r6_10 -= 1;
0802e93e          int32_t temp19_1 = r0_5;
0802e93e          r0_5 += arg3;
0802e940          r1_19 = r1_19 + r3_2;
0802e93a      }
0802e93a      
0802e944      int32_t r1_21 = r1_19 << 0xb | r0_5 >> 0x15;
0802e948      uint32_t r7_6 = r1_21 / r3_2;
0802e94c      int32_t r1_22 = r1_21 % r3_2;
0802e950      int32_t r3_3;
0802e950      int32_t r5_4;
0802e950      r5_4 = HIGHD(arg3 * r7_6);
0802e950      r3_3 = LOWD(arg3 * r7_6);
0802e954      bool c_18 = r0_5 << 0xb >= r3_3;
0802e958      bool cond:9 = ~c_18;
0802e95a      int32_t r7_7 = r7_6 - 0;
0802e95a      
0802e95e      if (r1_22 - r5_4)
0802e962          r7_7 |= 1;
0802e962      
0802e966      int32_t r7_8 = (r7_7 & 0xffc007ff) | (r6_10 & 0x7ff) << 0xb;
0802e96a      uint32_t r1_24 = lr_2 >> 0xc;
0802e96e      uint32_t r0_6 = r7_8 >> 2;
0802e96e      
0802e974      if (r4_1 > 0xfffffc00)
0802e974      {
0802e976          int32_t r5_5 = r7_8 << 0x1e;
0802e976          bool c_20 = TEST_BIT(r7_8, 2);
0802e978          bool cond:10 = ~c_20;
0802e978          bool c_21 = r5_5 + 0x80000000 < r5_5 || (r5_5 + 0x80000000 == r5_5 && c_20);
0802e97c          int32_t temp22 = lr_2 << 0x14;
0802e97c          int32_t result = r0_6 + temp22;
0802e980          int32_t r1_25 = r1_24 + ((r4_1 + 0x400) << 0x14);
0802e980          
0802e988          if (r1_25 + 0x100000 >= 0)
0802e98e              return result;
0802e98e          
0802e98e          /* tailcall */
0802e98e          return sub_802e992(arg7, result, r1_25, r5_5 + 0x80000000, r3_3, arg8);
0802e974      }
0802e974      
0802e9a2      uint32_t r5_8 = r7_8 << 0x1e >> 1;
0802e9a4      int32_t r0_8 = r0_6 | lr_2 << 0x14;
0802e9a8      int32_t r1_28 = r1_24 | 0x100000;
0802e9b4      int32_t r0_10;
0802e9b4      int32_t r5_9;
0802e9b4      bool c_23;
0802e9b4      
0802e9b4      if (1 - (r4_1 + 0x400) >= 0x20)
0802e9b4      {
0802e9ce          if (1 - (r4_1 + 0x400) > 0x34)
0802ea00              return 0;
0802ea00          
0802e9e0          r0_10 = r1_28 >> (1 - (r4_1 + 0x400) - 0x20);
0802e9e6          r5_9 = (r5_8 | r0_8 << 1) >> 1 | r0_8 >> (1 - (r4_1 + 0x400) - 0x20)
0802e9e6              | r1_28 << (0x20 * 2 - (1 - (r4_1 + 0x400)));
0802e9e6          c_23 = /* c_23 = unimplemented  {orrs r5, r1} */;
0802e9b4      }
0802e9b4      else
0802e9b4      {
0802e9c4          r0_10 = r0_8 >> (1 - (r4_1 + 0x400)) | r1_28 << (0x20 - (1 - (r4_1 + 0x400)));
0802e9c8          r5_9 = r5_8 | r0_8 << (0x20 - (1 - (r4_1 + 0x400)));
0802e9c8          c_23 = /* c_23 = unimplemented  {orrs r5, r2} */;
0802e9b4      }
0802e9b4      
0802e9ea      bool cond:12 = ~c_23;
0802e9f6      return r0_10 + 0;
0802ea04  }
0802ea78    int32_t sub_802ea78(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
0802ea78  {
0802ea78      int32_t r6_1 = arg1 | arg2 << 1;
0802ea7c      int32_t r12;
0802ea7c      int32_t r4;
0802ea7c      int32_t r7;
0802ea7c      
0802ea7c      if (r6_1)
0802ea82          /* tailcall */
0802ea82          return sub_802ea04(arg1, arg2, arg3, arg4, r4, r7, r12);
0802ea82      int32_t r5;
0802ea82      /* tailcall */
0802ea82      return sub_802ea84(arg1, arg2, arg3, arg4, r5, r6_1, r12);
0802ea78  }
0802ea84    int32_t sub_802ea84(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5 @ r5, int32_t arg6 @ r6, int32_t arg7 @ r12, int32_t arg8, int32_t arg9, int32_t arg10, int32_t arg11, int32_t arg12)
0802ea84  {
0802ea8c      if (arg1 | arg2 << 1)
0802ea92          return arg6;
0802ea92      
0802ea92      /* tailcall */
0802ea92      return sub_802ea96(arg6, arg7, arg3, arg4, arg8, arg9, arg10, arg11, arg12);
0802ea84  }
0802ea96    void sub_802ea96(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, int32_t arg8, int32_t arg9) __pure
0802ea96  {
0802ea9e      return;
0802ea96  }
0802eabe  data_802eabe:
0802eabe                                                                                            16 eb                                ..
0802eac0  43 0f 0c bf 61 46 4c ea 05 51                                                                    C...aFL..Q
0802eace                                            00 00                                                                ..
0802ead0    int32_t sub_802ead0(int32_t arg1, int32_t arg2)
0802ead0  {
0802ead0      int32_t r12_2 = RORD(arg2, 0x1f);
0802ead0      
0802ead8      if (r12_2 >= 0x70000000)
0802eade          /* tailcall */
0802eade          return sub_802eae0(arg1, arg2, r12_2 - 0x70000000);
0802eade      
0802eade      /* tailcall */
0802eade      return sub_802eb04(arg1, arg2, r12_2 - 0x70000000);
0802ead0  }
0802eae0    int32_t sub_802eae0(int32_t arg1, int32_t arg2, int32_t arg3 @ r12)
0802eae0  {
0802eae0      int32_t r12_1 = arg3 << 1;
0802eae0      
0802eae4      if (!TEST_BIT(arg3, 0x1f))
0802eaea          /* tailcall */
0802eaea          return sub_802eaec(arg1, r12_1);
0802eaea      
0802eaea      /* tailcall */
0802eaea      return sub_802eb4a(arg1, arg2, r12_1);
0802eae0  }
0802eaec    uint32_t sub_802eaec(int32_t arg1, int32_t arg2 @ r12) __pure
0802eaec  {
0802eaf8      int32_t r1 = arg1 << 3;
0802eaf8      bool c = TEST_BIT(arg1, 0x1d);
0802eafa      bool cond:0 = ~c;
0802eb02      return (arg2 >> 2 << 4) + (arg1 >> 0x1d);
0802eaec  }
0802eb04    int32_t sub_802eb04(int32_t arg1, int32_t arg2, int32_t arg3 @ r12) __pure
0802eb04  {
0802eb06      int32_t r1 = arg2 << 0xb | arg1 >> 0x15;
0802eb06      
0802eb0c      if (arg1 << 0xb)
0802eb0e          r1 |= 1;
0802eb0e      
0802eb12      int32_t r1_1 = r1 | 0x80000000;
0802eb12      
0802eb20      if (9 - (arg3 >> 0x15) >= 0x21)
0802eb48          return arg3 << 0x1f;
0802eb48      
0802eb2a      int32_t r0_3 = r1_1 << (0x20 - ((9 - (arg3 >> 0x15)) | arg3 << 0x1f));
0802eb2a      bool c = TEST_BIT(r1_1, 0x20 * 0 + ((9 - (arg3 >> 0x15)) | arg3 << 0x1f));
0802eb2e      bool cond:0 = ~c;
0802eb3e      int32_t result = (r1_1 >> (0x20 * 0 + ((9 - (arg3 >> 0x15)) | arg3 << 0x1f)))
0802eb3e          + ((0x20 * 0 + ((9 - (arg3 >> 0x15)) | arg3 << 0x1f)) & 0x80000000);
0802eb42      return result;
0802eb04  }
0802eb4a    int32_t sub_802eb4a(int32_t arg1, int32_t arg2, int32_t arg3 @ r12) __pure
0802eb4a  {
0802eb4a      int32_t r1 = arg2 << 1;
0802eb4a      
0802eb50      if (r1 != 0xffe00000 && r1 >= 0xffe00000)
0802eb5e          return r1 >> 0x1f;
0802eb5e      
0802eb5a      return ((arg3 << 7) + 0xff) << 0x17;
0802eb4a  }
0802eb60    void sub_802eb60(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
0802eb60  {
0802eb6a      if ((arg2 ^ arg4) >= 0)
0802eb6e          /* jump -> &data_802eb72 */
0802eb6e      
0802eb6c      int32_t r3 = arg4 ^ 0x80000000;
0802ed08      int32_t r4 = arg1 - arg3;
0802ed08      bool c = arg1 >= arg3;
0802ed0a      bool cond:0 = ~c;
0802ed0a      int32_t r6 = arg2 - r3;
0802ed0a      
0802ed0e      if (arg2 - r3 >= arg2 && (arg2 - r3 != arg2 || !c))
0802ed0e      {
0802ed10          int32_t temp1_1 = arg1;
0802ed10          arg1 -= r4;
0802ed12          arg2 = arg2 - r6;
0802ed14          int32_t temp2_1 = arg3;
0802ed14          arg3 += r4;
0802ed16          r3 = r3 + r6;
0802ed0e      }
0802ed0e      
0802ed20      if (0x200000 + (arg2 << 1) >= 0x200000)
0802ed26          /* jump -> &data_802ed28 */
0802ed26      
0802edb4      if (0x200000 + (arg2 << 1) < 0x200000)
0802edda          return;
0802edda      
0802edc0      if (!(arg3 | r3 << 1) || 0x200000 > arg2 << 1)
0802edc0          return;
0802edc0      
0802edc2      uint32_t r4_2 = arg2 >> 0x14;
0802edc4      int32_t r3_5 = r3 & 0x7fffffff;
0802edc4      
0802edca      if (r4_2 - 1 > 0x34)
0802ed3c          return;
0802ed3c      
0802ed3c      int32_t r1_1 = (0x80000000 | arg2 << 0xb) >> 0xb;
0802ed42      int32_t r0;
0802ed42      uint32_t r1_2;
0802ed42      int32_t r5_1;
0802ed42      
0802ed42      if (r4_2 - 1 <= 0x20)
0802ed42      {
0802ed64          uint32_t r2 = arg3 >> (r4_2 - 1);
0802ed66          r5_1 = RORD(arg3, r4_2 - 1) ^ r2;
0802ed68          int32_t r3_2 = RORD(r3_5, r4_2 - 1);
0802ed6e          uint32_t r3_4 = r3_2 << (r4_2 - 1) >> (r4_2 - 1);
0802ed70          int32_t r2_2 = r2 ^ r3_2 ^ r3_4;
0802ed72          r0 = arg1 + r2_2;
0802ed72          bool c_7 = arg1 + r2_2 < arg1;
0802ed74          r1_2 = r1_1 + r3_4;
0802ed74          
0802ed76          if (r1_1 + r3_4 < r1_1 || (c_7 && r1_1 + r3_4 == r1_1))
0802ed76          {
0802ed78          label_802ed78:
0802ed78              uint32_t temp9_1 = r1_2;
0802ed78              r1_2 u>>= 1;
0802ed7a              r0 <<= 1;
0802ed7e              r5_1 <<= 1;
0802ed7e              
0802ed82              if (TEST_BIT(temp9_1, 0))
0802ed84                  r5_1 |= 1;
0802ed76          }
0802ed42      }
0802ed42      else
0802ed42      {
0802ed48          uint32_t r3_1 = r3_5 >> (r4_2 - 0x21);
0802ed4a          r5_1 = RORD(r3_5, r4_2 - 0x21) ^ r3_1;
0802ed4a          
0802ed50          if (arg3)
0802ed52              r5_1 |= 1;
0802ed52          
0802ed56          r0 = arg1 + r3_1;
0802ed56          bool c_5 = arg1 + r3_1 < arg1;
0802ed58          r1_2 = r1_1 + 0;
0802ed58          
0802ed5c          if (r1_1 + 0 < r1_1 || (c_5 && r1_1 + 0 == r1_1))
0802ed5c              goto label_802ed78;
0802ed42      }
0802ed42      
0802ed8c      bool c_10 = TEST_BIT(r0, 0);
0802ed8e      bool cond:2 = ~c_10;
0802ed8e      bool c_11 = r5_1 + 0x80000000 < r5_1 || (r5_1 + 0x80000000 == r5_1 && c_10);
0802ed8e      
0802eda4      if (0x200000 + ((r1_2 + 0x100000 + (r4_2 << 0x14)) << 1) >= 0x200000)
0802eda6          return;
0802eda6      
0802eda6      /* jump -> sub_802eda8 */
0802eb60  }
0802eb72  data_802eb72:
0802eb72                                                        00 bf                                                        ..
0802eb96  data_802eb96:
0802eb96                                                                    0c 0d a4 eb 13 56 36 2e 7d dc                        .....V6.}.
0802eba0  01 2e 43 dc 45 ea c3 23 43 ea 52 53 12 bf d2 02 92 02 5b 08 24 05 45 ea c1 21 41 ea 50 51 d2 eb  ..C.E..#C.RS......[.$.E..!A.PQ..
0802ebc0  c0 20 99 41 25 d4 07 d1 b0 fa 80 f6 10 fa 06 f1 64 d0 00 20 20 36 08 e0 b1 fa 81 f6 b1 40 c6 f1  . .A%...........d..  6.......@..
0802ebe0  20 02 20 fa 02 f2 11 43 b0 40 4f ea f4 74 b4 eb 46 54 34 f0 01 06 4f ea 74 04 0a d8 d6 f5 00 16   . ....C.@O..t..FT4...O.t.......
0802ec00  76 0d 04 f0 00 44 f0 40 61 fa 06 f2 50 40 f1 40 48 40 c0 0a 40 ea 41 50 21 f0 00 41 28 bf 5f ea  v....D.@a...P@.@H@..@.AP!..A(._.
0802ec20  50 05 50 f1 00 00 44 eb d1 21 37 e0 45 ea c3 23 db 0a                                            P.P...D..!7.E..#..
0802ece0    int32_t sub_802ece0(int32_t arg1 @ r7, int64_t arg2 @ q0)
0802ece0  {
0802ece4      int32_t r0;
0802ece4      int32_t r1;
0802ece4      r1 = HIGHD(arg2);
0802ece4      r0 = LOWD(arg2);
0802ece8      int32_t r0_1;
0802ece8      int32_t r1_1;
0802ece8      int128_t q4;
0802ece8      dbl_bits q5;
0802ece8      r0_1 = sub_8035c7c(r0, r1, 0, q4, q5);
0802ecf0      return arg1;
0802ece0  }
0802ecf2                                                        00 00                                                        ..
0802ecf4    void sub_802ecf4(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
0802ecf4  {
0802ecfe      if ((arg2 ^ arg4) >= 0)
0802ed02          /* jump -> &data_802ed06 */
0802ed02      
0802ed00      int32_t r3 = arg4 ^ 0x80000000;
0802eb74      int32_t r4 = arg1 - arg3;
0802eb74      bool c = arg1 >= arg3;
0802eb76      bool cond:0 = ~c;
0802eb76      
0802eb7a      if (arg2 - r3 >= arg2 && (arg2 - r3 != arg2 || !c))
0802eb7a      {
0802eb7c          int32_t r6_1 = (arg2 - r3) ^ 0x80000000;
0802eb80          arg2 = arg2 - r6_1;
0802eb82          int32_t temp2_1 = arg3;
0802eb82          arg3 += r4;
0802eb84          r3 = r3 + r6_1;
0802eb7a      }
0802eb7a      
0802eb8e      if (0x200000 + (arg2 << 1) >= 0x200000)
0802eb94          /* jump -> &data_802eb96 */
0802eb94      
0802eca4      if (0x200000 + (arg2 << 1) < 0x200000)
0802ecd2          return;
0802ecd2      
0802ecae      if (!(arg3 | (r3 & 0x7fffffff) << 1))
0802ecae          goto label_802ecc8;
0802ecae      
0802ecb8      if (0x400000 > arg2 << 1)
0802ecc8      label_802ecc8:
0802ecf4  }
0802ed06  data_802ed06:
0802ed06                    00 bf                                                                                ..
0802ed28  data_802ed28:
0802ed28                          0c 0d a4 eb 13 56 35 2e 50 dc 45 ea c3 23 db 0a                                  .....V5.P.E..#..
0802eda8    int32_t sub_802eda8(int32_t arg1, int32_t arg2) __pure
0802eda8  {
0802edae      return 0;
0802eda8  }
0802eddc                                                                                      4d 4f 44 55                              MODU
0802ede0  4c 45 5f 53 45 4e 53 4f 52 5f 33 53 5f 43 4f 4c 4c 49 53 49 4f 4e 5f 53 48 49 46 54 20 3e 3e 3e  LE_SENSOR_3S_COLLISION_SHIFT >>>
0802ee00  3e 3e 3e 3e 3e 3e 3e 3e 3e 3e 0d 0a 00 00 00 00                                                  >>>>>>>>>>......
0802ee10    int32_t sub_802ee10(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int128_t arg5 @ q4, int128_t arg6 @ q5, int16_t* arg7)
0802ee10  {
0802ee10      int32_t r7;
0802ee10      int32_t var_10 = r7;
0802ee10      int32_t var_20 = arg4;
0802ee14      int64_t var_28 = (uint64_t)arg5;
0802ee14      int64_t var_30 = *(uint64_t*)((char*)arg5)[8];
0802ee14      int64_t var_38 = (uint64_t)arg6;
0802ee14      int64_t var_40 = *(uint64_t*)((char*)arg6)[8];
0802ee18      int32_t var_4c = arg2;
0802ee18      int32_t result_1 = arg1;
0802ee22      int64_t b_5 = arg3;
0802ee26      int32_t b_6 = b_5;
0802ee2a      int32_t r0_1 = var_4c >> 0x14 & 0x7ff;
0802ee30      int32_t r4;
0802ee30      int32_t r5;
0802ee30      
0802ee30      if (r0_1 == 0x7ff)
0802ee30      {
0802ee34          r4 = 0;
0802ee34          
0802ee38          r5 = !(var_4c << 0xc) ? 1 : 2;
0802ee30      }
0802ee30      else if (r0_1 >= 1)
0802ee46      {
0802ee62      label_802ee62:
0802ee62          var_4c = (var_4c & 0x800fffff) | 0x3fe00000;
0802ee64          r4 = r0_1 - 0x3fe;
0802ee66          r5 = 0xffffffff;
0802ee46      }
0802ee46      else
0802ee46      {
0802ee4a          r0_1 = sub_8035fdc(&result_1);
0802ee4a          
0802ee50          if (r0_1 < 1)
0802ee50              goto label_802ee62;
0802ee50          
0802ee52          r4 = 0;
0802ee54          r5 = 0;
0802ee46      }
0802ee46      
0802ee6e      int32_t result = sub_8036020(&b_6, 0);
0802ee76      int32_t result_2 = result;
0802ee76      
0802ee7c      if (arg7)
0802ee7c      {
0802ee7e          result = 0;
0802ee80          *(uint16_t*)arg7 = 0;
0802ee7c      }
0802ee7c      
0802ee84      if (!result_2)
0802ee8a          result = 0;
0802ee84      else
0802ee84      {
0802ee96          int32_t r1_47;
0802ee96          
0802ee96          if (r5 < 0)
0802ee96          {
0802ee98              r4 = (int32_t)(int16_t)r4;
0802ee98              
0802ee9c              if (r4 != 1)
0802ee9c              {
0802eecc                  if (result_2 >= 1)
0802eecc                      goto label_802eed0;
0802eecc                  
0802efb0                  bool cond:3_1 = var_4c >= 0;
0802efb0                  bool cond:5_1 = var_4c < 0;
0802efb0                  bool cond:6_1 = var_4c < 0;
0802efb0                  
0802efb2                  if (var_4c < 0)
0802efb2                  {
0802efb4                      cond:3_1 = result_2 >= 0;
0802efb4                      cond:5_1 = result_2 < 0;
0802efb4                      cond:6_1 = result_2 < 0;
0802efb2                  }
0802efb2                  
0802efb6                  if (!cond:3_1)
0802efb6                  {
0802efb8                      sub_80360bc();
0802efbe                      data_20000d58 = 0x21;
0802efc6                      (uint64_t)arg5 = var_40;
0802efc6                      *(uint64_t*)((char*)arg5)[8] = var_38;
0802efc6                      (uint64_t)arg6 = var_30;
0802efc6                      *(uint64_t*)((char*)arg6)[8] = var_28;
0802efce                      return 0xffffffff;
0802efb6                  }
0802efb6                  
0802efd2                  int32_t result_3 = result_1;
0802efda                  sub_80360c8(result_3, var_4c, 0, 0);
0802efda                  
0802efde                  if (cond:5_1)
0802efe0                      r5 = 0;
0802efe0                  
0802efe2                  if (!cond:6_1)
0802efe2                  {
0802efe8                      result_1 = result_3;
0802efe8                      var_4c ^= 0x80000000;
0802eff6                      r5 = sub_8036020(&b_6, 0xffffffff);
0802efe2                  }
0802efe2                  
0802eff8                  bool c_1 = r4 >= 1;
0802eff8                  
0802effa                  if (r4 == 1)
0802f004                      sub_8031ac8(result_1, var_4c, 0x667f3bcd, 0x3fe6a09e);
0802f004                  
0802f008                  int32_t a;
0802f008                  int32_t b;
0802f008                  int32_t r6;
0802f008                  
0802f008                  if (r4 != 1 || c_1)
0802f008                  {
0802f02c                      int32_t r0_27;
0802f02c                      int32_t r1_10;
0802f02c                      r0_27 = soft_dmul(a, b);
0802f030                      (uint64_t)arg5 = 0;
0802f038                      int32_t r0_28;
0802f038                      int32_t r1_11;
0802f038                      r0_28 = sub_802ecf4(r0_27, r1_10, 0, 0);
0802f040                      int32_t r6_1 = sub_802ff74(r0_28, r1_11) - 0x20;
0802f046                      sub_802e6a4(r6_1);
0802f04e                      int32_t r0_31;
0802f04e                      int32_t r1_12;
0802f04e                      r0_31 = soft_dmul();
0802f056                      int32_t r0_32;
0802f056                      int32_t r1_13;
0802f056                      r0_32 = sub_802ecf4(r0_31, r1_12, 0, 0);
0802f05a                      (uint64_t)arg5 = (r1_13 << 32) | r0_32;
0802f05e                      r6 = r6_1 << 5;
0802f05e                      c_1 = TEST_BIT(r6_1, 0x1b);
0802f008                  }
0802f008                  else
0802f008                  {
0802f014                      int32_t result_4;
0802f014                      int32_t r1_8;
0802f014                      result_4 = soft_dmul(a, b);
0802f018                      result_1 = result_4;
0802f018                      var_4c = r1_8;
0802f01c                      r6 = 0;
0802f01e                      (uint64_t)arg5 = 0;
0802f008                  }
0802f008                  
0802f06c                  int32_t r2_10;
0802f06c                  int32_t r3_7;
0802f06c                  r3_7 = HIGHD((uint64_t)arg5);
0802f06c                  r2_10 = LOWD((uint64_t)arg5);
0802f070                  int32_t r0_34;
0802f070                  int32_t r1_15;
0802f070                  r0_34 = sub_802eb60(result_1, var_4c, r2_10, r3_7);
0802f078                  *(uint64_t*)((char*)arg5)[8] = (r1_15 << 32) | r0_34;
0802f07c                  int32_t r0_35;
0802f07c                  int32_t r1_16;
0802f07c                  r1_16 = HIGHD((uint64_t)arg5);
0802f07c                  r0_35 = LOWD((uint64_t)arg5);
0802f080                  int32_t r0_36;
0802f080                  int32_t r1_17;
0802f080                  r0_36 = sub_802ecf4(r0_35, r1_16, result_1, var_4c);
0802f08c                  int32_t r0_38;
0802f08c                  int32_t r1_19;
0802f08c                  r0_38 = soft_dadd(a, b);
0802f090                  (uint64_t)arg6 = (r1_19 << 32) | r0_38;
0802f098                  int32_t r0_39;
0802f098                  int32_t r1_20;
0802f098                  r0_39 = soft_dmul();
0802f09c                  *(uint64_t*)((char*)arg6)[8] = (r1_20 << 32) | r0_39;
0802f0a0                  result_1 = *(uint64_t*)((char*)arg5)[8];
0802f0a4                  arg5 = sub_8035ee0(r0_39, r1_20, r7, (uint64_t)arg5);
0802f0ac                  int32_t r0_40;
0802f0ac                  int32_t r1_21;
0802f0ac                  r0_40 = soft_dmul();
0802f0b4                  int32_t r0_41;
0802f0b4                  int32_t r1_22;
0802f0b4                  r0_41 = sub_802eb60(r0_40, r1_21, result_1, var_4c);
0802f0c0                  int32_t r2_16;
0802f0c0                  int32_t r3_13;
0802f0c0                  r3_13 = HIGHD((uint64_t)arg5);
0802f0c0                  r2_16 = LOWD((uint64_t)arg5);
0802f0c4                  sub_802eb60(0, 0x3ff00000, r2_16, r3_13);
0802f0ce                  int32_t r0_42;
0802f0ce                  int32_t r1_23;
0802f0ce                  r0_42 = soft_dmul();
0802f0d6                  sub_802ecf4(r0_42, r1_23, r0_41, r1_22);
0802f0de                  int32_t r0_43;
0802f0de                  int32_t r1_24;
0802f0de                  r0_43 = soft_dmul();
0802f0e6                  int32_t r0_44;
0802f0e6                  int32_t r1_25;
0802f0e6                  r0_44 = sub_802ecf4(r0_43, r1_24, result_1, var_4c);
0802f0ea                  (uint64_t)arg5 = (r1_25 << 32) | r0_44;
0802f0f2                  int32_t b_7;
0802f0f2                  int32_t r1_26;
0802f0f2                  b_7 = soft_dadd();
0802f0f6                  b_6 = b_7;
0802f0fc                  int32_t r0_46;
0802f0fc                  int32_t r1_27;
0802f0fc                  r0_46 = sub_802e6a4(r4);
0802f100                  *(uint64_t*)((char*)arg5)[8] = (r1_27 << 32) | r0_46;
0802f108                  int32_t r2_22;
0802f108                  int32_t r3_19;
0802f108                  r3_19 = HIGHD(*(uint64_t*)((char*)arg5)[8]);
0802f108                  r2_22 = LOWD(*(uint64_t*)((char*)arg5)[8]);
0802f10c                  int32_t r0_48;
0802f10c                  int32_t r1_29;
0802f10c                  r0_48 = sub_802ecf4(*(uint32_t*)(0x802f2c0 + r6), 
0802f10c                      *(uint32_t*)(r6 + 0x802f2c4), r2_22, r3_19);
0802f114                  int32_t b_8;
0802f114                  int32_t r1_30;
0802f114                  b_8 = sub_802ecf4(r0_48, r1_29, b_6, r1_26);
0802f118                  b_6 = b_8;
0802f118                  int32_t var_54_2 = r1_30;
0802f120                  int32_t b_1;
0802f120                  int32_t r1_31;
0802f120                  b_1 = soft_dmul();
0802f128                  b = b_1;
0802f12c                  sub_8031ac8(b_1, r1_31, 0, 0xc0e00000);
0802f130                  int32_t var_5c_4;
0802f130                  
0802f130                  if (!c_1)
0802f130                  {
0802f262                  label_802f262:
0802f262                      b = 0;
0802f262                      var_5c_4 = 0;
0802f278                      sub_80360bc();
0802f27e                      data_20000d58 = 0x22;
0802f130                  }
0802f130                  else
0802f130                  {
0802f138                      sub_80360c8(b_1, r1_31, 1, 0x40e00000);
0802f138                      
0802f13c                      if (!c_1)
0802f13c                      {
0802f274                      label_802f274:
0802f274                          b = 0;
0802f274                          var_5c_4 = 0x7ff00000;
0802f278                          sub_80360bc();
0802f27e                          data_20000d58 = 0x22;
0802f13c                      }
0802f13c                      else
0802f13c                      {
0802f144                          sub_8031ac8(b_1, r1_31, 0, 0);
0802f14c                          int32_t r1_32;
0802f14c                          
0802f14c                          r1_32 = !c_1 ? 0xbfe00000 : 0x3fe00000;
0802f14c                          
0802f156                          int32_t r0_49;
0802f156                          int32_t r1_33;
0802f156                          r0_49 = sub_802ecf4(0, r1_32, b, r1_31);
0802f15e                          int32_t r4_2 = sub_802ff74(r0_49, r1_33);
0802f168                          int32_t b_2;
0802f168                          int32_t r1_35;
0802f168                          b_2 = soft_dmul();
0802f16c                          b = b_2;
0802f178                          sub_802ecf4(*(uint32_t*)(r6 + 0x802f2d0), 
0802f178                              *(uint32_t*)(r6 + 0x802f2d4), *(uint32_t*)(r6 + 0x802f2c8), 
0802f178                              *(uint32_t*)(r6 + 0x802f2cc));
0802f180                          soft_dmul();
0802f184                          (uint64_t)arg5 = 0xfefa39ef;
0802f18c                          int32_t r0_53;
0802f18c                          int32_t r1_37;
0802f18c                          r0_53 = soft_dmul();
0802f194                          int32_t b_3;
0802f194                          int32_t r1_38;
0802f194                          b_3 = sub_802ecf4(r0_53, r1_37, b, r1_35);
0802f198                          b = b_3;
0802f1a0                          int32_t r0_54;
0802f1a0                          int32_t r1_39;
0802f1a0                          r1_39 = HIGHD(*(uint64_t*)((char*)arg5)[8]);
0802f1a0                          r0_54 = LOWD(*(uint64_t*)((char*)arg5)[8]);
0802f1a4                          sub_802ecf4(r0_54, r1_39, *(uint32_t*)(0x802f2c0 + r6), 
0802f1a4                              *(uint32_t*)(r6 + 0x802f2c4));
0802f1ac                          int32_t r0_55;
0802f1ac                          int32_t r1_40;
0802f1ac                          r0_55 = soft_dmul();
0802f1b6                          int32_t r0_57;
0802f1b6                          int32_t r1_41;
0802f1b6                          r0_57 = sub_802e6a4(r4_2);
0802f1c2                          sub_802eb60(r0_55, r1_40, r0_57, r1_41);
0802f1ca                          int32_t r0_59;
0802f1ca                          int32_t r1_43;
0802f1ca                          r0_59 = soft_dmul();
0802f1d2                          int32_t b_4;
0802f1d2                          int32_t r1_44;
0802f1d2                          b_4 = sub_802ecf4(r0_59, r1_43, b, r1_38);
0802f1d6                          b = b_4;
0802f1d6                          var_5c_4 = r1_44;
0802f1d6                          
0802f1de                          if (arg7)
0802f1de                          {
0802f1e0                              *(uint16_t*)arg7 = (int16_t)r4_2;
0802f1e4                              r4_2 = 0;
0802f1de                          }
0802f1de                          
0802f1ee                          int32_t r0_61;
0802f1ee                          r0_61 = sub_80360f8(&b, r1_44, 0, 0x3ff00000, arg5, arg6, r4_2);
0802f1ee                          
0802f1f2                          if (!r0_61)
0802f1f2                              goto label_802f262;
0802f1f2                          
0802f1f6                          if (r0_61 == 1)
0802f1f6                              goto label_802f274;
0802f13c                      }
0802f130                  }
0802f130                  
0802f282                  b_5 = r5 ?  : b;
0802f282                  
0802f294                  r1_47 = HIGHD(b_5);
0802f294                  result = LOWD(b_5);
0802ee9c              }
0802ee9c              else
0802eea2                  result = 0;
0802ee96          }
0802ee96          else if (r5 != 2)
0802eec2          {
0802eed0          label_802eed0:
0802eed0              
0802eed0              if (result_2 == 2)
0802eed2                  result = arg3;
0802eed2              
0802eed6              if (result_2 != 2)
0802eed6              {
0802eedc                  if (r5 != 1)
0802eedc                  {
0802ef36                      if (result_2 == 1)
0802ef36                      {
0802ef3c                          int32_t r4_1 = (int32_t)(int16_t)r4;
0802ef3c                          
0802ef3e                          if (arg4 < 0)
0802ef3e                          {
0802ef50                              if (r4_1 >= 1)
0802ef52                                  b_5 = 0;
0802ef50                              else
0802ef56                                  b_5 = 0;
0802ef3e                          }
0802ef3e                          else if (r4_1 >= 1)
0802ef44                              b_5 = 0;
0802ef42                          else
0802ef48                              b_5 = 0;
0802ef36                      }
0802ef36                      else if (arg4 < 0)
0802ef60                      {
0802ef84                          sub_80360bc();
0802ef8a                          data_20000d58 = 0x22;
0802ef8c                          bool cond:10_1;
0802ef8c                          
0802ef8c                          if (!result_2)
0802ef8c                          {
0802ef94                              int32_t r0_18 = sub_8036020(&b_6, 0xffffffff);
0802ef98                              cond:10_1 = r0_18 < 0;
0802ef98                              
0802ef9a                              if (r0_18 < 0)
0802ef9a                              {
0802ef9e                                  cond:10_1 = var_4c < 0;
0802efa0                                  b_5 = 0;
0802ef9a                              }
0802ef8c                          }
0802ef8c                          
0802efa4                          if (result_2 || !cond:10_1)
0802efa8                              b_5 = 0;
0802ef60                      }
0802ef60                      else
0802ef60                      {
0802ef62                          bool cond:11_1;
0802ef62                          
0802ef62                          if (!result_2)
0802ef62                          {
0802ef6a                              int32_t r0_15 = sub_8036020(&b_6, 0xffffffff);
0802ef6e                              cond:11_1 = r0_15 < 0;
0802ef6e                              
0802ef70                              if (r0_15 < 0)
0802ef70                              {
0802ef74                                  cond:11_1 = var_4c < 0;
0802ef76                                  b_5 = 0;
0802ef70                              }
0802ef62                          }
0802ef62                          
0802ef7a                          if (result_2 || !cond:11_1)
0802ef7e                              b_5 = 0;
0802ef60                      }
0802eedc                  }
0802eedc                  else if (var_4c < 0)
0802eee4                  {
0802eef6                      if (arg4 < 0)
0802eef6                      {
0802ef16                          int32_t r0_11;
0802ef16                          
0802ef16                          if (!result_2)
0802ef16                          {
0802ef1e                              r0_11 = sub_8036020(&b_6, 0xffffffff);
0802ef1e                              
0802ef24                              if (r0_11 < 0)
0802ef26                                  b_5 = 0;
0802ef16                          }
0802ef16                          
0802ef2a                          if (result_2 || r0_11 >= 0)
0802ef2e                              b_5 = 0;
0802eef6                      }
0802eef6                      else
0802eef6                      {
0802eef8                          int32_t r0_9;
0802eef8                          
0802eef8                          if (!result_2)
0802eef8                          {
0802ef00                              r0_9 = sub_8036020(&b_6, 0xffffffff);
0802ef00                              
0802ef06                              if (r0_9 < 0)
0802ef08                                  b_5 = 0;
0802eef8                          }
0802eef8                          
0802ef0c                          if (result_2 || r0_9 >= 0)
0802ef10                              b_5 = 0;
0802eef6                      }
0802eee4                  }
0802eee4                  else if (arg4 >= 0)
0802eeea                      b_5 = 0;
0802eee8                  else
0802eeee                      b_5 = 0;
0802eeee                  
0802f294                  r1_47 = HIGHD(b_5);
0802f294                  result = LOWD(b_5);
0802eed6              }
0802eec2          }
0802eec2          else
0802eec4              result = result_1;
0802ee84      }
0802ee84      
0802f29a      (uint64_t)arg5 = var_40;
0802f29a      *(uint64_t*)((char*)arg5)[8] = var_38;
0802f29a      (uint64_t)arg6 = var_30;
0802f29a      *(uint64_t*)((char*)arg6)[8] = var_28;
0802f29e      return result;
0802ee10  }
0802f1fa                                                                                00 bf                                        ..
0802f1fc  int32_t data_802f1fc = 0x3ff00000
0802f200  00 00                                                                                            ..
0802f202  int32_t data_802f202 = 0x0
0802f206                    00 80                                                                                ..
0802f208  int32_t data_802f208 = 0x667f3bcd
0802f20c  int32_t data_802f20c = 0x3fe6a09e
0802f210                                                  00 00                                                            ..
0802f212  int32_t data_802f212 = 0x0
0802f216                                                                    f0 3f                                                .?
0802f218  int32_t data_802f218 = 0x40500000
0802f21c  int32_t data_802f21c = 0x0
0802f220  00 00 e0 3f                                                                                      ...?
0802f224  int32_t data_802f224 = 0x3f900000
0802f228  int32_t data_802f228 = -0x105c611
0802f22c  int32_t data_802f22c = 0x3fe62e42
0802f230  int32_t data_802f230 = -0x3f200000
0802f234  int32_t data_802f234 = 0x40e00000
0802f238  int32_t data_802f238 = -0x40200000
0802f23c  int32_t data_802f23c = 0x3fe00000
0802f240  int32_t data_802f240 = -0x105c611
0802f244              42 2e e6 3f                                                                              B..?
0802f248  int32_t data_802f248 = 0x0
0802f24c                                      00 00 f0 7f                                                              ....
0802f250  int32_t data_802f250 = 0x0
0802f254                                                              00 00 00 00                                              ....
0802f258  int32_t data_802f258 = 0x0
0802f25c                                                                                      00 00 f0 ff                              ....
0802f26e                                            00 bf                                                                ..
0802f270  int32_t data_802f270 = 0x7ff00000
0802f2a2    int32_t sub_802f2a2(int128_t arg1 @ q0)
0802f2a2  {
0802f2a2      int32_t r7;
0802f2a2      int32_t var_8 = r7;
0802f2a8      int32_t r2;
0802f2a8      int32_t r3;
0802f2a8      r3 = HIGHD(*(uint64_t*)((char*)arg1)[8]);
0802f2a8      r2 = LOWD(*(uint64_t*)((char*)arg1)[8]);
0802f2ac      int32_t r0;
0802f2ac      int32_t r1;
0802f2ac      r1 = HIGHD((uint64_t)arg1);
0802f2ac      r0 = LOWD((uint64_t)arg1);
0802f2b0      int32_t r0_1;
0802f2b0      int32_t r1_1;
0802f2b0      int128_t q0;
0802f2b0      int128_t q4;
0802f2b0      int128_t q5;
0802f2b0      r0_1 = sub_802ee10(r0, r1, r2, r3, q4, q5, nullptr);
0802f2b4      (uint64_t)q0 = (r1_1 << 32) | r0_1;
0802f2b8      return 0;
0802f2a2  }
0802f2ba                                                                                00 00 00 00 00 00                            ......
0802f2c0  00 00 00 00 00 00 f0 bf 00 00 00 00 00 00 00 80 00 00 00 00 00 00 00 80 00 00 00 00 00 00 00 00  ................................
0802f2e0  00 00 00 c0 52 94 ee bf 00 00 00 48 20 4e 51 be 00 00 00 f8 64 67 bc bc 00 00 00 00 00 00 00 00  ....R......H NQ.....dg..........
0802f300  00 00 00 20 81 33 ed bf 00 00 00 80 b3 db 14 be 00 00 00 50 67 06 a3 bc 00 00 00 00 00 00 00 00  ... .3.............Pg...........
0802f320  00 00 00 d0 e9 dc eb bf 00 00 00 08 c3 92 59 be 00 00 00 80 b0 d3 b8 bc 00 00 00 00 00 00 00 00  ..............Y.................
0802f340  00 00 00 70 f9 8f ea bf 00 00 00 c0 a5 10 28 be 00 00 00 e8 bf c0 b0 bc 00 00 00 00 00 00 00 00  ...p..........(.................
0802f360  00 00 00 70 28 4c e9 bf 00 00 00 60 13 4b 42 be 00 00 00 c0 3d 20 b8 bc 00 00 00 00 00 00 00 00  ...p(L.....`.KB.....= ..........
0802f380  00 00 00 50 fa 10 e8 bf 00 00 00 c0 5f f6 2b be 00 00 00 90 5c 71 a7 bc 00 00 00 00 00 00 00 00  ...P........_.+.....\q..........
0802f3a0  00 00 00 20 fc dd e6 bf 00 00 00 c0 f8 f1 54 be 00 00 00 18 e9 f6 b9 bc 00 00 00 00 00 00 00 00  ... ..........T.................
0802f3c0  00 00 00 d0 c3 b2 e5 bf 00 00 00 70 e4 32 54 be 00 00 00 50 db 06 b4 bc 00 00 00 00 00 00 00 00  ...........p.2T....P............
0802f3e0  00 00 00 10 ef 8e e4 bf 00 00 00 20 f3 62 52 be 00 00 00 c0 2a 87 9a bc 00 00 00 00 00 00 00 00  ........... .bR.....*...........
0802f400  00 00 00 b0 22 72 e3 bf 00 00 00 f0 e8 e0 56 be 00 00 00 28 35 2d bd bc 00 00 00 00 00 00 00 00  ...."r........V....(5-..........
0802f420  00 00 00 00 0a 5c e2 bf 00 00 00 b0 fa 8e 41 be 00 00 00 40 ae 6f bd bc 00 00 00 00 00 00 00 00  .....\........A....@.o..........
0802f440  00 00 00 00 56 4c e1 bf 00 00 00 f0                                                              ....VL......
0802f44c    void sub_802f44c(int32_t* arg1 @ r5) __noreturn
0802f44c  {
0802f44c      *(uint32_t*)arg1;
0802f44c      arg1[1];
0802f44c      arg1[2];
0802f44e      breakpoint();
0802f44c  }
0802f474    void sub_802f474(int32_t arg1, int32_t arg2, int16_t arg3, int32_t arg4 @ r5, int32_t arg5 @ r6, int32_t arg6, int16_t* arg7, int32_t arg8, int32_t arg9) __noreturn
0802f474  {
0802f486      if (!arg6 || arg6 < 0 != arg4 - 1)
0802f48c          *(uint16_t*)((char*)arg7 + arg5) = arg3;
0802f48c      
0802f48e      breakpoint();
0802f474  }
0802f484    void sub_802f484(int32_t arg1, int16_t* arg2, int16_t arg3, void* arg4 @ r6) __noreturn
0802f484  {
0802f484      *(uint8_t*)((char*)arg4 + 0x17);
0802f486      bool n;
0802f486      bool z;
0802f486      bool v;
0802f486      
0802f486      if (z || n != v)
0802f48c          *(uint16_t*)((char*)arg2 + arg4) = arg3;
0802f48c      
0802f48e      breakpoint();
0802f484  }
0802f4b6                                                                    b0 bc 00 00 00 00 00 00 00 00                        ..........
0802f4c0  00 00 00 60 f9 8f da bf 00 00 00 58 0a 81 51 be 00 00 00 f0 5f 60 b8 bc 00 00 00 00 00 00 00 00  ...`.......X..Q....._`..........
0802f4e0  00 00 00 00 98 a8 d8 bf 00 00 00 60 7a 7f 45 be 00 00 00 d0 54 33 a3 bc 00 00 00 00 00 00 00 00  ...........`z.E.....T3..........
0802f500  00 00 00 60 0f cb d6 bf 00 00 00 d0 91 cb 40 be 00 00 00 40 6d 1b a0 bc 00 00 00 00 00 00 00 00  ...`..........@....@m...........
0802f520  00 00 00 a0 fb f6 d4 bf 00 00                                                                    ..........
0802f52a    void sub_802f52a(int32_t* arg1 @ r6) __noreturn
0802f52a  {
0802f52c      *(uint32_t*)arg1;
0802f52c      arg1[1];
0802f52c      arg1[2];
0802f52c      arg1[3];
0802f52e      breakpoint();
0802f52a  }
0802f544              fe 2b                                                                                    .+
0802f5ae                                            53 be 00 00 00 50 e0 0d b8 bc 00 00 00 00 00 00 00 00                S....P............
0802f5c0  00 00 00 00 98 a8 c8 bf 00 00 00 60 7a 7f 35 be 00 00 00 c0 54 33 93 bc 00 00 00 00 00 00 00 00  ...........`z.5.....T3..........
0802f5e0  00 00 00 00 dc 63 c5 bf 00 00 00 58 d6 ff 54 be 00 00 00 00                                      .....c.....X..T.....
0802f5f4    void sub_802f5f4(int16_t* arg1, int32_t arg2, int32_t arg3 @ r5, int32_t arg4 @ r6, void* arg5 @ r7, int32_t* arg6, int32_t arg7) __noreturn
0802f5f4  {
0802f5f4      *(uint32_t*)((char*)arg5 + 0x40) = arg2;
0802f5f4      
0802f606      if (arg3 > 0xad)
0802f606      {
0802f60a          *(uint16_t*)arg1 = (int16_t)arg1;
0802f60c          *(uint32_t*)((char*)arg6 + arg4);
0802f606      }
0802f606      
0802f60e      breakpoint();
0802f5f4  }
0802f614    void sub_802f614(int32_t arg1 @ r4, int16_t* arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6) __noreturn
0802f614  {
0802f622      *(uint16_t*)arg2 = (int16_t)arg2;
0802f626      bool v;
0802f626      
0802f626      if (arg4 >> 0xc < 0 != v)
0802f62a          *(uint32_t*)(arg2 * 2) = arg2;
0802f62a      
0802f62e      breakpoint();
0802f614  }
0802f6e0    void sub_802f6e0() __noreturn
0802f6e0  {
0802f6e0      __dsb_SY();
0802f6f8      *(uint32_t*)0xe000ed0c = (*(uint32_t*)0xe000ed0c & 0x700) | 0x5fa0004;
0802f6fa      __dsb_SY();
0802f6fa      
0802f6fe      while (true)
0802f6fe          /* nop */
0802f6e0  }
0802f700    int32_t sub_802f700(int32_t arg1 @ r7)
0802f700  {
0802f70a      logging_wrapper("\r\n %s ", "##### USB Host library started #####");
0802f70e      return arg1;
0802f700  }
0802f710    int32_t sub_802f710(int32_t arg1 @ r7)
0802f710  {
0802f71a      logging_wrapper("\r\n %s ", "> Device Attached.");
0802f71e      return arg1;
0802f710  }
0802f720    int32_t sub_802f720(int32_t arg1 @ r7)
0802f720  {
0802f72a      logging_wrapper("\r\n %s ", "> UNRECOVERED ERROR STATE.");
0802f72e      return arg1;
0802f720  }
0802f730    int32_t sub_802f730(int32_t arg1 @ r7)
0802f730  {
0802f73a      logging_wrapper("\r\n %s ", "> Device Disconnected.");
0802f73e      return arg1;
0802f730  }
0802f740    int32_t sub_802f740(int32_t arg1 @ r7)
0802f740  {
0802f74a      logging_wrapper("\r\n %s ", "> Reset the USB device.");
0802f74e      return arg1;
0802f740  }
0802f750    int32_t log_status_msg(uint8_t sel)
0802f750  {
0802f752      uint32_t sel_1 = (uint32_t)sel;
0802f752      
0802f756      if (sel_1)
0802f756      {
0802f766          uint32_t r0 = (uint32_t)(uint8_t)sel_1;
0802f766          
0802f76a          if (r0 == 1)
0802f774              logging_wrapper("\r\n %s ", "> Full speed device detected.");
0802f76a          else if ((uint32_t)(uint8_t)r0 != 2)
0802f796              logging_wrapper("\r\n %s ", "> Device fault.");
0802f77e          else
0802f788              logging_wrapper("\r\n %s ", "> Low speed device detected.");
0802f756      }
0802f756      else
0802f760          logging_wrapper("\r\n %s ", "> High speed device detected.");
0802f760      
0802f79a      int32_t entry_result;
0802f79a      return entry_result;
0802f750  }
0802f79c    int32_t usb_log_vid_pid(USB_DeviceDescriptor* dev)
0802f79c  {
0802f7a6      logging_wrapper("\r\n > VID: %04Xh ", (uint32_t)dev->idVendor);
0802f7b4      return logging_wrapper("\r\n > PID: %04Xh ", (uint32_t)dev->idProduct);
0802f79c  }
0802f7b6    int32_t sub_802f7b6() __pure
0802f7b6  {
0802f7b6      return;
0802f7b6  }
0802f7b8    int32_t sub_802f7b8(int32_t arg1, void* arg2, int32_t arg3 @ r7)
0802f7b8  {
0802f7be      if ((uint32_t)*(uint8_t*)((char*)arg2 + 5) == 8)
0802f7c8          logging_wrapper("\r\n %s ", &data_803b188);
0802f7be      else if ((uint32_t)*(uint8_t*)((char*)arg2 + 5) == 3)
0802f7dc          logging_wrapper("\r\n %s ", "> HID device connected.");
0802f7dc      
0802f7e0      return arg3;
0802f7b8  }
0802f7e2    int32_t sub_802f7e2() __pure
0802f7e2  {
0802f7e2      return;
0802f7e2  }
0802f7e4    int32_t sub_802f7e4() __pure
0802f7e4  {
0802f7e4      return;
0802f7e4  }
0802f7e6    int32_t sub_802f7e6() __pure
0802f7e6  {
0802f7e6      return;
0802f7e6  }
0802f7e8    int32_t sub_802f7e8() __pure
0802f7e8  {
0802f7e8      return;
0802f7e8  }
0802f7ea    int32_t sub_802f7ea() __pure
0802f7ea  {
0802f7ea      return;
0802f7ea  }
0802f7ec    int32_t sub_802f7ec() __pure
0802f7ec  {
0802f7f2      return 1;
0802f7ec  }
0802f7f4    int32_t sub_802f7f4() __pure
0802f7f4  {
0802f7f4      return;
0802f7f4  }
0802f7f6    int32_t sub_802f7f6()
0802f7f6  {
0802f7f6      int32_t r7;
0802f7f6      int32_t var_8 = r7;
0802f7fc      uint32_t r0 = (uint32_t)data_2000e467;
0802f7fc      
0802f800      if (!r0)
0802f800      {
0802f81a          if (fs_set_working_drive(0, 0x2000cdf0))
0802f81c              return 0xffffffff;
0802f81c          
0802f828          data_2000e467 = 1;
0802f800      }
0802f800      else if (r0 == 2)
0802f804      {
0802f842          if (fs_set_working_drive(0, nullptr))
0802f844              return 0xffffffff;
0802f844          
0802f850          data_2000e467 = 3;
0802f804      }
0802f804      else if (r0 < 2)
0802f834          data_2000e467 = sub_802fb84();
0802f834      
0802f856      return 0;
0802f7f6  }
0802f85a    int32_t sub_802f85a()
0802f85a  {
0802f860      data_2000e467 = 0;
0802f862      return 0;
0802f85a  }
0802f864    int32_t sub_802f864(int32_t arg1 @ r7)
0802f864  {
0802f868      sub_8030104(0);
0802f86e      sub_80300f0(0);
0802f876      rcc_enable_by_code(0xd07);
0802f87a      return arg1;
0802f864  }
0802f87c    int32_t sub_802f87c(int32_t arg1 @ r7)
0802f87c  {
0802f882      rcc_enable_by_code(0xc00);
0802f88a      rcc_enable_by_code(0x110e);
0802f892      rcc_enable_by_code(0x101c);
0802f8a2      gpio_config_mode_pull(&GPIOA, 2, 0, 0x1800);
0802f8b2      gpio_config_otype_speed(&GPIOA, 0, 3, 0x1800);
0802f8c0      sub_80304da(&GPIOA, 0xa, 0x1800);
0802f8c4      return arg1;
0802f87c  }
0802f8c6    int32_t sub_802f8c6(int32_t arg1 @ r7)
0802f8c6  {
0802f8cc      nvic_set_priority_grouping(0x300);
0802f8d6      nvic_enable_irq_with_priority(0x43, 2, 0);
0802f8da      return arg1;
0802f8c6  }
0802f8dc    int32_t sub_802f8dc() __pure
0802f8dc  {
0802f8dc      return;
0802f8dc  }
0802f8de    int32_t sub_802f8de() __pure
0802f8de  {
0802f8de      return;
0802f8de  }
0802f8e0    uint32_t sub_802f8e0()
0802f8e0  {
0802f8e6      return (uint32_t)data_2000e46a;
0802f8e0  }
0802f8e8    int32_t createUsbTask()
0802f8e8  {
0802f8ec      int32_t r7;
0802f8ec      sub_802f87c(r7);
0802f8f0      sub_802f864(r7);
0802f8f4      sub_80363c0(r7);
0802f90c      sub_802267e(0x20000740, 0x20000b78, 0x2000dd28);
0802f916      sub_8022614(0x20000740, 1);
0802f922      (**(uint32_t**)&data_20000be0)();
0802f922      
0802f92a      if (sub_8025c04() != 1)
0802f92a      {
0802f93a          data_2000e3e4 = sub_80308ae(1, 0, 3);
0802f93e          int32_t var_c = 0;
0802f942          int32_t var_10 = 8;
0802f952          rtos_xTaskCreate(sub_802f994, "UsbTask", 0x164, nullptr, 8, nullptr);
0802f92a      }
0802f92a      
0802f95a      sub_802f8c6(r7);
0802f960      return 1;
0802f8e8  }
0802f962    int32_t sub_802f962()
0802f962  {
0802f962      int32_t result_1;
0802f962      int32_t result = result_1;
0802f962      
0802f96a      if (sub_8025c04() != 1)
0802f96a      {
0802f974          sub_8030aea(data_2000e3e4, &result);
0802f974          
0802f97c          if (result)
0802f97c          {
0802f986              *(uint32_t*)0xe000ed04 = 0x10000000;
0802f988              __dsb_SY();
0802f98c              __isb();
0802f97c          }
0802f96a      }
0802f96a      
0802f990      return result;
0802f962  }
0802f992                                                        00 00                                                        ..
0802f994    void sub_802f994() __noreturn
0802f994  {
0802f9a2      rtos_dma_rx_wait_and_service(data_2000e3e4, 0xffffffff);
0802f9ac      data_2000e468 = 1;
0802f9b4      sub_8035c04(0xfff, 6);
0802f9b8      sub_8035bfa();
0802f9bc      motorBrake();
0802f9c0      motorStop();
0802f9c8      safetyEventSet(5, 1);
0802f9cc      sub_80271d8();
0802f9fe      uint32_t i;
0802f9fe      
0802f9fe      do
0802f9fe      {
0802f9d0          watchdog_kick();
0802f9e0          sub_80223ac(0x20000740, 0x20000b78, 0x2000dd28);
0802f9e0          
0802f9ec          if ((uint32_t)data_2000e467 == 3)
0802f9f0              rtos_delay_ticks(0x64);
0802f9f0          
0802f9f8          i = sub_802265c(0x20000740);
0802f9fe      } while (i);
0802fa02      sub_802a0cc(0);
0802fa06      sub_802f6e0();
0802fa06      /* no return */
0802f994  }
0802fa0a                                c5 e7                                                                        ..
0802fa0c    int32_t sub_802fa0c(int32_t arg1 @ r7)
0802fa0c  {
0802fa1a      sub_80223ac(0x20000740, 0x20000b78, 0x2000dd28);
0802fa1e      return arg1;
0802fa0c  }
0802fa20    uint32_t sub_802fa20(char* arg1, char* arg2, void* arg3)
0802fa20  {
0802fa2a      char r6 = 0;
0802fa2a      
0802fa2e      if (arg3)
0802fa36          memset16x2(arg3, 0x1e, 0);
0802fa36      
0802fa3e      FILINFO_Compat var_58;
0802fa3e      var_58.lfsize = 0x1ff;
0802fa46      var_58.lfname = sub_8032108(0x1ff);
0802fa54      void var_38;
0802fa54      
0802fa54      if (!(uint32_t)sub_8021daa(&var_38, arg1))
0802fa54      {
0802fa5c          while (sub_802265c(0x20000740))
0802fa5c          {
0802fa70              if ((uint32_t)sub_8021e24(&var_38, &var_58))
0802fa70                  break;
0802fa70              
0802fa78              if (!(uint32_t)var_58.fname[0])
0802fa78                  break;
0802fa78              
0802fa82              if ((uint32_t)var_58.fname[0] != 0x2e)
0802fa82              {
0802fa8a                  char* lfname;
0802fa8a                  var_4f;
0802fa8a                  
0802fa8a                  if (!(uint32_t)*(uint8_t*)var_58.lfname)
0802fa90                      lfname = &var_4f;
0802fa8a                  else
0802fa8c                      lfname = var_58.lfname;
0802fa8c                  
0802fa9e                  if (((uint32_t)var_58.fattrib & 0x3f) != 0x10
0802fa9e                      && sub_8036478(lfname, arg2))
0802fa9e                  {
0802faae                      if (arg3)
0802fabc                          sub_8036480(arg3, lfname, sub_8035580(lfname));
0802fabc                      
0802fac0                      r6 = 1;
0802fac0                      break;
0802fa9e                  }
0802fa82              }
0802fa5c          }
0802fa54      }
0802fa54      
0802fac4      sub_8032214(var_58.lfname);
0802face      return (uint32_t)r6;
0802fa20  }
0802fad0    int32_t board_storage_smoke_test()
0802fad0  {
0802fadc      void buf;
0802fadc      memcpy_(&buf, "board test  ", 0xd);
0802fae6      fs_set_working_drive(0, 0x2000cdf0);
0802faee      logging_wrapper(&data_803b164);
0802faee      
0802fb02      if (f_open(0x2000d020, "0:boadTest.TXT", 0xa))
0802fb02      {
0802fb30          logging_wrapper("No\r\n");
0802fb3a          board_test_result = 2;
0802fb02      }
0802fb02      else
0802fb02      {
0802fb0e          uint32_t bw;
0802fb0e          f_write(0x2000d020, &buf, 0xd, &bw);
0802fb16          f_close(0x2000d020);
0802fb1e          logging_wrapper("Yes\r\n");
0802fb28          board_test_result = 1;
0802fb02      }
0802fb02      
0802fb46      return fs_set_working_drive(0, nullptr);
0802fad0  }
0802fb48    uint32_t sub_802fb48()
0802fb48  {
0802fb4e      return (uint32_t)board_test_result;
0802fb48  }
0802fb50    int32_t sub_802fb50(int32_t arg1 @ r7)
0802fb50  {
0802fb5a      if ((uint32_t)data_2000e46a)
0802fb5a      {
0802fb68          data_2000e3e8 += 1;
0802fb68          
0802fb74          if (data_2000e3e8 > 0x3e8)
0802fb74          {
0802fb7c              data_2000e3e8 = 0;
0802fb7e              watchdog_kick();
0802fb74          }
0802fb5a      }
0802fb5a      
0802fb82      return arg1;
0802fb50  }
0802fb84    int32_t sub_802fb84()
0802fb84  {
0802fb8e      if (sub_8025c04() != 1)
0802fb8e      {
0802fb9a          char buf = 0;
0802fba2          fs_set_working_drive(0, 0x2000cdf0);
0802fba2          
0802fbb6          if (sub_802fa20(sub_802fcb0, "Cam_WDR0", 0x2000e0c8) != 1)
0802fbb6          {
0802fbce              if (sub_802fa20(sub_802fcb0, "rm12vs", 0x2000e0c8) != 1)
0802fbce              {
0802fbe4                  if (sub_802fa20(sub_802fcb0, "Model_L", 0x2000e0c8) == 1)
0802fbe8                      buf = 4;
0802fbce              }
0802fbce              else
0802fbd2                  buf = 1;
0802fbb6          }
0802fbb6          else
0802fbba              buf = 2;
0802fbba          
0802fbf2          if ((uint32_t)buf == 1)
0802fbf2          {
0802fbfe              camera_link_send(0, 0x5000, 1, &buf);
0802fc02              sub_802f6e0();
0802fc02              /* no return */
0802fbf2          }
0802fbf2          
0802fc16          if ((uint32_t)buf == 2 || (uint32_t)buf == 4)
0802fc16          {
0802fc1e              data_2000e46a = 1;
0802fc22              sub_8025bfa(1);
0802fc2c              uint32_t r4_1;
0802fc2c              
0802fc2c              if ((uint32_t)buf != 2)
0802fc40                  r4_1 = upload_camera_model_L(0x2000e0c8, 8);
0802fc2c              else
0802fc34                  r4_1 = upload_camera_firmware_cam_wdr(0x2000e0c8);
0802fc34              
0802fc58              uint32_t i;
0802fc58              
0802fc58              do
0802fc58              {
0802fc5e                  r4_1 = (uint32_t)(uint8_t)r4_1;
0802fc5e                  
0802fc62                  if (!r4_1)
0802fc4c                      sub_802728a(2, 0, 1, 1);
0802fc62                  else
0802fc62                  {
0802fc64                      sub_802c036();
0802fc70                      sub_8027224(2, 1, 2, 0);
0802fc62                  }
0802fc62                  
0802fc52                  i = sub_802265c(0x20000740);
0802fc58              } while (i);
0802fc5a              sub_802f6e0();
0802fc5a              /* no return */
0802fc16          }
0802fc16          
0802fc7c          if (!(uint32_t)buf)
0802fc7c          {
0802fc7e              sub_802fe02();
0802fc82              sub_802fcb4();
0802fc86              sub_802fda4();
0802fc8c              sub_802ce3e(6);
0802fc92              sub_802ce1a(6);
0802fc98              doBeep(0x40);
0802fc7c          }
0802fc7c          
0802fca0          fs_set_working_drive(0, nullptr);
0802fb8e      }
0802fb8e      else
0802fb90          board_storage_smoke_test();
0802fb90      
0802fca6      return 3;
0802fb84  }
0802fc06                    49 e0                                                                                I.
0802fca8    uint32_t sub_802fca8()
0802fca8  {
0802fcac      return (uint32_t)data_2000e468;
0802fca8  }
0802fcae                                            00 00                                                                ..
0802fcb0    int32_t sub_802fcb0(int32_t arg1, int32_t arg2, int32_t arg3)
0802fcb0  {
0802fcb2      /* tailcall */
0802fcb2      return sub_802fcb4();
0802fcb0  }
0802fcb4    int32_t sub_802fcb4()
0802fcb4  {
0802fcc2      int32_t var_264 = 0;
0802fcc2      int32_t var_260 = 0;
0802fcc2      int32_t var_25c = 0;
0802fcce      void var_244;
0802fcce      j_sub_80168a8(&var_244, 0x14);
0802fcd6      void var_258;
0802fcd6      j_sub_80168a8(&var_258, 0x14);
0802fcde      fs_set_working_drive(0, 0x2000cdf0);
0802fcee      void fil;
0802fcee      
0802fcee      if (f_open(&fil, "0:ERR_LOG", 0xa))
0802fd90          console_printf("ErrorLog No\r\n");
0802fcee      else
0802fcee      {
0802fcf4          sub_8021bf8(&fil, 0);
0802fcfc          void* r0_5 = sub_80282c2(0, 1);
0802fd02          char r4_1 = 0;
0802fd02          
0802fd4a          while (true)
0802fd4a          {
0802fd4a              uint32_t r4_3 = (uint32_t)r4_1;
0802fd4a              
0802fd4e              if (r4_3 >= 0x14)
0802fd4e                  break;
0802fd4e              
0802fd08              uint32_t r4_2 = (uint32_t)(uint8_t)r4_3;
0802fd0e              sub_8031d88(r0_5, r4_2, &var_264);
0802fd14              char* r0_8;
0802fd14              int32_t* r1_2;
0802fd14              r0_8 = float32_process(var_260);
0802fd20              sub_80364ec(&var_244, "%.6f", r0_8, r1_2);
0802fd26              char* r0_11;
0802fd26              int32_t* r1_3;
0802fd26              r0_11 = float32_process(var_25c);
0802fd32              sub_80364ec(&var_258, "%.2f", r0_11, r1_3);
0802fd38              void* var_268_1 = &var_258;
0802fd44              sub_8021fdc(&fil, "[%d] %s %s\n", (uint32_t)(uint8_t)var_264);
0802fd48              r4_1 = (uint8_t)r4_2 + 1;
0802fd4a          }
0802fd4a          
0802fd5a          sub_8021fdc(&fil, "Working Time : %d(sec)\r\n", sub_8035984());
0802fd68          sub_8021fdc(&fil, "Running Time : %d(sec)\r\n", sub_803598a());
0802fd76          sub_8021fdc(&fil, "Blade   Time : %d(sec)\r\n", sub_8035990());
0802fd7c          sub_8021b28(&fil);
0802fd82          f_close(&fil);
0802fd88          console_printf("ErrorLog Yes\r\n");
0802fcee      }
0802fcee      
0802fd98      fs_set_working_drive(0, nullptr);
0802fda2      return 1;
0802fcb4  }
0802fda4    int32_t sub_802fda4()
0802fda4  {
0802fdae      fs_set_working_drive(0, 0x2000cdf0);
0802fdbe      void fil;
0802fdbe      
0802fdbe      if (f_open(&fil, "0:TEST", 0xa))
0802fde8          console_printf("TEST No\r\n");
0802fdbe      else
0802fdbe      {
0802fdc4          sub_8021bf8(&fil, 0);
0802fdce          sub_8021fdc(&fil, "%s\r\n", "test");
0802fdd4          sub_8021b28(&fil);
0802fdda          f_close(&fil);
0802fde0          console_printf("TEST Yes\r\n");
0802fdbe      }
0802fdbe      
0802fdee      sub_8021e94("0:TEST");
0802fdf6      fs_set_working_drive(0, nullptr);
0802fe00      return 1;
0802fda4  }
0802fe02    int32_t sub_802fe02()
0802fe02  {
0802fe0c      int32_t var_230 = 0;
0802fe10      sub_802b16c(&var_230);
0802fe18      fs_set_working_drive(0, 0x2000cdf0);
0802fe28      void fil;
0802fe28      
0802fe28      if (f_open(&fil, "0:PUK", 0xa))
0802fe78          console_printf("PUK No\r\n");
0802fe28      else
0802fe28      {
0802fe2e          sub_8021bf8(&fil, 0);
0802fe34          int32_t var_234_1 = 0;
0802fe38          int32_t var_238_1 = 1;
0802fe42          sub_8021fdc(&fil, "rm12vs_%d.%d.%d.%d\r\n", 1);
0802fe4a          uint32_t var_234_2 = (uint32_t)*(uint8_t*)((char*)var_230)[3];
0802fe50          uint32_t var_238_2 = (uint32_t)*(uint8_t*)((char*)var_230)[2];
0802fe5e          sub_8021fdc(&fil, "Cam_%d.%d.%d.%d\r\n\r\n", (uint32_t)(uint8_t)var_230);
0802fe64          sub_8021b28(&fil);
0802fe6a          f_close(&fil);
0802fe70          console_printf("PUK Yes\r\n");
0802fe28      }
0802fe28      
0802fe80      fs_set_working_drive(0, nullptr);
0802fe8a      return 1;
0802fe02  }
0802fe8c  int32_t data_802fe8c = -0x1fff12f4
0802fe90  int32_t data_802fe90 = 0x5fa0004
0802fe94  int32_t data_802fe94 = 0x803aef0
0802fe98  int32_t data_802fe98 = 0x803c0c0
0802fe9c  int32_t data_802fe9c = 0x803bd10
0802fea0  int32_t data_802fea0 = 0x803b758
0802fea4  int32_t data_802fea4 = 0x803ba34
0802fea8  int32_t data_802fea8 = 0x803ba4c
0802feac  int32_t data_802feac = 0x803b3b0
0802feb0  int32_t data_802feb0 = 0x803b3d0
0802feb4  int32_t data_802feb4 = 0x803b3f0
0802feb8  int32_t data_802feb8 = 0x803bf10
0802febc  int32_t data_802febc = 0x803bcd4
0802fec0  int32_t data_802fec0 = 0x803bce8
0802fec4  int32_t data_802fec4 = 0x803b188
0802fec8  int32_t data_802fec8 = 0x803ba64
0802fecc  int32_t data_802fecc = 0x2000e467
0802fed0  int32_t data_802fed0 = 0x2000cdf0
0802fed4  int32_t data_802fed4 = 0x20000740
0802fed8  int32_t data_802fed8 = 0x40020000
0802fedc  int32_t data_802fedc = 0x2000e46a
0802fee0  int32_t data_802fee0 = 0x2000dd28
0802fee4  int32_t data_802fee4 = 0x20000b78
0802fee8  int32_t data_802fee8 = 0x2000e3e4
0802feec  int32_t data_802feec = 0x803c0c8
0802fef0  int32_t data_802fef0 = -0x1fff12fc
0802fef4  int32_t data_802fef4 = 0x2000e468
0802fef8  int32_t data_802fef8 = 0x2000d020
0802fefc  int32_t data_802fefc = 0x803c0d0
0802ff00  int32_t data_802ff00 = 0x803c0d8
0802ff04  int32_t data_802ff04 = 0x2000e0c8
0802ff08  int32_t data_802ff08 = 0x803bfcc
0802ff0c  int32_t data_802ff0c = 0x803bed0
0802ff10  int32_t data_802ff10 = 0x803b164
0802ff14  int32_t data_802ff14 = 0x803bee0
0802ff18  int32_t data_802ff18 = 0x2000e469
0802ff1c  int32_t data_802ff1c = 0x2000e3e8
0802ff20  int32_t data_802ff20 = 0x803c0e0
0802ff24  int32_t data_802ff24 = 0x803c0e8
0802ff28  int32_t data_802ff28 = 0x803bfd8
0802ff2c  int32_t data_802ff2c = 0x803c0f0
0802ff30  int32_t data_802ff30 = 0x803c0f8
0802ff34  int32_t data_802ff34 = 0x803bfe4
0802ff38  int32_t data_802ff38 = 0x803b704
0802ff3c  int32_t data_802ff3c = 0x803b720
0802ff40  int32_t data_802ff40 = 0x803b73c
0802ff44  int32_t data_802ff44 = 0x803bef0
0802ff48  int32_t data_802ff48 = 0x803bf00
0802ff4c  int32_t data_802ff4c = 0x803c100
0802ff50  int32_t data_802ff50 = 0x803c110
0802ff54  int32_t data_802ff54 = 0x803c108
0802ff58  int32_t data_802ff58 = 0x803bff0
0802ff5c  int32_t data_802ff5c = 0x803bffc
0802ff60  int32_t data_802ff60 = 0x803c118
0802ff64  int32_t data_802ff64 = 0x803ba1c
0802ff68  int32_t data_802ff68 = 0x803bcfc
0802ff6c  int32_t data_802ff6c = 0x803c008
0802ff70  int32_t data_802ff70 = 0x803c014
0802ff74    int32_t sub_802ff74(int32_t arg1, int32_t arg2)
0802ff74  {
0802ff78      int32_t r0_1 = arg1 >> 0x15 | arg2 << 0xb;
0802ff7c      int32_t r1 = arg2 << 1;
0802ff7c      
0802ff7e      if (TEST_BIT(arg2, 0x1f))
0802ff7e      {
0802ff8e          int32_t r0_2 = sub_802ffac(r0_1, r1);
0802ff8e          
0802ff98          if (r0_2 > 0x80000000)
0802ff9a              return 0x80000000;
0802ff9a          
0802ff9c          return 0 - r0_2;
0802ff7e      }
0802ff7e      
0802ff80      int32_t result = sub_802ffac(r0_1, r1);
0802ff80      
0802ff86      if (result < 0)
0802ff88          return 0x7fffffff;
0802ff88      
0802ff8c      return result;
0802ff74  }
0802ffa0    int32_t sub_802ffa0(int32_t arg1, int32_t arg2)
0802ffa0  {
0802ffa8      if (TEST_BIT(arg2, 0x1f))
0802ffca          return 0;
0802ffca      
0802ffa8      /* tailcall */
0802ffa8      return sub_802ffac(arg1 >> 0x15 | arg2 << 0xb, arg2 << 1);
0802ffa0  }
0802ffac    int32_t sub_802ffac(int32_t arg1, int32_t arg2) __pure
0802ffac  {
0802ffac      int32_t r0_2 = arg1 | 0x80000000;
0802ffac      
0802ffb8      if ((arg2 >> 0x15) - 0x3ff < 0)
0802ffca          return 0;
0802ffca      
0802ffbe      if (0x1f - ((arg2 >> 0x15) - 0x3ff) >= 0)
0802ffc0          return r0_2 >> (0x1f - ((arg2 >> 0x15) - 0x3ff));
0802ffc0      
0802ffc2      return r0_2 >> 0x1f;
0802ffac  }
0802ffcc    void* gpio_config_af(GPIO_TypeDef* base, uint16_t pinMask, uint32_t cfg, uint8_t af)
0802ffcc  {
0802ffd0      uint32_t pinMask_1 = pinMask;
0802ffd4      uint32_t pull = af;
0802ffd8      rcc_enable_by_code((uint16_t)cfg);
0802ffe4      gpio_config_mode_pull(base, 1, pull, (uint16_t)pinMask_1);
0802fff0      int32_t* result = gpio_config_otype_speed(base, 0, 2, (uint16_t)pinMask_1);
0802fff0      
0802fff6      if (pull == 1)
0802fffe          return gpio_write_mask_set_reset(base, pinMask_1, true);
0802fffe      
08030006      if (pull != 2)
08030012          return result;
08030012      
0803000e      return gpio_write_mask_set_reset(base, pinMask_1, false);
0802ffcc  }
08030014    int32_t gpio_write(GPIO_TypeDef* port, uint16_t pin_mask, bool level)
08030014  {
08030018      gpio_write_mask_set_reset(port, pin_mask, level);
0803001c      int32_t entry_result;
0803001c      return entry_result;
08030014  }
0803001e    int32_t sub_803001e(void* arg1, int32_t arg2, int32_t arg3 @ r7)
0803001e  {
08030020      sub_8030552(arg1, arg2);
08030024      return arg3;
0803001e  }
08030026    void* sub_8030026(GPIO_TypeDef* arg1, uint16_t arg2, int16_t arg3, uint32_t arg4)
08030026  {
08030032      rcc_enable_by_code(arg3);
0803003a      rcc_enable_by_code(0x110e);
0803004a      return gpio_config_mode_pull(arg1, 0, arg4, arg2);
08030026  }
0803004c    int32_t sub_803004c(void* arg1, int32_t arg2)
0803004c  {
0803004c      int32_t r7;
0803004c      int32_t var_8 = r7;
08030052      return sub_80304ca(arg1, arg2);
0803004c  }
08030054    int32_t sub_8030054(int32_t arg1 @ r7)
08030054  {
0803005e      if (sub_80365c4(4))
08030066          data_2000dff8(0);
08030066      
0803006a      sub_80365e0(4);
0803006e      return arg1;
08030054  }
08030070                                                  00 00 00 00                                                      ....
08030074  int32_t data_8030074 = 0x2000dff0
08030078    int32_t* rcc_enable_by_code(int16_t code)
08030078  {
08030078      int32_t code_1 = (int32_t)code;
0803009c      *(uint32_t*)(((int32_t)(int16_t)code_1 >> 6) + 0x40023800) =
0803009c          *(uint32_t*)((code_1 >> 6) + 0x40023800) | 1 << (code_1 & 0x1f);
0803009e      return ((int32_t)(int16_t)code_1 >> 6) + 0x40023800;
08030078  }
080300a0    int32_t* BN_CODE_start_0x80300a0_size_0x2(int16_t arg1)
080300a0  {
080300a0      int32_t r0_4 = (int32_t)arg1;
080300c4      *(uint32_t*)(((int32_t)(int16_t)r0_4 >> 6) + 0x40023800) =
080300c4          *(uint32_t*)((r0_4 >> 6) + 0x40023800) | 1 << (r0_4 & 0x1f);
080300c6      return ((int32_t)(int16_t)r0_4 >> 6) + 0x40023800;
080300a0  }
080300c8    int32_t* sub_80300c8(int16_t arg1)
080300c8  {
080300c8      int32_t r0_4 = (int32_t)arg1;
080300ec      *(uint32_t*)(((int32_t)(int16_t)r0_4 >> 6) + 0x40023800) =
080300ec          *(uint32_t*)((r0_4 >> 6) + 0x40023800) & ~(1 << (r0_4 & 0x1f));
080300ee      return ((int32_t)(int16_t)r0_4 >> 6) + 0x40023800;
080300c8  }
080300f0    int32_t sub_80300f0(int32_t arg1)
080300f0  {
080300fa      int32_t result = arg1 | data_400238c0 >> 1 << 1;
08030100      data_400238c0 = result;
08030102      return result;
080300f0  }
08030104    int32_t sub_8030104(int32_t arg1)
08030104  {
0803010e      int32_t result = arg1 | (data_400238c0 & 0xfffffffd);
08030114      data_400238c0 = result;
08030116      return result;
08030104  }
08030118    int32_t sub_8030118(int32_t arg1)
08030118  {
0803011e      int32_t result;
0803011e      
0803011e      if (arg1 != 0xfeffffff)
0803011e      {
08030136          result = arg1 | data_4002388c;
0803013c          data_4002388c = result;
0803011e      }
0803011e      else
0803011e      {
08030126          result = arg1 & data_4002388c;
0803012c          data_4002388c = result;
0803011e      }
0803011e      
0803013e      return result;
08030118  }
08030140    int32_t sub_8030140(int16_t arg1)
08030140  {
08030140      int32_t r0_3 = (int32_t)arg1;
08030140      
08030156      if (*(uint32_t*)((r0_3 >> 6) + 0x40023800) >> (r0_3 & 0x1f) << 0x1f >= 0)
0803015c          return 0;
0803015c      
08030158      return 1;
08030140  }
08030160    uint32_t sub_8030160(int16_t arg1)
08030160  {
08030160      int32_t r3;
08030160      int32_t var_10 = r3;
08030164      int32_t r5 = 0;
08030166      char r4 = 0;
08030168      char r0 = 0;
08030168      
0803016e      switch ((int32_t)arg1)
0803016e      {
0803016c          case 0:
0803016c          {
080301f4              while (!(uint32_t)r0)
080301f4              {
080301fa                  if (r5 == 0x500)
080301fa                      break;
080301fa                  
080301ea                  r0 = sub_8030140(1);
080301ee                  r5 += 1;
080301f4              }
080301f4              
08030204              if (sub_8030140(1))
08030206                  r4 = 1;
0803016c              break;
0803016c          }
08030170          case 0x10:
08030170          {
080301aa              while (!(uint32_t)r0)
080301aa              {
080301b0                  if (r5 == 0x800)
080301b0                      break;
080301b0                  
080301a0                  r0 = sub_8030140(0x11);
080301a4                  r5 += 1;
080301aa              }
080301aa              
080301ba              if (sub_8030140(0x11))
080301bc                  r4 = 1;
08030170              break;
08030170          }
08030174          case 0x18:
08030174          {
08030266              while (!(uint32_t)r0)
08030266              {
0803026e                  if (r5 == 0xffff)
0803026e                      break;
0803026e                  
0803025c                  r0 = sub_8030140(0x19);
08030260                  r5 += 1;
08030266              }
08030266              
08030278              if (sub_8030140(0x19))
0803027a                  r4 = 1;
08030174              break;
08030174          }
08030178          case 0x1a:
08030178          {
0803028a              while (!(uint32_t)r0)
0803028a              {
08030292                  if (r5 == 0xffff)
08030292                      break;
08030292                  
08030280                  r0 = sub_8030140(0x1b);
08030284                  r5 += 1;
0803028a              }
0803028a              
0803029c              if (sub_8030140(0x1b))
0803029e                  r4 = 1;
08030178              break;
08030178          }
0803017e          case 0x1c:
0803017e          {
080302ae              while (!(uint32_t)r0)
080302ae              {
080302b6                  if (r5 == 0xffff)
080302b6                      break;
080302b6                  
080302a4                  r0 = sub_8030140(0x1d);
080302a8                  r5 += 1;
080302ae              }
080302ae              
080302c0              if (sub_8030140(0x1d))
080302c2                  r4 = 1;
0803017e              break;
0803017e          }
08030184          case 0x1c00:
08030184          {
080301ce              while (!(uint32_t)r0)
080301ce              {
080301d6                  if (r5 == 0xffff)
080301d6                      break;
080301d6                  
080301c4                  r0 = sub_8030140(0x1c01);
080301c8                  r5 += 1;
080301ce              }
080301ce              
080301e2              if (sub_8030140(0x1c01))
080301e4                  r4 = 1;
08030184              break;
08030184          }
0803018a          case 0x1d00:
0803018a          {
08030240              while (!(uint32_t)r0)
08030240              {
08030248                  if (r5 == 0xffff)
08030248                      break;
08030248                  
08030236                  r0 = sub_8030140(0x1d01);
0803023a                  r5 += 1;
08030240              }
08030240              
08030254              if (sub_8030140(0x1d01))
08030256                  r4 = 1;
0803018a              break;
0803018a          }
08030194          case 0x3010:
08030194          {
08030218              while (!(uint32_t)r0)
08030218              {
08030220                  if (r5 == 0xffff)
08030220                      break;
08030220                  
0803020e                  r0 = sub_8030140(0x3011);
08030212                  r5 += 1;
08030218              }
08030218              
0803022c              if (sub_8030140(0x3011))
0803022e                  r4 = 1;
08030194              break;
08030194          }
0803016e      }
0803016e      
0803019c      return (uint32_t)r4;
08030160  }
080302c6    int32_t* sub_80302c6(int16_t arg1)
080302c6  {
080302c6      int32_t r0_4 = (int32_t)arg1;
080302ea      *(uint32_t*)(((int32_t)(int16_t)r0_4 >> 6) + 0x40023800) =
080302ea          *(uint32_t*)((r0_4 >> 6) + 0x40023800) | 1 << (r0_4 & 0x1f);
080302ec      return ((int32_t)(int16_t)r0_4 >> 6) + 0x40023800;
080302c6  }
080302ee    uint32_t sub_80302ee(char arg1)
080302ee  {
080302fc      char var_20[0x10];
080302fc      memcpy(&var_20, 0x803bdc0, 0x10);
08030308      int32_t var_28 = 0;
08030308      int32_t var_24 = 0x4030201;
08030314      int32_t var_30 = 0;
08030314      int32_t var_2c = 0x4030201;
0803031c      int32_t r0_2 = RCC.CFGR >> 2 & 3;
08030322      uint32_t r0_3;
08030322      
08030322      if (!r0_2)
0803032c          r0_3 = 0xf42400;
08030322      else if (r0_2 == 2)
08030326      {
0803035c          int32_t r2_6;
0803035c          
0803035c          if ((RCC.PLLCFGR & 0x400000) != 0x400000)
08030362              r2_6 = 0xf42400;
0803035c          else
0803035e              r2_6 = 0xb71b00;
0803035e          
0803036a          r0_3 = (RCC.PLLCFGR >> 6 & 0x1ff) * r2_6 / (RCC.PLLCFGR & 0x3f)
0803036a              / (((RCC.PLLCFGR >> 0x10 & 3) + 1) << 1);
08030326      }
08030326      else if (r0_2 < 2)
08030330          r0_3 = 0xb71b00;
08030328      else
08030370          r0_3 = 0xf42400;
08030370      
08030380      uint32_t r1_5 = r0_3 >> (uint32_t)var_20[RCC.CFGR >> 4 & 0xf];
080303a2      uint32_t r4_1 = (uint32_t)arg1;
080303a2      
080303a6      if (!r4_1)
080303b4          return r0_3;
080303b4      
080303aa      if (r4_1 == 2)
080303bc          return r1_5 >> (uint32_t)*(uint8_t*)(&var_28 + (RCC.CFGR >> 0xa & 7));
080303bc      
080303ac      if (r4_1 < 2)
080303b8          return r1_5;
080303b8      
080303b0      if (r4_1 == 3)
080303c0          return r1_5 >> (uint32_t)*(uint8_t*)(&var_30 + (RCC.CFGR >> 0xd & 7));
080303c0      
080303c8      return 0;
080302ee  }
080303ca                                00 00                                                                        ..
080303cc  int32_t data_80303cc = 0x40023808
080303d0  int32_t data_80303d0 = 0x40023804
080303d4  int32_t data_80303d4 = 0x4002388c
080303d8  int32_t data_80303d8 = 0x400238c0
080303dc  int32_t data_80303dc = 0x803bdc0
080303e0  int32_t data_80303e0 = 0x803c060
080303e4  int32_t data_80303e4 = 0x803c068
080303e8  int32_t data_80303e8 = 0xf42400
080303ec  int32_t data_80303ec = 0xb71b00
080303f0    void* gpio_config_mode_pull(GPIO_TypeDef* gpio, uint32_t mode, uint32_t pull, uint16_t pinMask)
080303f0  {
080303f2      uint32_t volatile MODER = gpio->MODER;
080303f8      uint32_t volatile PUPDR = gpio->PUPDR;
080303fa      int16_t r6 = 0;
080303fa      
08030444      while (true)
08030444      {
08030444          uint32_t r6_1 = (uint32_t)r6;
08030444          
08030448          if (r6_1 >= 0x10)
08030448              break;
08030448          
08030404          if (pinMask >> r6_1 << 0x1f < 0)
08030404          {
08030422              MODER = (MODER & ~(3 << (uint32_t)(uint8_t)r6_1 << 1))
08030422                  | mode << (uint32_t)(uint8_t)r6_1 << 1;
08030440              PUPDR = (PUPDR & ~(3 << (uint32_t)(uint8_t)r6_1 << 1))
08030440                  | pull << (uint32_t)(uint8_t)r6_1 << 1;
08030404          }
08030404          
08030442          r6 = (uint16_t)r6_1 + 1;
08030444      }
08030444      
0803044a      gpio->MODER = MODER;
0803044e      gpio->PUPDR = PUPDR;
08030452      return &gpio->PUPDR;
080303f0  }
08030454    void* gpio_config_otype_speed(void* gpio, uint8_t openDrain, uint32_t speed, uint16_t pinMask)
08030454  {
0803045a      if ((uint32_t)openDrain != 1)
08030470          *(uint32_t*)((char*)gpio + 4) &= ~pinMask;
0803045a      else
08030464          *(uint32_t*)((char*)gpio + 4) |= pinMask;
08030464      
08030476      int32_t r1_8 = *(uint32_t*)((char*)gpio + 8);
08030478      int16_t r4_2 = 0;
08030478      
0803049e      while (true)
0803049e      {
0803049e          uint32_t r4_3 = (uint32_t)r4_2;
0803049e          
080304a2          if (r4_3 >= 0x10)
080304a2              break;
080304a2          
08030482          if (pinMask >> r4_3 << 0x1f < 0)
0803049a              r1_8 = (r1_8 & ~(3 << (uint32_t)(uint8_t)r4_3 << 1))
0803049a                  | speed << (uint32_t)(uint8_t)r4_3 << 1;
0803049a          
0803049c          r4_2 = (uint16_t)r4_3 + 1;
0803049e      }
0803049e      
080304a6      *(uint32_t*)((char*)gpio + 8) = r1_8;
080304aa      return (char*)gpio + 8;
08030454  }
080304ac    int32_t* sub_80304ac(void* arg1, int32_t arg2)
080304ac  {
080304ae      *(uint32_t*)((char*)arg1 + 0x18) = arg2;
080304b0      return (char*)arg1 + 0x18;
080304ac  }
080304b2    int32_t* sub_80304b2(void* arg1, int32_t arg2)
080304b2  {
080304b4      *(uint32_t*)((char*)arg1 + 0x28) = arg2;
080304b6      return (char*)arg1 + 0x28;
080304b2  }
080304b8    int32_t* gpio_write_mask_set_reset(GPIO_TypeDef* base, uint32_t pinMask, bool setElseReset)
080304b8  {
080304bc      uint32_t volatile* result;
080304bc      
080304bc      if (!(uint32_t)setElseReset)
080304bc      {
080304c4          result = &base[1];
080304c6          ADJ(result)->BSRR = pinMask;
080304bc      }
080304bc      else
080304bc      {
080304be          result = &base->BSRR;
080304c0          ADJ(result)->BSRR = pinMask;
080304bc      }
080304bc      
080304c8      return result;
080304b8  }
080304ca    int32_t sub_80304ca(void* arg1, int32_t arg2)
080304ca  {
080304d0      if (!(*(uint32_t*)((char*)arg1 + 0x10) & arg2))
080304d6          return 0;
080304d6      
080304d2      return 1;
080304ca  }
080304da    void* sub_80304da(void* arg1, int32_t arg2, int32_t arg3)
080304da  {
080304e0      int32_t r3_1 = *(uint32_t*)((char*)arg1 + 0x20);
080304e6      int32_t r4_1 = *(uint32_t*)((char*)arg1 + 0x24);
080304e8      int16_t r5 = 0;
080304e8      
0803050e      while (true)
0803050e      {
0803050e          uint32_t r5_1 = (uint32_t)r5;
0803050e          
08030512          if (r5_1 >= 8)
08030512              break;
08030512          
080304f2          if (arg3 >> r5_1 << 0x1f < 0)
0803050a              r3_1 = (r3_1 & ~(0xf << (uint32_t)(uint8_t)r5_1 << 2))
0803050a                  | arg2 << (uint32_t)(uint8_t)r5_1 << 2;
0803050a          
0803050c          r5 = (uint16_t)r5_1 + 1;
0803050e      }
0803050e      
08030514      int16_t r5_2 = 8;
08030514      
0803053e      while (true)
0803053e      {
0803053e          uint32_t r5_3 = (uint32_t)r5_2;
0803053e          
08030542          if (r5_3 >= 0x10)
08030542              break;
08030542          
0803051e          if (arg3 >> r5_3 << 0x1f < 0)
0803053a              r4_1 = (r4_1 & ~(0xf << (uint32_t)((uint8_t)r5_3 - 8) << 2))
0803053a                  | arg2 << (uint32_t)((uint8_t)r5_3 - 8) << 2;
0803053a          
0803053c          r5_2 = (uint16_t)r5_3 + 1;
0803053e      }
0803053e      
08030548      *(uint32_t*)((char*)arg1 + 0x20) = r3_1;
0803054c      *(uint32_t*)((char*)arg1 + 0x24) = r4_1;
08030550      return (char*)arg1 + 0x24;
080304da  }
08030552    int32_t* sub_8030552(void* arg1, int32_t arg2)
08030552  {
08030554      *(uint32_t*)((char*)arg1 + 0x2c) = arg2;
08030556      return (char*)arg1 + 0x2c;
08030552  }
08030558    int32_t usart_enable_clock_from_base(USART_TypeDef* usart_base, int32_t arg2 @ r7)
08030558  {
0803055e      switch (usart_base)
0803055e      {
0803055c          case &USART2:
0803055c          {
080305a2              BN_CODE_start_0x80300a0_size_0x2(0x811);
080305aa              sub_80300c8(0x811);
0803055c              break;
0803055c          }
08030562          case &USART3:
08030562          {
080305b4              BN_CODE_start_0x80300a0_size_0x2(0x812);
080305bc              sub_80300c8(0x812);
08030562              break;
08030562          }
08030568          case &UART4:
08030568          {
080305d8              BN_CODE_start_0x80300a0_size_0x2(0x813);
080305e0              sub_80300c8(0x813);
08030568              break;
08030568          }
0803056e          case &UART5:
0803056e          {
080305ea              BN_CODE_start_0x80300a0_size_0x2(0x814);
080305f2              sub_80300c8(0x814);
0803056e              break;
0803056e          }
08030574          case &UART7:
08030574          {
080305fc              BN_CODE_start_0x80300a0_size_0x2(0x81e);
08030604              sub_80300c8(0x81e);
08030574              break;
08030574          }
0803057a          case &UART4:
0803057a          {
0803060e              BN_CODE_start_0x80300a0_size_0x2(0x81f);
08030616              sub_80300c8(0x81f);
0803057a              break;
0803057a          }
08030580          case &USART1:
08030580          {
08030590              BN_CODE_start_0x80300a0_size_0x2(0x904);
08030598              sub_80300c8(0x904);
08030580              break;
08030580          }
08030586          case &USART6:
08030586          {
080305c6              BN_CODE_start_0x80300a0_size_0x2(0x905);
080305ce              sub_80300c8(0x905);
08030586              break;
08030586          }
0803055e      }
0803055e      
0803061c      return arg2;
08030558  }
0803061e    int32_t usart_set_baud_brr(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
0803061e  {
08030624      uint32_t r0 = 0;
08030624      
08030632      switch (arg1)
08030632      {
08030630          case &USART2:
08030630          {
08030672              r0 = sub_80302ee(2);
08030630              break;
08030630          }
08030636          case &USART3:
08030636          {
0803067a              r0 = sub_80302ee(2);
08030636              break;
08030636          }
0803063c          case &UART4:
0803063c          {
08030682              r0 = sub_80302ee(2);
0803063c              break;
0803063c          }
08030642          case &UART5:
08030642          {
0803068a              r0 = sub_80302ee(2);
08030642              break;
08030642          }
08030648          case &UART7:
08030648          {
08030692              r0 = sub_80302ee(2);
08030648              break;
08030648          }
0803064e          case &UART4:
0803064e          {
0803069a              r0 = sub_80302ee(2);
0803064e              break;
0803064e          }
08030654          case &USART1:
08030654          {
08030662              r0 = sub_80302ee(3);
08030654              break;
08030654          }
0803065a          case &USART6:
0803065a          {
0803066a              r0 = sub_80302ee(3);
0803065a              break;
0803065a          }
08030632      }
08030632      
080306a8      if (*(uint32_t*)((char*)arg1 + 0xc) << 0x10 >= 0)
080306a8      {
080306d8          uint16_t r2_2 = (int16_t)((r0 + (arg2 >> 1)) / arg2);
080306f8          *(uint32_t*)((char*)arg1 + 8) |=
080306f8              (0xfff0 & (uint32_t)r2_2) | ((uint32_t)r2_2 & 0xf);
080306a8      }
080306a8      else
080306a8      {
080306b0          uint16_t r2 = (int16_t)(((arg2 >> 1) + (r0 << 1)) / arg2);
080306d0          *(uint32_t*)((char*)arg1 + 8) |= (0xfff0 & (uint32_t)r2) | ((uint32_t)r2 & 7);
080306a8      }
080306a8      
080306fa      return arg4;
0803061e  }
080306fc  int32_t data_80306fc = 0x40004400
08030700  int32_t data_8030700 = 0x40004800
08030704  int32_t data_8030704 = 0x40004c00
08030708  int32_t data_8030708 = 0x40005000
0803070c  int32_t data_803070c = 0x40007800
08030710  int32_t data_8030710 = 0x40007c00
08030714  int32_t data_8030714 = 0x40011000
08030718  int32_t data_8030718 = 0x40011400
0803071c    void* usart_enable(void* arg1)
0803071c  {
08030728      *(uint32_t*)((char*)arg1 + 0xc) |= 0x2000;
0803072a      return (char*)arg1 + 0xc;
0803071c  }
0803072c    void* usart_enable_tx(void* arg1, int32_t arg2)
0803072c  {
0803073c      *(uint32_t*)((char*)arg1 + 0xc) =
0803073c          (*(uint32_t*)((char*)arg1 + 0xc) & 0xfffffff7) | arg2;
0803073e      return (char*)arg1 + 0xc;
0803072c  }
08030740    void* usart_enable_rx(void* arg1, int32_t arg2)
08030740  {
08030750      *(uint32_t*)((char*)arg1 + 0xc) =
08030750          (*(uint32_t*)((char*)arg1 + 0xc) & 0xfffffffb) | arg2;
08030752      return (char*)arg1 + 0xc;
08030740  }
08030754    int32_t usart_write_dr(int32_t usart_base, int32_t ch)
08030754  {
0803075a      *(uint32_t*)(usart_base + 4) = ch << 0x17 >> 0x17;
0803075c      return usart_base + 4;
08030754  }
0803075e    uint32_t sub_803075e(void* arg1)
0803075e  {
08030766      return *(uint32_t*)((char*)arg1 + 4) << 0x17 >> 0x17;
0803075e  }
08030768    void* usart_set_dmar(USART_TypeDef* usart, uint32_t enableMask)
08030768  {
08030778      usart->CR3 = (usart->CR3 & 0xffffffbf) | enableMask;
0803077a      return &usart->CR3;
08030768  }
0803077c    void* sub_803077c(void* arg1, int32_t arg2)
0803077c  {
0803078c      *(uint32_t*)((char*)arg1 + 0x14) =
0803078c          (*(uint32_t*)((char*)arg1 + 0x14) & 0xffffff7f) | arg2;
0803078e      return (char*)arg1 + 0x14;
0803077c  }
08030790    int32_t usart_check_flag(int32_t usart_base, int32_t flag)
08030790  {
08030790      int32_t r1_1 = (int32_t)(int16_t)flag;
08030790      
080307a0      if (*(uint32_t*)(usart_base + (r1_1 >> 6)) >> (r1_1 & 0x1f) << 0x1f >= 0)
080307a6          return 0;
080307a6      
080307a2      return 1;
08030790  }
080307aa    void sub_80307aa(void* arg1, int32_t arg2)
080307aa  {
080307ae      uint32_t r2_1 = arg2 >> 0xc << 0xc;
080307b2      uint32_t r1_1 = arg2 << 0x14 >> 0x14;
080307b2      
080307b8      if (r2_1 == 0x10000000)
080307c4          *(uint32_t*)((char*)arg1 + 0xc) |= r1_1;
080307b8      else if (r2_1 == &turnTable)
080307d8          *(uint32_t*)((char*)arg1 + 0x10) |= r1_1;
080307cc      else if (r2_1 == 0x40000000)
080307ec          *(uint32_t*)((char*)arg1 + 0x14) |= r1_1;
080307e0      else if (r2_1 == 0x80000000)
08030800          *(uint32_t*)((char*)arg1 + 0x80) |= r1_1;
080307aa  }
08030804    int32_t sub_8030804(int32_t arg1, int32_t arg2)
08030804  {
08030812      if (*(uint32_t*)(arg1 + (arg2 >> 6)) >> (arg2 & 0x1f) << 0x1f >= 0)
08030818          return 0;
08030818      
08030814      return 1;
08030804  }
0803081c    int32_t sub_803081c(int32_t* arg1, int32_t arg2)
0803081c  {
0803081c      int32_t r3;
0803081c      int32_t var_10 = r3;
0803081c      
08030824      if (arg1)
08030824      {
08030836          sub_803253a();
08030844          arg1[2] = *(uint32_t*)arg1 + arg1[0x10] * arg1[0xf];
08030848          arg1[0xe] = 0;
0803084c          arg1[1] = *(uint32_t*)arg1;
0803085a          arg1[3] = *(uint32_t*)arg1 + arg1[0x10] * (arg1[0xf] - 1);
08030860          arg1[0x11] = 0xff;
08030868          *(uint8_t*)((char*)arg1 + 0x45) = 0xff;
08030868          
0803086e          if (arg2)
0803086e          {
0803089a              sub_8032368(&arg1[4]);
080308a2              sub_8032368(&arg1[9]);
0803086e          }
0803086e          else if (arg1[4] && sub_8029b08(&arg1[4]))
08030874          {
0803088a              *(uint32_t*)0xe000ed04 = 0x10000000;
0803088c              __dsb_SY();
08030890              __isb();
08030874          }
08030874          
080308a6          sub_8032574();
080308ac          return 1;
08030824      }
08030824      
08030828      __msr(basepri, 0x20);
0803082c      __dsb_SY();
08030830      __isb();
08030830      
08030834      while (true)
08030834          /* nop */
0803081c  }
080308ae    int32_t* sub_80308ae(int32_t arg1, int32_t arg2, char arg3)
080308ae  {
080308ae      int32_t* r3;
080308ae      int32_t* var_18 = r3;
080308ae      
080308b8      if (arg1)
080308b8      {
080308cc          int32_t r0;
080308cc          
080308cc          r0 = arg2 ? arg2 * arg1 : 0;
080308cc          
080308d8          int32_t* result = sub_8032108(r0 + 0x50);
080308d8          
080308e0          if (result)
080308f0              sub_80308f8(arg1, arg2, &result[0x14], (uint32_t)arg3, result);
080308f0          
080308f6          return result;
080308b8      }
080308b8      
080308bc      __msr(basepri, 0x20);
080308c0      __dsb_SY();
080308c4      __isb();
080308c4      
080308c8      while (true)
080308c8          /* nop */
080308ae  }
080308f8    int32_t sub_80308f8(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t* arg5)
080308f8  {
08030900      if (arg2)
08030906          *(uint32_t*)arg5 = arg3;
08030900      else
08030902          *(uint32_t*)arg5 = arg5;
08030902      
08030908      arg5[0xf] = arg1;
0803090a      arg5[0x10] = arg2;
08030910      sub_803081c(arg5, 1);
08030914      arg5[0x13] = (uint8_t)arg4;
08030918      return arg4;
080308f8  }
0803091a    int32_t sub_803091a(int32_t* arg1, int32_t arg2 @ r7)
0803091a  {
0803091e      if (arg1)
0803091e      {
08030922          arg1[2] = 0;
08030926          *(uint32_t*)arg1 = 0;
0803092a          arg1[3] = 0;
08030932          sub_8030954(arg1, nullptr, 0, 0);
0803091e      }
0803091e      
08030936      return arg2;
0803091a  }
08030938    int32_t* sub_8030938(char arg1)
08030938  {
08030944      int32_t* result = sub_80308ae(1, 0, arg1);
0803094c      int32_t r7;
0803094c      sub_803091a(result, r7);
08030952      return result;
08030938  }
08030954    int32_t sub_8030954(int32_t* arg1, char* arg2, int32_t arg3, int32_t arg4)
08030954  {
08030954      int32_t var_18 = arg3;
08030954      char* var_1c = arg2;
08030954      int32_t* var_20 = arg1;
0803095c      int32_t r7 = 0;
0803095c      
08030960      if (!arg1)
08030960      {
08030964          __msr(basepri, 0x20);
08030968          __dsb_SY();
0803096c          __isb();
0803096c          
08030970          while (true)
08030970              /* nop */
08030970          
08030970          return;
08030960      }
08030960      
0803097a      char r0_1;
0803097a      
0803097a      if (arg2 || !arg1[0x10])
0803097c          r0_1 = 1;
0803097a      else
08030980          r0_1 = 0;
08030980      
08030986      if (!(uint32_t)r0_1)
08030986      {
0803098a          __msr(basepri, 0x20);
0803098e          __dsb_SY();
08030992          __isb();
08030992          
08030996          while (true)
08030996              /* nop */
08030996          
08030996          return;
08030986      }
08030986      
080309a0      char r0_4;
080309a0      
080309a0      if (arg4 != 2 || arg1[0xf] == 1)
080309a2          r0_4 = 1;
080309a0      else
080309a6          r0_4 = 0;
080309a6      
080309ac      if (!(uint32_t)r0_4)
080309ac      {
080309b0          __msr(basepri, 0x20);
080309b4          __dsb_SY();
080309b8          __isb();
080309b8          
080309bc          while (true)
080309bc              /* nop */
080309bc          
080309bc          return;
080309ac      }
080309ac      
080309ca      char r0_8;
080309ca      
080309ca      if (sub_8029d46() || !var_18)
080309cc          r0_8 = 1;
080309ca      else
080309d0          r0_8 = 0;
080309d0      
080309d6      if ((uint32_t)r0_8)
080309d6      {
080309f2          int32_t r0_13;
080309f2          
080309f2          while (true)
080309f2          {
080309f2              sub_803253a();
080309f2              
08030a00              if (arg1[0xe] >= arg1[0xf] && arg4 != 2)
08030a00              {
08030a54                  if (!var_18)
08030a54                  {
08030a56                      sub_8032574();
08030a5a                      return 0;
08030a54                  }
08030a54                  
08030a60                  if (!r7)
08030a60                  {
08030a64                      sub_8029b9c(&var_20);
08030a68                      r7 = 1;
08030a60                  }
08030a60                  
08030a6a                  sub_8032574();
08030a6e                  sub_8029834();
08030a72                  sub_803253a();
08030a72                  
08030a7e                  if ((int32_t)arg1[0x11] == 0xffffffff)
08030a82                      arg1[0x11] = 0;
08030a82                  
08030a8e                  if ((int32_t)*(uint8_t*)((char*)arg1 + 0x45) == 0xffffffff)
08030a92                      *(uint8_t*)((char*)arg1 + 0x45) = 0;
08030a92                  
08030a96                  sub_8032574();
08030a9e                  int32_t r0_22;
08030a9e                  int32_t r1_4;
08030a9e                  int32_t r2_1;
08030a9e                  int32_t r3;
08030a9e                  r0_22 = sub_8029bb4(&var_20, &var_18);
08030a9e                  
08030aa4                  if (r0_22)
08030aa4                  {
08030ade                      sub_8030dd2(arg1, r1_4, r2_1, r3);
08030ae2                      sub_8029844();
08030ae6                      return 0;
08030aa4                  }
08030aa4                  
08030aa8                  int32_t r0_24;
08030aa8                  int32_t r1_5;
08030aa8                  int32_t r2_2;
08030aa8                  int32_t r3_1;
08030aa8                  r0_24 = sub_8030e5c(arg1);
08030aa8                  
08030aae                  if (!r0_24)
08030aae                  {
080309ea                      sub_8030dd2(arg1, r1_5, r2_2, r3_1);
080309ee                      sub_8029844();
080309ee                      continue;
08030aae                  }
08030aae                  else
08030aae                  {
08030ab6                      int32_t r1_7;
08030ab6                      int32_t r2_3;
08030ab6                      int32_t r3_2;
08030ab6                      r1_7 = sub_8029ac8(&arg1[4], var_18);
08030abc                      sub_8030dd2(arg1, r1_7, r2_3, r3_2);
08030abc                      
08030ac6                      if (sub_8029844())
08030ac6                          continue;
08030ac6                      else
08030ac6                      {
08030ad0                          *(uint32_t*)0xe000ed04 = 0x10000000;
08030ad2                          __dsb_SY();
08030ad6                          __isb();
08030ada                          continue;
08030ac6                      }
08030aae                  }
08030a00              }
08030a00              
08030a08              r0_13 = sub_8030d4c(arg1, arg2, arg4);
08030a10              break;
080309f2          }
080309f2          
08030a10          if (arg1[9])
08030a10          {
08030a1c              if (sub_8029b08(&arg1[9]))
08030a1c              {
08030a26                  *(uint32_t*)0xe000ed04 = 0x10000000;
08030a28                  __dsb_SY();
08030a2c                  __isb();
08030a1c              }
08030a10          }
08030a10          else if (r0_13)
08030a34          {
08030a3e              *(uint32_t*)0xe000ed04 = 0x10000000;
08030a40              __dsb_SY();
08030a44              __isb();
08030a34          }
08030a34          
08030a48          sub_8032574();
08030a4c          return 1;
080309d6      }
080309d6      
080309da      __msr(basepri, 0x20);
080309de      __dsb_SY();
080309e2      __isb();
080309e2      
080309e6      while (true)
080309e6          /* nop */
08030954  }
08030aea    int32_t sub_8030aea(int32_t* arg1, int32_t* arg2)
08030aea  {
08030af2      if (!arg1)
08030af2      {
08030af6          __msr(basepri, 0x20);
08030afa          __dsb_SY();
08030afe          __isb();
08030afe          
08030b02          while (true)
08030b02              /* nop */
08030af2      }
08030af2      else if (!arg1[0x10])
08030b08      {
08030b24          char r0_3;
08030b24          
08030b24          if (*(uint32_t*)arg1 || !arg1[2])
08030b26              r0_3 = 1;
08030b24          else
08030b2a              r0_3 = 0;
08030b2a          
08030b30          if ((uint32_t)r0_3)
08030b30          {
08030b42              sub_80325d4();
08030b46              uint32_t r6 = __mrs(basepri);
08030b4c              __msr(basepri, 0x20);
08030b50              __dsb_SY();
08030b54              __isb();
08030b58              int32_t r0_5 = arg1[0xe];
08030b5e              int32_t result;
08030b5e              
08030b5e              if (r0_5 >= arg1[0xf])
08030b96                  result = 0;
08030b5e              else
08030b5e              {
08030b60                  char r1_1 = *(uint8_t*)((char*)arg1 + 0x45);
08030b66                  arg1[0xe] = r0_5 + 1;
08030b68                  int32_t r1_2 = (int32_t)r1_1;
08030b68                  
08030b6e                  if (r1_2 != 0xffffffff)
08030b8e                      *(uint8_t*)((char*)arg1 + 0x45) = (uint8_t)r1_2 + 1;
08030b6e                  else if (arg1[9] && sub_8029b08(&arg1[9]) && arg2)
08030b88                      *(uint32_t*)arg2 = 1;
08030b88                  
08030b92                  result = 1;
08030b5e              }
08030b5e              
08030b98              __msr(basepri, r6);
08030b9c              return result;
08030b30          }
08030b30          
08030b34          __msr(basepri, 0x20);
08030b38          __dsb_SY();
08030b3c          __isb();
08030b3c          
08030b40          while (true)
08030b40              /* nop */
08030b08      }
08030b08      else
08030b08      {
08030b0c          __msr(basepri, 0x20);
08030b10          __dsb_SY();
08030b14          __isb();
08030b14          
08030b18          while (true)
08030b18              /* nop */
08030b08      }
08030aea  }
08030b9e    int32_t rtos_dma_rx_wait_and_service(int32_t* ctx, int32_t timeoutTicks)
08030b9e  {
08030b9e      int32_t timeoutTicks_1 = timeoutTicks;
08030ba4      int32_t r5 = 0;
08030ba6      int32_t r6 = 0;
08030ba6      
08030baa      if (!ctx)
08030baa      {
08030bae          __msr(basepri, 0x20);
08030bb2          __dsb_SY();
08030bb6          __isb();
08030bb6          
08030bba          while (true)
08030bba              /* nop */
08030baa      }
08030baa      else if (!ctx[0x10])
08030bc0      {
08030bde          char r0_3;
08030bde          
08030bde          if (sub_8029d46() || !timeoutTicks_1)
08030be0              r0_3 = 1;
08030bde          else
08030be4              r0_3 = 0;
08030be4          
08030bea          if ((uint32_t)r0_3)
08030bea          {
08030c06              while (true)
08030c06              {
08030c06                  sub_803253a();
08030c0a                  int32_t r0_6 = ctx[0xe];
08030c0a                  
08030c0e                  if (r0_6)
08030c0e                  {
08030c12                      ctx[0xe] = r0_6 - 1;
08030c12                      
08030c18                      if (!*(uint32_t*)ctx)
08030c1e                          ctx[2] = sub_8029fac();
08030c1e                      
08030c24                      if (ctx[4] && sub_8029b08(&ctx[4]))
08030c24                      {
08030c3a                          *(uint32_t*)0xe000ed04 = 0x10000000;
08030c3c                          __dsb_SY();
08030c40                          __isb();
08030c24                      }
08030c24                      
08030c44                      sub_8032574();
08030c48                      return 1;
08030c0e                  }
08030c0e                  
08030c50                  if (!timeoutTicks_1)
08030c50                      break;
08030c50                  
08030c70                  void var_20;
08030c70                  
08030c70                  if (!r5)
08030c70                  {
08030c74                      sub_8029b9c(&var_20);
08030c78                      r5 = 1;
08030c70                  }
08030c70                  
08030c7a                  sub_8032574();
08030c7e                  sub_8029834();
08030c82                  sub_803253a();
08030c82                  
08030c8e                  if ((int32_t)ctx[0x11] == 0xffffffff)
08030c92                      ctx[0x11] = 0;
08030c92                  
08030c9e                  if ((int32_t)*(uint8_t*)((char*)ctx + 0x45) == 0xffffffff)
08030ca2                      *(uint8_t*)((char*)ctx + 0x45) = 0;
08030ca2                  
08030ca6                  sub_8032574();
08030cae                  int32_t r0_19;
08030cae                  int32_t r1_1;
08030cae                  int32_t r2_1;
08030cae                  int32_t r3_1;
08030cae                  r0_19 = sub_8029bb4(&var_20, &timeoutTicks_1);
08030cae                  
08030cb4                  if (r0_19)
08030cb4                  {
08030d04                      sub_8030dd2(ctx, r1_1, r2_1, r3_1);
08030d08                      sub_8029844();
08030d08                      
08030d14                      if (sub_8030e40(ctx))
08030d14                      {
08030d1a                          if (r6)
08030d1a                          {
08030d1c                              sub_803253a();
08030d22                              int32_t r0_32 = sub_8030d38(ctx);
08030d2a                              sub_8029ee8(ctx[2], r0_32);
08030d2e                              sub_8032574();
08030d1a                          }
08030d1a                          
08030d32                          return 0;
08030d14                      }
08030cb4                  }
08030cb4                  else
08030cb4                  {
08030cb8                      int32_t r0_21;
08030cb8                      int32_t r1_2;
08030cb8                      int32_t r2_2;
08030cb8                      int32_t r3_2;
08030cb8                      r0_21 = sub_8030e40(ctx);
08030cb8                      
08030cbe                      if (!r0_21)
08030cbe                      {
08030bfe                          sub_8030dd2(ctx, r1_2, r2_2, r3_2);
08030c02                          sub_8029844();
08030cbe                      }
08030cbe                      else
08030cbe                      {
08030cc4                          if (!*(uint32_t*)ctx)
08030cc4                          {
08030cc6                              sub_803253a();
08030cd0                              r6 = sub_8029d66(ctx[2]);
08030cd2                              sub_8032574();
08030cc4                          }
08030cc4                          
08030cdc                          int32_t r1_4;
08030cdc                          int32_t r2_3;
08030cdc                          int32_t r3_3;
08030cdc                          r1_4 = sub_8029ac8(&ctx[9], timeoutTicks_1);
08030ce2                          sub_8030dd2(ctx, r1_4, r2_3, r3_3);
08030ce2                          
08030cec                          if (!sub_8029844())
08030cec                          {
08030cf6                              *(uint32_t*)0xe000ed04 = 0x10000000;
08030cf8                              __dsb_SY();
08030cfc                              __isb();
08030cec                          }
08030cbe                      }
08030cb4                  }
08030c06              }
08030c06              
08030c54              if (!r6)
08030c54              {
08030c66                  sub_8032574();
08030c6a                  return 0;
08030c54              }
08030c54              
08030c58              __msr(basepri, 0x20);
08030c5c              __dsb_SY();
08030c60              __isb();
08030c60              
08030c64              while (true)
08030c64                  /* nop */
08030bea          }
08030bea          else
08030bea          {
08030bee              __msr(basepri, 0x20);
08030bf2              __dsb_SY();
08030bf6              __isb();
08030bf6              
08030bfa              while (true)
08030bfa                  /* nop */
08030bea          }
08030bc0      }
08030bc0      else
08030bc0      {
08030bc4          __msr(basepri, 0x20);
08030bc8          __dsb_SY();
08030bcc          __isb();
08030bcc          
08030bd0          while (true)
08030bd0              /* nop */
08030bc0      }
08030b9e  }
08030d38    int32_t sub_8030d38(void* arg1)
08030d38  {
08030d3c      if (!*(uint32_t*)((char*)arg1 + 0x24))
08030d48          return 0;
08030d48      
08030d42      return 8 - **(uint32_t**)((char*)arg1 + 0x30);
08030d38  }
08030d4c    int32_t sub_8030d4c(int32_t* arg1, char* arg2, int32_t arg3)
08030d4c  {
08030d54      int32_t result = 0;
08030d56      int32_t r6 = arg1[0xe];
08030d56      
08030d5c      if (arg1[0x10])
08030d5c      {
08030d74          if (arg3)
08030d74          {
08030d9e              memcpy_(arg1[3], arg2, arg1[0x10]);
08030daa              arg1[3] += 0 - arg1[0x10];
08030daa              
08030db2              if (arg1[3] < *(uint32_t*)arg1)
08030dbc                  arg1[3] = arg1[2] + 0 - arg1[0x10];
08030dbc              
08030dc4              if (arg3 == 2 && r6)
08030dc6                  r6 -= 1;
08030d74          }
08030d74          else
08030d74          {
08030d7c              memcpy_(arg1[1], arg2, arg1[0x10]);
08030d86              arg1[1] += arg1[0x10];
08030d86              
08030d8e              if (arg1[1] >= arg1[2])
08030d92                  arg1[1] = *(uint32_t*)arg1;
08030d74          }
08030d5c      }
08030d5c      else if (!*(uint32_t*)arg1)
08030d62      {
08030d6a          result = sub_8029e24(arg1[2]);
08030d6e          arg1[2] = 0;
08030d62      }
08030d62      
08030dca      arg1[0xe] = r6 + 1;
08030dce      return result;
08030d4c  }
08030dd2    int32_t sub_8030dd2(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
08030dd2  {
08030dd6      sub_803253a();
08030dda      char r5 = *(uint8_t*)((char*)arg1 + 0x45);
08030dda      
08030df2      while (true)
08030df2      {
08030df2          int32_t r5_1 = (int32_t)r5;
08030df2          
08030df6          if (r5_1 < 1)
08030df6              break;
08030df6          
08030dfc          if (!*(uint32_t*)((char*)arg1 + 0x24))
08030dfc              break;
08030dfc          
08030dea          if (sub_8029b08((char*)arg1 + 0x24))
08030dec              sub_8029c36();
08030dec          
08030df0          r5 = (uint8_t)r5_1 - 1;
08030df2      }
08030df2      
08030e02      *(uint8_t*)((char*)arg1 + 0x45) = 0xff;
08030e06      sub_8032574();
08030e0a      sub_803253a();
08030e0e      char r5_2 = *(uint8_t*)((char*)arg1 + 0x44);
08030e0e      
08030e26      while (true)
08030e26      {
08030e26          int32_t r5_3 = (int32_t)r5_2;
08030e26          
08030e30          if (r5_3 < 1 || !*(uint32_t*)((char*)arg1 + 0x10))
08030e30          {
08030e36              *(uint8_t*)((char*)arg1 + 0x44) = 0xff;
08030e3a              sub_8032574();
08030e3e              return arg4;
08030e30          }
08030e30          
08030e1e          if (sub_8029b08((char*)arg1 + 0x10))
08030e20              sub_8029c36();
08030e20          
08030e24          r5_2 = (uint8_t)r5_3 - 1;
08030e26      }
08030dd2  }
08030e40    int32_t sub_8030e40(void* arg1)
08030e40  {
08030e44      sub_803253a();
08030e4c      int32_t result;
08030e4c      
08030e4c      if (*(uint32_t*)((char*)arg1 + 0x38))
08030e52          result = 0;
08030e4c      else
08030e4e          result = 1;
08030e4e      
08030e54      sub_8032574();
08030e5a      return result;
08030e40  }
08030e5c    int32_t sub_8030e5c(void* arg1)
08030e5c  {
08030e60      sub_803253a();
08030e6a      int32_t result;
08030e6a      
08030e6a      if (*(uint32_t*)((char*)arg1 + 0x38) != *(uint32_t*)((char*)arg1 + 0x3c))
08030e70          result = 0;
08030e6a      else
08030e6c          result = 1;
08030e6c      
08030e72      sub_8032574();
08030e78      return result;
08030e5c  }
08030e7a                                                                                00 00                                        ..
08030e7c  int32_t data_8030e7c = -0x1fff12fc
08030e80    void* dma_stream_reset_and_clear_flags(DMA_F4_TypeDef* dma, uint8_t stream)
08030e80  {
08030e82      uint32_t stream_1 = (uint32_t)stream;
08030e92      uint32_t r1 = (uint32_t)(uint8_t)stream_1;
08030e9c      *(uint32_t*)(&dma->S + 0x18 * r1) = *(uint32_t*)(&dma->S + 0x18 * stream_1) >> 1 << 1;
08030ea0      uint32_t r1_1 = (uint32_t)(uint8_t)r1;
08030eaa      *(uint32_t*)(&dma->S + 0x18 * r1_1) = 0;
08030eae      uint32_t r1_2 = (uint32_t)(uint8_t)r1_1;
08030eb8      *(uint32_t*)(&dma->S[0].NDTR + 0x18 * r1_2) = 0;
08030ebc      uint32_t r1_3 = (uint32_t)(uint8_t)r1_2;
08030ec6      *(uint32_t*)(&dma->S[0].PAR + 0x18 * r1_3) = 0;
08030eca      uint32_t r1_4 = (uint32_t)(uint8_t)r1_3;
08030ed4      *(uint32_t*)(&dma->S[0].M0AR + 0x18 * r1_4) = 0;
08030ed8      uint32_t r1_5 = (uint32_t)(uint8_t)r1_4;
08030ee2      *(uint32_t*)(&dma->S[0].M1AR + 0x18 * r1_5) = 0;
08030ee6      uint32_t r1_6 = (uint32_t)(uint8_t)r1_5;
08030ef0      *(uint32_t*)(&dma->S[0].FCR + 0x18 * r1_6) = 0;
08030ef2      uint32_t r1_7 = (uint32_t)(uint8_t)r1_6;
08030ef6      uint32_t volatile* result;
08030ef6      
08030ef6      if (r1_7 >= 4)
08030ef6      {
08030f24          uint32_t r1_12 = (uint32_t)(uint8_t)r1_7;
08030f3a          result = &dma->HIFCR;
08030f3c          ADJ(result)->LIFCR =
08030f3c              0x3d << ((((uint32_t)(uint8_t)(r1_12 >> 1) & 1) << 2) + 6 * r1_12)
08030f3c              | dma->HIFCR;
08030ef6      }
08030ef6      else
08030ef6      {
08030f00          uint32_t r1_8 = (uint32_t)(uint8_t)r1_7;
08030f16          result = &dma->LIFCR;
08030f18          ADJ(result)->LIFCR =
08030f18              0x3d << ((((uint32_t)(uint8_t)(r1_8 >> 1) & 1) << 2) + 6 * r1_8) | dma->LIFCR;
08030ef6      }
08030ef6      
08030f40      return result;
08030e80  }
08030f42    int32_t* dma_stream_config(DMA_F4_TypeDef* dma, uint8_t stream, uint32_t par, uint32_t m0ar, uint32_t ndtr, uint32_t cr_bits, uint32_t fcr_bits, int32_t mode_sel, int32_t flow_ctrl, int32_t dmdis_fcr, uint8_t priority)
08030f42  {
08030f46      uint32_t stream_1 = (uint32_t)stream;
08030f56      uint32_t r1 = (uint32_t)(uint8_t)stream_1;
08030f60      *(uint32_t*)(&dma->S[0].FCR + 0x18 * r1) =
08030f60          *(uint32_t*)(&dma->S[0].FCR + 0x18 * stream_1) & 0xfffffffb;
08030f64      uint32_t r1_1 = (uint32_t)(uint8_t)r1;
08030f6e      *(uint32_t*)(&dma->S[0].PAR + 0x18 * r1_1) = par;
08030f72      uint32_t r1_2 = (uint32_t)(uint8_t)r1_1;
08030f7c      *(uint32_t*)(&dma->S[0].M0AR + 0x18 * r1_2) = ndtr;
08030f80      uint32_t r1_3 = (uint32_t)(uint8_t)r1_2;
08030f8a      *(uint32_t*)(&dma->S[0].NDTR + 0x18 * r1_3) = dmdis_fcr;
08030f8c      uint32_t r1_4 = (uint32_t)(uint8_t)r1_3;
08030fae      uint32_t r1_5 = (uint32_t)(uint8_t)r1_4;
08030fb8      *(uint32_t*)(&dma->S + 0x18 * r1_5) = (*(uint32_t*)(&dma->S + 0x18 * r1_4)
08030fb8          & 0xfffc873f) | fcr_bits | fcr_bits << 2 | priority | flow_ctrl;
08030fbe      uint32_t r1_7;
08030fbe      
08030fbe      if (!m0ar)
08030fbe      {
08030fc0          uint32_t r1_6 = (uint32_t)(uint8_t)r1_5;
08030fd0          r1_7 = (uint32_t)(uint8_t)r1_6;
08030fda          *(uint32_t*)(&dma->S + 0x18 * r1_7) = *(uint32_t*)(&dma->S + 0x18 * r1_6) | 0x200;
08030fbe      }
08030fbe      else if (m0ar != 1)
08030fe2      {
08031002          uint32_t r1_9 = (uint32_t)(uint8_t)r1_5;
08031012          r1_7 = (uint32_t)(uint8_t)r1_9;
0803101c          *(uint32_t*)(&dma->S + 0x18 * r1_7) =
0803101c              *(uint32_t*)(&dma->S + 0x18 * r1_9) | 0x8000;
08030fe2      }
08030fe2      else
08030fe2      {
08030fe4          uint32_t r1_8 = (uint32_t)(uint8_t)r1_5;
08030ff4          r1_7 = (uint32_t)(uint8_t)r1_8;
08030ffe          *(uint32_t*)(&dma->S + 0x18 * r1_7) =
08030ffe              *(uint32_t*)(&dma->S + 0x18 * r1_8) & 0xfffffdff;
08030fe2      }
08030fe2      
08031022      uint32_t r1_11;
08031022      
08031022      if (cr_bits)
08031022      {
08031042          uint32_t r1_12 = (uint32_t)(uint8_t)r1_7;
08031052          r1_11 = (uint32_t)(uint8_t)r1_12;
0803105c          *(uint32_t*)(&dma->S + 0x18 * r1_11) =
0803105c              *(uint32_t*)(&dma->S + 0x18 * r1_12) & 0xfffffbff;
08031022      }
08031022      else
08031022      {
08031024          uint32_t r1_10 = (uint32_t)(uint8_t)r1_7;
08031034          r1_11 = (uint32_t)(uint8_t)r1_10;
0803103e          *(uint32_t*)(&dma->S + 0x18 * r1_11) =
0803103e              *(uint32_t*)(&dma->S + 0x18 * r1_10) | 0x400;
08031022      }
08031022      
08031062      int32_t* result;
08031062      
08031062      if (mode_sel)
08031062      {
08031082          uint32_t r1_15 = (uint32_t)(uint8_t)r1_11;
0803109a          result = &dma->S + 0x18 * (uint32_t)(uint8_t)r1_15;
0803109c          *(uint32_t*)result = *(uint32_t*)(&dma->S + 0x18 * r1_15) & 0xfffffeff;
08031062      }
08031062      else
08031062      {
08031064          uint32_t r1_13 = (uint32_t)(uint8_t)r1_11;
0803107c          result = &dma->S + 0x18 * (uint32_t)(uint8_t)r1_13;
0803107e          *(uint32_t*)result = *(uint32_t*)(&dma->S + 0x18 * r1_13) | 0x100;
08031062      }
08031062      
080310a2      return result;
08030f42  }
080310a4  int32_t data_80310a4 = -0x378c1
080310a8    void* dma_clear_flags(DMA_F4_TypeDef* dma, uint8_t stream, uint32_t flagMask)
080310a8  {
080310aa      uint32_t stream_1 = (uint32_t)stream;
080310ae      uint32_t volatile* result;
080310ae      
080310ae      if (stream_1 >= 4)
080310ae      {
080310da          uint32_t r1_5 = (uint32_t)((uint8_t)stream_1 - 4);
080310f0          result = &dma->HIFCR;
080310f2          ADJ(result)->LIFCR =
080310f2              flagMask << ((((uint32_t)(uint8_t)(r1_5 >> 1) & 1) << 2) + 6 * r1_5)
080310f2              | dma->HIFCR;
080310ae      }
080310ae      else
080310ae      {
080310b6          uint32_t r1 = (uint32_t)(uint8_t)stream_1;
080310cc          result = &dma->LIFCR;
080310ce          ADJ(result)->LIFCR =
080310ce              flagMask << ((((uint32_t)(uint8_t)(r1 >> 1) & 1) << 2) + 6 * r1) | dma->LIFCR;
080310ae      }
080310ae      
080310f6      return result;
080310a8  }
080310f8    int32_t* dma_or_bits(DMA_F4_TypeDef* dma, uint8_t stream, uint32_t mask)
080310f8  {
080310fa      int32_t* result;
080310fa      
080310fa      if (mask == 0x80)
080310fa      {
08031118          uint32_t stream_2 = (uint32_t)stream;
0803112e          result = &dma->S[0].FCR + 0x18 * (uint32_t)(uint8_t)stream_2;
08031130          *(uint32_t*)result = mask | *(uint32_t*)(&dma->S[0].FCR + 0x18 * stream_2);
080310fa      }
080310fa      else
080310fa      {
080310fc          uint32_t stream_1 = (uint32_t)stream;
08031112          result = &dma->S + 0x18 * (uint32_t)(uint8_t)stream_1;
08031114          *(uint32_t*)result = mask | *(uint32_t*)(&dma->S + 0x18 * stream_1);
080310fa      }
080310fa      
08031132      return result;
080310f8  }
08031134    int32_t* dma_andnot_bits(DMA_F4_TypeDef* dma, uint8_t stream, uint32_t mask)
08031134  {
08031136      int32_t* result;
08031136      
08031136      if (mask == 0x80)
08031136      {
08031156          uint32_t stream_2 = (uint32_t)stream;
0803116e          result = &dma->S[0].FCR + 0x18 * (uint32_t)(uint8_t)stream_2;
08031170          *(uint32_t*)result = *(uint32_t*)(&dma->S[0].FCR + 0x18 * stream_2) & ~mask;
08031136      }
08031136      else
08031136      {
08031138          uint32_t stream_1 = (uint32_t)stream;
08031150          result = &dma->S + 0x18 * (uint32_t)(uint8_t)stream_1;
08031152          *(uint32_t*)result = *(uint32_t*)(&dma->S + 0x18 * stream_1) & ~mask;
08031136      }
08031136      
08031172      return result;
08031134  }
08031174    int32_t* dma_cr_clear_bit(DMA_F4_TypeDef* dma, uint8_t stream)
08031174  {
08031174      uint32_t stream_1 = (uint32_t)stream;
0803118e      *(uint32_t*)(&dma->S + 0x18 * (uint32_t)(uint8_t)stream_1) =
0803118e          *(uint32_t*)(&dma->S + 0x18 * stream_1) & 0xfffffeff;
08031190      return &dma->S + 0x18 * (uint32_t)(uint8_t)stream_1;
08031174  }
08031192    int32_t* dma_stream_enable(DMA_F4_TypeDef* dma, uint8_t stream)
08031192  {
08031192      uint32_t stream_1 = (uint32_t)stream;
080311ac      *(uint32_t*)(&dma->S + 0x18 * (uint32_t)(uint8_t)stream_1) =
080311ac          *(uint32_t*)(&dma->S + 0x18 * stream_1) | 1;
080311ae      return &dma->S + 0x18 * (uint32_t)(uint8_t)stream_1;
08031192  }
080311b0    uint32_t* dma_stream_disable(DMA_F4_TypeDef* dma, uint8_t stream)
080311b0  {
080311b0      uint32_t stream_1 = (uint32_t)stream;
080311ca      *(uint32_t*)(&dma->S + 0x18 * (uint32_t)(uint8_t)stream_1) =
080311ca          *(uint32_t*)(&dma->S + 0x18 * stream_1) >> 1 << 1;
080311cc      return &dma->S + 0x18 * (uint32_t)(uint8_t)stream_1;
080311b0  }
080311ce    int32_t* dma_set_priority(DMA_F4_TypeDef* dma, uint8_t stream, uint8_t prio)
080311ce  {
080311ce      uint32_t stream_1 = (uint32_t)stream;
080311ee      *(uint32_t*)(&dma->S + 0x18 * (uint32_t)(uint8_t)stream_1) =
080311ee          (*(uint32_t*)(&dma->S + 0x18 * stream_1) & 0xf1ffffff) | (uint32_t)prio << 0x19;
080311f0      return &dma->S + 0x18 * (uint32_t)(uint8_t)stream_1;
080311ce  }
080311f2                                                        00 00                                                        ..
080311f4    int32_t nvic_set_priority_grouping(uint32_t prigroup_bits)
080311f4  {
080311f6      int32_t result = prigroup_bits | 0x5fa0000;
080311fa      *(uint32_t*)0xe000ed0c = result;
080311fc      return result;
080311f4  }
080311fe    int32_t nvic_enable_irq_with_priority(uint8_t irqn, uint8_t preempt_prio, uint8_t sub_prio)
080311fe  {
08031202      int32_t r4 = 0;
08031204      int32_t r3 = 0;
08031204      
08031212      if ((*(uint32_t*)0xe000ed0c & 0x700) == 0x700)
08031212      {
08031214          r4 = 0;
08031216          r3 = 4;
08031212      }
08031212      else if ((*(uint32_t*)0xe000ed0c & 0x700) == 0x600)
08031226      {
08031228          r4 = 1;
0803122a          r3 = 3;
08031226      }
08031226      else if ((*(uint32_t*)0xe000ed0c & 0x700) == 0x500)
0803123a      {
0803123c          r4 = 2;
0803123e          r3 = 2;
0803123a      }
0803123a      else if ((*(uint32_t*)0xe000ed0c & 0x700) == 0x400)
0803124e      {
08031250          r4 = 3;
08031252          r3 = 1;
0803124e      }
0803124e      else if ((*(uint32_t*)0xe000ed0c & 0x700) == 0x300)
08031262      {
08031264          r4 = 4;
08031266          r3 = 0;
08031262      }
08031262      
08031284      uint32_t irqn_1 = (uint32_t)irqn;
08031286      *(uint8_t*)(0xe000e400 + irqn_1) = (char)(((uint32_t)preempt_prio << (4 - r4)
08031286          | (0xf >> (4 - r3) & (uint32_t)sub_prio)) << 4);
08031294      int32_t result = (uint32_t)(uint8_t)irqn_1 >> 5;
08031296      *(uint32_t*)(0xe000e100 + (result << 2)) = 1 << (irqn_1 & 0x1f);
0803129c      return result;
080311fe  }
0803129e    int32_t nvic_disable_irq(uint8_t irqn)
0803129e  {
080312aa      int32_t result = (uint32_t)irqn >> 5;
080312ac      *(uint32_t*)(0xe000e180 + (result << 2)) = 1 << (irqn & 0x1f);
080312b0      return result;
0803129e  }
080312b2    int32_t setupVtor(int32_t arg1, int32_t arg2)
080312b2  {
080312b6      int32_t result = arg1 | (arg2 & 0x1fffff80);
080312ba      (*(uint32_t*)SCB_VTOR) = result;
080312bc      return result;
080312b2  }
080312be                                                                                            00 00                                ..
080312c0  int32_t data_80312c0 = 0x5fa0000
080312c4  int32_t data_80312c4 = -0x1fff12f4
080312c8  int32_t data_80312c8 = -0x1fff1c00
080312cc  int32_t data_80312cc = -0x1fff1f00
080312d0  int32_t data_80312d0 = -0x1fff1e80
080312d4  int32_t data_80312d4 = 0x1fffff80
080312d8  int32_t data_80312d8 = -0x1fff12f8
080312dc    int32_t sub_80312dc()
080312dc  {
080312e4      rcc_enable_by_code(0xc01);
080312ec      rcc_enable_by_code(0x100e);
080312fa      sub_80304da(&GPIOB, 5, 0xe000);
0803130a      gpio_config_mode_pull(&GPIOB, 2, 0, 0xe000);
0803131a      gpio_config_otype_speed(&GPIOB, 0, 2, 0xe000);
0803132a      gpio_config_mode_pull(&GPIOB, 1, 0, 0x1000);
0803133a      gpio_config_otype_speed(&GPIOB, 0, 2, 0x1000);
08031346      sub_80304ac(&GPIOB, 0x1000);
0803134c      int32_t var_1c = 0;
08031352      int32_t var_20 = 0x104;
08031356      int32_t var_18 = 0;
0803135a      int32_t var_c = 0;
08031360      int32_t var_14 = 0x200;
08031364      int32_t var_8 = 0x20;
08031368      int32_t var_10 = 0;
08031370      sub_80365fc(0x40003800, &var_20);
0803137a      sub_803665c(0x40003800, 7);
08031382      sub_8036632(0x40003800);
08031388      return 0x40003800;
080312dc  }
0803138a    int32_t camlink_select_base(int32_t arg1)
0803138a  {
0803138e      int32_t r7;
0803138e      sub_80315e4(r7);
0803139a      sub_80304b2(&GPIOB, 0x1000);
080313a0      sub_80315b2(0x20);
080313a8      sub_80315b2((char)(arg1 >> 0x10));
080313b0      sub_80315b2((char)(arg1 >> 8));
080313b8      sub_80315b2((uint8_t)arg1);
080313c4      sub_80304ac(&GPIOB, 0x1000);
080313cc      return sub_8031602(r7);
0803138a  }
080313ce    int32_t sub_80313ce(char* arg1, int32_t arg2, int32_t arg3)
080313ce  {
080313d0      char* r4 = arg1;
080313d4      int32_t r6 = arg3;
080313d6      int32_t r7;
080313d6      sub_80315e4(r7);
080313e2      sub_80304b2(&GPIOB, 0x1000);
080313e8      sub_80315b2(2);
080313f0      sub_80315b2((char)(arg2 >> 0x10));
080313f8      sub_80315b2((char)(arg2 >> 8));
08031400      sub_80315b2((uint8_t)arg2);
08031400      
0803140e      while (true)
0803140e      {
0803140e          int32_t r0_7 = r6;
08031410          r6 = r0_7 - 1;
08031410          
08031416          if (!(uint32_t)(uint16_t)r0_7)
08031416              break;
08031416          
08031408          sub_80315b2(*(uint8_t*)r4);
0803140c          r4 = &r4[1];
0803140e      }
0803140e      
08031420      sub_80304ac(&GPIOB, 0x1000);
08031428      return sub_8031602(r7);
080313ce  }
0803142a    uint32_t camlink_write(char* arg1, int32_t arg2, int16_t arg3)
0803142a  {
0803142e      char* r5 = arg1;
08031430      int32_t r4 = arg2;
0803143e      char r0 = (uint8_t)r4;
08031442      uint32_t r2 = (uint32_t)arg3;
08031448      char r7 = (char)(r2 / 0x100);
0803144c      uint32_t r2_1 = (uint32_t)(uint16_t)r2;
0803144c      
0803145e      if (!(uint32_t)r0)
0803145e      {
08031460          uint32_t r7_1 = (uint32_t)r7;
08031460          
08031464          if (r7_1)
08031464          {
08031488              while (true)
08031488              {
08031488                  uint32_t r0_4 = r7_1;
0803148a                  r7_1 = r0_4 - 1;
0803148a                  
08031490                  if (!(uint32_t)(uint8_t)r0_4)
08031490                      break;
08031490                  
0803147a                  sub_80313ce(r5, r4, 0x100);
0803147e                  r4 += 0x100;
08031486                  r5 = &r5[0x100];
08031488              }
08031488              
0803149e              char r8;
0803149e              return sub_80313ce(r5, r4, (uint32_t)r8);
08031464          }
08031464          
0803146c          return sub_80313ce(r5, r4, (uint32_t)(uint16_t)r2_1);
0803145e      }
0803145e      
080314a8      if (!(uint32_t)r7)
080314a8      {
080314b4          if ((uint32_t)(0 - r0) >= (uint32_t)(uint8_t)r2_1)
080314e6              return sub_80313ce(r5, r4, (uint32_t)(uint16_t)r2_1);
080314e6          
080314ba          uint16_t r6_1 = (uint16_t)(0 - r0);
080314c4          sub_80313ce(r5, r4, (uint32_t)r6_1);
080314da          return sub_80313ce(&r5[(uint32_t)(uint8_t)r6_1], r4 + (uint32_t)(uint8_t)r6_1, 
080314da              (uint32_t)((uint8_t)r2_1 - (0 - r0)));
080314a8      }
080314a8      
080314ec      uint16_t r6_3 = (uint16_t)(0 - r0);
080314f0      uint32_t r2_11 = (uint32_t)((uint16_t)r2_1 - r6_3);
080314f6      int32_t r7_5 = r2_11 / 0x100;
08031508      uint16_t r6_4 = (uint16_t)(uint8_t)r6_3;
08031512      sub_80313ce(r5, r4, (uint32_t)r6_4);
08031516      int32_t r4_2 = r4 + (uint32_t)(uint8_t)r6_4;
0803151c      void* r5_2 = &r5[(uint32_t)(uint8_t)r6_4];
08031536      uint32_t result;
08031536      
08031536      while (true)
08031536      {
08031536          int32_t r0_14 = r7_5;
08031538          r7_5 = r0_14 - 1;
0803153a          result = (uint32_t)(uint8_t)r0_14;
0803153a          
0803153e          if (!result)
0803153e              break;
0803153e          
08031528          sub_80313ce(r5_2, r4_2, 0x100);
0803152c          r4_2 += 0x100;
08031534          r5_2 += 0x100;
08031536      }
08031536      
08031540      uint32_t r8_3 = (uint32_t)((int16_t)r2_11);
08031540      
08031548      if (!r8_3)
0803155a          return result;
0803155a      
08031556      return sub_80313ce(r5_2, r4_2, (uint32_t)(uint8_t)r8_3);
0803142a  }
0803155e    int32_t* sub_803155e(char* arg1, int32_t arg2, int32_t arg3)
0803155e  {
08031560      char* r4 = arg1;
08031564      int32_t r6 = arg3;
0803156e      sub_80304b2(&GPIOB, 0x1000);
08031574      sub_80315b2(3);
0803157c      sub_80315b2((char)(arg2 >> 0x10));
08031584      sub_80315b2((char)(arg2 >> 8));
0803158c      sub_80315b2((uint8_t)arg2);
0803158c      
0803159c      while (true)
0803159c      {
0803159c          int32_t r0_7 = r6;
0803159e          r6 = r0_7 - 1;
0803159e          
080315a4          if (!(uint32_t)(uint16_t)r0_7)
080315a4              break;
080315a4          
08031598          *(uint8_t*)r4 = sub_80315b2(0xa5);
0803159a          r4 = &r4[1];
0803159c      }
0803159c      
080315b0      return sub_80304ac(&GPIOB, 0x1000);
0803155e  }
080315b2    uint32_t sub_80315b2(char arg1)
080315b2  {
080315c0      int32_t i;
080315c0      
080315c0      do
080315ba          i = sub_803664c(0x40003800, 2);
080315c0       while (!i);
080315ca      sub_803663c(0x40003800, (uint16_t)arg1);
080315d8      int32_t i_1;
080315d8      
080315d8      do
080315d2          i_1 = sub_803664c(0x40003800, 1);
080315d8       while (!i_1);
080315e2      return (uint32_t)sub_8036644(0x40003800);
080315b2  }
080315e4    int32_t sub_80315e4(int32_t arg1 @ r7)
080315e4  {
080315ec      sub_80304b2(&GPIOB, 0x1000);
080315f2      sub_80315b2(6);
080315fc      sub_80304ac(&GPIOB, 0x1000);
08031600      return arg1;
080315e4  }
08031602    int32_t sub_8031602(int32_t arg1 @ r7)
08031602  {
0803160c      sub_80304b2(&GPIOB, 0x1000);
08031612      sub_80315b2(5);
08031620      uint32_t i;
08031620      
08031620      do
0803161e          i = (uint32_t)sub_80315b2(0xa5) << 0x1f;
08031620       while (i < 0);
08031628      sub_80304ac(&GPIOB, 0x1000);
0803162c      return arg1;
08031602  }
0803162e                                            00 00                                                                ..
08031630  int32_t data_8031630 = 0x40020400
08031634  int32_t data_8031634 = 0x40003800
08031638    int32_t sub_8031638(void* arg1, int32_t arg2, int32_t arg3)
08031638  {
08031642      uint32_t r0 = sub_80302ee(2);
08031648      uint32_t r1 = r0 / 0xf4240;
08031648      
0803164e      if (r1 >= 0x3f)
08031650          r1 = 0x3f;
08031650      
0803165e      *(uint32_t*)((char*)arg1 + 4) |= r1 & 0x3f;
08031664      int32_t result;
08031664      
08031664      if (arg2 >= 0x186a1)
08031664      {
080316d8          *(uint32_t*)((char*)arg1 + 0x20) |= (uint32_t)((int16_t)(0x12c * r1 / 0x3e8) + 1);
080316dc          uint32_t r0_5;
080316dc          
080316dc          if (arg3)
080316dc          {
080316f6              r0_5 = (uint32_t)(uint16_t)(r0 / (0x19 * arg2));
08031706              *(uint32_t*)((char*)arg1 + 0x1c) |= 0x4000;
080316dc          }
080316dc          else
080316e8              r0_5 = (uint32_t)(uint16_t)(r0 / (3 * arg2));
080316e8          
0803170a          if (!(r0_5 << 0x14))
0803170c              r0_5 |= 1;
0803170c          
08031716          result = r0_5 | *(uint32_t*)((char*)arg1 + 0x1c);
0803171c          *(uint32_t*)((char*)arg1 + 0x1c) = result;
08031664      }
08031664      else
08031664      {
08031670          if (r0 / 0xf4240 + 1 < 0x3f)
08031698              *(uint32_t*)((char*)arg1 + 0x20) |= r0 / 0xf4240 + 1;
08031670          else
08031680              *(uint32_t*)((char*)arg1 + 0x20) |= 0x3f;
08031680          
0803169c          uint32_t r0_1 = r0 / (arg2 << 1);
0803169c          
080316a2          if (r0_1 < 4)
080316a4              r0_1 = 4;
080316a4          
080316b0          result = r0_1 << 0x14 >> 0x14 | *(uint32_t*)((char*)arg1 + 0x1c);
080316b6          *(uint32_t*)((char*)arg1 + 0x1c) = result;
08031664      }
08031664      
0803171e      return result;
08031638  }
08031720  00 00 00 00                                                                                      ....
08031724  int32_t data_8031724 = 0xf4240
08031728  int32_t data_8031728 = 0x186a1
0803172c    void* sub_803172c(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
0803172c  {
08031738      *(uint32_t*)arg1 = (*(uint32_t*)arg1 & 0xfffffffd) | arg2;
08031740      arg1[2] = arg4 | arg3;
08031744      return &arg1[2];
0803172c  }
08031746    void sub_8031746(int32_t* arg1, char arg2)
08031746  {
0803174a      if ((uint32_t)arg2 != 1)
0803175c          *(uint32_t*)arg1 &= 0xfffffbff;
0803174a      else
08031752          *(uint32_t*)arg1 |= 0x400;
08031746  }
08031760    void sub_8031760(int32_t* arg1, char arg2)
08031760  {
08031764      if ((uint32_t)arg2)
08031776          *(uint32_t*)arg1 &= 0xfffff7ff;
08031764      else
0803176c          *(uint32_t*)arg1 |= 0x800;
08031760  }
0803177a    uint32_t* sub_803177a(void* arg1, char arg2, int32_t arg3)
0803177a  {
0803177e      char r1;
0803177e      
0803177e      r1 = arg3 != 0xfffffffe ? arg2 | 1 : arg2 & 0xfe;
0803177e      
0803178e      *(uint32_t*)((char*)arg1 + 0x10) = (uint32_t)r1;
08031790      return (char*)arg1 + 0x10;
0803177a  }
08031792    void sub_8031792(int32_t* arg1)
08031792  {
08031798      *(uint32_t*)arg1 |= 1;
08031792  }
0803179c    void sub_803179c(int32_t* arg1)
0803179c  {
080317a2      *(uint32_t*)arg1 |= 0x100;
0803179c  }
080317a6    void sub_80317a6(int32_t* arg1)
080317a6  {
080317ac      *(uint32_t*)arg1 |= 0x200;
080317a6  }
080317b0    uint32_t* sub_80317b0(void* arg1, char arg2)
080317b0  {
080317b4      *(uint32_t*)((char*)arg1 + 0x10) = (uint32_t)arg2;
080317b6      return (char*)arg1 + 0x10;
080317b0  }
080317b8    uint32_t sub_80317b8(void* arg1)
080317b8  {
080317be      return (uint32_t)(uint8_t)*(uint32_t*)((char*)arg1 + 0x10);
080317b8  }
080317c0    uint32_t sub_80317c0(void* arg1, int32_t arg2)
080317c0  {
080317cc      char r2_1;
080317cc      
080317cc      if ((arg2 & 0x80000000) != 0x80000000)
080317cc      {
080317e8          if (!((*(uint32_t*)((char*)arg1 + 0x14) & arg2) << 0x10))
080317ee              r2_1 = 0;
080317e8          else
080317ea              r2_1 = 1;
080317cc      }
080317cc      else if (!((*(uint32_t*)((char*)arg1 + 0x18) & arg2) << 0x10))
080317dc          r2_1 = 0;
080317d6      else
080317d8          r2_1 = 1;
080317d8      
080317f4      return (uint32_t)r2_1;
080317c0  }
080317f6    void* sub_80317f6(void* arg1, int32_t arg2)
080317f6  {
080317f8      if (arg2 == 2)
080317f8      {
080317fe          *(uint32_t*)((char*)arg1 + 0x14);
08031802          return *(uint32_t*)((char*)arg1 + 0x18);
080317f8      }
080317f8      
08031810      void* result = (char*)arg1 + 0x14;
08031812      *(uint32_t*)result = *(uint32_t*)((char*)arg1 + 0x14) & ~arg2;
08031814      return result;
080317f6  }
08031816                                                                    00 00                                                ..
08031818    int32_t sub_8031818(int64_t arg1 @ q0)
08031818  {
08031818      int32_t r0;
08031818      int32_t r1_1;
08031818      r1_1 = HIGHD(arg1);
08031818      r0 = LOWD(arg1);
0803181e      int32_t result;
0803181e      int32_t r1;
0803181e      result = sub_8031828(r0, r1_1);
08031826      return result;
08031818  }
08031828    void sub_8031828(int32_t arg1, int32_t arg2)
08031828  {
0803182c      uint32_t r3 = arg2 >> 0x14;
0803182e      int32_t var_8_1;
0803182e      int32_t var_4_1;
0803182e      int32_t r1_1;
0803182e      int32_t r4;
0803182e      int32_t r5;
0803182e      
0803182e      if (!r3)
0803182e      {
080318d0          if (arg1 | arg2)
080318d0          {
080318d2              var_4_1 = r5;
080318d2              var_8_1 = r4;
080318d4              __clz(arg2);
080318d4              
080318d8              if (!arg2)
080318da                  __clz(arg1);
080318da              
080318e2              int32_t r3_3;
080318e2              uint32_t r4_4 = r3_3 - 0x2b;
080318e2              
080318e6              if (r3_3 - 0xb >= 0x20)
080318e8                  r1_1 = arg1 << r4_4;
080318e6              else
080318e6              {
080318ec                  r1_1 = arg2 << (r3_3 - 0xb);
080318f2                  r4_4 = arg1 >> (0x20 - (r3_3 - 0xb));
080318e6              }
080318e6              
080318f6              if (r3_3 - 0xb < 0x20)
080318f8                  r1_1 |= r4_4;
080318f8              
080318fa              arg1 <<= r3_3 - 0xb;
080318e6              goto label_8031846;
080318d0          }
0803182e      }
0803182e      else if (r3 < 0x7ff)
08031832      {
08031834          var_4_1 = r5;
08031834          var_8_1 = r4;
0803183a          r1_1 = (arg2 & ~(r3 << 0x14)) | 0x100000;
08031846      label_8031846:
08031846          
08031846          if (TEST_BIT(r3 + 0x3fd, 0))
08031846          {
08031848              int32_t temp2_1 = arg1;
08031848              int32_t temp3_1 = arg1;
08031848              arg1 *= 2;
0803184a              r1_1 = r1_1 + r1_1;
08031846          }
08031846          
0803184e          int32_t r1_3 = r1_1 << 2 | arg1 >> 0x1e;
08031852          int32_t r0 = arg1 << 2;
08031854          int32_t r4_1 = 0x300000;
08031858          int32_t r3_1 = 0;
0803185a          uint32_t r2_1 = 0x80000000;
0803185c          uint32_t r5_1 = 0x100000;
0803185e          int32_t i = r1_3 - 0x900000;
0803185e          
08031862          if (r1_3 - 0x900000 < 0)
08031862              goto label_8031874;
08031862          
08031864          while (true)
08031864          {
08031864              uint32_t temp5_1 = r5_1;
08031864              r5_1 u>>= 1;
08031864              
08031866              if (TEST_BIT(temp5_1, 0))
08031866                  break;
08031866              
08031868              int32_t r1_4 = i - r4_1;
0803186a              r4_1 += r5_1;
0803186c              int32_t temp19_1 = r0;
0803186c              int32_t temp20_1 = r0;
0803186c              r0 *= 2;
0803186e              int32_t r1_5 = r1_4 + r1_4;
08031870              i = r1_5 - r5_1;
08031870              
08031872              if (r1_5 - r5_1 < 0)
08031872              {
08031874              label_8031874:
08031874                  uint32_t temp4_1 = r5_1;
08031874                  r5_1 u>>= 1;
08031874                  
08031876                  if (TEST_BIT(temp4_1, 0))
08031876                      goto label_803188e;
08031876                  
08031878              label_8031878:
08031878                  int32_t r1_6 = i + r4_1;
0803187a                  r4_1 -= r5_1;
0803187c                  int32_t temp11_1 = r0;
0803187c                  int32_t temp12_1 = r0;
0803187c                  r0 *= 2;
0803187e                  int32_t r1_7 = r1_6 + r1_6;
08031880                  i = r1_7 - r5_1;
08031880                  
08031882                  if (r1_7 - r5_1 < 0)
08031882                  {
08031884                      uint32_t temp22_1 = r5_1;
08031884                      r5_1 u>>= 1;
08031884                      
08031886                      if (!TEST_BIT(temp22_1, 0))
08031886                          goto label_8031878;
08031886                      
08031886                      goto label_803188e;
08031882                  }
08031872              }
08031864          }
08031864          
080318a4          while (true)
080318a4          {
080318a4              int32_t r0_3 = r0 - r3_1;
080318a6              int32_t r1_10 = i - r4_1;
080318a8              int32_t temp15_1 = r3_1;
080318a8              r3_1 += r2_1;
080318aa              r4_1 = r4_1 + r5_1;
080318ac              int32_t r0_4 = r0_3 * 2;
080318b0              r0 = r0_4 - r2_1;
080318b2              i = r1_10 + r1_10 - r5_1;
080318b2              
080318b4              if (i < 0)
080318b4              {
0803189e                  do
0803189e                  {
0803188a                      r2_1 u>>= 1;
0803188a                      
0803188c                      if (!r2_1)
080318ca                          return;
080318ca                      
0803188e                  label_803188e:
0803188e                      int32_t r0_1 = r0 + r3_1;
08031890                      int32_t r1_8 = i + r4_1;
08031892                      int32_t temp7_1 = r3_1;
08031892                      r3_1 -= r2_1;
08031894                      r4_1 = r4_1 - r5_1;
08031896                      int32_t r0_2 = r0_1 * 2;
0803189a                      r0 = r0_2 - r2_1;
0803189c                      i = r1_8 + r1_8 - r5_1;
0803189e                  } while (i < 0);
0803189e                  
080318a0                  r2_1 u>>= 1;
080318a0                  
080318a2                  if (!r2_1)
080318a2                      break;
080318b4              }
080318b4              else
080318b4              {
080318b6                  r2_1 u>>= 1;
080318b6                  
080318b8                  if (!r2_1)
080318b8                      break;
080318b4              }
080318a4          }
08031832      }
08031832      else if (r3 != 0x7ff && (arg2 == 0xfff00000 || arg2 < 0xfff00000) && arg1 | arg2 << 1)
08031914          /* tailcall */
08031914          return sub_803666c(arg1);
08031828  }
08031918    int32_t sub_8031918(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
08031918  {
08031918      int32_t lr;
08031918      int32_t var_4 = lr;
08031918      int32_t var_10 = arg4;
0803191a      int32_t var_14 = arg4;
0803191a      int32_t var_1c = arg2;
08031920      int32_t r0_1 = sub_8036678(arg3, var_14);
0803192a      int32_t result = sub_8036678(arg1, var_1c);
0803192e      bool cond:0 = r0_1 >= 1;
0803192e      
08031930      if (r0_1 < 1)
08031932          cond:0 = result >= 1;
08031932      
08031934      int32_t r4;
08031934      int64_t q0;
08031934      
08031934      if (cond:0)
08031934      {
08031998          bool cond:1_1 = result == 2;
08031998          
0803199a          if (result == 2)
0803199c              result = arg1;
0803199c          
080319a0          if (!cond:1_1 && r0_1 == 2)
080319a6              result = arg3;
080319a6          
080319aa          if (cond:1_1 || r0_1 == 2)
080319e6              return result;
080319e6          
080319b0          q0 = r0_1 == result ? 0 : 0;
080319b0          
080319be          r4 = var_1c < 0 ? 8 : 0;
080319be          
080319c6          if (var_14 < 0)
080319c8              r4 ^= 6;
080319c8          
080319ce          if (result == 1)
080319d0              r4 ^= 2;
08031934      }
08031934      else
08031934      {
0803193a          if (var_1c >= 0)
0803194c              r4 = 0;
0803193a          else
0803193a          {
08031944              var_1c ^= 0x80000000;
08031948              r4 = 8;
0803193a          }
0803193a          
08031950          bool cond:5_1 = var_14 >= 0;
08031950          
08031952          if (var_14 < 0)
08031952          {
0803195c              var_14 ^= 0x80000000;
08031960              r4 ^= 6;
08031952          }
08031952          
0803196c          sub_8031ac8(arg3, var_14, arg1, var_1c);
0803196c          
08031970          if (!cond:5_1)
08031970          {
08031972              int32_t r0_8;
08031972              int32_t r1_7;
08031972              r0_8 = soft_dadd(arg1, arg3);
08031976              q0 = (r1_7 << 32) | r0_8;
080319d0              r4 ^= 2;
08031970          }
08031970          else if (r0_1 >= 0)
08031992              q0 = 0;
0803197e          else
0803197e          {
08031988              int32_t r0_10;
08031988              int32_t r1_9;
08031988              r0_10 = soft_dadd(arg1, arg3);
0803198c              q0 = (r1_9 << 32) | r0_10;
0803197e          }
08031934      }
08031934      
080319dc      int32_t r0_11;
080319dc      int32_t r1_14;
080319dc      r1_14 = HIGHD(q0);
080319dc      r0_11 = LOWD(q0);
080319e0      int128_t q4;
080319e0      /* tailcall */
080319e0      return sub_80366b8(r0_11, r1_14, r4, q4);
08031918  }
080319e8                          00 00                                                                            ..
080319ea  int32_t data_80319ea = 0x0
080319ee                                            00 00 00 00                                                          ....
080319f2  int32_t data_80319f2 = 0x0
080319f6                                                                    f0 3f                                                .?
080319f8    int32_t sub_80319f8(int32_t arg1 @ r7, int128_t arg2 @ q0)
080319f8  {
080319fa      int32_t r2;
080319fa      int32_t r3;
080319fa      r3 = HIGHD(*(uint64_t*)((char*)arg2)[8]);
080319fa      r2 = LOWD(*(uint64_t*)((char*)arg2)[8]);
080319fe      int32_t r0;
080319fe      int32_t r1;
080319fe      r1 = HIGHD((uint64_t)arg2);
080319fe      r0 = LOWD((uint64_t)arg2);
08031a02      int32_t r0_1;
08031a02      int32_t r1_1;
08031a02      int128_t q0;
08031a02      r0_1 = sub_8031918(r0, r1, r2, r3);
08031a06      (uint64_t)q0 = (r1_1 << 32) | r0_1;
08031a0a      return arg1;
080319f8  }
08031a0c    int32_t sub_8031a0c(int32_t arg1, int32_t arg2)
08031a0c  {
08031a0c      int32_t lr;
08031a0c      int32_t var_4 = lr;
08031a0c      int32_t var_c = arg2;
08031a0c      int32_t var_10 = arg1;
08031a1c      int32_t var_14;
08031a1c      int32_t r1 = var_14 >> 0x14 & 0x7ff;
08031a24      bool c = r1 >= 0x7ff;
08031a24      
08031a26      if (r1 != 0x7ff)
08031a26      {
08031a28          if (!r1)
08031a2e              c = /* c = unimplemented  {orrs r0, r1} */;
08031a2e          
08031a30          if (r1 || arg1 | (var_14 & 0xfffff))
08031a30          {
08031a60              sub_8031ac8(var_10, var_c, 0, 0);
08031a64              int32_t r4;
08031a64              
08031a64              if (!c)
08031a64              {
08031a6a                  var_c ^= 0x80000000;
08031a6e                  r4 = 8;
08031a64              }
08031a64              else
08031a70                  r4 = 0;
08031a70              
08031a7a              sub_80360c8(var_10, var_c, 1, 0x3ff00000);
08031a7a              
08031a7e              if (!c)
08031a7e              {
08031a88                  int32_t r0_8;
08031a88                  int32_t r1_9;
08031a88                  r0_8 = soft_dadd(var_10, var_10);
08031a8c                  var_10 = r0_8;
08031a8c                  var_c = r1_9;
08031a90                  r4 ^= 2;
08031a7e              }
08031a7e              
08031aa0              int128_t q4;
08031aa0              /* tailcall */
08031aa0              return sub_80366b8(var_10, var_c, r4, q4);
08031a30          }
08031a26      }
08031a26      else if (!(arg1 | (var_14 & 0xfffff)))
08031a40      {
08031a46          int64_t q0;
08031a46          
08031a46          q0 = var_c < 0 ? 0x54442d18 : 0x54442d18;
08031a46          
08031a50          int32_t r0_4;
08031a50          int32_t r1_4;
08031a50          r1_4 = HIGHD(q0);
08031a50          r0_4 = LOWD(q0);
08031a56          return r0_4;
08031a40      }
08031a40      
08031a38      return var_10;
08031a0c  }
08031aa4  int32_t data_8031aa4 = 0x54442d18
08031aa8                          fb 21 f9 bf                                                                      .!..
08031aac  int32_t data_8031aac = 0x54442d18
08031ab0                                                  fb 21 f9 3f                                                      .!.?
08031ab4  int32_t data_8031ab4 = 0x3ff00000
08031ab8    int32_t sub_8031ab8(int32_t arg1 @ r7, int64_t arg2 @ q0)
08031ab8  {
08031aba      int32_t r0;
08031aba      int32_t r1;
08031aba      r1 = HIGHD(arg2);
08031aba      r0 = LOWD(arg2);
08031abe      int32_t r0_1;
08031abe      int32_t r1_1;
08031abe      int128_t q0;
08031abe      r0_1 = sub_8031a0c(r0, r1);
08031ac2      (uint64_t)q0 = (r1_1 << 32) | r0_1;
08031ac6      return arg1;
08031ab8  }
08031ac8    void sub_8031ac8(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
08031ac8  {
08031acc      int32_t temp0 = arg2 << 1;
08031acc      
08031ad0      if (0x200000 == -(temp0) || 0x200000 + temp0 >= 0x200000)
08031ad6          /* tailcall */
08031ad6          return sub_8031ad8(arg1, arg2, arg3, arg4);
08031ac8  }
08031ad8    void sub_8031ad8(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4) __pure
08031aec  {
08031aec      return;
08031aec  }
08031af6                                                                    00 00                                                ..
08031af8    int32_t sub_8031af8()
08031af8  {
08031af8      int32_t r7;
08031af8      int32_t var_8 = r7;
08031b02      data_2000e37c = sub_8030938(1);
08031b02      
08031b0a      if (!data_2000e37c)
08031b0e          logging_wrapper("Softwdg Mutex error\r\n", &data_2000e37c);
08031b0e      
08031b14      return 1;
08031af8  }
08031b16    int32_t software_mutex(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
08031b16  {
08031b2c      if (rtos_dma_rx_wait_and_service(data_2000e37c, 0xffffffff) != 1)
08031b30          logging_wrapper("Softwdg Mutex Error!!!\r\n");
08031b30      
08031b40      *(uint32_t*)(&data_200004d4 + 0xc * arg1) = TickType_t xTaskGetTickCount(void)();
08031b4c      *(uint32_t*)(0xc * arg1 + 0x200004d8) = arg2;
08031b4c      
08031b5e      if (sub_8030954(data_2000e37c, nullptr, 0, 0) != 1)
08031b62          logging_wrapper("Softwdg Mutex Error!!!\r\n");
08031b62      
08031b66      return arg4;
08031b16  }
08031b68    int32_t sub_8031b68()
08031b68  {
08031b7a      if (rtos_dma_rx_wait_and_service(data_2000e37c, 0xffffffff) != 1)
08031b7e          logging_wrapper("Softwdg Mutex Error!!!\r\n");
08031b7e      
08031b82      int32_t r0_2 = TickType_t xTaskGetTickCount(void)();
08031b82      
08031bc6      for (int32_t i = 0; i < 4; i += 1)
08031bc6      {
08031bd4          int32_t r2_2;
08031bd4          
08031bd4          if (r0_2 >= *(uint32_t*)(&data_200004d4 + 0xc * i))
08031b94              r2_2 = r0_2 - *(uint32_t*)(&data_200004d4 + 0xc * i);
08031bd4          else
08031be6              r2_2 = r0_2 + 0xffffffff - *(uint32_t*)(&data_200004d4 + 0xc * i);
08031be6          
08031ba4          if (*(uint32_t*)(0xc * i + 0x200004d8) < r2_2)
08031ba4          {
08031bb2              *(uint8_t*)(0xc * i + 0x200004dc) = 0;
08031bc0              data_2000e378 |= 1 << i;
08031ba4          }
08031bc6      }
08031bc6      
08031bfa      if (sub_8030954(data_2000e37c, nullptr, 0, 0) != 1)
08031bfe          logging_wrapper("Softwdg Mutex Error!!!\r\n");
08031bfe      
08031c0a      return data_2000e378 & 0xfffffffd;
08031b68  }
08031c0c    int32_t sub_8031c0c(int32_t arg1)
08031c0c  {
08031c14      if (data_2000e378 >> arg1 << 0x1f >= 0)
08031c1a          return 1;
08031c1a      
08031c16      return 0;
08031c0c  }
08031c1e    int32_t sub_8031c1e(int32_t arg1)
08031c1e  {
08031c2a      *(uint8_t*)(0xc * arg1 + 0x200004dc) = 1;
08031c36      int32_t result = data_2000e378 & ~(1 << arg1);
08031c3c      data_2000e378 = result;
08031c3e      return result;
08031c1e  }
08031c40  int32_t data_8031c40 = 0x2000e37c
08031c44  int32_t data_8031c44 = 0x803b9ec
08031c48  int32_t data_8031c48 = 0x803b6b0
08031c4c  int32_t data_8031c4c = 0x200004d4
08031c50  int32_t data_8031c50 = 0x2000e378
08031c54    int32_t* sub_8031c54(int32_t arg1, int32_t arg2)
08031c54  {
08031c54      int32_t r3;
08031c54      int32_t var_10 = r3;
08031c5c      int32_t* result = sub_8032108(0x14);
08031c5c      
08031c62      if (!result)
08031c62      {
08031c66          logging_wrapper("[createQueue]CRITICAL_ERROR_LACK_OF_MEMORY\n");
08031c6a          return nullptr;
08031c62      }
08031c62      
08031c6e      *(uint32_t*)result = arg1;
08031c70      result[2] = arg2;
08031c74      result[4] = 0;
08031c78      result[3] = result[4];
08031c7c      result[1] = 0;
08031c7e      return result;
08031c54  }
08031c80    int32_t* sub_8031c80(int32_t* arg1, char* arg2)
08031c80  {
08031c80      int32_t r3;
08031c80      int32_t var_18 = r3;
08031c80      
08031c8e      if (!arg1 || !arg2)
08031c90          return nullptr;
08031c90      
08031ca0      if (arg1[1] == *(uint32_t*)arg1 && *(uint32_t*)arg1)
08031ca6          sub_8031d12(arg1, nullptr);
08031ca6      
08031cac      int32_t* result = sub_8032108(0xc);
08031cac      
08031cb4      if (!result)
08031cb4      {
08031cb8          logging_wrapper("[enqueue]CRITICAL_ERROR_LACK_OF_MEMORY\n");
08031cbc          return nullptr;
08031cb4      }
08031cb4      
08031cc6      *(uint32_t*)result = sub_8032108(arg1[2]);
08031cc6      
08031ccc      if (!*(uint32_t*)result)
08031ccc      {
08031cd0          logging_wrapper("[enqueue]CRITICAL_ERROR_LACK_OF_MEMORY\n");
08031cd4          return nullptr;
08031ccc      }
08031ccc      
08031ce0      memcpy_(*(uint32_t*)result, arg2, arg1[2]);
08031ce0      
08031ce8      if (!*(uint32_t*)result)
08031cea          return nullptr;
08031cea      
08031cf2      if (!arg1[1])
08031cf2      {
08031d02          result[1] = arg1[3];
08031d04          arg1[3] = result;
08031d06          arg1[4] = result;
08031cf2      }
08031cf2      else
08031cf2      {
08031cf6          result[1] = arg1[3];
08031cfa          *(uint32_t*)(result[1] + 8) = result;
08031cfc          arg1[3] = result;
08031cf2      }
08031cf2      
08031d0c      arg1[1] += 1;
08031d0e      return result;
08031c80  }
08031d12    int32_t sub_8031d12(void* arg1, char* arg2)
08031d12  {
08031d1c      if (!arg1)
08031d1e          return 0;
08031d1e      
08031d26      if (!*(uint32_t*)((char*)arg1 + 4))
08031d28          return 0;
08031d28      
08031d2c      int32_t* r5_1 = *(uint32_t*)((char*)arg1 + 0x10);
08031d2c      
08031d30      if (arg2)
08031d38          memcpy_(arg2, *(uint32_t*)r5_1, *(uint32_t*)((char*)arg1 + 8));
08031d38      
08031d40      if (*(uint32_t*)((char*)arg1 + 4) != 1)
08031d40      {
08031d50          *(uint32_t*)((char*)arg1 + 0x10) =
08031d50              *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x10) + 8);
08031d56          *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x10) + 4) = 0;
08031d40      }
08031d40      else
08031d40      {
08031d44          *(uint32_t*)((char*)arg1 + 0xc) = 0;
08031d48          *(uint32_t*)((char*)arg1 + 0x10) = 0;
08031d40      }
08031d40      
08031d5a      sub_8032214(*(uint32_t*)r5_1);
08031d60      sub_8032214(r5_1);
08031d68      *(uint32_t*)((char*)arg1 + 4) -= 1;
08031d6a      return 1;
08031d12  }
08031d6e                                            00 00                                                                ..
08031d70  int32_t data_8031d70 = 0x803ad80
08031d74  int32_t data_8031d74 = 0x803aec8
08031d78    uint32_t sub_8031d78(void* arg1)
08031d78  {
08031d7c      char r0;
08031d7c      
08031d7c      if (*(uint32_t*)((char*)arg1 + 4))
08031d82          r0 = 0;
08031d7c      else
08031d7e          r0 = 1;
08031d7e      
08031d86      return (uint32_t)r0;
08031d78  }
08031d88    int32_t sub_8031d88(void* arg1, int32_t arg2, char* arg3)
08031d88  {
08031d92      if (!arg1)
08031d94          return 0;
08031d94      
08031da2      if (!*(uint32_t*)((char*)arg1 + 4) || arg2 >= *(uint32_t*)((char*)arg1 + 4))
08031da4          return 0;
08031da4      
08031da8      int32_t* r3_1 = *(uint32_t*)((char*)arg1 + 0xc);
08031da8      
08031db4      for (int32_t i = 0; i < arg2; i += 1)
08031dae          r3_1 = r3_1[1];
08031dae      
08031dbc      memcpy_(arg3, *(uint32_t*)r3_1, *(uint32_t*)((char*)arg1 + 8));
08031dc0      return 1;
08031d88  }
08031dc4    int32_t j_sub_80168a8(int32_t arg1, int32_t arg2)
08031dc4  {
08031dc6      /* tailcall */
08031dc6      return sub_80368a8(arg1, arg2, 0);
08031dc4  }
08031dca                                00 00                                                                        ..
08031dcc    int32_t CreateModeTask()
08031dcc  {
08031de4      rtos_xTaskCreate(ModeTask, "ModeTask", 0x1f4, nullptr, 4, nullptr);
08031dea      return 1;
08031dcc  }
08031dec    void ModeTask(void* ctx) __noreturn
08031dec  {
08031dec      int32_t entry_r1;
08031dec      int32_t var_2c = entry_r1;
08031dec      void* ctx_1 = ctx;
08031df4      int32_t r4 = TickType_t xTaskGetTickCount(void)();
08031df8      mode_post_event(0);
08031dfc      int32_t total = 0;
08031dfe      int32_t activeA = 0;
08031e00      int32_t activeB = 0;
08031e04      uint32_t r5 = 0;
08031e04      
08031e2e      while (true)
08031e2e      {
08031e2e          int32_t r0_5 = TickType_t xTaskGetTickCount(void)();
08031e36          int32_t r10_1;
08031e36          
08031e36          r10_1 = r0_5 >= r4 ? r0_5 - r4 : r0_5 + 0xffffffff - r4;
08031e36          
08031e4c          logging_wrapper("t: %d\r\n", r10_1);
08031e50          r4 = r0_5;
08031e52          int32_t r0_7 = driveSubsystemState();
08031e58          uint32_t r0_8;
08031e58          
08031e58          if (r0_7 != 2)
08031e5c              r0_8 = isDriveSubsystemReady(2);
08031e5c          
08031e62          if (r0_7 == 2 || r0_8 == 2)
08031e64              activeA += r10_1;
08031e64          
08031e70          if (isDriveSubsystemReady(2) == 2)
08031e72              activeB += r10_1;
08031e72          
08031e76          total += r10_1;
08031e7c          r5 = (uint32_t)((uint16_t)r5 + 1);
08031e7c          
08031e80          if (r5 >= 0xc9)
08031e80          {
08031e88              stats_publish(total, activeA, activeB);
08031e8c              r5 = 0;
08031e8e              total = 0;
08031e90              activeA = 0;
08031e92              activeB = 0;
08031e80          }
08031e80          
08031e96          watchdog_kick();
08031e96          
08031ea0          if (sub_8031b68() && sub_8028bf2() != 2 && !sub_802fca8())
08031ea0          {
08031eb4              logging_wrapper(sub_803af88+0x50);
08031eba              mode_post_event(7);
08031ea0          }
08031ea0          
08031ebe          int32_t r3;
08031ebe          int128_t q4;
08031ebe          r3 = sub_802a108(q4);
08031ec2          char r0_14 = sub_802a09c();
08031ec2          
08031ece          if (sub_8028bf2() != 2)
08031ece          {
08031ed0              uint32_t r0_16;
08031ed0              r0_16 = sub_803203a();
08031ed0              
08031ed6              if (r0_16 == 1 && !sub_802fca8())
08031ed6              {
08031ee2                  logging_wrapper("[error]HardwareState error\n");
08031ee8                  r3 = mode_post_event(7);
08031ed6              }
08031ece          }
08031ece          
08031eec          uint32_t r9_3 = (uint32_t)r0_14;
08031ef4          int32_t entry_r3;
08031ef4          
08031ef4          if (r9_3 == 0xa)
08031ef4          {
08031efc              if (!(uint32_t)(uint8_t)entry_r3)
08031f04                  sub_80282e4(0x93, 0, 1, r3, r5);
08031f04              
08031f0a              mode_post_event(9);
08031ef4          }
08031ef4          
08031f10          sub_8033e3c(&var_2c);
08031f1a          uint32_t currentModeIndex_1 = (uint32_t)g_currentModeIndex;
08031f1a          
08031f22          if (!currentModeIndex_1)
08031f22          {
08031f2c              data_2000e445 += 1;
08031f2c              
08031f34              if ((uint32_t)data_2000e445 >= 5)
08031f34              {
08031f3a                  data_2000e445 = 0;
08031f40                  ui_led_heartbeat(0, 1);
08031f34              }
08031f22          }
08031f22          
08031f48          ui_set_mode_indicator((uint32_t)(uint8_t)currentModeIndex_1);
08031f5c          logging_wrapper("Mode : %s\r\n", 
08031f5c              *(uint32_t*)(0x14 * (uint32_t)g_currentModeIndex + 0x2000037c), 0x14);
08031f68          int32_t r1_8 = 0x14 * (uint32_t)g_currentModeIndex;
08031f70          int32_t entry_r2;
08031f70          
08031f70          if (!*(uint32_t*)(r1_8 + 0x20000380))
08031f70          {
08031e0a              logging_wrapper("Error No Mode Logic Func\r\n", r1_8, 0x14);
08031e10              rtos_delay_ticks(0x32);
08031f70          }
08031f70          else
08031f9c              currentModeIndex_1 = (
08031f9c                  *(uint32_t*)(0x14 * (uint32_t)g_currentModeIndex + 0x20000380))(var_2c, 
08031f9c                  entry_r2, entry_r3, (uint32_t)(uint8_t)r9_3, 0);
08031e18          mode_post_event((uint32_t)(uint8_t)currentModeIndex_1);
08031e2a          rtos_delay_ticks(*(uint32_t*)(0x14 * (uint32_t)g_currentModeIndex + 0x2000038c));
08031e2e      }
08031dec  }
08031fa0    int32_t mode_post_event(uint8_t code, ...)
08031fa0  {
08031fa0      int32_t entry_r3;
08031fa0      int32_t var_10 = entry_r3;
08031fa4      char r5 = 0;
08031fa8      (uint8_t)var_10 = 0x10;
08031fa8      
08031fb6      if ((uint32_t)g_currentModeIndex != (uint32_t)code)
08031fb6      {
08031fbc          uint32_t code_1 = (uint32_t)code;
08031fbc          
08031fc0          if (code_1 != 7)
08031fc0          {
08031fc2              code_1 = (uint32_t)(uint8_t)code_1;
08031fc2              
08031fc6              if (code_1 != 6)
08031fc8                  sub_8028ae4();
08031fc0          }
08031fc0          
08031fce          uint32_t r4_1 = (uint32_t)(uint8_t)code_1;
08031fce          
08031fdc          if (*(uint32_t*)(0x14 * r4_1 + 0x20000388))
08031fdc          {
08031fe2              r4_1 = (uint32_t)(uint8_t)r4_1;
08031ff0              r5 = (*(uint32_t*)(0x14 * r4_1 + 0x20000388))(&var_10);
08031fdc          }
08031fdc          
08031ff4          uint32_t r4_2 = (uint32_t)(uint8_t)r4_1;
08031ff4          
08032002          if (*(uint32_t*)(0x14 * r4_2 + 0x20000384))
08032012              (*(uint32_t*)(0x14 * (uint32_t)(uint8_t)r4_2 + 0x20000384))();
08032012          
0803201a          g_currentModeIndex = (uint8_t)var_10;
0803201a          
08032020          if ((uint32_t)r5 == 1)
08032028              data_20000379 = g_currentModeIndex;
08031fb6      }
08031fb6      
0803202c      return 1;
08031fa0  }
0803202e    uint32_t get_current_mode_index()
0803202e  {
08032032      return (uint32_t)g_currentModeIndex;
0803202e  }
08032034    uint32_t sub_8032034()
08032034  {
08032038      return (uint32_t)data_20000379;
08032034  }
0803203a    uint32_t sub_803203a()
0803203a  {
0803203c      char r4 = 0;
0803203c      
08032044      if (sub_802cf46() == 1)
08032070          r4 = 1;
08032044      else if (sub_8028adc())
0803204c      {
08032064      label_8032064:
08032064          
0803206e          if ((uint32_t)g_currentModeIndex != 8 && (uint32_t)g_currentModeIndex != 9)
08032070              r4 = 1;
0803204c      }
0803204c      else
0803204c      {
08032054          if (driveSubsystemState() == 3)
08032054              goto label_8032064;
08032054          
0803205e          if (isDriveSubsystemReady(2) == 3)
0803205e              goto label_8032064;
0803204c      }
0803204c      
08032076      return (uint32_t)r4;
0803203a  }
08032078    uint32_t ui_set_mode_indicator(uint32_t mode)
08032078  {
0803207c      sub_8028bce();
08032080      int128_t q0;
08032080      *(uint32_t*)((char*)q0)[4] = 0x41826667;
08032084      /* unimplemented  {vcmp.f32.F32 s0, s1} */
08032088      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
0803208c      uint32_t r4_1;
0803208c      
0803208c      if (mode < 0)
0803208e          r4_1 = (uint32_t)(uint8_t)mode;
0803208e      
08032098      uint32_t result;
08032098      
08032098      if (mode < 0 && (r4_1 || (uint32_t)(uint8_t)r4_1 != 8))
08032098      {
080320a2          data_2000e446 += 1;
080320a6          result = (uint32_t)data_2000e446;
080320a6          
080320aa          if (result >= 3)
080320aa          {
080320b0              camera_pa8_set(false, true);
080320b4              motorStop();
080320b8              motorBrake();
080320c0              sub_802d598(0, 4);
080320c8              sub_802d598(1, 4);
080320d0              return sub_802d598(2, 4);
080320aa          }
08032098      }
08032098      else
08032098      {
080320d6          result = 0;
080320da          data_2000e446 = 0;
08032098      }
08032098      
080320dc      return result;
08032078  }
080320de                                                                                            00 00                                ..
080320e0  int32_t data_80320e0 = 0x41826667
080320e4  int32_t data_80320e4 = 0x803bf84
080320e8  int32_t data_80320e8 = 0x803b5ec
080320ec  int32_t data_80320ec = 0x20000378
080320f0  int32_t data_80320f0 = 0x803c0a0
080320f4  int32_t data_80320f4 = 0x803afd8
080320f8  int32_t data_80320f8 = 0x803b5d0
080320fc  int32_t data_80320fc = 0x2000e445
08032100  int32_t data_8032100 = 0x803bf90
08032104  int32_t data_8032104 = 0x2000e446
08032108    int32_t sub_8032108(int32_t arg1)
08032108  {
0803210a      int32_t i = arg1;
0803210c      int32_t result = 0;
0803210e      sub_8029834();
0803210e      
08032118      if (!data_2000e31c)
0803211a          sub_803228a();
0803211a      
08032124      if (!(i & data_2000e328))
08032124      {
08032128          if (i)
08032128          {
0803212e              i += 8;
0803212e              
08032134              if (i & 7)
08032134              {
0803213e                  i = i + 8 - (i & 7);
0803213e                  
08032144                  if (i & 7)
08032144                  {
08032148                      __msr(basepri, 0x20);
0803214c                      __dsb_SY();
08032150                      __isb();
08032150                      
08032154                      while (true)
08032154                          /* nop */
08032144                  }
08032134              }
08032128          }
08032128          
08032160          if (i && data_2000e320 >= i)
08032160          {
08032162              int32_t* r0_4 = &data_2000e2ec;
08032166              int32_t* r6_1 = data_2000e2ec;
08032166              
08032172              while (r6_1[1] < i)
08032172              {
08032178                  if (!*(uint32_t*)r6_1)
08032178                      break;
08032178                  
0803216a                  r0_4 = r6_1;
0803216c                  r6_1 = *(uint32_t*)r6_1;
08032172              }
08032172              
08032180              if (r6_1 != data_2000e31c)
08032180              {
08032188                  result = *(uint32_t*)r0_4 + 8;
0803218e                  *(uint32_t*)r0_4 = *(uint32_t*)r6_1;
0803218e                  
0803219c                  if (0x10 < r6_1[1] - i)
0803219c                  {
0803219e                      void* r0_5 = (char*)r6_1 + i;
0803219e                      
080321a8                      if (!(r0_5 & 7))
080321a8                      {
080321be                          *(uint32_t*)((char*)r0_5 + 4) = r6_1[1] - i;
080321c0                          r6_1[1] = i;
080321c2                          sub_80322ee(r0_5);
080321a8                      }
080321a8                      else
080321a8                      {
080321ac                          __msr(basepri, 0x20);
080321b0                          __dsb_SY();
080321b4                          __isb();
080321b4                          
080321b8                          while (true)
080321b8                              /* nop */
080321a8                      }
0803219c                  }
0803219c                  
080321d0                  data_2000e320 -= r6_1[1];
080321d0                  
080321dc                  if (data_2000e320 < data_2000e324)
080321e4                      data_2000e324 = data_2000e320;
080321e4                  
080321ee                  r6_1[1] |= data_2000e328;
080321f2                  *(uint32_t*)r6_1 = 0;
08032180              }
08032160          }
08032124      }
08032124      
080321f4      sub_8029844();
080321f4      
080321fe      if (!(result & 7))
08032212          return result;
08032212      
08032202      __msr(basepri, 0x20);
08032206      __dsb_SY();
0803220a      __isb();
0803220a      
0803220e      while (true)
0803220e          /* nop */
08032108  }
08032214    void sub_8032214(void* arg1)
08032214  {
0803221a      if (!arg1)
0803221a          return;
0803221a      
08032222      int32_t* r4_1 = (char*)arg1 - 8;
08032222      
0803222c      if (!(r4_1[1] & data_2000e328))
0803222c      {
08032230          __msr(basepri, 0x20);
08032234          __dsb_SY();
08032238          __isb();
08032238          
0803223c          while (true)
0803223c              /* nop */
0803222c      }
0803222c      else if (*(uint32_t*)r4_1)
08032242      {
08032246          __msr(basepri, 0x20);
0803224a          __dsb_SY();
0803224e          __isb();
0803224e          
08032252          while (true)
08032252              /* nop */
08032242      }
08032242      else if (r4_1[1] & data_2000e328 && !*(uint32_t*)r4_1)
08032262      {
0803226c          r4_1[1] &= ~data_2000e328;
0803226e          sub_8029834();
0803227c          data_2000e320 += r4_1[1];
08032280          sub_80322ee(r4_1);
08032284          sub_8029844();
08032262      }
08032214  }
0803228a    int32_t sub_803228a()
0803228a  {
080322a6      data_2000e2ec = &data_20004df0;
080322ac      data_2000e2f0 = 0;
080322bc      data_2000e31c = 0x2000cde8;
080322c4      *(uint32_t*)(data_2000e31c + 4) = 0;
080322cc      **(uint32_t**)&data_2000e31c = 0;
080322d0      data_20004df4 = 0x7ff8;
080322d6      data_20004df0 = data_2000e31c;
080322dc      data_2000e324 = data_20004df4;
080322e2      data_2000e320 = data_20004df4;
080322ea      data_2000e328 = 0x80000000;
080322ec      return 0x80000000;
0803228a  }
080322ee    void sub_80322ee(int32_t* arg1)
080322ee  {
080322ee      int32_t* r1 = &data_2000e2ec;
080322ee      
080322f8      while (*(uint32_t*)r1 < arg1)
080322f2          r1 = *(uint32_t*)r1;
080322f2      
08032302      if ((char*)r1 + r1[1] == arg1)
08032302      {
0803230a          r1[1] += arg1[1];
0803230c          arg1 = r1;
08032302      }
08032302      
08032318      if ((char*)arg1 + arg1[1] != *(uint32_t*)r1)
08032340          *(uint32_t*)arg1 = *(uint32_t*)r1;
08032318      else if (*(uint32_t*)r1 == data_2000e31c)
0803233a          *(uint32_t*)arg1 = data_2000e31c;
08032322      else
08032322      {
0803232c          arg1[1] += *(uint32_t*)(*(uint32_t*)r1 + 4);
08032332          *(uint32_t*)arg1 = **(uint32_t**)r1;
08032322      }
08032322      
08032344      if (r1 != arg1)
08032346          *(uint32_t*)r1 = arg1;
080322ee  }
0803234a                                00 00                                                                        ..
0803234c  int32_t data_803234c = 0x2000e31c
08032350  int32_t data_8032350 = 0x2000e328
08032354  int32_t data_8032354 = 0x803c130
08032358  int32_t data_8032358 = 0x2000e320
0803235c  int32_t data_803235c = 0x2000e2ec
08032360  int32_t data_8032360 = 0x2000e324
08032364  int32_t data_8032364 = 0x20004df0
08032368    void sub_8032368(int32_t* arg1)
08032368  {
0803236c      arg1[1] = &arg1[2];
08032372      arg1[2] = 0xffffffff;
08032378      arg1[3] = &arg1[2];
0803237e      arg1[4] = &arg1[2];
08032382      *(uint32_t*)arg1 = 0;
08032368  }
08032386    void sub_8032386(void* arg1)
08032386  {
08032388      *(uint32_t*)((char*)arg1 + 0x10) = 0;
08032386  }
0803238c    void sub_803238c(int32_t* arg1, void* arg2)
0803238c  {
0803238c      void* r2 = arg1[1];
0803238e      *(uint32_t*)((char*)arg2 + 4) = r2;
08032392      *(uint32_t*)((char*)arg2 + 8) = *(uint32_t*)((char*)r2 + 8);
08032396      *(uint32_t*)(*(uint32_t*)((char*)r2 + 8) + 4) = arg2;
08032398      *(uint32_t*)((char*)r2 + 8) = arg2;
0803239a      *(uint32_t*)((char*)arg2 + 0x10) = arg1;
080323a0      *(uint32_t*)arg1 += 1;
0803238c  }
080323a4    void sub_80323a4(int32_t* arg1, int32_t* arg2)
080323a4  {
080323a6      int32_t i = *(uint32_t*)arg2;
080323ac      void* r2;
080323ac      
080323ac      if (i != 0xffffffff)
080323ac      {
080323b2          r2 = &arg1[2];
080323b2          
080323c0          while (i >= **(uint32_t**)((char*)r2 + 4))
080323b8              r2 = *(uint32_t*)((char*)r2 + 4);
080323ac      }
080323ac      else
080323ae          r2 = arg1[4];
080323ae      
080323c4      arg2[1] = *(uint32_t*)((char*)r2 + 4);
080323c8      *(uint32_t*)(arg2[1] + 8) = arg2;
080323ca      arg2[2] = r2;
080323cc      *(uint32_t*)((char*)r2 + 4) = arg2;
080323ce      arg2[4] = arg1;
080323d4      *(uint32_t*)arg1 += 1;
080323a4  }
080323da    int32_t sub_80323da(void* arg1)
080323da  {
080323da      int32_t* r1 = *(uint32_t*)((char*)arg1 + 0x10);
080323e0      *(uint32_t*)(*(uint32_t*)((char*)arg1 + 4) + 8) = *(uint32_t*)((char*)arg1 + 8);
080323e6      *(uint32_t*)(*(uint32_t*)((char*)arg1 + 8) + 4) = *(uint32_t*)((char*)arg1 + 4);
080323e6      
080323ec      if (r1[1] == arg1)
080323f0          r1[1] = *(uint32_t*)((char*)arg1 + 8);
080323f0      
080323f4      *(uint32_t*)((char*)arg1 + 0x10) = 0;
080323fa      *(uint32_t*)r1 -= 1;
080323fe      return *(uint32_t*)r1;
080323da  }
08032400    void* sub_8032400(int32_t arg1, int32_t arg2, int32_t arg3)
08032400  {
08032406      *(uint32_t*)(arg1 - 4) = 0x1000000;
0803240e      *(uint32_t*)(arg1 - 8) = arg2 >> 1 << 1;
08032416      *(uint32_t*)(arg1 - 0xc) = sub_8032428;
0803241a      *(uint32_t*)(arg1 - 0x20) = arg3;
08032422      *(uint32_t*)(arg1 - 0x24) = 0xfffffffd;
08032426      return arg1 - 0x44;
08032400  }
08032428    void sub_8032428() __noreturn
08032428  {
08032430      if (data_200004d0 == 0xffffffff)
08032430      {
08032444          __msr(basepri, 0x20);
08032448          __dsb_SY();
0803244c          __isb();
0803244c          
08032450          while (true)
08032450              /* nop */
08032430      }
08032430      else
08032430      {
08032434          __msr(basepri, 0x20);
08032438          __dsb_SY();
0803243c          __isb();
0803243c          
08032440          while (true)
08032440              /* nop */
08032430      }
08032428  }
08032452    int32_t sub_8032452()
08032452  {
0803245e      if (*(uint32_t*)0xe000ed00 == 0x410fc271)
0803245e      {
08032462          __msr(basepri, 0x20);
08032466          __dsb_SY();
0803246a          __isb();
0803246a          
0803246e          while (true)
0803246e              /* nop */
0803245e      }
0803245e      else if (*(uint32_t*)0xe000ed00 != 0x410fc270)
08032478      {
0803248c          uint32_t r1 = (uint32_t)*(uint8_t*)0xe000e400;
08032492          *(uint8_t*)0xe000e400 = 0xff;
08032496          uint8_t var_10 = *(uint8_t*)0xe000e400;
080324a4          data_2000e44d = var_10 & 0x20;
080324aa          data_2000e35c = 7;
080324aa          
080324c8          while ((uint32_t)var_10 << 0x18 < 0)
080324c8          {
080324b6              data_2000e35c -= 1;
080324be              var_10 <<= 1;
080324c8          }
080324c8          
080324d4          if (7 - data_2000e35c == 4)
080324d4          {
080324ee              data_2000e35c <<= 8;
080324fa              data_2000e35c &= 0x700;
080324fe              *(uint8_t*)0xe000e400 = (uint8_t)r1;
0803250a              *(uint32_t*)0xe000ed20 |= 0xf00000;
08032516              *(uint32_t*)0xe000ed20 |= 0xf0000000;
08032518              sub_8032650();
08032520              data_200004d0 = 0;
08032522              sub_8036970();
08032530              *(uint32_t*)0xe000ef34 |= 0xc0000000;
08032532              sub_8036950();
08032538              return 0;
080324d4          }
080324d4          
080324d8          __msr(basepri, 0x20);
080324dc          __dsb_SY();
080324e0          __isb();
080324e0          
080324e4          while (true)
080324e4              /* nop */
08032478      }
08032478      else
08032478      {
0803247c          __msr(basepri, 0x20);
08032480          __dsb_SY();
08032484          __isb();
08032484          
08032488          while (true)
08032488              /* nop */
08032478      }
08032452  }
0803253a    int32_t sub_803253a()
0803253a  {
0803253c      __msr(basepri, 0x20);
08032540      __dsb_SY();
08032544      __isb();
08032550      data_200004d0 += 1;
08032554      int32_t result = data_200004d0;
08032554      
08032558      if (result == 1)
08032558      {
0803255e          result = *(uint32_t*)0xe000ed04 << 0x18;
0803255e          
08032560          if (result)
08032560          {
08032564              __msr(basepri, 0x20);
08032568              __dsb_SY();
0803256c              __isb();
0803256c              
08032570              while (true)
08032570                  /* nop */
08032560          }
08032558      }
08032558      
08032572      return result;
0803253a  }
08032574    int32_t sub_8032574()
08032574  {
0803257a      if (data_200004d0)
0803257a      {
08032594          data_200004d0 -= 1;
08032598          int32_t result = data_200004d0;
08032598          
0803259c          if (!result)
0803259c          {
0803259e              result = 0;
080325a0              __msr(basepri, 0);
0803259c          }
0803259c          
080325a4          return result;
0803257a      }
0803257a      
0803257e      __msr(basepri, 0x20);
08032582      __dsb_SY();
08032586      __isb();
08032586      
0803258a      while (true)
0803258a          /* nop */
08032574  }
080325a6    int32_t sub_80325a6(int32_t arg1 @ r7)
080325a6  {
080325a8      sub_802fb50(arg1);
080325ae      __msr(basepri, 0x20);
080325b2      __dsb_SY();
080325b6      __isb();
080325b6      
080325c0      if (sub_8029946())
080325c8          *(uint32_t*)0xe000ed04 = 0x10000000;
080325c8      
080325cc      __msr(basepri, 0);
080325d0      return arg1;
080325a6  }
080325d2                                                        00 00                                                        ..
080325d4    int32_t sub_80325d4()
080325d4  {
080325d4      uint32_t r0_2 = __mrs(ipsr);
080325d4      
080325ea      if (r0_2 >= 0x10
080325ea          && (uint32_t)*(uint8_t*)(0xe000e3f0 + r0_2) < (uint32_t)data_2000e44d)
080325ea      {
080325ee          __msr(basepri, 0x20);
080325f2          __dsb_SY();
080325f6          __isb();
080325f6          
080325fa          while (true)
080325fa              /* nop */
080325ea      }
080325ea      
080325fe      int32_t result = data_2000e35c;
080325fe      
0803260a      if (result >= (*(uint32_t*)0xe000ed0c & 0x700))
0803261c          return result;
0803261c      
0803260e      __msr(basepri, 0x20);
08032612      __dsb_SY();
08032616      __isb();
08032616      
0803261a      while (true)
0803261a          /* nop */
080325d4  }
0803261e                                                                                            00 00                                ..
08032620  int32_t data_8032620 = 0x200004d0
08032624  int32_t data_8032624 = -0x1fff1300
08032628  int32_t data_8032628 = 0x410fc271
0803262c  int32_t data_803262c = 0x410fc270
08032630  int32_t data_8032630 = -0x1fff1c00
08032634  int32_t data_8032634 = 0x2000e44d
08032638  int32_t data_8032638 = 0x2000e35c
0803263c  int32_t data_803263c = -0x1fff12e0
08032640  int32_t data_8032640 = -0x1fff10cc
08032644  int32_t data_8032644 = -0x1fff12fc
08032648  int32_t data_8032648 = 0x803c134
0803264c  int32_t data_803264c = -0x1fff12f4
08032650    int32_t sub_8032650()
08032650  {
08032654      *(uint32_t*)0xe000e010 = 0;
0803265a      *(uint32_t*)0xe000e018 = 0;
0803266c      *(uint32_t*)0xe000e014 = data_20000504 / 0x3e8 - 1;
08032672      *(uint32_t*)0xe000e010 = 7;
08032674      return 7;
08032650  }
08032676                                                                    00 bf                                                ..
08032678  int32_t data_8032678 = -0x1fff1ff0
0803267c  int32_t data_803267c = -0x1fff1fe8
08032680  int32_t data_8032680 = 0x20000504
08032684  int32_t data_8032684 = -0x1fff1fec
08032688    int32_t tiny_printf(int32_t (* putc_fn)(int32_t state, int32_t ch), int32_t init_state, char const* fmt, void* va_list_ptr)
08032688  {
08032688      int32_t i_9;
08032688      int32_t i_23 = i_9;
08032692      char const* fmt_1 = fmt;
08032696      int32_t state = init_state;
08032698      int32_t result = 0;
08032698      
080326ba      while (true)
080326ba      {
080326ba          uint32_t r0_3 = (uint32_t)*(uint8_t*)fmt_1;
080326ba          
080326be          if (!r0_3)
080326c0              return result;
080326c0          
080326c6          if (r0_3 != 0x25)
080326c6          {
080326a4              uint32_t ch = (uint32_t)*(uint8_t*)fmt_1;
080326a4              fmt_1 = &fmt_1[1];
080326aa              int32_t state_1 = putc_fn(state, ch);
080326ae              state = state_1;
080326ae              
080326b0              if (!state_1)
080326b0                  break;
080326b0              
080326b8              result += 1;
080326c6          }
080326c6          else
080326c6          {
080326c8              uint32_t r0_5 = 0;
080326ca              int32_t i_17;
080326ca              __builtin_memset(&i_17, 0, 0x18);
080326dc              uint32_t r1_1;
080326dc              
080326dc              while (true)
080326dc              {
080326dc                  fmt_1 = &fmt_1[1];
080326dc                  r1_1 = (uint32_t)*(uint8_t*)fmt_1;
080326dc                  
080326e2                  if (r1_1 == 0x20)
080326d8                      r0_5 |= 1;
080326e2                  else
080326e2                  {
080326e6                      int16_t r0_6;
080326e6                      
080326e6                      if (r1_1 == 0x23)
08032704                          r0_6 = (uint16_t)r0_5 | 8;
080326e6                      else if (r1_1 == 0x2b)
080326f6                          r0_6 = (uint16_t)r0_5 | 2;
080326ea                      else if (r1_1 == 0x2d)
080326fe                          r0_6 = (uint16_t)r0_5 | 4;
080326ee                      else
080326ee                      {
080326f2                          if (r1_1 != 0x30)
080326f2                              break;
080326f2                          
0803270a                          r0_6 = (uint16_t)r0_5 | 0x10;
080326ee                      }
080326ee                      
080326fa                      r0_5 = (uint32_t)r0_6;
080326e2                  }
080326dc              }
080326dc              
08032712              int32_t var_74_1;
08032712              
08032712              if (r1_1 != 0x2a)
08032712              {
08032734                  var_74_1 = 0;
08032734                  
0803274c                  while (true)
0803274c                  {
0803274c                      uint32_t r2_1 = (uint32_t)*(uint8_t*)fmt_1;
0803274c                      
08032754                      if (r2_1 - 0x30 >= 0xa)
08032754                          break;
08032754                      
0803273c                      if (var_74_1 != 0x7fffffff)
08032748                          var_74_1 = r2_1 + var_74_1 * 0xa - 0x30;
08032748                      
0803274a                      fmt_1 = &fmt_1[1];
0803274c                  }
08032712              }
08032712              else
08032712              {
08032714                  int32_t* r1_2 = *(uint32_t*)va_list_ptr;
08032716                  *(uint32_t*)va_list_ptr = r1_2;
08032718                  int32_t r2 = *(uint32_t*)r1_2;
0803271c                  *(uint32_t*)va_list_ptr = &r1_2[1];
08032720                  var_74_1 = r2;
08032720                  
08032722                  if (r2 < 0)
08032722                  {
0803272a                      var_74_1 = 0 - r2;
0803272c                      r0_5 = (uint32_t)(uint16_t)r0_5 | 4;
08032722                  }
08032722                  
0803272e                  fmt_1 = &fmt_1[1];
08032712              }
08032712              
0803275a              void* i_29;
0803275a              
0803275a              if ((uint32_t)*(uint8_t*)fmt_1 == 0x2e)
0803275a              {
08032764                  fmt_1 = &fmt_1[1];
08032764                  
0803276a                  if ((uint32_t)*(uint8_t*)fmt_1 != 0x2a)
0803276a                  {
0803277e                      i_29 = nullptr;
0803277e                      
08032796                      while (true)
08032796                      {
08032796                          uint32_t r2_2 = (uint32_t)*(uint8_t*)fmt_1;
08032796                          
0803279e                          if (r2_2 - 0x30 >= 0xa)
0803279e                              break;
0803279e                          
08032786                          if (i_29 != 0x7fffffff)
08032792                              i_29 = r2_2 + i_29 * 0xa - 0x30;
08032792                          
08032794                          fmt_1 = &fmt_1[1];
08032796                      }
0803276a                  }
0803276a                  else
0803276a                  {
0803276c                      void** r1_11 = *(uint32_t*)va_list_ptr;
0803276e                      *(uint32_t*)va_list_ptr = r1_11;
08032770                      fmt_1 = &fmt_1[1];
08032772                      void* i_30 = *(uint32_t*)r1_11;
08032776                      *(uint32_t*)va_list_ptr = &r1_11[1];
08032778                      i_29 = i_30;
0803276a                  }
0803275a              }
0803275a              else
08032760                  i_29 = 0xffffffff;
08032760              
080327a0              uint16_t var_70_1 = (int16_t)r0_5;
080327aa              uint32_t r0_8 = sub_803698c("hjltzL", *(uint8_t*)fmt_1);
080327aa              
080327ae              if (r0_8)
080327ae              {
080327b0                  r0_8 = (uint32_t)*(uint8_t*)fmt_1;
080327b0                  fmt_1 = &fmt_1[1];
080327ae              }
080327ae              
080327b4              uint8_t var_6e_1 = (char)r0_8;
080327b8              uint32_t r0_9 = (uint32_t)var_6e_1;
080327bc              bool cond:2_1 = r0_9 == 0x68;
080327bc              
080327be              if (r0_9 == 0x68)
080327be              {
080327c2                  cond:2_1 = (uint32_t)*(uint8_t*)fmt_1 == 0x68;
080327c4                  r0_9 = 0x62;
080327be              }
080327be              
080327c6              if (cond:2_1)
080327c6              {
080327d4                  var_6e_1 = (char)r0_9;
080327d8                  fmt_1 = &fmt_1[1];
080327c6              }
080327c6              else
080327c6              {
080327c8                  bool cond:3_1 = r0_9 != 0x6c;
080327c8                  
080327ca                  if (r0_9 == 0x6c)
080327ce                      cond:3_1 = (uint32_t)*(uint8_t*)fmt_1 != 0x6c;
080327ce                  
080327d0                  if (!cond:3_1)
080327d0                  {
080327d4                      var_6e_1 = (char)0x71;
080327d8                      fmt_1 = &fmt_1[1];
080327d0                  }
080327c6              }
080327c6              
080327dc              char var_64;
080327dc              char* var_98_1 = &var_64;
080327de              uint32_t r7_1 = (uint32_t)*(uint8_t*)fmt_1;
080327de              fmt_1 = &fmt_1[1];
080327e6              int32_t ctx;
080327e6              void* var_9c;
080327e6              void* i_18;
080327e6              void* i_20;
080327e6              
080327e6              if (r7_1 == 0x25)
080327e6              {
08032840                  var_64 = 0x25;
08032adc                  i_17 = 1;
080327e6              }
080327e6              else if (r7_1 == 0x41 || r7_1 - 0x45 <= 2)
080327f2              {
08032986              label_8032986:
08032986                  int32_t* r2_10 = (*(uint32_t*)va_list_ptr + 7) & 0xfffffff8;
0803298a                  *(uint32_t*)va_list_ptr = r2_10;
0803298c                  int32_t ctx_3 = *(uint32_t*)r2_10;
0803298c                  int32_t r1_26 = r2_10[1];
08032992                  *(uint32_t*)va_list_ptr = &r2_10[2];
08032994                  ctx = ctx_3;
08032994                  int32_t var_a4_1 = r1_26;
0803299a                  int32_t i_25;
0803299a                  
0803299a                  if (r1_26 >= 0)
0803299a                  {
080329a2                      uint32_t r0_59 = (uint32_t)var_70_1;
080329a2                      
080329a8                      if (r0_59 << 0x1e < 0)
080329a8                      {
080329aa                          i_25 = i_17;
080329b8                          (&var_64)[i_25] = 0x2b;
080329be                          i_17 = i_25 + 1;
080329a8                      }
080329a8                      else if (r0_59 << 0x1f < 0)
080329b2                      {
080329b4                          i_25 = i_17;
080329b8                          (&var_64)[i_25] = 0x20;
080329be                          i_17 = i_25 + 1;
080329b2                      }
0803299a                  }
0803299a                  else
0803299a                  {
0803299c                      i_25 = i_17;
080329b8                      (&var_64)[i_25] = 0x2d;
080329be                      i_17 = i_25 + 1;
0803299a                  }
080329c6                  var_9c = &(&var_64)[i_17];
080329cc                  sub_8032da0(&ctx, (uint8_t)r7_1);
080327f2              }
080327f2              else if (r7_1 == 0x58)
080327f8              {
080329d2              label_80329d2:
080329d2                  uint32_t r0_64 = (uint32_t)var_6e_1;
080329d8                  bool cond:8_1;
080329d8                  
080329d8                  if (r0_64 != 0x6c)
080329d8                  {
080329da                      cond:8_1 = r0_64 != 0x71;
080329da                      
080329dc                      if (r0_64 != 0x71)
080329de                          cond:8_1 = r0_64 != 0x6a;
080329d8                  }
080329d8                  
080329e0                  int32_t ctx_4;
080329e0                  int32_t r1_31;
080329e0                  
080329e0                  if (r0_64 == 0x6c || cond:8_1)
080329e0                  {
080329f6                      int32_t* r1_32 = *(uint32_t*)va_list_ptr;
080329f8                      *(uint32_t*)va_list_ptr = r1_32;
080329fa                      ctx_4 = *(uint32_t*)r1_32;
080329fe                      *(uint32_t*)va_list_ptr = &r1_32[1];
08032a00                      r1_31 = 0;
080329e0                  }
080329e0                  else
080329e0                  {
080329e6                      int32_t* r2_12 = (*(uint32_t*)va_list_ptr + 7) & 0xfffffff8;
080329ea                      *(uint32_t*)va_list_ptr = r2_12;
080329ec                      ctx_4 = *(uint32_t*)r2_12;
080329ec                      r1_31 = r2_12[1];
080329f2                      *(uint32_t*)va_list_ptr = &r2_12[2];
080329e0                  }
080329e0                  
08032a02                  ctx = ctx_4;
08032a02                  int32_t var_a4_2 = r1_31;
08032a06                  uint32_t r0_67 = (uint32_t)var_6e_1;
08032a06                  
08032a0c                  if (r0_67 == 0x68)
08032a0c                  {
08032a30                      ctx = (uint32_t)(uint16_t)ctx;
08032a30                      var_a4_2 = 0;
08032a0c                  }
08032a0c                  else if (r0_67 != 0x62)
08032a18                  {
08032a22                      bool cond:11_1 = r0_67 != 0x74;
08032a22                      
08032a24                      if (r0_67 != 0x74)
08032a26                          cond:11_1 = r0_67 != 0x7a;
08032a26                      
08032a28                      if (!cond:11_1)
08032a28                      {
08032a30                          ctx = ctx;
08032a30                          var_a4_2 = 0;
08032a28                      }
08032a18                  }
08032a18                  else
08032a18                  {
08032a30                      ctx = (uint32_t)(uint8_t)ctx;
08032a30                      var_a4_2 = 0;
08032a18                  }
08032a18                  
08032a3a                  if ((uint32_t)(uint8_t)var_70_1 << 0x1c < 0)
08032a3a                  {
08032a42                      bool cond:12_1 = !var_a4_2;
08032a42                      
08032a44                      if (!var_a4_2)
08032a46                          cond:12_1 = !ctx;
08032a46                      
08032a50                      if (!cond:12_1 && (r7_1 | 0x20) == 0x78)
08032a50                      {
08032a52                          int32_t i_26 = i_17;
08032a56                          (&var_64)[i_26] = 0x30;
08032a5e                          i_17 = i_26 + 2;
08032a60                          (&var_64)[i_26 + 1] = (char)r7_1;
08032a50                      }
08032a3a                  }
08032a3a                  
08032aa8                  var_9c = &(&var_64)[i_17];
08032aae                  sub_8032c96(&ctx, r7_1, i_9);
080327f8              }
080327f8              else
080327f8              {
080327fe                  if (r7_1 == 0x61)
080327fe                      goto label_8032986;
080327fe                  
08032804                  if (r7_1 == 0x63)
08032804                  {
08032ab6                      i_17 = 1;
08032ab8                      int32_t* r0_81 = *(uint32_t*)va_list_ptr;
08032aba                      *(uint32_t*)va_list_ptr = r0_81;
08032abc                      char r1_44 = (char)*(uint32_t*)r0_81;
08032ac0                      *(uint32_t*)va_list_ptr = &r0_81[1];
08032ac2                      var_64 = r1_44;
08032804                  }
08032804                  else if (r7_1 == 0x64)
0803280a                  {
08032a6c                  label_8032a6c:
08032a6c                      int32_t ctx_5;
08032a6c                      int32_t r1_39;
08032a6c                      ctx_5 = sub_8032c28((uint32_t)var_6e_1, va_list_ptr);
08032a70                      ctx = ctx_5;
08032a7c                      int32_t i_27;
08032a7c                      
08032a7c                      if (r1_39 >= 0)
08032a7c                      {
08032a84                          uint32_t r0_76 = (uint32_t)var_70_1;
08032a84                          
08032a8a                          if (r0_76 << 0x1e < 0)
08032a8a                          {
08032a8c                              i_27 = i_17;
08032a9a                              (&var_64)[i_27] = 0x2b;
08032aa0                              i_17 = i_27 + 1;
08032a8a                          }
08032a8a                          else if (r0_76 << 0x1f < 0)
08032a94                          {
08032a96                              i_27 = i_17;
08032a9a                              (&var_64)[i_27] = 0x20;
08032aa0                              i_17 = i_27 + 1;
08032a94                          }
08032a7c                      }
08032a7c                      else
08032a7c                      {
08032a7e                          i_27 = i_17;
08032a9a                          (&var_64)[i_27] = 0x2d;
08032aa0                          i_17 = i_27 + 1;
08032a7c                      }
08032aa8                      var_9c = &(&var_64)[i_17];
08032aae                      sub_8032c96(&ctx, r7_1, i_9);
0803280a                  }
0803280a                  else
0803280a                  {
08032812                      if (r7_1 - 0x65 <= 2)
08032812                          goto label_8032986;
08032812                      
08032818                      if (r7_1 == 0x69)
08032818                          goto label_8032a6c;
08032818                      
0803281e                      if (r7_1 == 0x6e)
0803281e                      {
08032924                          uint32_t r0_44 = (uint32_t)var_6e_1;
08032924                          
0803292a                          if (r0_44 == 0x62)
0803292a                          {
08032962                              int32_t* r0_51 = *(uint32_t*)va_list_ptr;
08032964                              *(uint32_t*)va_list_ptr = r0_51;
08032966                              char* r1_24 = *(uint32_t*)r0_51;
0803296a                              *(uint32_t*)va_list_ptr = &r0_51[1];
0803296e                              *(uint8_t*)r1_24 = (uint8_t)result;
0803292a                          }
0803292a                          else if (r0_44 == 0x68)
0803292e                          {
0803293e                              int32_t* r0_45 = *(uint32_t*)va_list_ptr;
08032940                              *(uint32_t*)va_list_ptr = r0_45;
08032942                              int16_t* r1_22 = *(uint32_t*)r0_45;
08032946                              *(uint32_t*)va_list_ptr = &r0_45[1];
0803294a                              *(uint16_t*)r1_22 = (uint16_t)result;
0803292e                          }
0803292e                          else if (r0_44 == 0x6a || (r0_44 != 0x6c && r0_44 == 0x71))
0803293a                          {
0803294e                              int32_t* r0_48 = *(uint32_t*)va_list_ptr;
08032950                              *(uint32_t*)va_list_ptr = r0_48;
08032952                              int32_t* r2_9 = *(uint32_t*)r0_48;
08032956                              *(uint32_t*)va_list_ptr = &r0_48[1];
0803295c                              *(uint32_t*)r2_9 = result;
0803295c                              r2_9[1] = result >> 0x1f;
0803293a                          }
0803293a                          else
0803293a                          {
08032972                              int32_t* r0_54 = *(uint32_t*)va_list_ptr;
08032974                              *(uint32_t*)va_list_ptr = r0_54;
08032976                              int32_t* r1_25 = *(uint32_t*)r0_54;
0803297a                              *(uint32_t*)va_list_ptr = &r0_54[1];
0803297e                              *(uint32_t*)r1_25 = result;
0803293a                          }
0803281e                      }
0803281e                      else
0803281e                      {
08032824                          if (r7_1 == 0x6f)
08032824                              goto label_80329d2;
08032824                          
0803282a                          if (r7_1 == 0x70)
0803282a                          {
08032876                              int32_t* r1_19 = *(uint32_t*)va_list_ptr;
08032878                              *(uint32_t*)va_list_ptr = r1_19;
0803287c                              int32_t ctx_1 = *(uint32_t*)r1_19;
08032880                              *(uint32_t*)va_list_ptr = &r1_19[1];
08032884                              ctx = ctx_1;
0803288a                              char* i = &var_64;
0803288c                              int32_t ctx_2 = ctx;
08032898                              int32_t r12_1 = 0x3c;
08032898                              
080328a0                              if (ctx_2 || i_29)
080328a0                              {
080328d2                                  do
080328d2                                  {
080328a8                                      uint32_t r3_4 =
080328a8                                          (uint32_t)(((uint8_t)ctx_2 & 0xf) + 0x30);
080328a8                                      
080328ac                                      if (r3_4 >= 0x3a)
080328ae                                          r3_4 += 0x27;
080328ae                                      
080328b6                                      var_98_1[r12_1 - 1] = (char)r3_4;
080328b8                                      r12_1 -= 1;
080328ba                                      ctx_2 u>>= 4;
080328ba                                      
080328c8                                      if (!ctx_2)
080328c8                                          break;
080328d2                                  } while (i < &var_98_1[r12_1]);
080328a0                              }
080328a0                              
080328d8                              var_9c = &var_98_1[r12_1];
080328e0                              i_18 = 0x3c - r12_1;
080328e0                              
080328e4                              if (0x3c - r12_1 < i_29)
080328e4                              {
080328e8                                  i_20 = (char*)i_29 - (0x3c - r12_1);
080328f4                                  var_70_1 &= 0xffef;
080328e4                              }
080328e4                              else if (i_29 < 0
080328e4                                  && ((uint32_t)(uint8_t)var_70_1 & 0x14) == 0x10)
0803290a                              {
08032918                                  void* i_24 = var_74_1 - i_17 - i_20 - (0x3c - r12_1);
08032918                                  
0803291c                                  if (i_24 >= 1)
08032920                                      i_20 = i_24;
0803290a                              }
0803282a                          }
0803282a                          else if (r7_1 == 0x73)
0803282e                          {
08032848                              void** r0_27 = *(uint32_t*)va_list_ptr;
0803284a                              *(uint32_t*)va_list_ptr = r0_27;
0803284c                              void* r4 = *(uint32_t*)r0_27;
08032850                              *(uint32_t*)va_list_ptr = &r0_27[1];
08032852                              var_9c = r4;
08032854                              void* i_28 = i_29;
08032854                              
08032858                              if (i_28 >= 0)
08032858                              {
0803286a                                  void* r0_32 = sub_80369a4(r4, 0, i_28);
0803286a                                  
0803286e                                  if (r0_32)
08032870                                      i_28 = (char*)r0_32 - r4;
08032858                              }
08032858                              else
08032860                                  i_28 = sub_8035580(r4);
08032860                              
08032872                              i_18 = i_28;
0803282e                          }
0803282e                          else
0803282e                          {
08032838                              if (r7_1 == 0x75 || r7_1 == 0x78)
08032832                                  goto label_80329d2;
08032832                              
08032aca                              var_64 = 0x25;
08032ad0                              i_17 = 1;
08032ad0                              
08032ad4                              if (r7_1)
08032ad4                              {
08032ad6                                  uint8_t var_63_1 = (char)r7_1;
08032adc                                  i_17 = 2;
08032ad4                              }
0803282e                          }
0803281e                      }
0803280a                  }
080327f8              }
080327f8              
08032af6              int32_t i_19;
08032af6              int32_t i_21;
08032af6              int32_t i_22;
08032af6              void* i_13 = var_74_1 - i_17 - i_20 - i_18 - i_21 - i_19 - i_22;
08032afe              char buf;
08032afe              
08032afe              if ((uint32_t)(uint8_t)var_70_1 << 0x1d >= 0)
08032afe              {
08032b04                  buf = 0x20;
08032b04                  
08032b08                  if (i_13 >= 1)
08032b08                  {
08032b0a                      void* i_10 = i_13;
08032b20                      void* i_1;
08032b20                      
08032b20                      do
08032b20                      {
08032b1a                          if (print_block(putc_fn, &ctx, &buf, 1))
08032c1e                              return 0xffffffff;
08032c1e                          
08032b1e                          i_1 = i_10;
08032b1e                          i_10 -= 1;
08032b20                      } while (i_1 != 1);
08032b08                  }
08032afe              }
08032afe              
08032b22              int32_t i_14 = i_17;
08032b2a              char* r4_1 = &var_64;
08032b2a              
08032b2c              if (i_14)
08032b2c              {
08032b46                  int32_t i_2;
08032b46                  
08032b46                  do
08032b46                  {
08032b2e                      uint32_t ch_1 = (uint32_t)*(uint8_t*)r4_1;
08032b2e                      r4_1 = &r4_1[1];
08032b34                      int32_t state_2 = putc_fn(state, ch_1);
08032b38                      state = state_2;
08032b38                      
08032b3a                      if (!state_2)
08032c1e                          return 0xffffffff;
08032c1e                      
08032b40                      i_2 = i_14;
08032b40                      i_14 -= 1;
08032b44                      result += 1;
08032b46                  } while (i_2 != 1);
08032b2c              }
08032b2c              
08032b4a              buf = 0x30;
08032b4e              void* i_11 = i_20;
08032b4e              
08032b52              if (i_11 >= 1)
08032b52              {
08032b66                  void* i_3;
08032b66                  
08032b66                  do
08032b66                  {
08032b62                      if (print_block(putc_fn, &ctx, &buf, 1))
08032c1e                          return 0xffffffff;
08032c1e                      
08032b64                      i_3 = i_11;
08032b64                      i_11 -= 1;
08032b66                  } while (i_3 != 1);
08032b52              }
08032b52              
08032b68              void* i_15 = i_18;
08032b6c              void* r4_2 = var_9c;
08032b6c              
08032b72              if (i_15)
08032b72              {
08032b8c                  void* i_4;
08032b8c                  
08032b8c                  do
08032b8c                  {
08032b74                      uint32_t ch_2 = (uint32_t)*(uint8_t*)r4_2;
08032b74                      r4_2 += 1;
08032b7a                      int32_t state_3 = putc_fn(state, ch_2);
08032b7e                      state = state_3;
08032b7e                      
08032b80                      if (!state_3)
08032c1e                          return 0xffffffff;
08032c1e                      
08032b86                      i_4 = i_15;
08032b86                      i_15 -= 1;
08032b8a                      result += 1;
08032b8c                  } while (i_4 != 1);
08032b72              }
08032b72              
08032b90              buf = 0x30;
08032b94              int32_t i_12 = i_21;
08032b94              
08032b98              if (i_12 >= 1)
08032b98              {
08032bac                  int32_t i_5;
08032bac                  
08032bac                  do
08032bac                  {
08032ba8                      if (print_block(putc_fn, &ctx, &buf, 1))
08032c1e                          return 0xffffffff;
08032c1e                      
08032baa                      i_5 = i_12;
08032baa                      i_12 -= 1;
08032bac                  } while (i_5 != 1);
08032b98              }
08032b98              
08032bb2              int32_t i_16 = i_19;
08032bb6              void* r4_3 = (char*)var_9c + i_18;
08032bb6              
08032bbc              if (i_16)
08032bbc              {
08032bd4                  int32_t i_6;
08032bd4                  
08032bd4                  do
08032bd4                  {
08032bbe                      uint32_t ch_3 = (uint32_t)*(uint8_t*)r4_3;
08032bbe                      r4_3 += 1;
08032bc4                      int32_t state_4 = putc_fn(state, ch_3);
08032bc6                      state = state_4;
08032bc6                      
08032bc8                      if (!state_4)
08032c1e                          return 0xffffffff;
08032c1e                      
08032bce                      i_6 = i_16;
08032bce                      i_16 -= 1;
08032bd2                      result += 1;
08032bd4                  } while (i_6 != 1);
08032bbc              }
08032bbc              
08032bd8              buf = 0x30;
08032bdc              i_9 = i_22;
08032bdc              
08032be0              if (i_9 >= 1)
08032be0              {
08032bf2                  int32_t i_7;
08032bf2                  
08032bf2                  do
08032bf2                  {
08032bee                      if (print_block(putc_fn, &ctx, &buf, 1))
08032c1e                          return 0xffffffff;
08032c1e                      
08032bf0                      i_7 = i_9;
08032bf0                      i_9 -= 1;
08032bf2                  } while (i_7 != 1);
08032be0              }
08032be0              
08032bfa              if ((uint32_t)(uint8_t)var_70_1 << 0x1d < 0)
08032bfa              {
08032c02                  buf = 0x20;
08032c02                  
08032c06                  if (i_13 >= 1)
08032c06                  {
08032c1a                      void* i_8;
08032c1a                      
08032c1a                      do
08032c1a                      {
08032c16                          if (print_block(putc_fn, &ctx, &buf, 1))
08032c1e                              return 0xffffffff;
08032c1e                          
08032c18                          i_8 = i_13;
08032c18                          i_13 -= 1;
08032c1a                      } while (i_8 != 1);
08032c06                  }
08032bfa              }
080326c6          }
080326ba      }
080326ba      
08032c1e      return 0xffffffff;
08032688  }
08032c28    int32_t sub_8032c28(int32_t arg1, int32_t* arg2)
08032c28  {
08032c2a      if (arg1 == 0x62)
08032c2a      {
08032c7a          int32_t* r2_5 = *(uint32_t*)arg2;
08032c7c          *(uint32_t*)arg2 = r2_5;
08032c7e          char r0_8 = (char)*(uint32_t*)r2_5;
08032c82          *(uint32_t*)arg2 = &r2_5[1];
08032c84          return (int32_t)r0_8;
08032c2a      }
08032c2a      
08032c2e      if (arg1 == 0x68)
08032c2e      {
08032c6c          int32_t* r2_3 = *(uint32_t*)arg2;
08032c6e          *(uint32_t*)arg2 = r2_3;
08032c70          int16_t r0_6 = (int16_t)*(uint32_t*)r2_3;
08032c74          *(uint32_t*)arg2 = &r2_3[1];
08032c76          return (int32_t)r0_6;
08032c2e      }
08032c2e      
08032c32      if (arg1 != 0x6a)
08032c32      {
08032c36          if (arg1 == 0x6c)
08032c36          {
08032c88          label_8032c88:
08032c88              int32_t* r2_7 = *(uint32_t*)arg2;
08032c8a              *(uint32_t*)arg2 = r2_7;
08032c8c              int32_t r0_7 = *(uint32_t*)r2_7;
08032c90              *(uint32_t*)arg2 = &r2_7[1];
08032c94              return r0_7;
08032c36          }
08032c36          
08032c3a          if (arg1 != 0x71)
08032c3a          {
08032c42              if (arg1 == 0x74 || arg1 != 0x7a)
08032c42                  goto label_8032c88;
08032c42              
08032c5e              int32_t* r2_1 = *(uint32_t*)arg2;
08032c60              *(uint32_t*)arg2 = r2_1;
08032c62              int32_t r0_5 = *(uint32_t*)r2_1;
08032c66              *(uint32_t*)arg2 = &r2_1[1];
08032c6a              return r0_5;
08032c3a          }
08032c32      }
08032c32      
08032c4a      int32_t* r0_2 = (*(uint32_t*)arg2 + 7) & 0xfffffff8;
08032c4e      *(uint32_t*)arg2 = r0_2;
08032c50      int32_t r2 = *(uint32_t*)r0_2;
08032c50      r0_2[1];
08032c56      *(uint32_t*)arg2 = &r0_2[2];
08032c5c      return r2;
08032c28  }
08032c96    int32_t* sub_8032c96(int32_t* arg1, int32_t arg2, int32_t arg3 @ r4)
08032c96  {
08032c96      int32_t var_1c = arg3;
08032c96      int32_t* result = arg1;
08032c9e      char* r7 = arg1[4];
08032c9e      
08032ca2      if (arg2 == 0x6f)
08032ca4          arg3 = 8;
08032ca4      
08032ca6      if (arg2 != 0x6f)
08032ca6      {
08032cae          arg3 = (arg2 | 0x20) != 0x78 ? 0xa : 0x10;
08032ca6      }
08032ca6      
08032cb4      int32_t* r6 = 0x3c;
08032cb6      int32_t r3 = arg1[1];
08032cba      bool cond:1 = arg2 != 0x64;
08032cba      
08032cbc      if (arg2 != 0x64)
08032cbe          cond:1 = arg2 != 0x69;
08032cbe      
08032cc0      int32_t r8 = *(uint32_t*)arg1;
08032cc2      int32_t r9 = r3;
08032cc2      
08032cca      if (!cond:1 && r3 < 0)
08032cca      {
08032ccc          int32_t temp0_1 = r8;
08032ccc          r8 = 0 - r8;
08032cd0          r9 = r9 - (r9 << 1);
08032cca      }
08032cca      
08032cd6      bool cond:2 = r9;
08032cd6      
08032cd8      if (!r9)
08032cda          cond:2 = r8;
08032cda      
08032ce0      if (cond:2 || arg1[0xc])
08032ce0      {
08032d3e          do
08032d3e          {
08032cfa              result = (char*)r6 - 1;
08032cfc              r6 -= 1;
08032d0e              uint32_t r0_7 = (uint32_t)(sub_80369fc(r8, r9, arg3, arg3 >> 0x1f) + 0x30);
08032d0e              
08032d12              if (r0_7 >= 0x3a)
08032d1a                  r0_7 += (uint32_t)(uint8_t)arg2 - 0x51;
08032d1a              
08032d1c              *(uint8_t*)(r7 + r6) = (char)r0_7;
08032d26              int32_t r0_9;
08032d26              int32_t r1_5;
08032d26              r0_9 = sub_80369fc(r8, r9, arg3, arg3 >> 0x1f);
08032d2a              r8 = r0_9;
08032d2c              r9 = r1_5;
08032d30              bool cond:3_1 = !r9;
08032d30              
08032d32              if (!r9)
08032d34                  cond:3_1 = !r8;
08032d34              
08032d36              if (cond:3_1)
08032d36                  break;
08032d3e          } while (arg1[3] < r7 + r6);
08032d3e          
08032d50          if (arg3 == 8 && (uint32_t)arg1[0xe] << 0x1c < 0
08032d50              && (uint32_t)*(uint8_t*)(r7 + r6) != 0x30)
08032d50          {
08032d52              r6 -= 1;
08032d56              *(uint8_t*)(r7 + r6) = 0x30;
08032d50          }
08032ce0      }
08032ce0      else if (arg3 == 8 && (uint32_t)arg1[0xe] << 0x1c < 0)
08032cec      {
08032cf0          r6 = 0x3b;
08032cf2          r7[0x3b] = 0x30;
08032cec      }
08032cec      
08032d5a      arg1[3] = r7 + r6;
08032d60      int32_t r1_8 = arg1[0xc];
08032d62      arg1[6] = 0x3c - r6;
08032d62      
08032d66      if (0x3c - r6 < r1_8)
08032d66      {
08032d6a          arg1[8] = r1_8 - (0x3c - r6);
08032d74          arg1[0xe] &= 0xffef;
08032d76          return result;
08032d66      }
08032d66      
08032d88      if (r1_8 < 0 && ((uint32_t)arg1[0xe] & 0x14) == 0x10)
08032d88      {
08032d94          void* r6_1 = arg1[0xd] - arg1[5] - arg1[8] - (0x3c - r6);
08032d94          
08032d98          if (r6_1 >= 1)
08032d9a              arg1[8] = r6_1;
08032d88      }
08032d88      
08032d9c      return result;
08032c96  }
08032da0    int32_t sub_8032da0(int32_t* arg1, char arg2)
08032da0  {
08032da8      int32_t r1 = arg1[1];
08032dac      int32_t b = *(uint32_t*)arg1;
08032dac      int32_t var_54 = r1;
08032db0      char var_50;
08032db0      char* r7 = &var_50;
08032db6      int32_t r11 = (uint32_t)arg2 | 0x20;
08032db6      
08032dbe      if (r11 != 0x61)
08032dbe      {
08032dc0          int32_t r0_2 = arg1[0xc];
08032dc2          bool cond:0_1 = r0_2 < 0;
08032dc2          bool cond:2_1 = !r0_2;
08032dc2          bool cond:3_1 = r0_2;
08032dc2          
08032dc4          if (r0_2 < 0)
08032dc6              r0_2 = 6;
08032dc6          
08032dc8          if (cond:0_1)
08032dd4              arg1[0xc] = r0_2;
08032dc8          else
08032dc8          {
08032dca              if (cond:2_1)
08032dcc                  cond:3_1 = r11 != 0x67;
08032dcc              
08032dd0              if (!cond:3_1)
08032dd4                  arg1[0xc] = 1;
08032dc8          }
08032dbe      }
08032dbe      
08032dd6      int32_t r1_1 = arg1[1];
08032dd8      int32_t r0_3 = r1_1 >> 0x14 & 0x7ff;
08032dd8      
08032de2      if (r0_3 == 0x7ff)
08032de2      {
08032de4          int32_t r0_4 = r1_1 << 0xc;
08032de4          bool cond:1_1 = r0_4;
08032de4          
08032de6          if (!r0_4)
08032dea              cond:1_1 = *(uint32_t*)arg1;
08032dea          
08032dec          void* const r1_2;
08032dec          
08032dec          if (cond:1_1)
08032dec          {
08032e04              arg1[6] = 3;
08032e04              
08032e0e              r1_2 = (uint32_t)arg2 - 0x61 < 0x1a ? &data_803342c : &data_8033430;
08032dec          }
08032dec          else
08032dec          {
08032df0              arg1[6] = 3;
08032df0              
08032dfa              r1_2 = (uint32_t)arg2 - 0x61 < 0x1a ? &data_8033434 : &data_8033438;
08032dec          }
08032dec          
08032e18          return memcpy_(arg1[3], r1_2, 3);
08032de2      }
08032de2      
08032e20      int32_t r0_13;
08032e20      int32_t r5_1;
08032e20      
08032e20      if (r0_3 >= 1)
08032e20      {
08032e58      label_8032e58:
08032e58          r5_1 = r0_3 - 0x3fe;
08032e5a          arg1[1] = (arg1[1] & 0x800fffff) | 0x3fe00000;
08032e5c          r0_13 = 0xffffffff;
08032e20      }
08032e20      else
08032e20      {
08032e24          r0_3 = sub_8035fdc(arg1);
08032e24          
08032e2a          if (r0_3 < 1)
08032e2a              goto label_8032e58;
08032e2a          
08032e2c          r5_1 = 0;
08032e2e          r0_13 = 0;
08032e20      }
08032e20      
08032e34      if (r11 == 0x61)
08032e34      {
08032e36          char* r1_3 = arg1[3];
08032e3a          *(uint8_t*)r1_3 = 0x30;
08032e3e          arg1[3] = &r1_3[2];
08032e46          char r2_3;
08032e46          
08032e46          r2_3 = (uint32_t)arg2 == 0x61 ? 0x78 : 0x58;
08032e46          
08032e6e          r1_3[1] = r2_3;
08032e74          arg1[5] += 2;
08032e34      }
08032e34      
08032e76      int32_t r5_2;
08032e76      int32_t r6_1;
08032e76      
08032e76      if (!r0_13)
08032e76      {
08032e78          r6_1 = 0;
08032e7a          r5_2 = 0;
08032e76      }
08032e76      else
08032e76      {
08032e82          void var_4f;
08032e82          
08032e82          if (r11 != 0x61)
08032e82          {
08032fb6              int32_t b_2 = b;
08032fbe              sub_8031ac8(b_2, var_54, 0, 0);
08032fbe              
08032fc2              if (r11 < 0x61)
08032fc2              {
08032fc8                  b = b_2;
08032fc8                  var_54 ^= 0x80000000;
08032fc2              }
08032fc2              
08032fde              r5_2 = (int32_t)(int16_t)((int32_t)(int16_t)r5_1 * 0x7597 / 0x186a0);
08032fe0              int32_t i_1 = 7 - r5_2;
08032fea              int32_t a;
08032fea              int32_t var_54_2;
08032fea              
08032fea              if (i_1 < 1)
08032fea              {
0803305e                  for (int32_t i = 0 - i_1; i; i s>>= 1)
0803305e                  {
08033034                      int32_t r0_34;
08033034                      int32_t r1_25;
08033034                      
08033034                      if (i << 0x1f < 0)
0803303e                          r0_34 = soft_dmul(a, b);
0803304e                      int32_t r0_36;
0803304e                      int32_t r1_27;
0803304e                      r0_36 = soft_dmul(a, b);
0803305e                  }
0803305e                  
08033068                  int32_t b_3;
08033068                  int32_t r1_29;
08033068                  b_3 = soft_dadd(a, b);
0803306c                  b = b_3;
0803306c                  var_54_2 = r1_29;
08032fea              }
08032fea              else
08032fea              {
08032fec                  int32_t b_5 = b;
08032fec                  int32_t r7_2 = var_54;
08032fec                  
0803301e                  do
0803301e                  {
08032ff4                      if (i_1 << 0x1f < 0)
08032ff4                      {
08032ffe                          int32_t b_7;
08032ffe                          int32_t r1_21;
08032ffe                          b_7 = soft_dmul(a, b);
08033002                          b_5 = b_7;
08033004                          r7_2 = r1_21;
08032ff4                      }
08032ff4                      
0803300e                      i_1 s>>= 1;
08033012                      int32_t r0_31;
08033012                      int32_t r1_23;
08033012                      r0_31 = soft_dmul(a, b);
0803301e                  } while (i_1);
0803301e                  
08033020                  b = b_5;
08033020                  var_54_2 = r7_2;
08032fea              }
08032fea              
0803307a              int32_t r0_38;
0803307a              
0803307a              r0_38 = r11 == 0x66 ? r5_2 + 0xa : 6;
0803307a              
08033082              int32_t i_2 = r0_38 + arg1[0xc];
08033082              
08033086              if (i_2 >= 0x14)
08033088                  i_2 = 0x13;
08033088              
0803308c              var_50 = 0x30;
08033090              void* r7_4 = &var_4f;
08033090              
08033096              while (i_2 >= 1)
08033096              {
0803309c                  while (true)
0803309c                  {
0803309c                      uint32_t r0_40 = sub_802ffa0(b, var_54_2);
080330a0                      void* r1_32 = (char*)r7_4 + 8;
080330a4                      int32_t j_3 = 4;
080330d0                      int32_t j;
080330d0                      
080330d0                      do
080330d0                      {
080330a8                          uint32_t r3_10 = r0_40 / 0xa;
080330b6                          *(uint8_t*)((char*)r1_32 - 1) =
080330b6                              (uint8_t)r0_40 - (char)(r3_10 * 0xa) + 0x30;
080330bc                          r0_40 = r3_10 / 0xa;
080330ca                          j = j_3;
080330ca                          j_3 -= 1;
080330cc                          r1_32 -= 2;
080330cc                          *(uint8_t*)r1_32 = (uint8_t)r3_10 - (char)(r0_40 * 0xa) + 0x30;
080330d0                      } while (j != 1);
080330d2                      i_2 -= 8;
080330d6                      r7_4 = (char*)r1_32 + 8;
080330d6                      
080330da                      if (i_2 < 1)
080330da                          break;
080330da                      
080330e4                      int32_t r0_45;
080330e4                      int32_t r1_34;
080330e4                      r0_45 = sub_802e6b8(sub_802ffa0(b, var_54_2));
080330f0                      sub_802eb60(b, var_54_2, r0_45, r1_34);
080330f8                      int32_t b_4;
080330f8                      int32_t r1_36;
080330f8                      b_4 = soft_dmul(a, b);
080330fc                      b = b_4;
080330fc                      var_54_2 = r1_36;
0803309c                  }
08033096              }
08033096              
08033118              int32_t r0_47 = (char*)r7_4 - &var_4f;
0803311a              r7 = &var_4f;
08033126              uint32_t r1_37;
08033126              
08033126              while (true)
08033126              {
08033126                  r1_37 = (uint32_t)*(uint8_t*)r7;
08033126                  
0803312a                  if (r1_37 != 0x30)
0803312a                      break;
0803312a                  
08033120                  r0_47 -= 1;
08033122                  r5_2 -= 1;
08033124                  r7 = &r7[1];
08033126              }
08033126              
08033130              if (r11 == 0x66)
08033132                  r1_37 = r5_2 + 1;
08033132              
08033134              if (r11 != 0x66)
08033134              {
0803313a                  r1_37 = r11 == 0x65 ? 1 : 0;
08033134              }
08033134              
08033144              int32_t r6_6 = (int32_t)((uint16_t)r1_37 + (int16_t)arg1[0xc]);
08033144              
08033148              if (r0_47 < r6_6)
0803314a                  r6_6 = r0_47;
0803314a              
0803314c              r6_1 = (int32_t)(int16_t)r6_6;
0803314e              int32_t r1_38 = r6_1;
0803314e              
08033150              if (r1_38 >= 0)
08033150              {
08033154                  uint32_t r0_48;
08033154                  bool cond:18_1;
08033154                  
08033154                  if (r1_38 < r0_47)
08033154                  {
08033156                      r0_48 = (uint32_t)r7[r1_38];
08033158                      cond:18_1 = r0_48 >= 0x35;
08033158                      
0803315a                      if (r0_48 >= 0x35)
0803315c                          r0_48 = 0x39;
08033154                  }
08033154                  
0803315e                  if (r1_38 >= r0_47 || !cond:18_1)
08033160                      r0_48 = 0x30;
08033160                  
08033164                  void* r2_23 = &r7[r1_38] - 1;
08033164                  
0803316a                  while (true)
0803316a                  {
0803316a                      uint32_t r3_15 = (uint32_t)*(uint8_t*)r2_23;
0803316a                      r2_23 -= 1;
0803316e                      r1_38 -= 1;
0803316e                      
08033172                      if (r3_15 != r0_48)
08033172                          break;
08033172                      
08033168                      r6_1 -= 1;
0803316a                  }
0803316a                  
08033176                  if (r0_48 == 0x39)
0803317c                      r7[r1_38] += 1;
0803317c                  
08033180                  if (r1_38 < 0)
08033180                  {
08033182                      r7 -= 1;
08033184                      r6_1 += 1;
08033186                      r5_2 += 1;
08033180                  }
08033150              }
08032e82          }
08032e82          else
08032e82          {
08032e86              int32_t r0_14 = arg1[0xc];
08032e88              int32_t b_6 = *(uint32_t*)arg1;
08032e88              int32_t r11_1 = arg1[1];
08032e8e              int16_t r6_2;
08032e8e              
08032e8e              r6_2 = r0_14 < 0 ? 0x21 : (uint16_t)r0_14 + 1;
08032e8e              
08032e9c              sub_8031ac8(b, var_54, 0, 0);
08032ea0              int32_t r6_3 = (int32_t)r6_2;
08032ea2              int32_t var_54_1;
08032ea2              
08032ea2              if (r0_14 < 0)
08032ea2              {
08032ea8                  b = b_6;
08032ea8                  var_54_1 = r11_1 ^ 0x80000000;
08032ea2              }
08032ea2              else
08032ea2              {
08032eac                  b = b_6;
08032eac                  var_54_1 = r11_1;
08032ea2              }
08032ea2              
08032eb0              int32_t i_3 = r6_3 + 1;
08032eb4              r5_2 = r5_1 - 4;
08032eb6              bool cond:9_1 = i_3 >= 1;
08032eba              var_50 = 0;
08032ebe              void* r7_1 = &var_4f;
08032ebe              
08032ec2              while (i_3 >= 1)
08032ec2              {
08032ecc                  sub_80360c8(b, var_54_1, 0, 0);
08032ecc                  
08032ed0                  if (cond:9_1)
08032ed0                      break;
08032ed0                  
08032ed6                  sub_8036aec(&b, 0x1c);
08032ede                  int32_t j_2 = sub_802ff74(b, var_54_1);
08032ee2                  i_3 -= 7;
08032eea                  int32_t j_1 = j_2;
08032eea                  
08032eec                  if (i_3 >= 1)
08032eec                  {
08032eee                      int32_t r0_20;
08032eee                      int32_t r1_9;
08032eee                      r0_20 = sub_802e6a4(j_2);
08032efa                      int32_t b_1;
08032efa                      int32_t r1_11;
08032efa                      b_1 = sub_802eb60(b, var_54_1, r0_20, r1_9);
08032efe                      b = b_1;
08032efe                      var_54_1 = r1_11;
08032eec                  }
08032eec                  
08032f02                  void* r0_22 = (char*)r7_1 + 7;
08032f04                  int32_t r1_12 = 7;
08032f04                  
08032f18                  for (; j_1 >= 1; j_1 s>>= 4)
08032f18                  {
08032f1a                      int32_t temp1_1 = r1_12;
08032f1a                      r1_12 -= 1;
08032f1a                      
08032f1c                      if (temp1_1 - 1 < 0)
08032f1c                          break;
08032f1c                      
08032f0c                      r0_22 -= 1;
08032f0c                      *(uint8_t*)r0_22 = (uint8_t)j_1 & 0xf;
08032f18                  }
08032f18                  
08032f28                  int32_t temp0_1;
08032f28                  
08032f28                  do
08032f28                  {
08032f1e                      temp0_1 = r1_12;
08032f1e                      r1_12 -= 1;
08032f1e                      
08032f20                      if (temp0_1 - 1 >= 0)
08032f20                      {
08032f24                          r0_22 -= 1;
08032f24                          *(uint8_t*)r0_22 = 0;
08032f20                      }
08032f28                  } while (temp0_1 - 1 >= 0);
08032f2a                  r7_1 = (char*)r0_22 + 7;
08032f2c                  cond:9_1 = i_3 >= 1;
08032ec2              }
08032ec2              
08032f36              int32_t r1_13 = (char*)r7_1 - &var_4f;
08032f36              
08032f3a              if (r1_13 < r6_3)
08032f3c                  r6_3 = r1_13;
08032f3c              
08032f3e              r6_1 = (int32_t)(int16_t)r6_3;
08032f40              int32_t r0_23 = r6_1;
08032f42              r7 = &var_4f;
08032f42              
08032f46              if (r0_23 >= 0)
08032f46              {
08032f4a                  uint32_t r1_15;
08032f4a                  bool cond:12_1;
08032f4a                  
08032f4a                  if (r0_23 < r1_13)
08032f4a                  {
08032f50                      r1_15 = (uint32_t)(&var_50)[r0_23 + 1];
08032f52                      cond:12_1 = r1_15 >= 8;
08032f52                      
08032f54                      if (r1_15 >= 8)
08032f56                          r1_15 = 0xf;
08032f4a                  }
08032f4a                  
08032f58                  if (r0_23 >= r1_13 || !cond:12_1)
08032f5a                      r1_15 = 0;
08032f5a                  
08032f5e                  void* r2_8 = &(&var_50)[r0_23];
08032f5e                  
08032f64                  while (true)
08032f64                  {
08032f64                      uint32_t r3_2 = (uint32_t)*(uint8_t*)r2_8;
08032f64                      r2_8 -= 1;
08032f68                      r0_23 -= 1;
08032f68                      
08032f6c                      if (r3_2 != r1_15)
08032f6c                          break;
08032f6c                      
08032f62                      r6_1 -= 1;
08032f64                  }
08032f64                  
08032f70                  if (r1_15 == 0xf)
08032f70                  {
08032f74                      void* r1_16 = &(&var_50)[r0_23];
08032f7a                      *(uint8_t*)((char*)r1_16 + 1) += 1;
08032f70                  }
08032f70                  
08032f7e                  if (r0_23 < 0)
08032f7e                  {
08032f80                      r7 = &var_50;
08032f82                      r6_1 += 1;
08032f84                      r5_2 += 4;
08032f7e                  }
08032f7e                  
08032f86                  r6_1 = (int32_t)(int16_t)r6_1;
08032f88                  int32_t r0_24 = r6_1 - 1;
08032f88                  
08032f8a                  if (r6_1 - 1 >= 0)
08032f8a                  {
08032f8c                      void* r1_17 = &r7[r0_24];
08032fa6                      int32_t temp3_1;
08032fa6                      
08032fa6                      do
08032fa6                      {
08032f92                          uint32_t r2_13 = (uint32_t)(*(uint8_t*)r1_17 + 0x30);
08032f92                          
08032f96                          if (r2_13 >= 0x3a)
08032f9e                              r2_13 += (uint32_t)arg2 - 0x3a;
08032f9e                          
08032fa0                          temp3_1 = r0_24;
08032fa0                          r0_24 -= 1;
08032fa2                          *(uint8_t*)r1_17 = (char)r2_13;
08032fa2                          r1_17 -= 1;
08032fa6                      } while (temp3_1 - 1 >= 0);
08032f8a                  }
08032f46              }
08032f46              
08032fac              if (arg1[0xc] < 0)
08032fb2                  arg1[0xc] = r6_1 - 1;
08032e82          }
08032e76      }
08032e76      
08033196      return sub_80331a0(arg1, (uint32_t)arg2, r7, (int32_t)(int16_t)r6_1, (int16_t)r5_2);
08032da0  }
08033102        00 bf                                                                                        ..
08033104  int32_t data_8033104 = 0x186a0
08033108  int32_t data_8033108 = 0x40240000
0803310c  int32_t data_803310c = 0x3ff00000
08033110  int32_t data_8033110 = 0x4197d784
080331a0    int32_t sub_80331a0(void* arg1, int32_t arg2, void* arg3, int32_t arg4, int16_t arg5)
080331a0  {
080331a8      int32_t r10 = arg2;
080331aa      void* const r8 = arg3;
080331ac      int32_t r5 = arg4;
080331b4      char* r0_1 = *(uint32_t*)(sub_8036c3a() + 0x24);
080331b6      int32_t r7 = *(uint32_t*)((char*)arg1 + 0x30);
080331b8      char r9 = *(uint8_t*)r0_1;
080331b8      
080331bc      if (r5 < 1)
080331bc      {
080331be          r5 = 1;
080331c0          r8 = &data_803343c;
080331bc      }
080331bc      
080331c4      int32_t r0_2 = r10 | 0x20;
080331c8      int32_t r4 = (int32_t)arg5;
080331c8      
080331ce      if (r0_2 == 0x66)
080331d0          r4 += 1;
080331d0      
080331d2      if (r0_2 == 0x66)
080331d2      {
080331fa      label_80331fa:
080331fa          int32_t r4_2 = (int32_t)(int16_t)r4;
080331fc          char* r0_5 = *(uint32_t*)((char*)arg1 + 0xc);
080331fe          int32_t r1 = *(uint32_t*)((char*)arg1 + 0x18);
080331fe          
08033202          if (r4_2 >= 1)
08033202          {
08033250              void* r0_13 = &r0_5[r1];
08033250              
08033252              if (r5 >= r4_2)
08033252              {
08033284                  memcpy_(r0_13, r8, r4_2);
0803328a                  int32_t r0_21 = r4_2 + *(uint32_t*)((char*)arg1 + 0x18);
0803328a                  
08033298                  if (r7 >= 1 || (uint32_t)*(uint8_t*)((char*)arg1 + 0x38) << 0x1c < 0)
08033298                  {
0803329c                      (*(uint32_t*)((char*)arg1 + 0xc))[r0_21] = r9;
080332a0                      r0_21 += 1;
08033298                  }
08033298                  
080332a2                  *(uint32_t*)((char*)arg1 + 0x18) = r0_21;
080332a4                  int32_t r5_3 = (int32_t)((uint16_t)r5 - (uint16_t)r4_2);
080332a4                  
080332a8                  if (r7 < r5_3)
080332aa                      r5_3 = r7;
080332aa                  
080332b0                  int32_t r5_4 = (int32_t)(int16_t)r5_3;
080332ba                  memcpy_(
080332ba                      *(uint32_t*)((char*)arg1 + 0xc) + *(uint32_t*)((char*)arg1 + 0x18), 
080332ba                      (char*)r8 + r4_2, r5_4);
080332c2                  *(uint32_t*)((char*)arg1 + 0x18) += r5_4;
080332c6                  *(uint32_t*)((char*)arg1 + 0x24) = r7 - r5_4;
08033252              }
08033252              else
08033252              {
08033258                  memcpy_(r0_13, r8, r5);
0803325e                  int32_t r1_4 = r5 + *(uint32_t*)((char*)arg1 + 0x18);
08033264                  *(uint32_t*)((char*)arg1 + 0x18) = r1_4;
08033266                  *(uint32_t*)((char*)arg1 + 0x24) = r4_2 - r5;
08033266                  
08033270                  if (r7 >= 1 || (uint32_t)*(uint8_t*)((char*)arg1 + 0x38) << 0x1c < 0)
08033270                  {
08033274                      (*(uint32_t*)((char*)arg1 + 0xc))[r1_4] = r9;
0803327c                      *(uint32_t*)((char*)arg1 + 0x1c) += 1;
08033270                  }
08033270                  
0803327e                  *(uint32_t*)((char*)arg1 + 0x28) = r7;
08033252              }
08033202          }
08033202          else
08033202          {
08033204              int32_t r2 = r1 + 1;
08033208              r0_5[r1] = 0x30;
08033208              
08033214              if (r7 >= 1 || (uint32_t)*(uint8_t*)((char*)arg1 + 0x38) << 0x1c < 0)
08033214              {
08033218                  (*(uint32_t*)((char*)arg1 + 0xc))[r2] = r9;
0803321c                  r2 += 1;
08033214              }
08033214              
08033220              if (r7 < -(r4_2))
08033222                  r4_2 = 0 - r7;
08033222              
08033224              int32_t r4_3 = (int32_t)(int16_t)r4_2;
08033228              *(uint32_t*)((char*)arg1 + 0x24) = 0 - r4_3;
0803322a              int32_t r7_1 = r4_3 + r7;
0803322e              *(uint32_t*)((char*)arg1 + 0x18) = r2;
0803322e              
08033230              if (r7_1 < r5)
08033232                  r5 = r7_1;
08033232              
08033234              void* r0_10 = *(uint32_t*)((char*)arg1 + 0xc);
08033236              int32_t r3 = *(uint32_t*)((char*)arg1 + 0x18);
08033238              int32_t r5_1 = (int32_t)(int16_t)r5;
0803323a              *(uint32_t*)((char*)arg1 + 0x1c) = r5_1;
08033242              memcpy_((char*)r0_10 + r3, r8, r5_1);
08033248              *(uint32_t*)((char*)arg1 + 0x28) = r7_1 - r5_1;
08033202          }
080331d2      }
080331d2      else
080331d2      {
080331d6          if (r0_2 == 0x67)
080331d6          {
080331e0              if (r4 >= 0xfffffffc && r4 < r7)
080331e0              {
080331ee                  if ((uint32_t)*(uint8_t*)((char*)arg1 + 0x38) << 0x1c >= 0 && r5 < r7)
080331f0                      r7 = r5;
080331f0                  
080331f2                  r4 = (int32_t)((uint16_t)r4 + 1);
080331f4                  int32_t temp1_1 = r7;
080331f4                  r7 -= r4;
080331f4                  
080331f6                  if (temp1_1 - r4 < 0)
080331f8                      r7 = 0;
080331f8                  
080331f6                  goto label_80331fa;
080331e0              }
080331e0              
080332e0              if (r5 < r7 && (uint32_t)*(uint8_t*)((char*)arg1 + 0x38) << 0x1c >= 0)
080332e2                  r7 = r5;
080332e2              
080332e4              int32_t temp0_1 = r7;
080332e4              r7 -= 1;
080332e4              
080332e6              if (temp0_1 - 1 < 0)
080332e8                  r7 = 0;
080332e8              
080332ee              r10 = r10 != 0x67 ? 0x45 : 0x65;
080331d6          }
080331d6          else if (r10 == 0x61)
080332d0              r10 = 0x70;
080332ce          else if (r10 == 0x41)
08033300              r10 = 0x50;
08033300          
08033304          int32_t r1_12 = *(uint32_t*)((char*)arg1 + 0x18);
08033306          char* r3_2 = *(uint32_t*)((char*)arg1 + 0xc);
0803330a          *(uint32_t*)((char*)arg1 + 0x18) = r1_12 + 1;
08033312          r3_2[r1_12] = *(uint8_t*)r8;
08033312          
0803331c          if (r7 >= 1 || (uint32_t)*(uint8_t*)((char*)arg1 + 0x38) << 0x1c < 0)
0803331c          {
0803331e              char* r1_15 = *(uint32_t*)((char*)arg1 + 0xc);
08033322              *(uint32_t*)((char*)arg1 + 0x18) = r1_12 + 2;
08033324              r1_15[r1_12 + 1] = r9;
08033324              
0803332a              if (r7 >= 1)
0803332a              {
0803332e                  int32_t r5_6 = (int32_t)((uint16_t)r5 - 1);
0803332e                  
08033332                  if (r7 < r5_6)
08033334                      r5_6 = r7;
08033334                  
08033338                  int32_t r5_7 = (int32_t)(int16_t)r5_6;
08033340                  memcpy_(*(uint32_t*)((char*)arg1 + 0xc) + r1_12 + 2, (char*)r8 + 1, r5_7);
08033348                  *(uint32_t*)((char*)arg1 + 0x18) += r5_7;
0803334c                  *(uint32_t*)((char*)arg1 + 0x24) = r7 - r5_7;
0803332a              }
0803331c          }
0803331c          
08033352          char* r1_18 = *(uint32_t*)((char*)arg1 + 0x18) + *(uint32_t*)((char*)arg1 + 0xc);
08033356          *(uint8_t*)r1_18 = (char)r10;
0803335a          void* r8_2;
0803335a          
0803335a          if (r4 < 0)
0803335a          {
08033368              r1_18[1] = 0x2d;
0803336a              r8_2 = &r1_18[2];
0803336e              r4 = 0 - r4;
0803335a          }
0803335a          else
0803335a          {
0803335e              r1_18[1] = 0x2b;
08033360              r8_2 = &r1_18[2];
0803335a          }
0803335a          
08033370          int32_t i = 0;
08033372          char var_30[0x10];
08033372          char (* r7_2)[0x10] = &var_30;
08033372          
08033388          while (true)
08033388          {
08033388              int32_t r1_19 = (int32_t)(int16_t)r4;
08033388              
0803338c              if (r1_19 < 1)
0803338c                  break;
0803338c              
0803337a              int32_t var_38;
0803337a              sub_8036c6c(&var_38, r1_19, 0xa);
08033380              char var_34;
08033380              *(uint8_t*)r7_2 = var_34;
08033380              r7_2 = &(*(uint128_t*)r7_2)[1];
08033384              i += 1;
08033386              r4 = var_38;
08033388          }
08033388          
08033398          if (i < 2 && (r10 | 0x20) == 0x65)
08033398          {
0803339c              *(uint8_t*)r8_2 = 0x30;
0803339c              r8_2 += 1;
08033398          }
08033398          
080333a0          if (i)
080333a0          {
080333b8              while (i >= 1)
080333b8              {
080333aa                  i -= 1;
080333b2                  *(uint8_t*)r8_2 = var_30[i] + 0x30;
080333b2                  r8_2 += 1;
080333b8              }
080333a0          }
080333a0          else
080333a0          {
080333a4              *(uint8_t*)r8_2 = 0x30;
080333a4              r8_2 += 1;
080333a0          }
080333a0          
080333c4          *(uint32_t*)((char*)arg1 + 0x1c) = (char*)r8_2
080333c4              - (*(uint32_t*)((char*)arg1 + 0xc) + *(uint32_t*)((char*)arg1 + 0x18));
080331d2      }
080331d2      
080333ca      int32_t result = (uint32_t)*(uint8_t*)((char*)arg1 + 0x38) & 0x14;
080333ca      
080333d0      if (result == 0x10)
080333d0      {
080333e2          result = *(uint32_t*)((char*)arg1 + 0x28) + *(uint32_t*)((char*)arg1 + 0x1c)
080333e2              + *(uint32_t*)((char*)arg1 + 0x24) + *(uint32_t*)((char*)arg1 + 0x18)
080333e2              + *(uint32_t*)((char*)arg1 + 0x14);
080333e4          int32_t r1_25 = *(uint32_t*)((char*)arg1 + 0x34);
080333e4          
080333e8          if (result < r1_25)
080333e8          {
080333ea              result = r1_25 - result;
080333ec              *(uint32_t*)((char*)arg1 + 0x20) = result;
080333e8          }
080333d0      }
080333d0      
080333f0      return result;
080331a0  }
080333f4    int32_t print_block(int32_t (* putc_fn)(int32_t, int32_t), void* ctx, char* buf, int32_t len)
080333f4  {
080333f4      int32_t len_1 = len;
080333fa      char* buf_1 = buf;
080333fc      int32_t r7 = len;
080333fc      
08033400      if (!r7)
08033420          return 0;
08033420      
08033418      int32_t i;
08033418      
08033418      do
08033418      {
08033402          uint32_t r1 = (uint32_t)*(uint8_t*)buf_1;
08033402          buf_1 = &buf_1[1];
08033408          int32_t r0_2 = putc_fn(*(uint32_t*)((char*)ctx + 8), r1);
0803340a          *(uint32_t*)((char*)ctx + 8) = r0_2;
0803340a          
0803340c          if (!r0_2)
0803341c              return 0xffffffff;
0803341c          
08033412          *(uint32_t*)((char*)ctx + 0x2c) += 1;
08033416          i = r7;
08033416          r7 -= 1;
08033418      } while (i != 1);
0803341a      return 0;
080333f4  }
08033422        00 00                                                                                        ..
08033424  data_8033424:
08033424              68 6a 6c 74 7a 4c 00 00                                                                  hjltzL..
0803342c  data_803342c:
0803342c                                      6e 61 6e 00                                                              nan.
08033430  data_8033430:
08033430                                                  4e 41 4e 00                                                      NAN.
08033434  data_8033434:
08033434                                                              69 6e 66 00                                              inf.
08033438  data_8033438:
08033438                                                                          49 4e 46 00                                      INF.
0803343c  data_803343c:
0803343c                                                                                      30 00                                    0.
0803343e    int32_t sub_803343e(int16_t arg1, int32_t* arg2, int32_t arg3, int32_t arg4, int32_t arg5 @ r7, GPIO_TypeDef* arg6, uint16_t arg7)
0803343e  {
08033446      rcc_enable_by_code(*(uint16_t*)((char*)arg4)[2]);
0803344e      rcc_enable_by_code(arg1);
0803345a      gpio_config_mode_pull(arg6, 3, 0, arg7);
08033460      sub_8036ccc(arg2);
08033468      sub_8036cf4(arg2, 0);
0803346e      sub_8036ca4(arg2);
08033474      sub_8036c7c(arg2);
08033480      sub_8036d2a(arg2, arg3, (uint16_t)arg4);
08033486      return arg5;
0803343e  }
0803348a    int32_t sub_803348a(int32_t arg1, int32_t* arg2, int32_t arg3, int32_t arg4 @ r7, int16_t arg5)
0803348a  {
0803348a      int32_t r3;
0803348a      int32_t var_4 = r3;
0803348a      int32_t var_10 = arg1;
08033494      sub_8036d2a(arg2, arg3, arg5);
0803349a      return arg4;
0803348a  }
0803349e                                                                                            00 00                                ..
080334a0    int32_t sub_80334a0(int32_t* arg1, int16_t arg2, int16_t arg3, int32_t arg4 @ r7, int16_t arg5, GPIO_TypeDef* arg6, int32_t arg7, int32_t arg8)
080334a0  {
080334a0      int32_t r3;
080334a0      int32_t var_4 = r3;
080334aa      sub_8033526(arg6, arg8, arg7);
080334b6      sub_8033594(arg1, (uint32_t)arg3);
080334c2      sub_80336ac(arg1, arg2);
080334c8      return arg4;
080334a0  }
080334cc    int32_t sub_80334cc(int32_t* arg1, int32_t arg2 @ r7)
080334cc  {
080334ce      sub_8036fac(arg1);
080334d2      return arg2;
080334cc  }
080334d4    int32_t sub_80334d4(int32_t* arg1, int16_t arg2, int32_t arg3, int32_t arg4, int32_t arg5 @ r5)
080334d4  {
080334d4      int32_t var_8 = arg3;
080334dc      /* unimplemented  {vcmp.f32.F32 s0, s1} */
080334e0      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
080334e4      uint32_t r0_1;
080334e4      bool n;
080334e4      bool v;
080334e4      
080334e4      if (n != v)
080334e4      {
080334f0          float32_process(0x42c60001);
080334f8          int32_t r0_3;
080334f8          int32_t r1;
080334f8          r0_3 = soft_dadd(arg4, arg5);
08033502          sub_802e6b8(arg4);
0803350a          int32_t r0_5;
0803350a          int32_t r1_1;
0803350a          r0_5 = soft_dmul();
08033512          r0_1 = (uint32_t)sub_802ff74(r0_5, r1_1);
080334e4      }
080334e4      else
080334e8          r0_1 = arg4 + 1;
080334e8      
0803351c      sub_8037418(arg1, arg2, r0_1);
08033522      return arg4;
080334d4  }
08033526    void* sub_8033526(GPIO_TypeDef* arg1, int32_t arg2, int32_t arg3)
08033526  {
08033534      if (arg1 == &GPIOA)
0803354e          rcc_enable_by_code(0xc00);
08033534      else if (arg1 == &GPIOB)
08033558          rcc_enable_by_code(0xc01);
0803353a      else if (arg1 == &GPIOC)
08033562          rcc_enable_by_code(0xc02);
08033540      else if (arg1 == 0x40021000)
0803356c          rcc_enable_by_code(0xc04);
0803356c      
08033578      gpio_config_mode_pull(arg1, 2, 0, (uint16_t)arg3);
08033584      gpio_config_otype_speed(arg1, 0, 2, (uint16_t)arg3);
08033592      return sub_80304da(arg1, arg2, arg3);
08033526  }
08033594    int32_t* sub_8033594(int32_t* arg1, int32_t arg2)
08033594  {
08033594      int32_t r3;
08033594      int32_t var_14 = r3;
08033594      int32_t r2;
08033594      int32_t var_18 = r2;
08033594      int32_t var_1c = arg2;
08033594      int32_t* result = arg1;
08033594      
080335a2      if (arg1 == 0x40000000)
080335a2      {
080335e8          if ((uint32_t)data_2000e41e << 0x1e >= 0)
080335e8          {
080335ee              rcc_enable_by_code(0x1000);
080335fc              (*(uint16_t*)data_2000e41e) |= 2;
0803367a          label_803367a:
0803367a              sub_8030118(0x1000000);
08033680              int32_t r7;
08033680              sub_8036d98(arg1, r7);
08033684              (uint16_t)result = (uint16_t)arg2;
0803368a              *(uint16_t*)((char*)result)[2] = 0;
08033690              (uint16_t)var_1c = 0;
08033694              var_18 = r2;
08033698              (uint16_t)var_14 = 0;
0803369e              *(uint8_t*)((char*)var_14)[2] = 0;
080336a6              sub_8036f0e(arg1, &result);
080335e8          }
080335a2      }
080335a2      else if (arg1 == 0x40000400)
080335a8      {
08033606          if ((uint32_t)data_2000e41e << 0x1d >= 0)
08033606          {
0803360c              rcc_enable_by_code(0x1001);
0803361a              (*(uint16_t*)data_2000e41e) |= 4;
0803361c              goto label_803367a;
08033606          }
080335a8      }
080335a8      else if (arg1 == 0x40000800)
080335ae      {
08033624          if ((uint32_t)data_2000e41e << 0x1c >= 0)
08033624          {
0803362a              rcc_enable_by_code(0x1002);
08033638              (*(uint16_t*)data_2000e41e) |= 8;
0803363a              goto label_803367a;
08033624          }
080335ae      }
080335ae      else if (arg1 == 0x40000c00)
080335b4      {
08033642          if ((uint32_t)data_2000e41e << 0x1b >= 0)
08033642          {
08033648              rcc_enable_by_code(0x1003);
08033656              (*(uint16_t*)data_2000e41e) |= 0x10;
08033658              goto label_803367a;
08033642          }
080335b4      }
080335b4      else if (arg1 != 0x40010000)
080335ba      {
080335c0          if (arg1 != 0x40010400)
080335c0              goto label_803367a;
080335c0          
08033660          if ((uint32_t)data_2000e41e << 0x18 >= 0)
08033660          {
08033666              rcc_enable_by_code(0x1101);
08033674              (*(uint16_t*)data_2000e41e) |= 0x80;
08033674              goto label_803367a;
08033660          }
080335ba      }
080335ba      else if ((uint32_t)data_2000e41e << 0x1f >= 0)
080335ca      {
080335d0          rcc_enable_by_code(0x1100);
080335de          (*(uint16_t*)data_2000e41e) |= 1;
080335e0          goto label_803367a;
080335ca      }
080335ca      
080336aa      return result;
08033594  }
080336ac    void* sub_80336ac(void* arg1, int16_t arg2)
080336ac  {
080336b4      int16_t r2;
080336b4      int16_t var_1a = r2;
080336ba      int32_t var_20 = 1;
080336be      int16_t var_18 = 0;
080336c4      int16_t var_1c = 0;
080336ca      int16_t var_16 = 0;
080336d0      int16_t var_14 = 0;
080336dc      sub_803703a(arg1, arg2, &var_20);
080336e8      sub_8037418(arg1, arg2, 0);
080336f4      sub_8037380(arg1, arg2, 0x60);
08033700      sub_8037444(arg1, arg2, 0);
08033700      
0803370e      if (arg1 == 0x40010000 || arg1 == 0x40010400)
08033714          sub_8037014(arg1, 1);
08033714      
0803371a      sub_8036fc0(arg1);
08033720      return arg1;
080336ac  }
08033722        00 00                                                                                        ..
08033724  int32_t data_8033724 = 0x42c60001
08033728  int32_t data_8033728 = 0x40590000
0803372c  int32_t data_803372c = 0x40020000
08033730  int32_t data_8033730 = 0x40020400
08033734  int32_t data_8033734 = 0x40020800
08033738  int32_t data_8033738 = 0x40021000
0803373c  int32_t data_803373c = 0x40000400
08033740  int32_t data_8033740 = 0x40000800
08033744  int32_t data_8033744 = 0x40000c00
08033748  int32_t data_8033748 = 0x40010000
0803374c  int32_t data_803374c = 0x40010400
08033750  int32_t data_8033750 = 0x2000e41e
08033754    int32_t sub_8033754(void* arg1, int16_t arg2, int32_t arg3, int16_t arg4, int32_t arg5, int32_t arg6, char arg7, GPIO_TypeDef* arg8, int32_t arg9, int32_t arg10)
08033754  {
08033760      sub_8033790(arg8, arg10, arg9);
0803376e      sub_80337fe((uint16_t)arg3, arg1, *(uint16_t*)((char*)arg3)[2]);
08033786      sub_803383a(arg1, arg2, arg4, arg5, arg6, arg7);
0803378c      return arg6;
08033754  }
08033790    void* sub_8033790(GPIO_TypeDef* arg1, int32_t arg2, int32_t arg3)
08033790  {
0803379e      if (arg1 == &GPIOA)
080337b8          rcc_enable_by_code(0xc00);
0803379e      else if (arg1 == &GPIOB)
080337c2          rcc_enable_by_code(0xc01);
080337a4      else if (arg1 == &GPIOC)
080337cc          rcc_enable_by_code(0xc02);
080337aa      else if (arg1 == 0x40021000)
080337d6          rcc_enable_by_code(0xc04);
080337d6      
080337e2      gpio_config_mode_pull(arg1, 2, 0, (uint16_t)arg3);
080337ee      gpio_config_otype_speed(arg1, 0, 2, (uint16_t)arg3);
080337fc      return sub_80304da(arg1, arg2, arg3);
08033790  }
080337fe    void* sub_80337fe(int16_t arg1, int32_t* arg2, int16_t arg3)
080337fe  {
08033808      rcc_enable_by_code(arg1);
0803380e      int32_t r7;
0803380e      sub_8036d98(arg2, r7);
08033812      int16_t var_20 = arg3;
08033818      int16_t var_1e = 0;
0803381e      int16_t var_1c = 0;
08033826      int32_t var_18 = 0xffff;
0803382a      int16_t var_14 = 0;
08033838      return sub_8036f0e(arg2, &var_20);
080337fe  }
0803383a    int32_t sub_803383a(void* arg1, int16_t arg2, int16_t arg3, int32_t arg4, int32_t arg5, uint8_t arg6)
0803383a  {
08033842      int16_t var_18 = arg3;
08033848      int16_t var_16 = 1;
0803384e      int16_t var_14 = 0;
08033854      int16_t var_12 = 0xf;
0803385e      sub_80374dc(arg1, arg2, &var_18);
08033864      sub_8036fc0(arg1);
0803386c      sub_8037004(arg1, arg4);
08033874      sub_8036fca(arg1, arg5);
0803387e      nvic_enable_irq_with_priority(arg6, 1, 0);
08033884      sub_8036fac(arg1);
08033888      return var_18;
0803383a  }
0803388a    int32_t sub_803388a(int32_t arg1 @ r7)
0803388a  {
08033898      if (sub_8036fe8(0x40000000, 4) == 1)
08033898      {
080338a0          sub_8037004(0x40000000, 4);
080338a0          
080338aa          if (!(uint32_t)data_2000e200)
080338aa          {
080338b8              data_2000e1fc = sub_80377b0(0x40000000, 1);
080338be              data_2000e200 = 1;
080338aa          }
080338aa          else if ((uint32_t)data_2000e200 == 1)
080338c8          {
080338d6              data_2000e1fe = sub_80377b0(0x40000000, 1);
080338e2              uint32_t r0_7;
080338e2              
080338e2              if ((uint32_t)data_2000e1fc >= (uint32_t)data_2000e1fe)
080338fe                  r0_7 = 0xffff - (uint32_t)data_2000e1fc + (uint32_t)data_2000e1fe;
080338e2              else
080338ec                  r0_7 = (uint32_t)data_2000e1fe - (uint32_t)data_2000e1fc;
080338ec              
08033904              if (r0_7 > 0x7d0)
08033908                  data_2000e204 = r0_7;
08033908              
0803390e              data_2000e200 = 0;
08033918              data_2000e20c += 1;
080338c8          }
08033898      }
08033898      
0803391a      return arg1;
0803388a  }
0803391c    int32_t sub_803391c(int32_t arg1 @ r7)
0803391c  {
08033928      if (sub_8036fe8(0x40000400, 2) == 1)
08033928      {
0803392e          sub_8037004(0x40000400, 2);
0803392e          
08033938          if (!(uint32_t)data_2000e214)
08033938          {
08033944              data_2000e210 = sub_80377b0(0x40000400, 0);
0803394a              data_2000e214 = 1;
08033938          }
08033938          else if ((uint32_t)data_2000e214 == 1)
08033954          {
08033960              data_2000e212 = sub_80377b0(0x40000400, 0);
0803396c              uint32_t r0_7;
0803396c              
0803396c              if ((uint32_t)data_2000e210 >= (uint32_t)data_2000e212)
08033988                  r0_7 = 0xffff - (uint32_t)data_2000e210 + (uint32_t)data_2000e212;
0803396c              else
08033976                  r0_7 = (uint32_t)data_2000e212 - (uint32_t)data_2000e210;
08033976              
0803398e              if (r0_7 > 0x7d0)
08033992                  data_2000e218 = r0_7;
08033992              
08033998              data_2000e214 = 0;
080339a2              data_2000e220 += 1;
08033954          }
08033928      }
08033928      
080339a4      return arg1;
0803391c  }
080339a6    int32_t sub_80339a6(int32_t arg1 @ r7)
080339a6  {
080339b2      if (sub_8036fe8(0x40014000, 2) == 1)
080339b2      {
080339b8          sub_8037004(0x40014000, 2);
080339b8          
080339c2          if (!(uint32_t)data_2000e228)
080339c2          {
080339ce              data_2000e224 = sub_80377b0(0x40014000, 0);
080339d4              data_2000e228 = 1;
080339c2          }
080339c2          else if ((uint32_t)data_2000e228 == 1)
080339de          {
080339ea              data_2000e226 = sub_80377b0(0x40014000, 0);
080339f6              uint32_t r0_7;
080339f6              
080339f6              if ((uint32_t)data_2000e224 >= (uint32_t)data_2000e226)
08033a12                  r0_7 = 0xffff - (uint32_t)data_2000e224 + (uint32_t)data_2000e226;
080339f6              else
08033a00                  r0_7 = (uint32_t)data_2000e226 - (uint32_t)data_2000e224;
08033a00              
08033a18              if (r0_7 > 0x7d0)
08033a1c                  data_2000e22c = r0_7;
08033a1c              
08033a22              data_2000e228 = 0;
08033a2c              data_2000e234 += 1;
080339de          }
080339b2      }
080339b2      
08033a2e      return arg1;
080339a6  }
08033a30    int32_t sub_8033a30(int32_t* arg1, int32_t arg2)
08033a30  {
08033a3a      void var_20;
08033a3a      
08033a3a      if (arg2 == 0x40000000)
08033a3a      {
08033a50          memcpy(&var_20, &data_2000e1fc, 0x14);
08033a58          data_2000e204 = 0;
08033a3a      }
08033a3a      else if (arg2 == 0x40000400)
08033a40      {
08033a62          memcpy(&var_20, &data_2000e210, 0x14);
08033a6a          data_2000e218 = 0;
08033a40      }
08033a40      else if (arg2 == 0x40014000)
08033a46      {
08033a74          memcpy(&var_20, &data_2000e224, 0x14);
08033a7c          data_2000e22c = 0;
08033a46      }
08033a46      else
08033a46      {
08033a82          int32_t var_18_1 = 0;
08033a86          int16_t var_1c_1 = 0;
08033a46      }
08033a46      
08033a96      return memcpy(arg1, &var_20, 0x14);
08033a30  }
08033a98  int32_t data_8033a98 = 0x40020000
08033a9c  int32_t data_8033a9c = 0x40020400
08033aa0  int32_t data_8033aa0 = 0x40020800
08033aa4  int32_t data_8033aa4 = 0x40021000
08033aa8  int32_t data_8033aa8 = 0x2000e1fc
08033aac  int32_t data_8033aac = 0x40000400
08033ab0  int32_t data_8033ab0 = 0x2000e210
08033ab4  int32_t data_8033ab4 = 0x40014000
08033ab8  int32_t data_8033ab8 = 0x2000e224
08033abc    int32_t moduleBorderInit()
08033abc  {
08033ac6      data_2000e15c = 1;
08033ace      data_2000e15d = 0;
08033ada      data_2000e160 = sub_8030938(1);
08033ada      
08033ae4      if (!data_2000e160)
08033aea          logging_wrapper("borderDataMutex error\r\n", &data_2000e15c);
08033aea      
08033af4      data_2000e164 = 1;
08033af6      sub_802c536();
08033b02      data_2000e168 = 0x1f4;
08033b0c      data_2000e16a = 0x1f4;
08033b14      data_2000e166 = 0;
08033b2c      int32_t r2;
08033b2c      int32_t r3;
08033b2c      r2 = rtos_xTaskCreate(BorderCheckTask, "BorderCheckTask", 0x100, nullptr, 5, nullptr);
08033b36      software_mutex(3, 0x1f4, r2, r3);
08033b3c      return 1;
08033abc  }
08033b3e    uint32_t sub_8033b3e()
08033b3e  {
08033b4a      return (uint32_t)(data_2000e15d >> 1) & 1;
08033b3e  }
08033b4c    void BorderCheckTask() __noreturn
08033b4c  {
08033b54      int16_t var_16 = 0x3e8;
08033b5c      int16_t var_14 = 0x3e8;
08033b62      char var_18 = 0;
08033b68      uint32_t r5 = 0;
08033b68      
08033b98      while (true)
08033b98      {
08033b98          int32_t entry_r2;
08033b98          int32_t entry_r3;
08033b98          software_mutex(3, 0x1f4, entry_r2, entry_r3);
08033b98          
08033baa          if (!((uint32_t)(data_2000e15d >> 1) & 1))
08033baa          {
08033c18              if (rtos_dma_rx_wait_and_service(data_2000e160, 0xffffffff) != 1)
08033c1e                  logging_wrapper("Mutex Error!!!\r\n");
08033c1e              
08033c28              data_2000e164 = 1;
08033c28              
08033c3c              if (sub_8030954(data_2000e160, nullptr, 0, 0) != 1)
08033c42                  logging_wrapper("Mutex Error!!!\r\n");
08033c42              
08033c46              r5 = 0;
08033baa          }
08033baa          else
08033baa          {
08033bac              uint32_t r0_6 = sub_802abbc();
08033bac              
08033bb2              if (!r0_6)
08033bc6                  data_2000e164 = 0;
08033bb2              else if (r0_6 == 2)
08033bda                  data_2000e164 = 3;
08033bb6              else if (r0_6 < 2)
08033bd0                  data_2000e164 = 1;
08033bb8              else if (r0_6 == 3)
08033be4                  data_2000e164 = 2;
08033bbc              else
08033bee                  data_2000e164 = 0;
08033bee              
08033bf8              if ((uint32_t)data_2000e164)
08033c04                  r5 = 0;
08033bf8              else
08033bf8              {
08033bfa                  r5 = (uint32_t)(uint8_t)r5;
08033bfa                  
08033bfe                  if (r5 < 0x15)
08033c00                      r5 += 1;
08033bf8              }
08033baa          }
08033baa          
08033c4c          sub_8033fb0((uint8_t)r5);
08033c5e          uint32_t r0_17;
08033c5e          
08033c5e          if ((uint32_t)(data_2000e15d >> 2) & 1)
08033c62              r0_17 = sub_802c5e2();
08033c62          
08033c68          if (!((uint32_t)(data_2000e15d >> 2) & 1) || r0_17 != 1)
08033c68          {
08033d72              if (rtos_dma_rx_wait_and_service(data_2000e160, 0xffffffff) != 1)
08033d78                  logging_wrapper("Mutex Error!!!\r\n");
08033d78              
08033d84              data_2000e168 = 0x1f4;
08033d8e              data_2000e16a = 0x1f4;
08033d96              data_2000e166 = 0;
08033d96              
08033daa              if (sub_8030954(data_2000e160, nullptr, 0, 0) != 1)
08033db0                  logging_wrapper("Mutex Error!!!\r\n");
08033c68          }
08033c68          else
08033c68          {
08033c6e              sub_802c5ca(&var_16);
08033c6e              
08033cea              if ((uint32_t)var_16 < 0x118 && (uint32_t)var_14 < 0x118)
08033cee                  var_18 = 3;
08033cea              else if ((uint32_t)var_16 < 0x118)
08033d00                  var_18 = 1;
08033cfc              else if ((uint32_t)var_14 >= 0x118)
08033d1a                  var_18 = 0;
08033d0e              else
08033d12                  var_18 = 2;
08033d12              
08033d2e              if (rtos_dma_rx_wait_and_service(data_2000e160, 0xffffffff) != 1)
08033d34                  logging_wrapper("Mutex Error!!!\r\n");
08033d34              
08033d40              memcpy_(&data_2000e166, &var_18, 6);
08033d40              
08033d56              if (sub_8030954(data_2000e160, nullptr, 0, 0) != 1)
08033d5c                  logging_wrapper("Mutex Error!!!\r\n");
08033c68          }
08033c68          
08033dbe          logging_wrapper("********************uBorderData.state = %d\r\n", 
08033dbe              (uint32_t)data_2000e166);
08033dbe          
08033dca          if ((uint32_t)data_2000e164 == 2)
08033dd2              data_2000e16c = 4;
08033dca          else if ((uint32_t)data_2000e164 == 3)
08033de2              data_2000e16c = 3;
08033ddc          else if (!(uint32_t)data_2000e164)
08033df2              data_2000e16c = 0;
08033dec          else if ((uint32_t)data_2000e164 == 1)
08033dfc          {
08033e06              if ((uint32_t)data_2000e166 == 1)
08033e0c                  data_2000e16c = 4;
08033e06              else if ((uint32_t)data_2000e166 == 2)
08033e1c                  data_2000e16c = 3;
08033e16              else if ((uint32_t)data_2000e166 != 3)
08033b74                  data_2000e16c = 1;
08033e26              else if ((uint32_t)data_2000e16c == 1)
08033e38                  data_2000e16c = 3;
08033dfc          }
08033dfc          
08033b7e          if ((uint32_t)data_2000e16c != 1 && sub_802d0b8() == 1)
08033b88              motorBrake();
08033b88          
08033b8e          entry_r2 = rtos_delay_ticks(0x32);
08033b98      }
08033b4c  }
08033e3c    int32_t sub_8033e3c(char* arg1)
08033e3c  {
08033e52      if (rtos_dma_rx_wait_and_service(data_2000e160, 0xffffffff) != 1)
08033e56          logging_wrapper("Mutex Error!!!\r\n");
08033e56      
08033e60      int32_t result;
08033e60      memcpy_(&result, &data_2000e164, 0xa);
08033e60      
08033e74      if (sub_8030954(data_2000e160, nullptr, 0, 0) != 1)
08033e78          logging_wrapper("Mutex Error!!!\r\n");
08033e78      
08033e80      char var_10;
08033e80      int32_t r7;
08033e80      sub_8033f6c(var_10, r7);
08033e8a      memcpy_(arg1, &result, 0xa);
08033e8e      return result;
08033e3c  }
08033e90    int32_t sub_8033e90(int32_t arg1, char arg2, int32_t arg3, int32_t arg4)
08033e90  {
08033eaa      char r0_2 = (char)((uint32_t)data_2000e15d >> arg1) & 1;
08033eaa      
08033eb2      if ((uint32_t)arg2)
08033eb2      {
08033f5a          if (!(uint32_t)r0_2)
08033f68              data_2000e15d |= (char)(1 << arg1);
08033eb2      }
08033eb2      else if ((uint32_t)r0_2)
08033eb8      {
08033ec6          data_2000e15d &= (char)~(1 << arg1);
08033ec8          uint32_t r4_1 = (uint32_t)(uint8_t)arg1;
08033ec8          
08033ecc          if (r4_1)
08033ecc          {
08033ece              uint32_t r4_2 = (uint32_t)(uint8_t)r4_1;
08033ece              
08033ed2              if (r4_2 == 1)
08033ed2              {
08033ee2                  if (rtos_dma_rx_wait_and_service(data_2000e160, 0xffffffff) != 1)
08033ee6                      logging_wrapper("Mutex Error!!!\r\n");
08033ee6                  
08033eee                  data_2000e164 = 1;
08033eee                  
08033f00                  if (sub_8030954(data_2000e160, nullptr, 0, 0) != 1)
08033f04                      logging_wrapper("Mutex Error!!!\r\n");
08033ed2              }
08033ed2              else if ((uint32_t)(uint8_t)r4_2 == 2)
08033f0e              {
08033f1e                  if (rtos_dma_rx_wait_and_service(data_2000e160, 0xffffffff) != 1)
08033f22                      logging_wrapper("Mutex Error!!!\r\n");
08033f22                  
08033f2c                  data_2000e168 = 0x1f4;
08033f34                  data_2000e16a = 0x1f4;
08033f3a                  data_2000e166 = 0;
08033f3a                  
08033f4c                  if (sub_8030954(data_2000e160, nullptr, 0, 0) != 1)
08033f50                      logging_wrapper("Mutex Error!!!\r\n");
08033f0e              }
08033ecc          }
08033eb8      }
08033eb8      
08033f6a      return arg4;
08033e90  }
08033f6c    int32_t sub_8033f6c(char arg1, int32_t arg2 @ r7)
08033f6c  {
08033f6e      uint32_t r0 = (uint32_t)arg1;
08033f6e      
08033f72      if (!r0)
08033f84          logging_wrapper("BORDER_STATE_UNKNOWN\r\n");
08033f72      else if (r0 == 2)
08033f94          logging_wrapper("BORDER_STATE_OUTSIDE_BORDER\r\n");
08033f76      else if (r0 < 2)
08033f8c          logging_wrapper("BORDER_STATE_INSIDE_BORDER\r\n");
08033f78      else if (r0 == 4)
08033fa4          logging_wrapper("BORDER_STATE_ON_BORDER_BACKWARD_GARAGE\r\n");
08033f7c      else if (r0 < 4)
08033f9c          logging_wrapper("BORDER_STATE_ON_BORDER_FORWARD_GARAGE\r\n");
08033f9c      
08033fa8      return arg2;
08033f6c  }
08033faa    uint32_t sub_8033faa()
08033faa  {
08033fae      return (uint32_t)data_2000e42d;
08033faa  }
08033fb0    uint32_t sub_8033fb0(char arg1)
08033fb0  {
08033fb2      char r4 = 0;
08033fb2      
08033fb8      if ((uint32_t)arg1 < 0x15)
08033fc6          data_2000e42d = 0;
08033fb8      else
08033fbe          data_2000e42d = 1;
08033fbe      
08033fc8      uint32_t result = sub_802fca8();
08033fc8      
08033fce      if (result != 1)
08033fce      {
08033fd4          uint32_t r0_1 = sub_8033b3e();
08033fda          uint32_t r0_2;
08033fda          
08033fda          if (r0_1)
08033fdc              r0_2 = sub_802c5e2();
08033fdc          
08033fe2          if (!r0_1 || !r0_2)
08033fe2          {
08033ff2              uint32_t r0_3 = sub_8033b3e();
08033ff8              uint32_t r0_4;
08033ff8              
08033ff8              if (r0_3)
08033ffa                  r0_4 = sub_802c5e2();
08033ffa              
08034000              if (!r0_3 || r0_4)
08034000              {
08034010                  result = sub_8033b3e();
08034010                  
08034016                  if (!result)
08034016                  {
08034018                      result = sub_802c5e2();
08034018                      
0803401e                      if (result)
08034020                          r4 = 1;
08034016                  }
08034000              }
08034000              else
08034000              {
08034002                  r4 = 2;
08034006                  result = (uint32_t)data_2000e42d;
08034006                  
0803400a                  if (result)
0803400c                      r4 = 3;
08034000              }
08033fe2          }
08033fe2          else
08033fe2          {
08033fe4              r4 = 0;
08033fe8              result = (uint32_t)data_2000e42d;
08033fe8              
08033fec              if (result)
08033fee                  r4 = 3;
08033fe2          }
08033fce      }
08033fce      else
08033fd0          r4 = 2;
08033fd0      
08034022      uint32_t r4_1 = (uint32_t)r4;
08034022      
08034026      if (!r4_1)
0803403e          return sub_802ce62(3);
0803403e      
0803402a      if (r4_1 == 2)
08034036          return sub_802ce62(0);
08034036      
0803402c      if (r4_1 < 2)
08034046          return sub_802ce62(1);
08034046      
08034030      if (r4_1 == 3)
0803404e          return sub_802ce62(2);
0803404e      
08034052      return result;
08033fb0  }
08034054  int32_t data_8034054 = 0x2000e15c
08034058  int32_t data_8034058 = 0x803b7f4
0803405c  int32_t data_803405c = 0x803bda0
08034060  int32_t data_8034060 = 0x803bb1c
08034064  int32_t data_8034064 = 0x803add8
08034068  int32_t data_8034068 = 0x2000e166
0803406c  int32_t data_803406c = 0x803ac98
08034070  int32_t data_8034070 = 0x2000e164
08034074  int32_t data_8034074 = 0x803b80c
08034078  int32_t data_8034078 = 0x803b1f0
0803407c  int32_t data_803407c = 0x803b210
08034080  int32_t data_8034080 = 0x803ae00
08034084  int32_t data_8034084 = 0x803ad28
08034088  int32_t data_8034088 = 0x2000e42d
0803408c    int32_t* sub_803408c(void* arg1, int32_t arg2)
0803408c  {
08034090      int32_t* i = (char*)arg1 + 0x1c0;
08034090      
080340a4      do
080340a4      {
08034092          int32_t r2_1 = *(uint32_t*)i;
08034092          
0803409e          if (arg2 >= r2_1 && arg2 < r2_1 + i[1])
0803409e              break;
0803409e          
080340a0          i = i[2];
080340a4      } while (i);
080340a4      
080340a6      return i;
0803408c  }
080340a8    int32_t sub_80340a8()
080340a8  {
080340ae      if (!data_2000e11c)
080340ae      {
080340b4          data_2000e124 = 0x10000;
080340ba          data_2000e120 = 0x1000;
080340c0          data_2000e128 = 0xffffffff;
080340c2          data_2000e12c = 0xffffffff;
080340ca          data_2000e130 = 4;
080340cc          data_2000dc0c = 4;
080340d4          data_2000e11c = 0x3c885968;
080340ae      }
080340ae      
080340d8      return 1;
080340a8  }
080340da    void sub_80340da(void* arg1, void* arg2, int32_t arg3)
080340da  {
080340de      void* r3 = ((char*)arg2 + 8) & 7;
080340de      
080340e2      if (r3)
080340ec          r3 = (8 * 0 - arg2) & 7;
080340ec      
080340f0      void* r1 = (char*)arg2 + r3;
080340f2      void* r2 = arg3 - r3;
080340f4      *(uint32_t*)((char*)arg1 + 0x18) = r1;
080340f6      *(uint32_t*)((char*)arg1 + 0xc) = r2;
080340fc      *(uint32_t*)((char*)r1 + 4) = r2 | 1;
08034102      *(uint32_t*)((char*)r1 + r2 + 4) = 0x28;
0803410a      *(uint32_t*)((char*)arg1 + 0x1c) = data_2000e12c;
080340da  }
08034168                          28 79 c0 07 58 bf 03 f0 37 fb b9 f1 10 0f 38 bf 03 f0 32 fb b0 69 85 42          (y..X...7.....8...2..i.B
08034180  09 d1 f0 68 48 44 f0 60 c6 f8 18 b0 40 f0 01 00 cb f8 04 00 70 e1 70 69 85 42 0b d1 b0 68 48 44  ...hHD.`....@.......p.pi.B...hHD
080341a0  b0 60 c6 f8 14 b0 40 f0 01 01 cb f8 04 10 4b f8 00 00 61 e1 68 68 00 f0 03 01 01 29 40 f0 af 80  .`....@.......K...a.hh.....)@...
080341c0  c0 08 c0 00 01 90 c0 08 20 28 3b d2 d5 f8 08 a0 ef 68 00 90 bd 42 08 bf 03 f0 02 fb 55 45 08 bf  ........ (;......h...B......UE..
080341e0  03 f0 fe fa 68 68 00 99 c0 08 c0 00 b0 eb c1 0f 18 bf 03 f0 f5 fa 00 98 06 eb c0 00 00 f1 28 01  ....hh........................(.
08034200  8a 45 08 d0 31 69 8a 45 c0 f0 84 80 da f8 0c 10 a9 42 40 f0 7f 80 57 45 06 d1 00 9a 30 68 01 21  .E..1i.E.........B@...WE....0h.!
08034220  91 40 88 43 30 60 77 e0 28 30 87 42 05 d0 30 69 87 42 6f d3 b8 68 a8 42 6c d1 ca f8 0c 70 c7 f8  .@.C0`w.(0.B..0i.Bo..h.Bl....p..
08034240  08 a0 69 e0 ef 68 d5 f8 18 a0 af 42 0c d0 a8 68 31 69 88 42 23 d3 c1 68 a9 42 04 bf b9 68 a9 42  ..i..h.....B...h1i.B#..h.B...h.B
08034260  1d d1 c7 60 b8 60 1c e0 05 f1 14 00 07 68 37 b9 05 f1 10 00 07 68 a7 b1 01 e0 08 46 07 68 07 f1  ...`.`.......h7......h.....F.h..
08034280  14 01 0a 68 00 2a 02 bf 07 f1 10 01 0a 68 00 2a f3 d1 31 69 88 42 02 d3 00 21 01 60 01 e0 03 f0  ...h.*.......h.*..1i.B...!.`....
080342a0  9f fa ba f1 00 0f 37 d0 e8 69 06 eb 80 00 4f f4 98 71 08 44 01 68 8d 42 08 d1 07 60 a7 b9 ea 69  ......7..i....O..q.D.h.B...`...i
080342c0  70 68 01 21 91 40 88 43 70 60 25 e0 30 69 82 45 08 d3 da f8 10 00 a8 42 14 bf ca f8 14 70 ca f8  ph.!.@.Cp`%.0i.E.......B.....p..
080342e0  10 70 01 e0 03 f0 7c fa b7 b1 30 69 87 42 11 d3 c7 f8 18 a0 29 69 29 b1 81 42 26 bf 39 61 8f 61  .p....|...0i.B......)i)..B&.9a.a
08034300  03 f0 6e fa 68 69 38 b1 31 69 88 42 02 d3 78 61 87 61 01 e0 03 f0 64 fa 01 98 05 44 81 44 68 68  ..n.hi8.1i.B..xa.a....d....D.Dhh
08034320  40 08 40 00 68 60 4f ea d9 05 49 f0 01 00 cb f8 04 00 4b f8 09 90 20 2d 23 d2 06 eb c5 00 00 f1  @.@.h`O...I.......K... -#.......
08034340  28 07 ba 46 b9 f1 10 0f 38 bf 03 f0 49 fa 30 68 20 fa 05 f1 c9 07 04 d4 01 21 a9 40 08 43 30 60  (..F....8...I.0h ........!.@.C0`
08034360  06 e0 b8 68 31 69 88 42 2c bf 82 46 03 f0 38 fa c7 f8 08 b0 ca f8 0c b0 cb f8 08 a0 cb f8 0c 70  ...h1i.B,..F..8................p
08034380  7a e0 5f ea 19 21 08 bf 00 20 23 d0 b1 f5 80 3f 28 bf 1f 20 1e d2 a1 f5 80 70 00 0c 00 f0 08 00  z._..!... #....?(.. .....p......
080343a0  81 40 a1 f5 80 52 12 0c 02 f0 04 02 91 40 a1 f5 80 43 1b 0c c0 f1 0e 00 03 f0 02 03 80 1a c0 1a  .@...R.......@...C..............
080343c0  99 40 00 eb d1 30 c1 1d 29 fa 01 f2 02 f0 01 01 01 eb 40 00 06 eb 80 01 4f f4 98 72 11 44 cb f8  .@...0..).........@.....O..r.D..
080343e0  1c 00 00 22 cb f8 14 20 cb f8 10 20 72 68 22 fa 00 f3 db 07 07 d4 01 23 03 fa 00 f0 10 43 70 60  ..."... ... rh"........#.....Cp`
08034400  c1 f8 00 b0 1d e0 09 68 1f 28 1d bf 40 08 c0 f1 19 00 09 fa 00 f0 48 46 00 e0 11 46 4a 68 d2 08  .......h.(..@.........HF...FJh..
08034420  d2 00 4a 45 14 d0 c2 0f 01 eb 82 02 02 f1 10 03 40 00 1a 68 00 2a f0 d1 30 69 83 42 1a d3 c3 f8  ..JE............@..h.*..0i.B....
08034440  00 b0 cb f8 18 10 cb f8 0c b0 cb f8 08 b0 13 e0 32 69 88 68 91 42 28 bf 90 42 0b d3 c0 f8 0c b0  ................2i.h.B(..B......
08034460  c1 f8 08 b0 cb f8 08 00 cb f8 0c 10 00 20 cb f8 18 00 01 e0 03 f0 b4 f9 08 f1 08 00 bd e8 e6 8f  ............. ..................
08034480    void* sub_8034480(void* arg1, void* arg2, void* arg3 @ r4, void* arg4 @ r8)
08034480  {
08034480      void* var_10 = arg4;
08034480      void* var_20 = arg3;
08034480      int32_t r3;
08034480      int32_t var_24 = r3;
08034480      
0803448e      if (!data_2000e11c)
08034490          sub_80340a8();
08034490      
0803449a      void* r0_1 = data_2000e124;
080344a2      void* r0_3 = ((char*)r0_1 + arg2 + 0x2f) & ~((char*)r0_1 - 1);
080344a2      
080344aa      if (arg2 < r0_3)
080344aa      {
080344b4          int32_t r1_4 = *(uint32_t*)((char*)arg1 + 0x1b8);
080344b4          
080344b6          if (!r1_4)
080344b6          {
080344c8          label_80344c8:
080344c8              void** r0_5 = sub_80377e8();
080344cc              bool cond:0_1 = !r0_5;
080344cc              
080344ce              if (r0_5)
080344ce              {
080344d0                  arg3 = r0_5;
080344d2                  arg4 = *(uint32_t*)r0_5;
080344d6                  cond:0_1 = arg3 == 0xffffffff;
080344ce              }
080344ce              
080344da              if (!cond:0_1)
080344da              {
080344e0                  void* r1_5 = *(uint32_t*)((char*)arg1 + 0x1b4);
080344e2                  void* r0_7 = *(uint32_t*)((char*)arg1 + 0x1b0) + arg4;
080344e6                  *(uint32_t*)((char*)arg1 + 0x1b0) = r0_7;
080344e6                  
080344e8                  if (r1_5 < r0_7)
080344ea                      r1_5 = r0_7;
080344ea                  
080344ec                  *(uint32_t*)((char*)arg1 + 0x1b4) = r1_5;
080344f0                  void* r1_7;
080344f0                  void* r2_3;
080344f0                  
080344f0                  if (*(uint32_t*)((char*)arg1 + 0x18))
080344f0                  {
0803455a                      void* r0_16 = (char*)arg1 + 0x1c0;
0803455a                      
08034560                      while (true)
08034560                      {
08034560                          if (r0_16)
08034560                          {
0803456a                              if (arg3
0803456a                                  != *(uint32_t*)r0_16 + *(uint32_t*)((char*)r0_16 + 4))
0803456a                              {
0803455e                                  r0_16 = *(uint32_t*)((char*)r0_16 + 8);
0803455e                                  continue;
0803456a                              }
0803456a                              else if ((uint32_t)*(uint8_t*)((char*)r0_16 + 0xc) << 0x1c
0803456a                                  >= 0)
08034570                              {
08034572                                  int32_t r2_8 = *(uint32_t*)((char*)arg1 + 0x18);
08034574                                  int32_t r3_2 = *(uint32_t*)r0_16;
08034574                                  
08034578                                  if (r2_8 >= r3_2)
08034578                                  {
0803457a                                      int32_t r7_1 = *(uint32_t*)((char*)r0_16 + 4);
0803457a                                      
08034580                                      if (r2_8 < r3_2 + r7_1)
08034580                                      {
08034586                                          *(uint32_t*)((char*)r0_16 + 4) =
08034586                                              (char*)arg4 + r7_1;
0803458a                                          r1_7 = *(uint32_t*)((char*)arg1 + 0x18);
0803458c                                          r2_3 =
0803458c                                              (char*)arg4 + *(uint32_t*)((char*)arg1 + 0xc);
0803458c                                          break;
08034580                                      }
08034578                                  }
08034570                              }
08034560                          }
08034560                          
0803459c                          void* i = (char*)arg1 + 0x1c0;
0803459c                          
0803459e                          if (arg3 < *(uint32_t*)((char*)arg1 + 0x10))
080345a0                              *(uint32_t*)((char*)arg1 + 0x10) = arg3;
080345a0                          
080345aa                          for (; i; i = *(uint32_t*)((char*)i + 8))
080345aa                          {
080345ac                              int32_t r2_9 = *(uint32_t*)i;
080345ac                              
080345b0                              if (r2_9 == (char*)arg3 + arg4)
080345b0                              {
080345b6                                  if ((uint32_t)*(uint8_t*)((char*)i + 0xc) << 0x1c < 0)
080345b6                                      break;
080345b6                                  
080345b8                                  *(uint32_t*)i = arg3;
080345be                                  *(uint32_t*)((char*)i + 4) += arg4;
080345c8                                  void* r8 = var_10;
0803410e                                  int32_t lr;
0803410e                                  int32_t var_4_1 = lr;
0803410e                                  int32_t r11;
0803410e                                  int32_t var_8_1 = r11;
0803410e                                  int32_t r10;
0803410e                                  int32_t var_c_1 = r10;
0803410e                                  int32_t r9;
0803410e                                  int32_t var_10_1 = r9;
0803410e                                  void* var_14_1 = r8;
0803410e                                  int32_t r7;
0803410e                                  int32_t var_18_1 = r7;
0803410e                                  int32_t r6;
0803410e                                  int32_t var_1c_1 = r6;
0803410e                                  int32_t r5;
0803410e                                  int32_t var_20_1 = r5;
0803410e                                  void* var_24_1 = var_20;
0803410e                                  void* var_28_1 = arg2;
08034118                                  void* r0_46 = ((char*)arg3 + 8) & 7;
08034118                                  
0803411c                                  if (!r0_46)
0803411e                                      r8 = arg3;
0803411e                                  
08034120                                  if (r0_46)
0803412e                                      r8 = (char*)arg3 + ((8 * 0 - arg3) & 7);
0803412e                                  
0803413a                                  if ((r2_9 + 8) & 7)
08034148                                      r2_9 += (8 * 0 - r2_9) & 7;
08034148                                  
0803415c                                  *(uint32_t*)((char*)r8 + 4) = arg2 | 3;
0803415c                                  
08034162                                  if ((char*)r8 + arg2 >= r2_9)
08034164                                      sub_80377e0();
08034164                                  
08034164                                  /* no return */
080345b0                              }
080345aa                          }
080345aa                          
080345ce                          int32_t r7_3 = *(uint32_t*)((char*)arg1 + 0x18);
080345d4                          int32_t* r0_22 = sub_803408c(arg1, r7_3);
080345e0                          int32_t r0_24 = r0_22[1] + *(uint32_t*)r0_22;
080345ec                          int32_t r0_26;
080345ec                          
080345ec                          r0_26 = !((r0_24 - 0x27) & 7) ? 0 : (8 - (r0_24 - 0x27)) & 7;
080345ec                          
08034602                          int32_t var_30;
08034602                          
08034602                          var_30 = r0_26 + r0_24 - 0x2f < r7_3 + 0x10 ? r7_3
08034602                              : r0_26 + r0_24 - 0x2f;
08034602                          
08034612                          void* r1_22 = ((char*)arg3 + 8) & 7;
08034612                          
0803461a                          if (r1_22)
08034624                              r1_22 = (8 * 0 - arg3) & 7;
08034624                          
08034628                          void* r0_32 = (char*)arg4 - 0x28 - r1_22;
0803462a                          void* r1_25 = (char*)r1_22 + arg3;
0803462c                          *(uint32_t*)((char*)arg1 + 0x18) = r1_25;
0803462e                          *(uint32_t*)((char*)arg1 + 0xc) = r0_32;
08034634                          *(uint32_t*)((char*)r1_25 + 4) = r0_32 | 1;
0803463a                          *(uint32_t*)((char*)r0_32 + r1_25 + 4) = 0x28;
08034640                          *(uint32_t*)((char*)arg1 + 0x1c) = data_2000e12c;
08034640                          
0803464a                          if ((var_30 + 8) & 7)
0803464c                              sub_80377e0();
0803464c                          
0803464c                          /* no return */
08034560                      }
080344f0                  }
080344f0                  else
080344f0                  {
080344f2                      int32_t r0_9 = *(uint32_t*)((char*)arg1 + 0x10);
080344f2                      
080344f8                      if (!r0_9 || arg3 < r0_9)
080344fa                          *(uint32_t*)((char*)arg1 + 0x10) = arg3;
080344fa                      
080344fe                      *(uint32_t*)((char*)arg1 + 0x1cc) = 0;
08034500                      *(uint32_t*)((char*)arg1 + 0x1c0) = arg3;
08034502                      *(uint32_t*)((char*)arg1 + 0x1c4) = arg4;
08034506                      void* r1_6 = (char*)arg1 + 0x28;
0803450e                      *(uint32_t*)((char*)arg1 + 0x24) = data_2000e11c;
08034514                      *(uint32_t*)((char*)arg1 + 0x20) = 0xffffffff;
08034514                      
0803452a                      for (int32_t i_1 = 0; i_1 < 0x20; )
0803452a                      {
08034518                          *(uint32_t*)((char*)r1_6 + 0xc) = r1_6;
0803451a                          *(uint32_t*)((char*)r1_6 + 8) = r1_6;
08034520                          *(uint32_t*)((char*)r1_6 + 0x14) = (char*)r1_6 + 8;
08034522                          *(uint32_t*)((char*)r1_6 + 0x10) = (char*)r1_6 + 8;
08034524                          i_1 += 2;
08034526                          r1_6 += 0x10;
0803452a                      }
0803452a                      
08034530                      if (arg1 != &data_2000da50)
08034530                      {
08034544                          r1_7 =
08034544                              (char*)arg1 + (*(uint32_t*)((char*)arg1 - 4) >> 3 << 3) - 8;
0803454e                          r2_3 = (char*)arg3 + arg4 - r1_7 - 0x28;
08034530                      }
08034530                      else
08034530                      {
08034532                          r2_3 = (char*)arg4 - 0x28;
08034536                          r1_7 = arg3;
08034530                      }
080344f0                  }
080344f0                  
08034592                  sub_80340da(arg1, r1_7, r2_3);
080347d4                  int32_t r0_38 = *(uint32_t*)((char*)arg1 + 0xc);
080347d4                  
080347da                  if (arg2 < r0_38)
080347da                  {
080347dc                      void* r0_39 = r0_38 - arg2;
080347de                      *(uint32_t*)((char*)arg1 + 0xc) = r0_39;
080347e0                      void* r1_27 = *(uint32_t*)((char*)arg1 + 0x18);
080347e4                      void* r2_12 = (char*)arg2 + r1_27;
080347e6                      *(uint32_t*)((char*)arg1 + 0x18) = r2_12;
080347ec                      *(uint32_t*)((char*)r2_12 + 4) = r0_39 | 1;
080347f4                      *(uint32_t*)((char*)r1_27 + 4) = arg2 | 3;
080347fc                      return (char*)r1_27 + 8;
080347da                  }
080344da              }
080344b6          }
080344b6          else
080344b6          {
080344b8              int32_t r2_1 = *(uint32_t*)((char*)arg1 + 0x1b0);
080344ba              void* r0_4 = (char*)r0_3 + r2_1;
080344ba              
080344c4              if (r2_1 < r0_4 && r1_4 >= r0_4)
080344c4                  goto label_80344c8;
080344b6          }
080344aa      }
080344aa      
08034804      return 0;
08034480  }
08034650                                                  00 99 1b 20 48 60 4f f4 e0 71 29 44 b1 e8 0c 50                  ... H`O..q)D...P
08034660  00 98 08 30 a0 e8 0c 50 34 61 c6 f8 14 80 c6 f8 1c b0 00 98 08 30 b0 61 01 98 01 e0 0a f1 04 0a  ...0...P4a...........0.a........
08034680  07 21 ca f8 04 10 0b f1 01 0b 0a f1 08 01 81 42 f4 d3 bb f1 02 0f b8 bf 03 f0 a2 f8 00 98 b8 42  .!.............B...............B
080346a0  00 f0 98 80 c0 1b 39 18 c4 08 4a 68 52 08 52 00 4a 60 40 f0 01 01 79 60 38 50 20 2c 20 d2 05 eb  ......9...JhR.R.J`@...y`8P , ...
080346c0  c4 01 01 f1 28 06 b0 46 10 28 38 bf 03 f0 88 f8 28 68 20 fa 04 f1 c9 07 04 d4 01 21 a1 40 08 43  ....(..F.(8.....(h ........!.@.C
080346e0  28 60 06 e0 b0 68 29 69 88 42 2c bf 80 46 03 f0 77 f8 b7 60 c8 f8 0c 70 c7 f8 08 80 fe 60 69 e0  (`...h)i.B,..F..w..`...p.....`i.
08034700  01 0a 23 d0 b1 f5 80 3f 28 bf 1f 21 1e d2 a1 f5 80 72 12 0c 02 f0 08 02 91 40 a1 f5 80 53 1b 0c  ..#....?(..!.....r.......@...S..
08034720  03 f0 04 03 99 40 a1 f5 80 44 24 0c c2 f1 0e 02 04 f0 02 04 d2 1a 12 1b a1 40 02 eb d1 31 ca 1d  .....@...D$..............@...1..
08034740  20 fa 02 f3 03 f0 01 02 02 eb 41 01 05 eb 81 02 4f f4 98 73 1a 44 f9 61 00 23 7b 61 3b 61 6b 68   .........A.....O..s.D.a.#{a;akh
08034760  23 fa 01 f4 e4 07 05 d4 01 20 88 40 18 43 68 60 17 60 1c e0 12 68 1f 29 1d bf 49 08 c1 f1 19 01  #........ .@.Ch`.`...h.)..I.....
08034780  00 fa 01 f1 01 46 00 e0 1a 46 53 68 db 08 db 00 83 42 10 d0 cb 0f 02 eb 83 03 03 f1 10 04 49 00  .....F...FSh.....B............I.
080347a0  23 68 00 2b f0 d1 28 69 84 42 11 d3 27 60 ba 61 ff 60 bf 60 0e e0 29 69 90 68 8a 42 28 bf 88 42  #h.+..(i.B..'`.a.`.`..)i.h.B(..B
080347c0  06 d3 c7 60 97 60 b8 60 fa 60 00 20 b8 61 01 e0 03 f0 06 f8                                      ...`.`.`.`. .a......
08034808  int32_t data_8034808 = 0x2000e11c
0803480c  int32_t data_803480c = 0x2000da50
08034810  int32_t data_8034810 = 0x3c885968
08034814    int32_t sub_8034814(void* arg1, int32_t arg2)
08034814  {
08034814      int32_t r3;
08034814      int32_t var_28 = r3;
0803481a      void* i_3 = nullptr;
0803481c      int32_t r9 = arg2;
0803481e      uint32_t r0 = r9 >> 8;
08034822      int32_t r11 = 0 - r9;
08034822      
08034826      if (!r0)
08034828          arg2 = 0;
08034828      
0803482a      if (r0)
0803482a      {
08034830          if (r0 >= 0x10000)
08034832              arg2 = 0x1f;
08034832          
08034834          if (r0 < 0x10000)
08034834          {
0803483c              int32_t r1_2 = (r0 - 0x100) >> 0x10 & 8;
08034840              uint32_t r0_1 = r0 << r1_2;
08034848              int32_t r2_3 = (r0_1 - 0x1000) >> 0x10 & 4;
0803484c              uint32_t r0_2 = r0_1 << r2_3;
08034858              int32_t r3_3 = (r0_2 - 0x4000) >> 0x10 & 2;
08034862              int32_t r0_4 = 0xe - r1_2 - r2_3 - r3_3 + (r0_2 << r3_3 >> 0xf);
08034870              arg2 = (r9 >> (r0_4 + 7) & 1) + (r0_4 << 1);
08034834          }
0803482a      }
0803482a      
08034878      void* i = *(uint32_t*)((char*)arg1 + (arg2 << 2) + 0x130);
08034878      
0803487c      if (!i)
0803487c      {
080348ca      label_80348ca:
080348ca          int32_t r0_8 = 1 << arg2 << 1;
080348d2          int32_t r0_10 = (r0_8 | (0 - r0_8)) & *(uint32_t*)((char*)arg1 + 4);
080348d2          
080348d4          if (r0_10)
080348d4          {
080348e0              int32_t r1_12 = ((r0_10 & (0 - r0_10)) - 1) >> 0xc & 0x10;
080348e4              uint32_t r0_13 = ((r0_10 & (0 - r0_10)) - 1) >> r1_12;
080348e8              int32_t r2_9 = r0_13 >> 5 & 8;
080348ec              uint32_t r0_14 = r0_13 >> r2_9;
080348f0              int32_t r3_5 = r0_14 >> 2 & 4;
080348f4              uint32_t r0_15 = r0_14 >> r3_5;
080348f8              int32_t r5_6 = r0_15 >> 1 & 2;
080348fe              uint32_t r0_16 = r0_15 >> r5_6;
08034902              int32_t r7_2 = r0_16 >> 1 & 1;
08034912              i = *(uint32_t*)((char*)arg1
08034912                  + (((r0_16 >> r7_2) + r3_5 + r2_9 + r1_12 + r5_6 + r7_2) << 2) + 0x130);
08034936          label_8034936:
08034936              
08034936              for (; i; i = *(uint32_t*)((char*)i + 0x14))
08034936              {
08034920                  while (true)
08034920                  {
08034920                      int32_t r1_20 = (*(uint32_t*)((char*)i + 4) >> 3 << 3) - r9;
08034920                      
08034926                      if (r1_20 < r11)
08034926                      {
08034928                          r11 = r1_20;
0803492a                          i_3 = i;
08034926                      }
08034926                      
0803492c                      void* i_1 = *(uint32_t*)((char*)i + 0x10);
0803492c                      
08034930                      if (!i_1)
08034930                          break;
08034930                      
08034918                      i = i_1;
08034920                  }
08034936              }
08034936              
08034936              goto label_8034938;
080348d4          }
0803487c      }
0803487c      else
0803487c      {
08034880          int32_t r2_5;
08034880          
08034880          r2_5 = arg2 == 0x1f ? r9 : r9 << (0x19 - (arg2 >> 1));
08034880          
0803488e          void* i_2 = nullptr;
0803488e          
0803489a          while (true)
0803489a          {
0803489a              int32_t r5_4 = (*(uint32_t*)((char*)i + 4) >> 3 << 3) - r9;
0803489a              
080348a0              if (r5_4 < r11)
080348a0              {
080348a2                  r11 = r5_4;
080348a6                  i_3 = i;
080348a6                  
080348a8                  if (!r11)
080348a8                      break;
080348a0              }
080348a0              
080348aa              void* i_4 = *(uint32_t*)((char*)i + 0x14);
080348b4              i = *(uint32_t*)((char*)i + (r2_5 >> 0x1f << 2) + 0x10);
080348b4              
080348b6              if (i_4)
080348ba                  i_2 = i_4;
080348ba              
080348be              if (!i)
080348be              {
080348c0                  i = i_2;
080348c0                  break;
080348be              }
080348be              
08034892              r2_5 <<= 1;
0803489a          }
0803489a          
080348c2          if (i)
080348c2              goto label_8034936;
080348c2          
080348c4          if (!i_3)
080348c4              goto label_80348ca;
080348c4          
08034938      label_8034938:
08034938          
08034946          if (i_3 && r11 < *(uint32_t*)((char*)arg1 + 8) - r9)
08034946          {
0803494e              if (i_3 < *(uint32_t*)((char*)arg1 + 0x10))
0803494e              {
08034b8e                  sub_80377e0();
08034b8e                  /* no return */
0803494e              }
0803494e              
0803495e              if (*(uint32_t*)((char*)i_3 + 4) >> 3 << 3 != r9 + r11)
08034960                  sub_80377e0();
08034960              
08034960              /* no return */
08034946          }
0803487c      }
0803487c      
08034d9c      return 0;
08034814  }
08034964              06 eb 09 05 ae 42 80 f0 10 81 f7 68 d6 f8 18 a0 b7 42 0c d0 b0 68 21 69 88 42 23 d3      .....B.....h.....B...h!i.B#.
08034980  c1 68 b1 42 04 bf b9 68 b1 42 1d d1 c7 60 b8 60 1c e0 06 f1 14 00 07 68 37 b9 06 f1 10 00 07 68  .h.B...h.B...`.`.......h7......h
080349a0  a7 b1 01 e0 08 46 07 68 07 f1 14 01 0a 68 00 2a 02 bf 07 f1 10 01 0a 68 00 2a f3 d1 21 69 88 42  .....F.h.....h.*.......h.*..!i.B
080349c0  02 d3 00 21 01 60 01 e0 02 f0 0a ff ba f1 00 0f 39 d0 f0 69 04 eb 80 00 4f f4 98 71 08 44 01 68  ...!.`..........9..i....O..q.D.h
080349e0  8e 42 09 d1 07 60 38 00 14 d1 f2 69 60 68 01 21 91 40 88 43 60 60 26 e0 20 69 82 45 08 d3 da f8  .B...`8....i`h.!.@.C``&. i.E....
08034a00  10 00 b0 42 14 bf ca f8 14 70 ca f8 10 70 01 e0 02 f0 e6 fe bf b1 20 69 87 42 12 d3 c7 f8 18 a0  ...B.....p...p........ i.B......
08034a20  30 69 30 b1 21 69 88 42 26 bf 38 61 87 61 02 f0 d7 fe 70 69 38 b1 21 69 88 42 02 d3 78 61 87 61  0i0.!i.B&.8a.a....pi8.!i.B..xa.a
08034a40  01 e0 02 f0 cd fe bb f1 10 0f 09 d2 48 f0 03 00 70 60 06 eb 08 00 41 68 41 f0 01 01 41 60 95 e0  ............H...p`....AhA...A`..
08034a60  49 f0 03 00 70 60 4b f0 01 00 68 60 4f ea db 00 45 f8 0b b0 20 28 1d d2 04 eb c0 01 01 f1 28 07  I...p`K...h`O...E... (........(.
08034a80  21 68 21 fa 00 f2 d2 07 bb 46 05 d4 01 22 02 fa 00 f0 08 43 20 60 06 e0 b8 68 21 69 88 42 2c bf  !h!......F...".....C `...h!i.B,.
08034aa0  83 46 02 f0 9d fe bd 60 cb f8 0c 50 c5 f8 08 b0 ef 60 6b e0 5f ea 1b 20 23 d0 b0 f5 80 3f 28 bf  .F.....`...P.....`k._.. #....?(.
08034ac0  1f 20 1e d2 a0 f5 80 71 09 0c 01 f0 08 01 88 40 a0 f5 80 52 12 0c 02 f0 04 02 90 40 a0 f5 80 43  . .....q.......@...R.......@...C
08034ae0  1b 0c c1 f1 0e 01 03 f0 02 03 89 1a c9 1a 98 40 01 eb d0 30 c1 1d 2b fa 01 f2 02 f0 01 01 01 eb  ...............@...0..+.........
08034b00  40 00 04 eb 80 01 4f f4 98 72 11 44 e8 61 00 22 6a 61 2a 61 62 68 22 fa 00 f3 db 07 06 d4 01 23  @.....O..r.D.a."ja*abh"........#
08034b20  03 fa 00 f0 10 43 60 60 0d 60 1c e0 09 68 1f 28 1d bf 40 08 c0 f1 19 00 0b fa 00 f0 58 46 00 e0  .....C``.`...h.(..@.........XF..
08034b40  11 46 4a 68 d2 08 d2 00 5a 45 10 d0 c2 0f 01 eb 82 02 02 f1 10 03 40 00 1a 68 00 2a f0 d1 20 69  .FJh....ZE............@..h.*.. i
08034b60  83 42 11 d3 1d 60 a9 61 ed 60 ad 60 0e e0 22 69 88 68 91 42 28 bf 90 42 06 d3 c5 60 8d 60 a8 60  .B...`.a.`.`.."i.h.B(..B...`.`.`
08034b80  e9 60 00 20 a8 61 01 e0 02 f0 2a fe 08 e1                                                        .`. .a....*...
08034b94    void sub_8034b94(void* arg1, int32_t arg2) __noreturn
08034b94  {
08034b94      int32_t r3;
08034b94      int32_t var_28 = r3;
08034b9c      int32_t r0 = *(uint32_t*)((char*)arg1 + 4);
08034ba6      int32_t r1_2 = ((r0 & (0 - r0)) - 1) >> 0xc & 0x10;
08034baa      uint32_t r0_3 = ((r0 & (0 - r0)) - 1) >> r1_2;
08034bae      int32_t r2_1 = r0_3 >> 5 & 8;
08034bb2      uint32_t r0_4 = r0_3 >> r2_1;
08034bb6      int32_t r3_2 = r0_4 >> 2 & 4;
08034bba      uint32_t r0_5 = r0_4 >> r3_2;
08034bbe      int32_t r5_1 = r0_5 >> 1 & 2;
08034bc4      uint32_t r0_6 = r0_5 >> r5_1;
08034bc8      int32_t r6 = r0_6 >> 1 & 1;
08034bd8      void* r0_10 = *(uint32_t*)((char*)arg1
08034bd8          + (((r0_6 >> r6) + r6 + r3_2 + r2_1 + r1_2 + r5_1) << 2) + 0x130);
08034be2      void* r6_1 = r0_10;
08034be4      int32_t r10 = (*(uint32_t*)((char*)r0_10 + 4) >> 3 << 3) - arg2;
08034be4      
08034bfe      while (true)
08034bfe      {
08034bfe          void* r1_14 = *(uint32_t*)((char*)r0_10 + 0x10);
08034bfe          
08034c02          if (r1_14)
08034bea              r0_10 = r1_14;
08034c02          else
08034c02          {
08034c04              r0_10 = *(uint32_t*)((char*)r0_10 + 0x14);
08034c04              
08034c08              if (!r0_10)
08034c08              {
08034c0e                  if (r6_1 < *(uint32_t*)((char*)arg1 + 0x10))
08034c0e                  {
08034d96                      sub_80377e0();
08034d96                      /* no return */
08034c0e                  }
08034c0e                  
08034c1e                  if (*(uint32_t*)((char*)r6_1 + 4) >> 3 << 3 != arg2 + r10)
08034c20                      sub_80377e0();
08034c20                  
08034c20                  /* no return */
08034c08              }
08034c02          }
08034c02          
08034bf2          int32_t r1_13 = (*(uint32_t*)((char*)r0_10 + 4) >> 3 << 3) - arg2;
08034bf2          
08034bf8          if (r1_13 < r10)
08034bf8          {
08034bfa              r10 = r1_13;
08034bfc              r6_1 = r0_10;
08034bf8          }
08034bfe      }
08034b94  }
08034c24              06 eb 08 0b 5e 45 80 f0 b4 80 f7 68 b5 69 b7 42 0c d0 b0 68 21 69 88 42 23 d3 c1 68      ....^E.....h.i.B...h!i.B#..h
08034c40  b1 42 04 bf b9 68 b1 42 1d d1 c7 60 b8 60 1c e0 06 f1 14 00 07 68 37 b9 06 f1 10 00 07 68 a7 b1  .B...h.B...`.`.......h7......h..
08034c60  01 e0 08 46 07 68 07 f1 14 01 0a 68 00 2a 02 bf 07 f1 10 01 0a 68 00 2a f3 d1 21 69 88 42 02 d3  ...F.h.....h.*.......h.*..!i.B..
08034c80  00 21 01 60 01 e0 02 f0 ab fd 00 2d 35 d0 f0 69 04 eb 80 00 4f f4 98 71 08 44 01 68 8e 42 09 d1  .!.`.......-5..i....O..q.D.h.B..
08034ca0  07 60 38 00 11 d1 f2 69 60 68 01 21 91 40 88 43 60 60 22 e0 20 69 85 42 05 d3 28 69 b0 42 14 bf  .`8....i`h.!.@.C``". i.B..(i.B..
08034cc0  6f 61 2f 61 01 e0 02 f0 8b fd b7 b1 20 69 87 42 11 d3 bd 61 30 69 30 b1 21 69 88 42 26 bf 38 61  oa/a........ i.B...a0i0.!i.B&.8a
08034ce0  87 61 02 f0 7d fd 70 69 38 b1 21 69 88 42 02 d3 78 61 87 61 01 e0 02 f0 73 fd ba f1 10 0f 09 d2  .a..}.pi8.!i.B..xa.a....s.......
08034d00  49 f0 03 00 70 60 06 eb 09 00 41 68 41 f0 01 01 41 60 3f e0 48 f0 03 00 70 60 4a f0 01 00 cb f8  I...p`....AhA...A`?.H...p`J.....
08034d20  04 00 4b f8 0a a0 d4 f8 08 80 4f ea d8 05 20 2d 28 bf 02 f0 55 fd b8 f1 00 0f 27 d0 d4 f8 14 90  ..K.......O... -(...U.....'.....
08034d40  00 95 04 eb c5 00 00 f1 28 05 2f 46 b8 f1 10 0f 38 bf 02 f0 45 fd 20 68 00 99 20 fa 01 f2 d1 07  ........(./F....8...E. h.. .....
08034d60  05 d4 00 9a 01 21 91 40 08 43 20 60 06 e0 a8 68 21 69 88 42 2c bf 07 46 02 f0 32 fd c5 f8 08 90  .....!.@.C `...h!i.B,..F..2.....
08034d80  c7 f8 0c 90 c9 f8 08 70 c9 f8 0c 50 c4 f8 08 a0 c4 f8 14 b0 04 e0                                .......p...P..........
08034da0  06 f1 08 00 bd e8 f2 8f                                                                          ........
08034da8    void* sub_8034da8(int32_t arg1, uint32_t arg2 @ r7, void* arg3 @ r8)
08034da8  {
08034da8      void* var_14 = arg3;
08034da8      uint32_t var_18 = arg2;
08034da8      
08034dba      if (arg1 < 0xf5)
08034dba      {
08034dc0          arg2 = arg1 < 0xb ? 0x10 : (arg1 + 0xb) >> 3 << 3;
08034dc0          
08034dce          uint32_t r6_1 = arg2 >> 3;
08034dd0          uint32_t r0_2 = data_2000da50 >> r6_1;
08034dd0          
08034dd6          if (r0_2 & 3)
08034dd6          {
08034dde              int32_t r6_2 = (~r0_2 & 1) + r6_1;
08034dde              
08034df6              if (*(uint32_t*)(*(uint32_t*)((r6_2 << 3) + 0x2000da80) + 4) >> 3 << 3
08034df6                      != r6_2 << 3)
08034df8                  sub_80377e0();
08034df8              
08034df8              /* no return */
08034dd6          }
08034dd6          
08034e62          if (data_2000da58 >= arg2)
08034e62              goto label_8034fe6;
08034e62          
08034e68          if (!r0_2)
08034e68          {
08034fb2              if (data_2000da54)
08034fb2              {
08034fb8                  sub_8034b94(&data_2000da50, arg2);
08034fb8                  /* no return */
08034fb2              }
08034fb2              
08034e68              goto label_8035026;
08034e68          }
08034e68          
08034e72          int32_t r1_3 = 1 << r6_1 << 1;
08034e7a          int32_t r0_10 = r0_2 << r6_1 & (r1_3 | (0 - r1_3));
08034e84          int32_t r1_7 = ((r0_10 & (0 - r0_10)) - 1) >> 0xc & 0x10;
08034e88          uint32_t r0_13 = ((r0_10 & (0 - r0_10)) - 1) >> r1_7;
08034e8c          int32_t r2_3 = r0_13 >> 5 & 8;
08034e90          uint32_t r0_14 = r0_13 >> r2_3;
08034e94          int32_t r3_2 = r0_14 >> 2 & 4;
08034e98          uint32_t r0_15 = r0_14 >> r3_2;
08034e9c          int32_t r6_4 = r0_15 >> 1 & 2;
08034ea2          uint32_t r0_16 = r0_15 >> r6_4;
08034ea6          int32_t r8_3 = r0_16 >> 1 & 1;
08034eb2          int32_t r8_4 = (r0_16 >> r8_3) + r6_4 + r3_2 + r2_3 + r1_7 + r8_3;
08034eb2          
08034ece          if (*(uint32_t*)(*(uint32_t*)((r8_4 << 3) + 0x2000da80) + 4) >> 3 << 3
08034ece                  != r8_4 << 3)
08034ed0              sub_80377e0();
08034ed0          
08034ed0          /* no return */
08034dba      }
08034dba      
08034fc2      bool c_1 = arg1 >= 0xffffffc0;
08034fc2      
08034fc6      if (c_1)
08034fc8          arg2 = 0xffffffff;
08034fc8      
08034fcc      void* result;
08034fcc      
08034fcc      if (c_1)
08034fcc      {
08034fe6      label_8034fe6:
08034fe6          void* r0_26 = data_2000da58;
08034fe6          
08034fea          if (r0_26 >= arg2)
08034fea          {
08034fec              void* r1_14 = (char*)r0_26 - arg2;
08034fee              void* r2_4 = data_2000da64;
08034fee              
08034ff2              if (r1_14 < 0x10)
08034ff2              {
0803500c                  data_2000da58 = 0;
0803500e                  data_2000da64 = 0;
08035014                  *(uint32_t*)((char*)r2_4 + 4) = r0_26 | 3;
08035016                  void* r0_29 = (char*)r0_26 + r2_4;
0803501e                  *(uint32_t*)((char*)r0_29 + 4) |= 1;
08034ff2              }
08034ff2              else
08034ff2              {
08034ff4                  void* r0_27 = (char*)r2_4 + arg2;
08034ff6                  data_2000da64 = r0_27;
08034ff8                  data_2000da58 = r1_14;
08034ffe                  *(uint32_t*)((char*)r0_27 + 4) = r1_14 | 1;
08035000                  *(uint32_t*)((char*)r0_27 + r1_14) = r1_14;
08035006                  *(uint32_t*)((char*)r2_4 + 4) = arg2 | 3;
08034ff2              }
08034ff2              
08035020              return (char*)r2_4 + 8;
08034fea          }
08034fea          
08035026      label_8035026:
08035026          int32_t r0_30 = data_2000da5c;
08035026          
0803502a          if (arg2 >= r0_30)
08035050              return sub_8034480(&data_2000da50, arg2, &data_2000da50, arg3);
08035050          
0803502c          int32_t r0_31 = r0_30 - arg2;
0803502e          void* r1_18 = data_2000da68;
08035030          data_2000da5c = r0_31;
08035032          void* r2_5 = (char*)r1_18 + arg2;
08035034          data_2000da68 = r2_5;
0803503a          *(uint32_t*)((char*)r2_5 + 4) = r0_31 | 1;
0803503c          result = (char*)r1_18 + 8;
08035044          *(uint32_t*)((char*)r1_18 + 4) = arg2 | 3;
08034fcc      }
08034fcc      else
08034fcc      {
08034fd6          arg2 = (arg1 + 0xb) >> 3 << 3;
08034fd6          
08034fd8          if (!data_2000da54)
08034fd8              goto label_8034fe6;
08034fd8          
08034fe2          result = sub_8034814(&data_2000da50, arg2);
08034fe2          
08034fe4          if (!result)
08034fe4              goto label_8034fe6;
08034fcc      }
08034fcc      
0803505a      return result;
08034da8  }
08034dfc                                                                                      d5 f8 08 90                              ....
08034e00  45 45 08 bf 02 f0 ec fc 4d 45 08 bf 02 f0 e8 fc 68 68 c0 08 c0 00 b8 42 18 bf 02 f0 e1 fc c8 45  EE......ME......hh.....B.......E
08034e20  05 d1 20 68 01 21 b1 40 88 43 20 60 0d e0 20 69 81 45 08 d3 d9 f8 0c 00 a8 42 04 d1 c8 f8 08 90  .. h.!.@.C `.. i.E.......B......
08034e40  c9 f8 0c 80 01 e0 02 f0 cb fc 47 f0 03 00 68 60 e8 19 08 35 41 68 41 f0 01 01 41 60 f9 e0        ..........G...h`...5AhA...A`..
08034ed4                                                              d6 f8 08 b0 4e 45 08 bf 02 f0 80 fc                      ....NE......
08034ee0  5e 45 08 bf 02 f0 7c fc 70 68 c0 08 c0 00 50 45 18 bf 02 f0 75 fc d9 45 05 d1 20 68 05 fa 08 f1  ^E....|.ph....PE....u..E.. h....
08034f00  88 43 20 60 0d e0 20 69 83 45 08 d3 db f8 0c 00 b0 42 04 d1 c9 f8 08 b0 cb f8 0c 90 01 e0 02 f0  .C `.. i.E.......B..............
08034f20  5f fc 47 f0 03 00 70 60 aa eb 07 08 f0 19 01 90 48 f0 01 00 01 99 48 60 01 98 40 f8 08 80 a7 68  _.G...p`........H.....H`..@....h
08034f40  4f ea d7 0a ba f1 20 0f 28 bf 02 f0 49 fc 47 b3 cd f8 00 a0 04 eb ca 00 d4 f8 14 90 00 f1 28 0a  O..... .(...I.G...............(.
08034f60  d3 46 10 2f 38 bf 02 f0 3b fc 20 68 00 99 20 fa 01 f2 d1 07 05 d4 00 99 05 fa 01 f1 08 43 20 60  .F./8...;. h.. ..............C `
08034f80  07 e0 da f8 08 00 21 69 88 42 2c bf 83 46 02 f0 27 fc ca f8 08 90 cb f8 0c 90 c9 f8 08 b0 c9 f8  ......!i.B,..F..'...............
08034fa0  0c a0 c4 f8 08 80 06 f1 08 05 01 98 60 61 50 e0                                                  ............`aP.
08034fbc                                                                                      05 00 12 d0                              ....
08034fc0  47 e0                                                                                            G.
0803505e    void sub_803505e(int32_t arg1)
0803505e  {
0803505e      if (!arg1)
08035060          return;
08035060      
08035062      int32_t r8;
08035062      int32_t var_10 = r8;
08035066      int32_t* r4 = arg1 - 8;
08035072      int32_t r0 = data_2000da60;
08035072      
08035076      if (r4 >= r0)
08035076      {
0803507a          int32_t r1_1 = r4[1];
0803507a          
08035082          if ((r1_1 & 3) != 1)
08035082          {
08035088              uint32_t r8_3 = r1_1 >> 3 << 3;
0803508e              void* r9_1 = (char*)r4 + r8_3;
0803508e              
08035092              if (r1_1 << 0x1f < 0)
08035092              {
08035104              label_8035104:
08035104                  
08035106                  if (r4 < r9_1)
08035106                  {
0803510a                      int32_t r0_1 = *(uint32_t*)((char*)r9_1 + 4);
0803510a                      
08035110                      if (r0_1 << 0x1f < 0)
08035110                      {
08035114                          int32_t r1_5 = r0_1 << 0x1e;
08035114                          
08035116                          if (r1_5 < 0)
08035116                          {
08035418                              *(uint32_t*)((char*)r9_1 + 4) = r0_1 >> 1 << 1;
08035420                              r4[1] = r8_3 | 1;
08035422                              *(uint32_t*)((char*)r4 + r8_3) = r8_3;
0803542a                          label_803542a:
0803542a                              
0803542c                              if (r8_3 >> 3 < 0x20)
0803542c                              {
0803543c                                  if (r8_3 < 0x10)
0803543e                                      sub_80377e0();
0803543e                                  
0803543e                                  /* no return */
0803542c                              }
0803542c                              
08035474                              uint32_t r0_41 = r8_3 >> 8;
08035474                              
08035478                              if (!r0_41)
0803547a                                  r1_5 = 0;
0803547a                              
0803547c                              if (r0_41)
0803547c                              {
08035482                                  if (r0_41 >= 0x10000)
08035484                                      r1_5 = 0x1f;
08035484                                  
08035486                                  if (r0_41 < 0x10000)
08035486                                  {
0803548e                                      int32_t r1_24 = (r0_41 - 0x100) >> 0x10 & 8;
08035492                                      uint32_t r0_42 = r0_41 << r1_24;
0803549a                                      int32_t r2_12 = (r0_42 - 0x1000) >> 0x10 & 4;
0803549e                                      uint32_t r0_43 = r0_42 << r2_12;
080354aa                                      int32_t r3_5 = (r0_43 - 0x4000) >> 0x10 & 2;
080354b4                                      int32_t r0_45 = 0xe - r1_24 - r2_12 - r3_5
080354b4                                          + (r0_43 << r3_5 >> 0xf);
080354c2                                      r1_5 = (r8_3 >> (r0_45 + 7) & 1) + (r0_45 << 1);
08035486                                  }
0803547c                              }
0803547c                              
080354ce                              int32_t** r0_47 = (r1_5 << 2) + 0x2000db80;
080354d2                              r4[5] = 0;
080354d4                              r4[4] = 0;
080354d6                              r4[7] = r1_5;
080354d8                              int32_t r2_14 = data_2000da54;
080354d8                              
080354e0                              if (r2_14 >> r1_5 << 0x1f < 0)
080354e0                              {
080354f0                                  r0_47 = *(uint32_t*)r0_47;
080354f4                                  uint32_t r1_34;
080354f4                                  
080354f4                                  r1_34 =
080354f4                                      r1_5 != 0x1f ? r8_3 << (0x19 - (r1_5 >> 1)) : r8_3;
080354f4                                  
0803550e                                  while (true)
0803550e                                  {
0803550e                                      if (r0_47[1] >> 3 << 3 == r8_3)
0803550e                                      {
08035532                                          int32_t r2_21 = data_2000da60;
08035534                                          void* r1_36 = r0_47[2];
08035536                                          bool cond:7_1 = r0_47 < r2_21;
08035536                                          
08035538                                          if (r0_47 >= r2_21)
0803553a                                              cond:7_1 = r1_36 < r2_21;
0803553a                                          
0803553c                                          if (cond:7_1)
0803553c                                              goto label_803554c;
0803553c                                          
0803553e                                          *(uint32_t*)((char*)r1_36 + 0xc) = r4;
08035540                                          r0_47[2] = r4;
08035542                                          r4[3] = r0_47;
08035544                                          r4[2] = r1_36;
08035548                                          r4[6] = 0;
0803554a                                          goto label_8035550;
0803550e                                      }
0803550e                                      
08035516                                      void** r3_8 = &r0_47[(r1_34 >> 0x1f) + 4];
0803551a                                      r1_34 <<= 1;
0803551c                                      int32_t** r2_20 = *(uint32_t*)r3_8;
0803551c                                      
08035520                                      if (!r2_20)
08035520                                      {
08035526                                          if (r3_8 >= data_2000da60)
08035526                                          {
08035528                                              *(uint32_t*)r3_8 = r4;
08035528                                              break;
08035526                                          }
08035526                                          
0803554c                                      label_803554c:
0803554c                                          sub_80377e0();
0803554c                                          /* no return */
08035520                                      }
08035520                                      
08035504                                      r0_47 = r2_20;
0803550e                                  }
080354e0                              }
080354e0                              else
080354e0                              {
080354ea                                  data_2000da54 = 1 << r1_5 | r2_14;
080354ec                                  *(uint32_t*)r0_47 = r4;
080354e0                              }
080354e0                              
0803552a                              r4[6] = r0_47;
0803552c                              r4[3] = r4;
0803552e                              r4[2] = r4;
08035550                          label_8035550:
08035550                              int32_t r0_48 = data_2000da70;
08035554                              data_2000da70 = r0_48 - 1;
08035554                              
08035556                              if (r0_48 == 1)
08035556                              {
08035562                                  for (void* i = data_2000dc18; i; 
08035562                                      i = *(uint32_t*)((char*)i + 8))
08035562                                  {
08035562                                  }
08035562                                  
08035568                                  data_2000da70 = 0xffffffff;
08035556                              }
08035116                          }
08035116                          else if (r9_1 != data_2000da68)
0803511e                          {
0803528e                              r1_5 = data_2000da64;
0803528e                              
08035292                              if (r9_1 != r1_5)
08035292                              {
080352a8                                  uint32_t r0_23 = r0_1 >> 3 << 3;
080352b2                                  r8_3 += r0_23;
080352b2                                  
080352b4                                  if (r0_23 >> 3 < 0x20)
080352b4                                  {
080352ba                                      *(uint32_t*)((char*)r9_1 + 8);
080352ba                                      
080352c0                                      if (r9_1 == *(uint32_t*)((char*)r9_1 + 0xc))
080352c2                                          sub_80377e0();
080352c2                                      
080352c2                                      /* no return */
080352b4                                  }
080352b4                                  
08035326                                  void* r7_4 = *(uint32_t*)((char*)r9_1 + 0xc);
0803532a                                  void* r6_4 = *(uint32_t*)((char*)r9_1 + 0x18);
0803532a                                  
08035330                                  if (r7_4 == r9_1)
08035330                                  {
0803534e                                      void* r0_25 = (char*)r9_1 + 0x14;
08035352                                      r7_4 = *(uint32_t*)r0_25;
08035352                                      
08035354                                      if (r7_4)
08035354                                      {
08035364                                      label_8035364:
08035364                                          
08035364                                          while (true)
08035364                                          {
08035364                                              void* r1_20 = (char*)r7_4 + 0x14;
08035368                                              int32_t r2_7 = *(uint32_t*)r1_20;
0803536a                                              bool cond:9_1 = r2_7;
0803536a                                              
0803536c                                              if (!r2_7)
0803536c                                              {
0803536e                                                  r1_20 = (char*)r7_4 + 0x10;
08035374                                                  cond:9_1 = *(uint32_t*)r1_20;
0803536c                                              }
0803536c                                              
08035376                                              if (!cond:9_1)
08035376                                                  break;
08035376                                              
08035360                                              r0_25 = r1_20;
08035362                                              r7_4 = *(uint32_t*)r0_25;
08035364                                          }
08035364                                          
0803537c                                          if (r0_25 < data_2000da60)
0803537c                                          {
08035384                                              sub_80377e0();
08035384                                              /* no return */
0803537c                                          }
0803537c                                          
0803537e                                          r1_5 = 0;
08035380                                          *(uint32_t*)r0_25 = 0;
08035354                                      }
08035354                                      else
08035354                                      {
08035356                                          r0_25 = (char*)r9_1 + 0x10;
0803535a                                          r7_4 = *(uint32_t*)r0_25;
0803535a                                          
0803535c                                          if (r7_4)
0803535c                                              goto label_8035364;
08035354                                      }
08035330                                  }
08035330                                  else
08035330                                  {
08035332                                      void* r0_24 = *(uint32_t*)((char*)r9_1 + 8);
08035332                                      
0803533a                                      if (r0_24 < data_2000da60)
0803533a                                      {
08035384                                          sub_80377e0();
08035384                                          /* no return */
0803533a                                      }
0803533a                                      
0803533c                                      r1_5 = *(uint32_t*)((char*)r0_24 + 0xc);
0803533e                                      bool cond:10_1 = r1_5 != r9_1;
0803533e                                      
08035340                                      if (r1_5 == r9_1)
08035340                                      {
08035342                                          r1_5 = *(uint32_t*)((char*)r7_4 + 8);
08035344                                          cond:10_1 = r1_5 != r9_1;
08035340                                      }
08035340                                      
08035346                                      if (cond:10_1)
08035346                                      {
08035384                                          sub_80377e0();
08035384                                          /* no return */
08035346                                      }
08035346                                      
08035348                                      *(uint32_t*)((char*)r0_24 + 0xc) = r7_4;
0803534a                                      *(uint32_t*)((char*)r7_4 + 8) = r0_24;
08035330                                  }
08035330                                  
0803538a                                  if (r6_4)
0803538a                                  {
08035398                                      void** r0_28 = (*(uint32_t*)((char*)r9_1 + 0x1c) << 2)
08035398                                          + 0x2000db80;
0803539a                                      r1_5 = *(uint32_t*)r0_28;
0803539a                                      
0803539e                                      if (r9_1 != r1_5)
0803539e                                      {
080353ba                                          if (r6_4 < data_2000da60)
080353ba                                          {
080353c8                                              sub_80377e0();
080353c8                                              /* no return */
080353ba                                          }
080353ba                                          
080353c0                                          if (*(uint32_t*)((char*)r6_4 + 0x10) != r9_1)
080353c2                                              *(uint32_t*)((char*)r6_4 + 0x14) = r7_4;
080353c0                                          else
080353c4                                              *(uint32_t*)((char*)r6_4 + 0x10) = r7_4;
080353c4                                          
080353ba                                          goto label_80353cc;
0803539e                                      }
0803539e                                      
080353a0                                      *(uint32_t*)r0_28 = r7_4;
080353a0                                      
080353a4                                      if (r7_4)
080353a4                                      {
080353cc                                      label_80353cc:
080353cc                                          
080353cc                                          if (r7_4)
080353cc                                          {
080353ce                                              int32_t r0_34 = data_2000da60;
080353ce                                              
080353d2                                              if (r7_4 < r0_34)
080353d2                                              {
080353fa                                                  sub_80377e0();
080353fa                                                  /* no return */
080353d2                                              }
080353d2                                              
080353d4                                              *(uint32_t*)((char*)r7_4 + 0x18) = r6_4;
080353d6                                              r1_5 = *(uint32_t*)((char*)r9_1 + 0x10);
080353d6                                              
080353da                                              if (r1_5)
080353da                                              {
080353de                                                  if (r1_5 >= r0_34)
080353de                                                  {
080353e0                                                      *(uint32_t*)((char*)r7_4 + 0x10) = r1_5;
080353e2                                                      *(uint32_t*)(r1_5 + 0x18) = r7_4;
080353de                                                  }
080353de                                                  else
080353e4                                                      sub_80377e0();
080353e4                                                  
080353e4                                                  /* no return */
080353da                                              }
080353da                                              
080353e8                                              void* r0_35 =
080353e8                                                  *(uint32_t*)((char*)r9_1 + 0x14);
080353e8                                              
080353ec                                              if (r0_35)
080353ec                                              {
080353ee                                                  r1_5 = data_2000da60;
080353ee                                                  
080353f2                                                  if (r0_35 < r1_5)
080353f2                                                  {
080353fa                                                      sub_80377e0();
080353fa                                                      /* no return */
080353f2                                                  }
080353f2                                                  
080353f4                                                  *(uint32_t*)((char*)r7_4 + 0x14) = r0_35;
080353f6                                                  *(uint32_t*)((char*)r0_35 + 0x18) = r7_4;
080353ec                                              }
080353cc                                          }
080353a4                                      }
080353a4                                      else
080353a4                                      {
080353ae                                          r1_5 = 1 << *(uint32_t*)((char*)r9_1 + 0x1c);
080353b2                                          data_2000da54 &= ~r1_5;
080353a4                                      }
0803538a                                  }
0803538a                                  
08035402                                  r4[1] = r8_3 | 1;
08035404                                  *(uint32_t*)((char*)r4 + r8_3) = r8_3;
08035404                                  
0803540c                                  if (r4 != data_2000da64)
0803540c                                      goto label_803542a;
0803540c                                  
0803540e                                  data_2000da58 = r8_3;
08035292                              }
08035292                              else
08035292                              {
08035294                                  int32_t r0_21 = data_2000da58;
08035296                                  data_2000da64 = r4;
08035298                                  r0 = r0_21 + r8_3;
0803529a                                  data_2000da58 = r0;
080352a0                                  r4[1] = r0 | 1;
080352a2                                  *(uint32_t*)((char*)r4 + r0) = r0;
08035292                              }
0803511e                          }
0803511e                          else
0803511e                          {
08035122                              int32_t r0_2 = data_2000da5c;
08035124                              data_2000da68 = r4;
08035126                              r0 = r0_2 + r8_3;
08035128                              data_2000da5c = r0;
0803512e                              r4[1] = r0 | 1;
0803512e                              
08035134                              if (r4 == data_2000da64)
08035134                              {
08035138                                  data_2000da64 = 0;
0803513a                                  data_2000da58 = 0;
08035134                              }
08035134                              
08035140                              if (data_2000da6c < r0)
08035140                              {
0803514a                                  if (!data_2000e11c)
0803514c                                      sub_80340a8();
0803514c                                  
08035150                                  int32_t r1_10 = data_2000da68;
08035150                                  
08035154                                  if (r1_10)
08035154                                  {
0803515c                                      if (data_2000da5c >= 0x29)
08035160                                          sub_803408c(&data_2000da50, r1_10);
08035160                                      
0803516a                                      if (data_2000da6c < data_2000da5c)
08035172                                          data_2000da6c = 0xffffffff;
08035154                                  }
08035140                              }
0803511e                          }
0803511e                          
08035574                          return;
08035110                      }
08035106                  }
08035092              }
08035092              else
08035092              {
08035094                  int32_t r2_4 = *(uint32_t*)r4;
08035094                  
0803509a                  if (!(r1_1 & 3))
08035574                      return;
08035574                  
080350a0                  r4 += 0 - r2_4;
080350a4                  r8_3 += r2_4;
080350a4                  
080350a6                  if (r4 >= r0)
080350a6                  {
080350ae                      if (r4 == data_2000da64)
080350ae                      {
0803526e                          if (((uint32_t)*(uint8_t*)((char*)r9_1 + 4) & 3) != 3)
0803526e                              goto label_8035104;
0803526e                          
08035272                          data_2000da58 = r8_3;
0803527e                          *(uint32_t*)((char*)r9_1 + 4) =
0803527e                              *(uint32_t*)((char*)r9_1 + 4) >> 1 << 1;
08035286                          r4[1] = r8_3 | 1;
08035288                          *(uint32_t*)((char*)r4 + r8_3) = r8_3;
08035574                          return;
080350ae                      }
080350ae                      
080350b6                      if (r2_4 >> 3 < 0x20)
080350b6                      {
080350bc                          r4[2];
080350bc                          
080350c0                          if (r4 == r4[3])
080350c2                              sub_80377e0();
080350c2                          
080350c2                          /* no return */
080350b6                      }
080350b6                      
0803519a                      void* r7_2 = r4[3];
0803519c                      void* r6_2 = r4[6];
0803519c                      
080351a0                      if (r7_2 == r4)
080351a0                      {
080351ba                          void* r1_13 = &r4[5];
080351be                          r7_2 = *(uint32_t*)r1_13;
080351be                          
080351c0                          if (r7_2)
080351c0                          {
080351d0                          label_80351d0:
080351d0                              
080351d0                              while (true)
080351d0                              {
080351d0                                  void* r2_5 = (char*)r7_2 + 0x14;
080351d4                                  int32_t r3_1 = *(uint32_t*)r2_5;
080351d6                                  bool cond:5_1 = r3_1;
080351d6                                  
080351d8                                  if (!r3_1)
080351d8                                  {
080351da                                      r2_5 = (char*)r7_2 + 0x10;
080351e0                                      cond:5_1 = *(uint32_t*)r2_5;
080351d8                                  }
080351d8                                  
080351e2                                  if (!cond:5_1)
080351e2                                      break;
080351e2                                  
080351cc                                  r1_13 = r2_5;
080351ce                                  r7_2 = *(uint32_t*)r1_13;
080351d0                              }
080351d0                              
080351e6                              if (r1_13 < r0)
080351e6                              {
080351ee                                  sub_80377e0();
080351ee                                  /* no return */
080351e6                              }
080351e6                              
080351ea                              *(uint32_t*)r1_13 = 0;
080351c0                          }
080351c0                          else
080351c0                          {
080351c2                              r1_13 = &r4[4];
080351c6                              r7_2 = *(uint32_t*)r1_13;
080351c6                              
080351c8                              if (r7_2)
080351c8                                  goto label_80351d0;
080351c0                          }
080351a0                      }
080351a0                      else
080351a0                      {
080351a2                          void* r1_12 = r4[2];
080351a2                          
080351a6                          if (r1_12 < r0)
080351a6                          {
080351ee                              sub_80377e0();
080351ee                              /* no return */
080351a6                          }
080351a6                          
080351a8                          int32_t r0_4 = *(uint32_t*)((char*)r1_12 + 0xc);
080351aa                          bool cond:6_1 = r0_4 != r4;
080351aa                          
080351ac                          if (r0_4 == r4)
080351b0                              cond:6_1 = *(uint32_t*)((char*)r7_2 + 8) != r4;
080351b0                          
080351b2                          if (cond:6_1)
080351b2                          {
080351ee                              sub_80377e0();
080351ee                              /* no return */
080351b2                          }
080351b2                          
080351b4                          *(uint32_t*)((char*)r1_12 + 0xc) = r7_2;
080351b6                          *(uint32_t*)((char*)r7_2 + 8) = r1_12;
080351a0                      }
080351a0                      
080351f4                      if (r6_2)
080351f4                      {
08035200                          void* r0_8 = (r4[7] << 2) + 0x2000db80;
08035200                          
08035206                          if (r4 != *(uint32_t*)r0_8)
08035206                          {
08035220                              if (r6_2 < data_2000da60)
08035220                              {
0803522e                                  sub_80377e0();
0803522e                                  /* no return */
08035220                              }
08035220                              
08035226                              if (*(uint32_t*)((char*)r6_2 + 0x10) != r4)
08035228                                  *(uint32_t*)((char*)r6_2 + 0x14) = r7_2;
08035226                              else
0803522a                                  *(uint32_t*)((char*)r6_2 + 0x10) = r7_2;
0803522a                              
08035220                              goto label_8035232;
08035206                          }
08035206                          
08035208                          *(uint32_t*)r0_8 = r7_2;
08035208                          
0803520c                          if (r7_2)
0803520c                          {
08035232                          label_8035232:
08035232                              
08035234                              if (r7_2)
08035234                              {
08035238                                  int32_t r0_14 = data_2000da60;
08035238                                  
0803523c                                  if (r7_2 < r0_14)
0803523c                                  {
08035194                                      sub_80377e0();
08035194                                      /* no return */
0803523c                                  }
0803523c                                  
0803523e                                  *(uint32_t*)((char*)r7_2 + 0x18) = r6_2;
08035240                                  void* r1_16 = r4[4];
08035240                                  
08035242                                  if (r1_16)
08035242                                  {
08035246                                      if (r1_16 >= r0_14)
08035246                                      {
08035248                                          *(uint32_t*)((char*)r7_2 + 0x10) = r1_16;
0803524a                                          *(uint32_t*)((char*)r1_16 + 0x18) = r7_2;
08035246                                      }
08035246                                      else
0803524c                                          sub_80377e0();
0803524c                                      
0803524c                                      /* no return */
08035242                                  }
08035242                                  
08035250                                  void* r0_15 = r4[5];
08035250                                  
08035254                                  if (r0_15)
08035254                                  {
0803525c                                      if (r0_15 < data_2000da60)
0803525c                                      {
08035194                                          sub_80377e0();
08035194                                          /* no return */
0803525c                                      }
0803525c                                      
0803525e                                      *(uint32_t*)((char*)r7_2 + 0x14) = r0_15;
08035260                                      *(uint32_t*)((char*)r0_15 + 0x18) = r7_2;
08035254                                  }
08035234                              }
0803520c                          }
0803520c                          else
08035218                              data_2000da54 &= ~(1 << r4[7]);
080351f4                      }
080351f4                      
080350b6                      goto label_8035104;
080350a6                  }
08035092              }
08035082          }
08035076      }
08035076      
0803556c      sub_80377e0();
0803556c      /* no return */
0803505e  }
080350c6                    bc 42 08 bf 02 f0 89 fb 60 68 c0 08 c0 00 b0 eb c6 0f 18 bf 02 f0 81 fb 05 eb        .B......`h................
080350e0  c6 00 00 f1 28 01 8f 42 05 d0 29 69 8f 42 51 d3 f9 68 a1 42 4e d1 ba 45 3d d1 28 68 01 21 b1 40  ....(..B..)i.BQ..h.BN..E=.(h.!.@
08035100  88 43 28 60                                                                                      .C(`
08035176                                                                    28 30 82 45 06 d0 28 69 82 45                        (0.E..(i.E
08035180  08 d3 da f8 08 00 a0 42 04 d1 c7 f8 0c a0 ca f8 08 70 b7 e7                                      .......B.........p..
08035198                                                                          b4 e7                                            ..
080352c6                    b1 45 08 bf 02 f0 89 fa d9 f8 04 00 c0 08 c0 00 b0 eb ca 0f 18 bf 02 f0 80 fa        .E........................
080352e0  05 eb ca 00 00 f1 28 01 8e 42 07 d0 29 69 8e 42 c0 f0 83 80 f1 68 49 45 40 f0 7f 80 b7 42 06 d1  ......(..B..)i.B.....hIE@....B..
08035300  28 68 01 21 01 fa 0a f1 88 43 28 60 77 e0 28 30 87 42 05 d0 28 69 87 42 6f d3 b8 68 48 45 6c d1  (h.!.....C(`w.(0.B..(i.Bo..hHEl.
08035320  f7 60 be 60 6b e0                                                                                .`.`k.
08035442        28 68 20 fa 07 f1 c9 07 04 d4 01 21 b9 40 08 43 28 60 07 e0 d9 f8 08 00 29 69 88 42 2c bf    (h ........!.@.C(`......)i.B,.
08035460  06 46 02 f0 bd f9 c9 f8 08 40 f4 60 a6 60 c4 f8 0c 90 7d e0                                      .F.......@.`.`....}.
08035578  int32_t data_8035578 = 0x2000da50
0803557c  int32_t data_803557c = 0x2000e11c
08035580    void* sub_8035580(char* arg1)
08035580  {
08035586      while (arg1 << 0x1e)
08035586      {
08035588          uint32_t r1_1 = (uint32_t)*(uint8_t*)arg1;
08035588          arg1 = &arg1[1];
08035588          
0803558c          if (!r1_1)
080355b4              return arg1 - &arg1[1];
08035586      }
08035586      
08035592      int32_t r2 = *(uint32_t*)arg1;
08035592      
0803559e      while (!((r2 - 0x1010101) & ~r2 & 0x80808080))
0803559e      {
080355a0          arg1 = &arg1[4];
080355a0          r2 = *(uint32_t*)arg1;
0803559e      }
0803559e      
080355a4      /* jump -> &data_80355a6 */
08035580  }
080355a6  data_80355a6:
080355a6                    10 f8 01 1b 11 b1 10 f8 01 1b fb e7                                                  ............
080355b6                                                                    00 00                                                ..
080355b8    uint8_t* sub_80355b8(uint8_t* arg1, char* arg2)
080355b8  {
080355b8      uint8_t* result = arg1;
080355b8      
080355be      while (arg1 << 0x1e)
080355be      {
080355c0          uint32_t r3_1 = (uint32_t)*(uint8_t*)arg2;
080355c0          arg2 = &arg2[1];
080355c4          *(uint8_t*)arg1 = (char)r3_1;
080355c4          arg1 = &arg1[1];
080355c4          
080355c8          if (!r3_1)
080355fa              return result;
080355be      }
080355be      
080355ce      int32_t r2 = *(uint32_t*)arg2;
080355ce      
080355dc      while (!((r2 - 0x1010101) & ~r2 & 0x80808080))
080355dc      {
080355de          *(uint32_t*)arg1 = r2;
080355de          arg1 = &arg1[4];
080355e2          arg2 = &arg2[4];
080355e2          r2 = *(uint32_t*)arg2;
080355dc      }
080355dc      
080355e6      /* jump -> &data_80355e8 */
080355b8  }
080355e8  data_80355e8:
080355e8                          11 f8 01 3b 00 f8 01 3b 13 b1 11 f8 01 3b f9 e7                                  ...;...;.....;..
080355fc    int32_t strncmp_local(char const* s1, char const* s2, uint32_t n)
080355fc  {
08035604      uint32_t r3_1;
08035604      uint32_t r4_1;
08035604      
08035604      while (true)
08035604      {
08035604          if (n)
08035604          {
08035606              r3_1 = (uint32_t)*(uint8_t*)s2;
08035608              r4_1 = (uint32_t)*(uint8_t*)s1;
08035608              
0803560c              if (r4_1 != r3_1)
0803560c                  break;
0803560c              
0803561a              uint32_t r3_2 = (uint32_t)*(uint8_t*)s1;
0803561a              s1 = &s1[1];
0803561a              
08035620              if (r3_2)
08035620              {
08035600                  s2 = &s2[1];
08035602                  n -= 1;
08035602                  continue;
08035620              }
08035604          }
08035604          
08035626          return 0;
08035604      }
08035604      
08035610      if (r4_1 >= r3_1)
08035612          return 1;
08035612      
08035614      return 0xffffffff;
080355fc  }
08035628    int32_t logging_wrapper2(char* arg1)
08035628  {
0803563a      int32_t __saved_r1;
0803563a      return tiny_printf(&*(uint32_t*)((char*)console_putc_stateful->putc)[1], 1, arg1, 
0803563a          &__saved_r1);
08035628  }
0803563c  int32_t data_803563c = 0x6459
08035640    void sub_8035640(void* arg1)
08035640  {
08035648      if (*(uint32_t*)((char*)arg1 + 8) << 0x1f >= 0)
08035656          *(uint32_t*)((char*)arg1 + 8) |= 1;
08035640  }
0803565a    void* sub_803565a(void* arg1, char arg2)
0803565a  {
0803565e      void* result;
0803565e      
0803565e      if (!(uint32_t)arg2)
0803565e      {
0803567a          result = (char*)arg1 + 8;
0803567c          *(uint32_t*)result = *(uint32_t*)((char*)arg1 + 8) & 0xfffff7ff;
0803565e      }
0803565e      else
0803565e      {
0803566a          result = (char*)arg1 + 8;
0803566c          *(uint32_t*)result = *(uint32_t*)((char*)arg1 + 8) | 0x800;
0803565e      }
0803565e      
0803567e      return result;
0803565a  }
08035680    void* sub_8035680(void* arg1, int32_t arg2)
08035680  {
0803568a      *(uint32_t*)((char*)arg1 + 4) &= 0xfcffffff;
08035694      *(uint32_t*)((char*)arg1 + 4) |= arg2;
08035696      return (char*)arg1 + 4;
08035680  }
08035698    void sub_8035698(void* arg1)
08035698  {
080356a6      *(uint32_t*)((char*)arg1 + 8) |= 8;
080356a6      
080356ae      while (*(uint32_t*)((char*)arg1 + 8) << 0x1c < 0)
080356ae          /* nop */
080356ae      
080356c0      *(uint32_t*)((char*)arg1 + 8) |= 4;
080356c0      
080356c8      while (*(uint32_t*)((char*)arg1 + 8) << 0x1d < 0)
080356c8          /* nop */
08035698  }
080356ce    void sub_80356ce(void* arg1, char arg2, char arg3)
080356ce  {
080356d2      if (!(uint32_t)arg3)
080356d2      {
08035712          uint32_t r1_10 = (uint32_t)arg2;
08035712          
08035716          if (!r1_10)
0803572c              *(uint32_t*)((char*)arg1 + 4) &= 0xfffffeff;
08035716          else if (r1_10 == 1)
0803573a              *(uint32_t*)((char*)arg1 + 4) &= 0xfffffbff;
0803571a          else if (r1_10 == 4)
0803574a              *(uint32_t*)((char*)arg1 + 8) &= 0xfffffffd;
080356d2      }
080356d2      else
080356d2      {
080356d4          uint32_t r1 = (uint32_t)arg2;
080356d4          
080356d8          if (!r1)
080356ee              *(uint32_t*)((char*)arg1 + 4) |= 0x100;
080356d8          else if (r1 == 1)
080356fc              *(uint32_t*)((char*)arg1 + 4) |= 0x400;
080356dc          else if (r1 == 4)
0803570c              *(uint32_t*)((char*)arg1 + 8) |= 2;
080356d2      }
080356ce  }
08035750    int32_t sub_8035750(int32_t arg1)
08035750  {
0803575e      data_40012304 &= 0xfff8ffff;
08035766      int32_t result = arg1 | data_40012304;
0803576c      data_40012304 = result;
0803576e      return result;
08035750  }
08035770    void sub_8035770(void* arg1, char arg2, int32_t arg3)
08035770  {
08035770      uint32_t r1_12 = (uint32_t)arg2;
08035770      
08035774      if (!r1_12)
08035774      {
08035782          if (arg3 && arg3 < 0x11)
08035782          {
08035792              *(uint32_t*)((char*)arg1 + 0x2c) &= 0xff0fffff;
080357a2              *(uint32_t*)((char*)arg1 + 0x2c) |= (arg3 - 1) << 0x14;
08035782          }
08035774      }
08035774      else if (r1_12 == 1 && arg3 && arg3 < 5)
080357ac      {
080357bc          *(uint32_t*)((char*)arg1 + 0x38) &= 0xffcfffff;
080357cc          *(uint32_t*)((char*)arg1 + 0x38) |= (arg3 - 1) << 0x14;
080357ac      }
08035770  }
080357d2    void sub_80357d2(void* arg1, char arg2, int32_t arg3)
080357d2  {
080357d2      uint32_t r1_12 = (uint32_t)arg2;
080357d2      
080357d6      if (!r1_12)
080357d6      {
080357ec          *(uint32_t*)((char*)arg1 + 8) &= 0xcfffffff;
080357fa          *(uint32_t*)((char*)arg1 + 8) |= arg3 << 0x1c;
080357d6      }
080357d6      else if (r1_12 == 1)
080357da      {
0803580c          *(uint32_t*)((char*)arg1 + 8) &= 0xffcfffff;
0803581a          *(uint32_t*)((char*)arg1 + 8) |= arg3 << 0x14;
080357da      }
080357d2  }
08035820    void sub_8035820(void* arg1, char arg2)
08035820  {
08035820      uint32_t r1_6 = (uint32_t)arg2;
08035820      
08035824      if (!r1_6)
08035838          *(uint32_t*)((char*)arg1 + 8) |= 0x40000000;
08035824      else if (r1_6 == 1)
08035848          *(uint32_t*)((char*)arg1 + 8) |= 0x400000;
08035820  }
0803584e    int32_t sub_803584e(int32_t* arg1, int32_t arg2)
0803584e  {
08035852      if (!(*(uint32_t*)arg1 & arg2))
08035858          return 0;
08035858      
08035854      return 1;
0803584e  }
0803585c    void sub_803585c(void* arg1, char arg2, uint32_t arg3, int32_t arg4)
0803585c  {
0803585e      uint32_t r1 = (uint32_t)arg2;
0803585e      
08035862      if (r1 >= 6)
08035862      {
0803588c          uint32_t r1_4 = (uint32_t)(uint8_t)r1;
0803588c          
08035890          if (r1_4 >= 0xc)
08035890          {
080358be              uint32_t r1_9 = (uint32_t)(uint8_t)r1_4;
080358be              
080358c2              if (r1_9 < 0x10)
080358c2              {
080358da                  arg3 = (uint32_t)(uint8_t)arg3;
080358ee                  *(uint32_t*)((char*)arg1 + 0x2c) = (*(uint32_t*)((char*)arg1 + 0x2c)
080358ee                      & ~(0x1f << (((uint16_t)r1_9 - 0xc) * 5)))
080358ee                      | arg3 << (((uint16_t)r1_9 - 0xc) * 5);
080358c2              }
08035890          }
08035890          else
08035890          {
080358a6              arg3 = (uint32_t)(uint8_t)arg3;
080358ba              *(uint32_t*)((char*)arg1 + 0x30) = (*(uint32_t*)((char*)arg1 + 0x30)
080358ba                  & ~(0x1f << (((uint16_t)r1_4 - 6) * 5)))
080358ba                  | arg3 << (((uint16_t)r1_4 - 6) * 5);
08035890          }
08035862      }
08035862      else
08035862      {
08035876          arg3 = (uint32_t)(uint8_t)arg3;
08035888          *(uint32_t*)((char*)arg1 + 0x34) = (*(uint32_t*)((char*)arg1 + 0x34)
08035888              & ~(0x1f << ((int16_t)r1 * 5))) | arg3 << ((int16_t)r1 * 5);
08035862      }
08035862      
080358f0      uint32_t r2 = (uint32_t)(uint8_t)arg3;
080358f0      
080358f4      if (r2 < 0xa)
080358f4      {
08035916          *(uint32_t*)((char*)arg1 + 0x10) = (*(uint32_t*)((char*)arg1 + 0x10)
08035916              & ~(7 << ((int16_t)r2 * 3))) | arg4 << ((int16_t)r2 * 3);
08035916          return;
080358f4      }
080358f4      
0803591a      uint32_t r2_3 = (uint32_t)(uint8_t)r2;
0803591a      
0803591e      if (r2_3 < 0x13)
08035946          *(uint32_t*)((char*)arg1 + 0xc) = (*(uint32_t*)((char*)arg1 + 0xc)
08035946              & ~(7 << (((uint16_t)r2_3 - 0xa) * 3))) | arg4 << (((uint16_t)r2_3 - 0xa) * 3);
0803585c  }
0803594c    void* sub_803594c(void* arg1)
0803594c  {
08035958      *(uint32_t*)((char*)arg1 + 8) |= 0x100;
0803595a      return (char*)arg1 + 8;
0803594c  }
0803595c    void* sub_803595c(void* arg1)
0803595c  {
08035968      *(uint32_t*)((char*)arg1 + 8) |= 0x200;
0803596a      return (char*)arg1 + 8;
0803595c  }
0803596c  int32_t data_803596c = 0x40012304
08035970    int32_t sub_8035970()
08035970  {
08035970      int32_t r7;
08035970      int32_t var_8 = r7;
08035970      
08035978      if (sub_8035a66() != 1)
0803597c          sub_8035b4a(3);
0803597c      
08035982      return 1;
08035970  }
08035984    int32_t sub_8035984()
08035984  {
08035988      return data_2000e104;
08035984  }
0803598a    int32_t sub_803598a()
0803598a  {
0803598e      return data_2000e108;
0803598a  }
08035990    int32_t sub_8035990()
08035990  {
08035994      return data_2000e10c;
08035990  }
08035996    int32_t stats_publish(int32_t total, int32_t activeA, int32_t activeB)
08035996  {
080359a8      data_2000e104 += total / 0x3e8;
080359ba      data_2000e108 += activeA / 0x3e8;
080359cc      data_2000e10c += activeB / 0x3e8;
080359e8      logging_wrapper(
080359e8          "\r\n-----OnceWorkTime = %d   OnceRunningTime = %d   OnceBladeTime =%d\r\n", 
080359e8          total / 0x3e8, activeA / 0x3e8, activeB / 0x3e8);
080359fa      logging_wrapper(
080359fa          "\r\n-----TotalWorkTime = %d  TotalRunningTime = %d  TotalBladeTime =%d\r\n", 
080359fa          data_2000e104, data_2000e108, data_2000e10c);
08035a04      int32_t r7;
08035a04      return sub_8035a06(0, r7);
08035996  }
08035a06    int32_t sub_8035a06(char arg1, int32_t arg2 @ r7)
08035a06  {
08035a0c      if ((uint32_t)arg1 == 1)
08035a0c      {
08035a52          camera_link_send(0, 0x9000, 0x18, &data_2000e104);
08035a60          camera_link_send(0, 0xa000, 0x18, &data_2000e104);
08035a0c      }
08035a0c      else
08035a0c      {
08035a10          sub_8035b8c(&data_2000e104);
08035a10          
08035a1a          if ((uint32_t)data_2000e430)
08035a1a          {
08035a3c              camera_link_send(0, 0xa000, 0x18, &data_2000e104);
08035a44              data_2000e430 = 0;
08035a1a          }
08035a1a          else
08035a1a          {
08035a26              camera_link_send(0, 0x9000, 0x18, &data_2000e104);
08035a2e              data_2000e430 = 1;
08035a1a          }
08035a0c      }
08035a0c      
08035a64      return arg2;
08035a06  }
08035a66    int32_t sub_8035a66()
08035a66  {
08035a6e      int128_t q0;
08035a6e      (uint64_t)q0 = 0;
08035a6e      *(uint64_t*)((char*)q0)[8] = 0;
08035a6e      int128_t q1;
08035a6e      (uint64_t)q1 = 0;
08035a7a      (uint64_t)q0 = 0;
08035a7a      *(uint64_t*)((char*)q0)[8] = 0;
08035a7a      (uint64_t)q1 = 0;
08035a8c      int64_t buf_1;
08035a8c      sub_8026ed4(0, 0x9000, 0x18, &buf_1);
08035a9a      int64_t buf;
08035a9a      sub_8026ed4(0, 0xa000, 0x18, &buf);
08035aa4      int32_t var_34;
08035aa4      int32_t var_1c;
08035aa4      int64_t var_30;
08035aa4      int64_t var_28;
08035aa4      int64_t var_18;
08035aa4      int64_t var_10;
08035aa4      
08035aa4      if (var_1c < var_34)
08035aa4      {
08035b02          if (sub_8035bb0(&buf) != 1)
08035b02          {
08035b28              if (sub_8035bb0(&buf_1) != 1)
08035b46                  return 0;
08035b46              
08035b34              camera_link_send(0, 0x9000, 0x18, &buf_1);
08035b3c              (uint64_t)q0 = buf_1;
08035b3c              *(uint64_t*)((char*)q0)[8] = var_18;
08035b3c              (uint64_t)q1 = var_10;
08035b02          }
08035b02          else
08035b02          {
08035b0e              camera_link_send(0, 0xa000, 0x18, &buf);
08035b16              (uint64_t)q0 = buf;
08035b16              *(uint64_t*)((char*)q0)[8] = var_30;
08035b16              (uint64_t)q1 = var_28;
08035b02          }
08035aa4      }
08035aa4      else if (sub_8035bb0(&buf_1) != 1)
08035aae      {
08035ad8          if (sub_8035bb0(&buf) != 1)
08035af6              return 0;
08035af6          
08035ae4          camera_link_send(0, 0xa000, 0x18, &buf);
08035aec          (uint64_t)q0 = buf;
08035aec          *(uint64_t*)((char*)q0)[8] = var_30;
08035aec          (uint64_t)q1 = var_28;
08035aae      }
08035aae      else
08035aae      {
08035aba          camera_link_send(0, 0x9000, 0x18, &buf_1);
08035ac2          (uint64_t)q0 = buf_1;
08035ac2          *(uint64_t*)((char*)q0)[8] = var_18;
08035ac2          (uint64_t)q1 = var_10;
08035aae      }
08035aca      return 1;
08035a66  }
08035b4a    int32_t sub_8035b4a(char arg1)
08035b4a  {
08035b4c      uint32_t r0 = (uint32_t)arg1;
08035b4c      
08035b50      if (r0 == 3)
08035b5a          memset16x2(&data_2000e104, 0x18, 0);
08035b50      else if ((uint32_t)(uint8_t)r0 == 2)
08035b6a          data_2000e10c = 0;
08035b6a      
08035b72      int32_t r7;
08035b72      return sub_8035a06(1, r7);
08035b4a  }
08035b74  int32_t data_8035b74 = 0x2000e104
08035b78  int32_t data_8035b78 = 0x803ab14
08035b7c  int32_t data_8035b7c = 0x803ab5c
08035b80  int32_t data_8035b80 = 0x2000e430
08035b84  int32_t data_8035b84 = 0x803b824
08035b88  int32_t data_8035b88 = 0x803b83c
08035b8c    void sub_8035b8c(void* arg1)
08035b8c  {
08035b8e      int32_t r1 = 0;
08035b92      char r3 = 0;
08035b92      
08035b9e      while (true)
08035b9e      {
08035b9e          uint32_t r3_2 = (uint32_t)r3;
08035b9e          
08035ba2          if (r3_2 >= 0x14)
08035ba2              break;
08035ba2          
08035b96          uint32_t r3_1 = (uint32_t)(uint8_t)r3_2;
08035b9a          r1 += (uint32_t)*(uint8_t*)((char*)arg1 + r3_1);
08035b9c          r3 = (uint8_t)r3_1 + 1;
08035b9e      }
08035b9e      
08035ba4      *(uint8_t*)((char*)arg1 + 0x14) = (char)r1;
08035baa      *(uint8_t*)((char*)arg1 + 0x15) = (char)((uint32_t)(uint16_t)r1 >> 8);
08035b8c  }
08035bb0    int32_t sub_8035bb0(void* arg1)
08035bb0  {
08035bb2      int32_t r1 = 0;
08035bba      char r3 = 0;
08035bba      
08035bc6      while (true)
08035bc6      {
08035bc6          uint32_t r3_2 = (uint32_t)r3;
08035bc6          
08035bca          if (r3_2 >= 0x14)
08035bca              break;
08035bca          
08035bbe          uint32_t r3_1 = (uint32_t)(uint8_t)r3_2;
08035bc2          r1 += (uint32_t)*(uint8_t*)((char*)arg1 + r3_1);
08035bc4          r3 = (uint8_t)r3_1 + 1;
08035bc6      }
08035bc6      
08035bd4      if ((uint32_t)(uint8_t)r1 != (uint32_t)*(uint8_t*)((char*)arg1 + 0x14))
08035bd6          return 0;
08035bd6      
08035be4      if ((uint32_t)(uint8_t)((uint32_t)(uint16_t)r1 >> 8)
08035be4              == (uint32_t)*(uint8_t*)((char*)arg1 + 0x15))
08035bea          return 1;
08035bea      
08035be6      return 0;
08035bb0  }
08035bf0    int32_t watchdog_kick()
08035bf0  {
08035bf6      watchdog_reg = 0xaaaa;
08035bf8      return 0xaaaa;
08035bf0  }
08035bfa    int32_t sub_8035bfa()
08035bfa  {
08035c00      watchdog_reg = 0xcccc;
08035c02      return 0xcccc;
08035bfa  }
08035c04    int32_t sub_8035c04(int16_t arg1, char arg2)
08035c04  {
08035c06      int32_t r2 = 0xfffff;
08035c10      watchdog_reg = 0x5555;
08035c22      int32_t i;
08035c22      
08035c22      do
08035c22      {
08035c16          i = data_4000300c & 1;
08035c1a          r2 -= 1;
08035c1a          
08035c1e          if (!r2)
08035c1e              break;
08035c22      } while (i);
08035c22      
08035c26      if (i)
08035c28          return 0;
08035c28      
08035c30      data_40003004 = (uint32_t)arg2;
08035c32      int32_t r2_1 = 0xfffff;
08035c44      int32_t i_1;
08035c44      
08035c44      do
08035c44      {
08035c38          i_1 = data_4000300c & 2;
08035c3c          r2_1 -= 1;
08035c3c          
08035c40          if (!r2_1)
08035c40              break;
08035c44      } while (i_1);
08035c44      
08035c48      if (i_1)
08035c4a          return 0;
08035c4a      
08035c56      data_40003008 = (uint32_t)arg1 << 0x14 >> 0x14;
08035c5e      watchdog_reg = 0xaaaa;
08035c60      return 1;
08035c04  }
08035c66                    00 00                                                                                ..
08035c68  int32_t data_8035c68 = 0x40003000
08035c6c  int32_t data_8035c6c = 0xfffff
08035c70  int32_t data_8035c70 = 0x4000300c
08035c74  int32_t data_8035c74 = 0x40003004
08035c78  int32_t data_8035c78 = 0x40003008
08035c7c    int32_t sub_8035c7c(int32_t arg1, int32_t arg2, int32_t arg3, int128_t arg4 @ q4, dbl_bits arg5 @ q5)
08035c7c  {
08035c7c      int32_t r3;
08035c7c      int32_t var_20 = r3;
08035c80      dbl_bits var_28;
08035c80      var_28.lo = (uint32_t)arg4;
08035c80      var_28.hi = *(uint32_t*)((char*)arg4)[4];
08035c80      int64_t var_30 = *(uint64_t*)((char*)arg4)[8];
08035c80      dbl_bits b;
08035c80      b.lo = arg5.lo;
08035c80      b.hi = arg5.hi;
08035c86      int32_t var_3c = arg2;
08035c86      int32_t a = arg1;
08035c88      int32_t r0 = arg2 >> 0x14 & 0x7ff;
08035c92      int32_t r4;
08035c92      
08035c92      if (r0 != 0x7ff)
08035c92      {
08035cb0          if (r0 < 1)
08035cb0          {
08035cb4              r0 = sub_8035fdc(&a);
08035cb4              
08035cba              if (r0 >= 1)
08035cba              {
08035cbc                  sub_80360bc();
08035cc2                  data_20000d58 = 0x22;
08035cc8                  (uint32_t)arg4 = b.lo;
08035cc8                  *(uint32_t*)((char*)arg4)[4] = b.hi;
08035cc8                  *(uint64_t*)((char*)arg4)[8] = var_30;
08035cc8                  arg5.lo = var_28.lo;
08035cc8                  arg5.hi = var_28.hi;
08035cce                  return 0;
08035cba              }
08035cb0          }
08035cb0          
08035cdc          var_3c = (var_3c & 0x800fffff) | 0x3fe00000;
08035cde          r4 = r0 - 0x3fe;
08035cde          goto label_8035ce2;
08035c92      }
08035c92      
08035c96      r4 = 0;
08035c98      int32_t r0_2 = var_3c << 0xc;
08035c98      bool cond:0_1 = r0_2;
08035c98      
08035c9a      if (!r0_2)
08035c9e          cond:0_1 = a;
08035c9e      
08035ca6      int32_t result;
08035ca6      
08035ca6      if (cond:0_1 || var_3c >= 0)
08035ca8          result = a;
08035ca6      else
08035ca6      {
08035ce2      label_8035ce2:
08035ce2          
08035ce4          if (var_3c < 0)
08035ce4          {
08035ce6              sub_80360bc();
08035cec              data_20000d58 = 0x21;
08035cf4              (uint32_t)arg4 = b.lo;
08035cf4              *(uint32_t*)((char*)arg4)[4] = b.hi;
08035cf4              *(uint64_t*)((char*)arg4)[8] = var_30;
08035cf4              arg5.lo = var_28.lo;
08035cf4              arg5.hi = var_28.hi;
08035cfc              return 0xffffffff;
08035ce4          }
08035ce4          
08035d08          sub_8031ac8(a, var_3c, 0x667f3bcd, 0x3fe6a09e);
08035d08          
08035d0c          if (var_3c < 0)
08035d0c          {
08035d18              int32_t a_1;
08035d18              int32_t r1_5;
08035d18              a_1 = soft_dmul(a, b);
08035d1c              a = a_1;
08035d1c              var_3c = r1_5;
08035d20              r4 -= 1;
08035d0c          }
08035d0c          
08035d2a          int32_t r0_11;
08035d2a          int32_t r1_6;
08035d2a          r0_11 = sub_802ecf4(0, 0xbff00000, a, var_3c);
08035d32          (uint64_t)arg4 = (r1_6 << 32) | r0_11;
08035d3a          int32_t r0_12;
08035d3a          int32_t r1_7;
08035d3a          r0_12 = sub_802ecf4(0, 0x3ff00000, a, var_3c);
08035d46          int32_t r0_14;
08035d46          int32_t r1_9;
08035d46          r0_14 = soft_dadd(a, b);
08035d4a          *(uint64_t*)((char*)arg4)[8] = (r1_9 << 32) | r0_14;
08035d52          int32_t r0_15;
08035d52          int32_t r1_10;
08035d52          r0_15 = soft_dmul();
08035d62          int32_t r0_17;
08035d62          int32_t r1_12;
08035d62          r0_17 = soft_dmul();
08035d6a          sub_802ecf4(r0_17, r1_12, 0xccfeb3f4, 0x3fc3991a);
08035d72          int32_t r0_18;
08035d72          int32_t r1_13;
08035d72          r0_18 = soft_dmul();
08035d7a          sub_802ecf4(r0_18, r1_13, 0xd968cb62, 0x3fc7466f);
08035d82          int32_t r0_19;
08035d82          int32_t r1_14;
08035d82          r0_19 = soft_dmul();
08035d8a          sub_802ecf4(r0_19, r1_14, 0xda12c9c6, 0x3fcc71c4);
08035d92          int32_t r0_20;
08035d92          int32_t r1_15;
08035d92          r0_20 = soft_dmul();
08035d9a          sub_802ecf4(r0_20, r1_15, 0x948ae94a, 0x3fd24924);
08035da2          int32_t r0_21;
08035da2          int32_t r1_16;
08035da2          r0_21 = soft_dmul();
08035daa          sub_802ecf4(r0_21, r1_16, 0x99975ff7, 0x3fd99999);
08035db2          int32_t r0_22;
08035db2          int32_t r1_17;
08035db2          r0_22 = soft_dmul();
08035dba          sub_802ecf4(r0_22, r1_17, 0x555555bc, 0x3fe55555);
08035dc2          int32_t r0_23;
08035dc2          int32_t r1_18;
08035dc2          r0_23 = soft_dmul();
08035dca          int32_t r0_24;
08035dca          int32_t r1_19;
08035dca          r1_19 = HIGHD((uint64_t)arg4);
08035dca          r0_24 = LOWD((uint64_t)arg4);
08035dce          sub_802eb60(r0_24, r1_19, r0_23, r1_18);
08035dd6          int32_t r0_25;
08035dd6          int32_t r1_20;
08035dd6          r0_25 = soft_dmul();
08035dda          *(uint64_t*)((char*)arg4)[8] = (r1_20 << 32) | r0_25;
08035de0          int32_t r0_27;
08035de0          int32_t r1_21;
08035de0          r0_27 = sub_802e6a4((int32_t)(int16_t)r4);
08035de8          int32_t r0_33;
08035de8          int32_t r1_27;
08035de8          int32_t r2_22;
08035de8          int32_t r3_19;
08035de8          
08035de8          if (arg3)
08035de8          {
08035e24              if (arg3 < 1)
08035e24              {
08035e96                  int32_t r0_48;
08035e96                  int32_t r1_42;
08035e96                  r0_48 = soft_dmul();
08035ea6                  int32_t r0_50;
08035ea6                  int32_t r1_44;
08035ea6                  r0_50 = soft_dmul();
08035eb6                  int32_t r0_52;
08035eb6                  int32_t r1_46;
08035eb6                  r0_52 = soft_dmul();
08035ec2                  int32_t r0_54;
08035ec2                  int32_t r1_48;
08035ec2                  r0_54 = sub_802eb60(r0_50, r1_44, r0_52, r1_46);
08035eca                  r0_33 = sub_802ecf4(r0_54, r1_48, r0_48, r1_42);
08035ece                  r3_19 = HIGHD();
08035ece                  r2_22 = LOWD();
08035e24              }
08035e24              else
08035e24              {
08035e2a                  int32_t r0_35;
08035e2a                  int32_t r1_29;
08035e2a                  r0_35 = soft_dmul();
08035e3a                  int32_t r0_37;
08035e3a                  int32_t r1_31;
08035e3a                  r0_37 = soft_dmul();
08035e4a                  int32_t r0_39;
08035e4a                  int32_t r1_33;
08035e4a                  r0_39 = soft_dmul();
08035e5a                  int32_t r0_41;
08035e5a                  int32_t r1_35;
08035e5a                  r0_41 = soft_dmul();
08035e66                  int32_t r0_43;
08035e66                  int32_t r1_37;
08035e66                  r0_43 = sub_802eb60(r0_39, r1_33, r0_41, r1_35);
08035e6e                  int32_t r0_44;
08035e6e                  int32_t r1_38;
08035e6e                  r0_44 = sub_802ecf4(r0_43, r1_37, r0_37, r1_31);
08035e76                  int32_t r0_45;
08035e76                  int32_t r1_39;
08035e76                  r0_45 = sub_802ecf4(r0_44, r1_38, r0_35, r1_29);
08035e86                  r0_33 = soft_dmul();
08035e8a                  r2_22 = r0_45;
08035e8c                  r3_19 = r1_39;
08035e24              }
08035de8          }
08035de8          else
08035de8          {
08035df2              int32_t r0_29;
08035df2              int32_t r1_23;
08035df2              r0_29 = soft_dmul();
08035df6              int32_t r2_19;
08035df6              int32_t r3_16;
08035df6              r3_16 = HIGHD(*(uint64_t*)((char*)arg4)[8]);
08035df6              r2_19 = LOWD(*(uint64_t*)((char*)arg4)[8]);
08035dfa              int32_t r0_30;
08035dfa              int32_t r1_24;
08035dfa              r0_30 = sub_802eb60(r0_29, r1_23, r2_19, r3_16);
08035dfe              int32_t r2_20;
08035dfe              int32_t r3_17;
08035dfe              r3_17 = HIGHD((uint64_t)arg4);
08035dfe              r2_20 = LOWD((uint64_t)arg4);
08035e02              int32_t r0_31;
08035e02              int32_t r1_25;
08035e02              r0_31 = sub_802ecf4(r0_30, r1_24, r2_20, r3_17);
08035e14              r0_33 = soft_dmul();
08035e18              r2_22 = r0_31;
08035e1a              r3_19 = r1_25;
08035de8          }
08035de8          
08035ed2          result = sub_802ecf4(r0_33, r1_27, r2_22, r3_19);
08035ca6      }
08035ca6      
08035ed8      (uint32_t)arg4 = b.lo;
08035ed8      *(uint32_t*)((char*)arg4)[4] = b.hi;
08035ed8      *(uint64_t*)((char*)arg4)[8] = var_30;
08035ed8      arg5.lo = var_28.lo;
08035ed8      arg5.hi = var_28.hi;
08035edc      return result;
08035c7c  }
08035ee0    int32_t sub_8035ee0(int32_t arg1, int32_t arg2, int32_t arg3 @ r7, dbl_bits arg4 @ q4)
08035ee0  {
08035ee2      dbl_bits __saved_q4;
08035ee2      __saved_q4.lo = arg4.lo;
08035ee2      __saved_q4.hi = arg4.hi;
08035ef2      int32_t r0_1;
08035ef2      int32_t r1_1;
08035ef2      r0_1 = soft_dmul(__saved_q4, arg3);
08035efa      sub_802ecf4(r0_1, r1_1, 0xccfeb3f4, 0x3fc3991a);
08035f02      int32_t r0_2;
08035f02      int32_t r1_2;
08035f02      r0_2 = soft_dmul();
08035f0a      sub_802ecf4(r0_2, r1_2, 0xd968cb62, 0x3fc7466f);
08035f12      int32_t r0_3;
08035f12      int32_t r1_3;
08035f12      r0_3 = soft_dmul();
08035f1a      sub_802ecf4(r0_3, r1_3, 0xda12c9c6, 0x3fcc71c4);
08035f22      int32_t r0_4;
08035f22      int32_t r1_4;
08035f22      r0_4 = soft_dmul();
08035f2a      sub_802ecf4(r0_4, r1_4, 0x948ae94a, 0x3fd24924);
08035f32      int32_t r0_5;
08035f32      int32_t r1_5;
08035f32      r0_5 = soft_dmul();
08035f3a      sub_802ecf4(r0_5, r1_5, 0x99975ff7, 0x3fd99999);
08035f42      int32_t r0_6;
08035f42      int32_t r1_6;
08035f42      r0_6 = soft_dmul();
08035f52      /* tailcall */
08035f52      return sub_802ecf4(r0_6, r1_6, 0x555555bc, 0x3fe55555);
08035ee0  }
08035f56                                                                    00 00                                                ..
08035f58  int32_t data_8035f58 = -0x100000
08035f5c  int32_t data_8035f5c = 0x667f3bcd
08035f60  int32_t data_8035f60 = 0x3fe6a09e
08035f64  int32_t data_8035f64 = -0x40100000
08035f68  int32_t data_8035f68 = 0x3ff00000
08035f6c  int32_t data_8035f6c = -0x40d62109
08035f70  int32_t data_8035f70 = 0x3fc2f8d8
08035f74  int32_t data_8035f74 = -0x33014c0c
08035f78  int32_t data_8035f78 = 0x3fc3991a
08035f7c  int32_t data_8035f7c = -0x2697349e
08035f80  int32_t data_8035f80 = 0x3fc7466f
08035f84  int32_t data_8035f84 = -0x25ed363a
08035f88  int32_t data_8035f88 = 0x3fcc71c4
08035f8c  int32_t data_8035f8c = -0x6b7516b6
08035f90  int32_t data_8035f90 = 0x3fd24924
08035f94  int32_t data_8035f94 = -0x6668a009
08035f98  int32_t data_8035f98 = 0x3fd99999
08035f9c  int32_t data_8035f9c = 0x555555bc
08035fa0  int32_t data_8035fa0 = 0x3fe55555
08035fa4  int32_t data_8035fa4 = -0x8654362
08035fa8  int32_t data_8035fa8 = 0x3e7f7d1c
08035fac  int32_t data_8035fac = 0x3fe62e42
08035fb0  int32_t data_8035fb0 = 0x3fdbcb7b
08035fb4  int32_t data_8035fb4 = 0xe32a6ab
08035fb8  int32_t data_8035fb8 = 0x3e5526e5
08035fbc  int32_t data_8035fbc = 0x7fbcc47c
08035fc0  int32_t data_8035fc0 = 0x3e7427de
08035fc4  int32_t data_8035fc4 = 0x1526e50e
08035fc8  int32_t data_8035fc8 = 0x3fd34413
08035fcc  int32_t data_8035fcc = 0x3ff71547
08035fd0  int32_t data_8035fd0 = -0x7a220bc
08035fd4  int32_t data_8035fd4 = 0x3e54ae0b
08035fd8  int32_t data_8035fd8 = 0x652b82fe
08035fdc    int32_t sub_8035fdc(int32_t* arg1)
08035fdc  {
08035fde      int32_t r3 = arg1[1];
08035fe4      int32_t result = 1;
08035fe6      int32_t r3_1 = r3 & 0xfffff;
08035fea      arg1[1] = r3_1;
08035fec      bool cond:0 = r3_1;
08035fec      
08035fee      if (!r3_1)
08035ff2          cond:0 = *(uint32_t*)arg1;
08035ff2      
08035ff4      if (cond:0)
08035ff4      {
08036008          int32_t r4_2;
08036008          
08036008          while (true)
08036008          {
08036008              r4_2 = arg1[1];
08036008              
0803600c              if (r4_2 << 0xb < 0)
0803600c                  break;
0803600c              
08035ff8              int32_t r3_3 = *(uint32_t*)arg1;
08036000              arg1[1] = r3_3 >> 0x1f | r4_2 << 1;
08036004              *(uint32_t*)arg1 = r3_3 << 1;
08036006              result -= 1;
08036008          }
08036008          
08036012          arg1[1] = r4_2 & 0xfffff;
08035ff4      }
08035ff4      
08036018      arg1[1] |= r3 & 0x80000000;
0803601e      return result;
08035fdc  }
08036020    int32_t sub_8036020(int32_t* arg1, int32_t arg2)
08036020  {
08036022      int32_t r2 = arg1[1] >> 0x14 & 0x7ff;
08036022      
0803602c      if (r2 == 0x7ff)
0803602c      {
08036032          if (!(arg1[1] << 0xc))
08036038              return 1;
08036038          
0803603a          return 2;
0803602c      }
0803602c      
08036040      int32_t r3_1 = arg1[1] << 1;
08036040      bool cond:0 = !r3_1;
08036040      
08036042      if (!r3_1)
08036046          cond:0 = !*(uint32_t*)arg1;
08036046      
08036048      if (!cond:0)
08036048      {
08036050          int32_t r2_2 = 0x433 - r2 - arg2;
08036050          
08036054          if (r2_2 >= 1)
08036054          {
08036058              if (r2_2 >= 0x35)
08036058              {
08036060                  arg1[1] &= 0x80000000;
08036064                  *(uint32_t*)arg1 = 0;
08036094                  return 0xffffffff;
08036058              }
08036058              
08036074              int32_t r1_7;
08036074              int32_t r2_7;
08036074              
08036074              if (r2_2 << 0x1a >= 0)
08036074              {
08036086                  int32_t r2_8 = *(uint32_t*)arg1;
08036088                  r1_7 = ((1 << (r2_2 & 0x1f)) - 1) & r2_8;
0803608a                  r2_7 = r2_8 ^ r1_7;
08036074              }
08036074              else
08036074              {
08036076                  int32_t r2_4 = arg1[1];
08036078                  int32_t r1_6 = ((1 << (r2_2 & 0x1f)) - 1) & r2_4;
0803607c                  arg1[1] = r2_4 ^ r1_6;
08036080                  r1_7 = r1_6 | *(uint32_t*)arg1;
08036082                  r2_7 = 0;
08036074              }
08036074              
0803608c              *(uint32_t*)arg1 = r2_7;
0803608c              
0803608e              if (r1_7)
08036094                  return 0xffffffff;
08036054          }
08036048      }
08036048      
08036098      return 0;
08036020  }
0803609a                                                                                00 00                                        ..
0803609c    void sub_803609c(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4) __pure
080360ba  {
080360ba      return;
080360ba  }
080360bc    int32_t sub_80360bc()
080360bc  {
080360be      /* tailcall */
080360be      return sub_8037814();
080360bc  }
080360c2        00 00                                                                                        ..
080360c4  int32_t data_80360c4 = 0x20000d58
080360c8    void sub_80360c8(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
080360c8  {
080360cc      int32_t temp0 = arg2 << 1;
080360cc      
080360d0      if (0x200000 == -(temp0) || 0x200000 + temp0 >= 0x200000)
080360d6          /* tailcall */
080360d6          return sub_80360d8(arg1, arg2, arg3, arg4);
080360c8  }
080360d8    void sub_80360d8(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4) __pure
080360ec  {
080360ec      return;
080360ec  }
080360f6                                                                    00 00                                                ..
080360f8    int32_t sub_80360f8(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int128_t arg5 @ q4, int128_t arg6 @ q5, int32_t arg7)
080360f8  {
080360fe      int64_t var_20 = (uint64_t)arg5;
080360fe      int64_t var_28 = *(uint64_t*)((char*)arg5)[8];
080360fe      dbl_bits b;
080360fe      b.lo = (uint32_t)arg6;
080360fe      b.hi = *(uint32_t*)((char*)arg6)[4];
080360fe      dbl_bits a;
080360fe      a.lo = *(uint32_t*)((char*)arg6)[8];
080360fe      a.hi = *(uint32_t*)((char*)arg6)[0xc];
08036102      *(uint64_t*)((char*)arg5)[8] = *(uint32_t*)arg1;
08036106      (uint64_t)arg5 = (arg4 << 32) | arg3;
0803610a      int32_t r0;
0803610a      int32_t r1;
0803610a      r1 = HIGHD(*(uint64_t*)((char*)arg5)[8]);
0803610a      r0 = LOWD(*(uint64_t*)((char*)arg5)[8]);
0803610e      int32_t r0_1 = sub_8036678(r0, r1);
08036114      int32_t r0_2;
08036114      int32_t r1_1;
08036114      r1_1 = HIGHD((uint64_t)arg5);
08036114      r0_2 = LOWD((uint64_t)arg5);
08036118      int32_t result = sub_8036678(r0_2, r1_1);
08036120      int32_t result_1;
08036120      
08036120      if (r0_1 >= 0)
08036120      {
08036132          if (r0_1 == 2)
08036132              goto label_803617a;
08036132          
08036126      label_8036126:
08036126          
08036128          if (result != 2)
08036128          {
08036136              if (!result)
08036136              {
08036166              label_8036166:
08036166                  sub_80360bc();
0803616c                  data_20000d58 = 0x21;
08036176                  *(uint32_t*)arg1 = 0xffffffff;
08036176                  arg1[1] = 0x7fffffff;
0803617a              label_803617a:
0803617a                  (uint32_t)arg5 = a.lo;
0803617a                  *(uint32_t*)((char*)arg5)[4] = a.hi;
0803617a                  *(uint32_t*)((char*)arg5)[8] = b.lo;
0803617a                  *(uint32_t*)((char*)arg5)[0xc] = b.hi;
0803617a                  (uint64_t)arg6 = var_28;
0803617a                  *(uint64_t*)((char*)arg6)[8] = var_20;
08036180                  return 2;
08036136              }
08036136              
08036150              if (result == 1)
0803615e                  goto label_8036166;
0803615e              
08036184              if (r0_1)
08036184              {
080361b8                  int32_t r0_10;
080361b8                  int32_t r1_8;
080361b8                  r0_10 = soft_dmul(a, b);
080361bc                  *(uint32_t*)arg1 = r0_10;
080361bc                  arg1[1] = r1_8;
0803620a                  result = 1;
08036184              }
08036184              else
08036184              {
08036186                  *(uint32_t*)arg1 = (uint64_t)arg5;
08036192                  result_1 = sub_8036aec(arg1, arg7);
08036192                  bool cond:6_1 = result_1;
08036192                  
08036194                  if (result_1)
08036196                      cond:6_1 = result_1 != 1;
08036196                  
08036198                  if (!cond:6_1)
08036198                  {
0803619c                      sub_80360bc();
080361a2                      data_20000d58 = 0x22;
08036198                  }
08036198                  
080363b4                  result = result_1;
08036184              }
08036128          }
08036128          else
0803612a              *(uint32_t*)arg1 = (uint64_t)arg5;
08036120      }
08036120      else
08036120      {
08036122          bool c_1 = result >= 0;
08036122          
08036124          if (result >= 0)
08036124              goto label_8036126;
08036124          
080361c2          int32_t r0_11;
080361c2          int32_t r1_9;
080361c2          r1_9 = HIGHD(*(uint64_t*)((char*)arg5)[8]);
080361c2          r0_11 = LOWD(*(uint64_t*)((char*)arg5)[8]);
080361ca          sub_8031ac8(r0_11, r1_9, 0, 0xc09cc800);
080361ca          
080361ce          if (!c_1)
080361ce          {
080361d6              int32_t r0_13;
080361d6              int32_t r1_11;
080361d6              r0_13 = soft_dmul(a, b);
080361da              *(uint32_t*)arg1 = r0_13;
080361da              arg1[1] = r1_11;
080361de              (uint32_t)arg5 = a.lo;
080361de              *(uint32_t*)((char*)arg5)[4] = a.hi;
080361de              *(uint32_t*)((char*)arg5)[8] = b.lo;
080361de              *(uint32_t*)((char*)arg5)[0xc] = b.hi;
080361de              (uint64_t)arg6 = var_28;
080361de              *(uint64_t*)((char*)arg6)[8] = var_20;
080361e4              return 0;
080361ce          }
080361ce          
080361ec          sub_80360c8(r0_11, r1_9, 1, 0x409cc800);
080361ec          
080361f0          if (c_1)
080361f0          {
08036224              int32_t r0_17;
08036224              int32_t r1_14;
08036224              r0_17 = soft_dmul(a, b);
0803622c              sub_8031ac8(r0_17, r1_14, 0, 0);
08036230              int64_t q0;
08036230              
08036230              q0 = !c_1 ? 0 : 0;
08036230              
0803623a              int32_t r2_2;
0803623a              int32_t r3_3;
0803623a              r3_3 = HIGHD(q0);
0803623a              r2_2 = LOWD(q0);
0803623e              int32_t r0_18;
0803623e              int32_t r1_15;
0803623e              r0_18 = sub_802ecf4(r0_17, r1_14, r2_2, r3_3);
08036242              int32_t r0_19 = sub_802ff74(r0_18, r1_15);
08036248              int32_t r0_20;
08036248              int32_t r1_16;
08036248              r0_20 = sub_802e6a4(r0_19);
0803624c              (uint64_t)arg6 = (r1_16 << 32) | r0_20;
08036256              int32_t r0_21;
08036256              int32_t r1_17;
08036256              r0_21 = soft_dmul();
0803625e              int32_t r0_22;
0803625e              int32_t r1_18;
0803625e              r1_18 = HIGHD(*(uint64_t*)((char*)arg5)[8]);
0803625e              r0_22 = LOWD(*(uint64_t*)((char*)arg5)[8]);
08036262              int32_t r0_23;
08036262              int32_t r1_19;
08036262              r0_23 = sub_802eb60(r0_22, r1_18, r0_21, r1_17);
08036272              int32_t r0_25;
08036272              int32_t r1_21;
08036272              r0_25 = soft_dmul();
0803627e              int32_t r0_27;
0803627e              int32_t r1_23;
0803627e              r0_27 = sub_802eb60(r0_23, r1_19, r0_25, r1_21);
08036288              sub_80360c8(r0_27, r1_23, 0xffffffff, 0xbc8fffff);
0803628c              *(uint64_t*)((char*)arg5)[8] = (r1_23 << 32) | r0_27;
08036296              sub_8031ac8(r0_27, r1_23, 0, 0x3c900000);
08036296              
0803629a              if (c_1)
0803629a              {
080362a2                  int32_t r0_28;
080362a2                  int32_t r1_24;
080362a2                  r0_28 = soft_dmul();
080362a6                  (uint64_t)arg6 = (r1_24 << 32) | r0_28;
080362ae                  int32_t r0_29;
080362ae                  int32_t r1_25;
080362ae                  r0_29 = soft_dmul();
080362b6                  sub_802ecf4(r0_29, r1_25, 0x8c124358, 0x3fbc718f);
080362be                  int32_t r0_30;
080362be                  int32_t r1_26;
080362be                  r0_30 = soft_dmul();
080362c2                  *(uint64_t*)((char*)arg6)[8] = (r1_26 << 32) | r0_30;
080362ce                  int32_t r0_32;
080362ce                  int32_t r1_28;
080362ce                  r0_32 = soft_dmul();
080362d6                  sub_802ecf4(r0_32, r1_28, 0xdaf3bd0b, 0x3f8c70e8);
080362de                  int32_t r0_33;
080362de                  int32_t r1_29;
080362de                  r0_33 = soft_dmul();
080362e6                  sub_802ecf4(r0_33, r1_29, 0, 0x3fe00000);
080362ee                  int32_t r0_34;
080362ee                  int32_t r1_30;
080362ee                  r0_34 = soft_dmul();
080362f2                  *(uint64_t*)((char*)arg5)[8] = (r1_30 << 32) | r0_34;
080362f6                  int32_t r0_35;
080362f6                  int32_t r1_31;
080362f6                  r1_31 = HIGHD(*(uint64_t*)((char*)arg6)[8]);
080362f6                  r0_35 = LOWD(*(uint64_t*)((char*)arg6)[8]);
080362fa                  int32_t r2_13;
080362fa                  int32_t r3_14;
080362fa                  r3_14 = HIGHD(*(uint64_t*)((char*)arg5)[8]);
080362fa                  r2_13 = LOWD(*(uint64_t*)((char*)arg5)[8]);
080362fe                  int32_t r0_36;
080362fe                  int32_t r1_32;
080362fe                  r0_36 = sub_802ecf4(r0_35, r1_31, r2_13, r3_14);
08036302                  (uint64_t)arg6 = 0;
08036364                  int32_t r0_37;
08036364                  int32_t r1_33;
08036364                  r0_37 = sub_802ecf4(r0_36, r1_32, 0, 0);
0803636c                  int32_t r0_38;
0803636c                  int32_t r1_34;
0803636c                  r1_34 = HIGHD(*(uint64_t*)((char*)arg6)[8]);
0803636c                  r0_38 = LOWD(*(uint64_t*)((char*)arg6)[8]);
08036370                  int32_t r2_15;
08036370                  int32_t r3_16;
08036370                  r3_16 = HIGHD(*(uint64_t*)((char*)arg5)[8]);
08036370                  r2_15 = LOWD(*(uint64_t*)((char*)arg5)[8]);
08036374                  int32_t r0_39;
08036374                  int32_t r1_35;
08036374                  r0_39 = sub_802eb60(r0_38, r1_34, r2_15, r3_16);
0803637c                  int32_t r0_40;
0803637c                  int32_t r1_36;
0803637c                  r0_40 = sub_802ecf4(r0_39, r1_35, 0, 0);
08036388                  soft_dadd();
08036390                  int32_t r0_42;
08036390                  int32_t r1_38;
08036390                  r0_42 = soft_dmul();
08036394                  (uint64_t)arg5 = (r1_38 << 32) | r0_42;
0803629a              }
0803629a              
08036398              *(uint32_t*)arg1 = (uint64_t)arg5;
080363a4              result_1 = sub_8036aec(arg1, arg7 + r0_19);
080363a4              bool cond:7_1 = result_1;
080363a4              
080363a6              if (result_1)
080363a8                  cond:7_1 = result_1 != 1;
080363a8              
080363aa              if (!cond:7_1)
080363aa              {
080363ac                  sub_80360bc();
080363b2                  data_20000d58 = 0x22;
080363aa              }
080363aa              
080363b4              result = result_1;
080361f0          }
080361f0          else
080361f0          {
080361fa              int32_t r0_16;
080361fa              int32_t r1_13;
080361fa              r0_16 = soft_dmul(a, b);
080361fe              *(uint32_t*)arg1 = r0_16;
080361fe              arg1[1] = r1_13;
08036202              sub_80360bc();
08036208              data_20000d58 = 0x22;
0803620a              result = 1;
080361f0          }
08036120      }
080363b6      (uint32_t)arg5 = a.lo;
080363b6      *(uint32_t*)((char*)arg5)[4] = a.hi;
080363b6      *(uint32_t*)((char*)arg5)[8] = b.lo;
080363b6      *(uint32_t*)((char*)arg5)[0xc] = b.hi;
080363b6      (uint64_t)arg6 = var_28;
080363b6      *(uint64_t*)((char*)arg6)[8] = var_20;
080363ba      return result;
080360f8  }
0803620e                                            00 bf                                                                ..
08036210  int32_t data_8036210 = 0x7ff00000
08036214  int32_t data_8036214 = -0x100000
08036218  int32_t data_8036218 = -0x3f633800
0803621c  int32_t data_803621c = 0x409cc800
08036308                          00 00                                                                            ..
0803630a  int32_t data_803630a = 0x0
0803630e                                            f0 3f                                                                .?
08036310  int32_t data_8036310 = 0x652b82fe
08036314  int32_t data_8036314 = 0x3ff71547
08036318                                                                          00 00                                            ..
0803631a  int32_t data_803631a = 0x0
0803631e                                                                                            e0 bf                                ..
08036320  00 00                                                                                            ..
08036322  int32_t data_8036322 = 0x0
08036326                    e0 3f                                                                                .?
08036328  int32_t data_8036328 = 0x3fe62e42
0803632c  int32_t data_803632c = -0x432a1b0e
08036330  int32_t data_8036330 = 0x3e4be8e7
08036334  int32_t data_8036334 = -0x43700001
08036338  int32_t data_8036338 = 0x3c900000
0803633c  int32_t data_803633c = -0x7ea8d1ef
08036340  int32_t data_8036340 = 0x3f503fa0
08036344  int32_t data_8036344 = -0x73edbca8
08036348  int32_t data_8036348 = 0x3fbc718f
0803634c  int32_t data_803634c = 0x41a5e84b
08036350  int32_t data_8036350 = 0x3f0152b7
08036354  int32_t data_8036354 = -0x250c42f5
08036358  int32_t data_8036358 = 0x3f8c70e8
0803635c  int32_t data_803635c = 0x3fe00000
080363be                                                                                            00 00                                ..
080363c0    int32_t sub_80363c0(int32_t arg1 @ r7)
080363c0  {
080363c8      nvic_enable_irq_with_priority(0x19, 1, 0);
080363d0      rcc_enable_by_code(0x1111);
080363d4      return arg1;
080363c0  }
080363d6    int32_t sub_80363d6(int32_t arg1, int32_t arg2 @ r7)
080363d6  {
080363da      sub_80363ea(arg1, 2, arg2);
080363de      return arg2;
080363d6  }
080363e0    int32_t sub_80363e0(int32_t arg1, int32_t arg2 @ r7)
080363e0  {
080363e4      sub_80363ea(arg1, 1, arg2);
080363e8      return arg2;
080363e0  }
080363ea    int32_t sub_80363ea(int32_t arg1, char arg2, int32_t arg3 @ r7)
080363ea  {
080363ee      data_2000e3d0 = arg1;
080363f4      sub_8036408((uint32_t)arg2);
080363f4      
080363fc      while (data_2000e3d0)
080363fc          /* nop */
080363fc      
08036402      sub_8036fb6(0x40014400);
08036406      return arg3;
080363ea  }
08036408    int32_t sub_8036408(int32_t arg1)
08036408  {
08036408      int32_t r3;
08036408      int32_t var_c = r3;
08036408      int32_t r2;
08036408      int32_t var_10 = r2;
08036408      int32_t r1;
08036408      int32_t var_14 = r1;
08036408      int32_t result = arg1;
0803640e      sub_8036fb6(0x40014400);
08036416      sub_8036fd8(0x40014400, 1);
0803641a      uint32_t r4_1 = (uint32_t)(uint8_t)arg1;
0803641a      
0803641e      if (r4_1 == 2)
08036422          var_10 = 7;
0803641e      else if ((uint32_t)(uint8_t)r4_1 == 1)
08036430          var_10 = 0x1f3f;
08036430      
08036436      (uint16_t)result = (int16_t)data_200005b8;
0803643c      (uint16_t)var_c = 0;
08036442      (uint16_t)var_14 = 0;
0803644a      sub_8036f0e(0x40014400, &result);
08036452      sub_8037004(0x40014400, 1);
08036458      sub_8036fc0(0x40014400);
08036460      sub_8036fca(0x40014400, 1);
08036466      sub_8036fac(0x40014400);
0803646a      return result;
08036408  }
0803646c  int32_t data_803646c = 0x2000e3d0
08036470  int32_t data_8036470 = 0x40014400
08036474  int32_t data_8036474 = 0x200005b8
08036478    int32_t sub_8036478(char* arg1, char* arg2)
08036478  {
08036478      int32_t r7;
08036478      int32_t var_8 = r7;
0803647e      return sub_8037816(arg1, arg2);
08036478  }
08036480    int32_t* sub_8036480(int32_t* arg1, int32_t* arg2, uint32_t arg3)
08036480  {
08036480      int32_t* result = arg1;
08036480      
08036484      if (!(arg2 << 0x1e))
08036484      {
08036486      label_8036486:
08036486          
08036486          while (true)
08036486          {
08036486              uint32_t temp0_1 = arg3;
08036486              arg3 -= 4;
08036486              
08036488              if (temp0_1 < 4)
08036488              {
080364ce                  arg3 += 4;
080364ce                  break;
08036488              }
08036488              
0803648a              int32_t r3_1 = *(uint32_t*)arg2;
0803648a              arg2 = &arg2[1];
0803648a              
0803649a              if ((r3_1 - 0x1010101) & ~r3_1 & 0x80808080)
080364a0                  /* jump -> &data_80364a2 */
080364a0              
0803649c              *(uint32_t*)arg1 = r3_1;
0803649c              arg1 = &arg1[1];
08036486          }
08036486          
08036488          goto label_80364d0;
08036484      }
08036484      
080364ba      if (arg3 >= 4)
080364ba      {
080364bc          while (true)
080364bc          {
080364bc              uint32_t r3_2 = (uint32_t)*(uint8_t*)arg2;
080364bc              arg2 += 1;
080364c0              arg3 -= 1;
080364c2              *(uint8_t*)arg1 = (char)r3_2;
080364c2              arg1 += 1;
080364c2              
080364c6              if (!r3_2)
080364c6                  break;
080364c6              
080364ca              if (!(arg2 << 0x1e))
080364ca                  goto label_8036486;
080364bc          }
080364bc          
080364c6          goto label_80364e0;
080364ba      }
080364ba      
080364d0  label_80364d0:
080364d0      
080364d0      if (arg3)
080364d0      {
080364de          uint32_t i;
080364de          
080364de          do
080364de          {
080364d2              uint32_t r3_4 = (uint32_t)*(uint8_t*)arg2;
080364d2              arg2 += 1;
080364d6              i = arg3;
080364d6              arg3 -= 1;
080364d8              *(uint8_t*)arg1 = (char)r3_4;
080364d8              arg1 += 1;
080364d8              
080364dc              if (!r3_4)
080364dc                  break;
080364de          } while (i != 1);
080364e0      label_80364e0:
080364e0          
080364e2          if (arg3)
080364e6              memfill_back32(arg1, arg3, 0);
080364d0      }
080364d0      
080364ea      return result;
08036480  }
080364a2  data_80364a2:
080364a2        9c fa 8c fc bc fa 8c f1 c1 f1 18 01 8b 40 cb 40 40 f8 04 3b 13 e0                            .............@.@@..;..
080364ec    int32_t sub_80364ec(char* arg1, char* arg2, char* arg3, int32_t* arg4)
080364ec  {
080364ec      int32_t* var_4 = arg4;
080364ec      char* var_8 = arg3;
080364ee      int32_t* va_list_ptr = arg4;
080364ee      char* init_state = arg3;
080364f4      va_list_ptr = &var_8;
080364f8      init_state = arg1;
08036504      int32_t result = tiny_printf(putc_fn_80234be, &init_state, arg2, &va_list_ptr);
0803650c      *(uint8_t*)init_state = 0;
0803650c      
08036510      if (result >= 0)
08036514          return init_state - arg1;
08036514      
08036518      return result;
080364ec  }
0803651c  int32_t data_803651c = -0x1305d
08036520    void exti_config(uint32_t line_mask, uint8_t mode, uint8_t trigger)
08036520  {
0803652a      data_40013c00 &= ~line_mask;
08036534      data_40013c04 &= ~line_mask;
0803653e      data_40013c08 &= ~line_mask;
08036548      data_40013c0c &= ~line_mask;
0803654a      uint32_t mode_1 = (uint32_t)mode;
0803654a      
0803654e      if (!mode_1)
0803655e          data_40013c00 |= line_mask;
0803654e      else if (mode_1 == 1)
0803656a          data_40013c04 |= line_mask;
0803656a      
0803656e      uint32_t trigger_1 = (uint32_t)trigger;
0803656e      
08036572      if (!trigger_1)
08036572      {
08036584          data_40013c08 |= line_mask;
08036590          data_40013c0c &= ~line_mask;
08036572      }
08036572      else if (trigger_1 == 2)
08036576      {
080365b2          data_40013c08 |= line_mask;
080365bc          data_40013c0c |= line_mask;
08036576      }
08036576      else if (trigger_1 < 2)
08036578      {
0803659c          data_40013c08 &= ~line_mask;
080365a6          data_40013c0c |= line_mask;
08036578      }
08036520  }
080365c4    int32_t sub_80365c4(int32_t arg1)
080365c4  {
080365d6      if (data_40013c14 & arg1 && arg1 & data_40013c00)
080365d8          return 1;
080365d8      
080365dc      return 0;
080365c4  }
080365e0    void sub_80365e0(int32_t arg1)
080365e0  {
080365e2      data_40013c14 = arg1;
080365e0  }
080365e6                    00 00                                                                                ..
080365e8  int32_t data_80365e8 = 0x40013c00
080365ec  int32_t data_80365ec = 0x40013c04
080365f0  int32_t data_80365f0 = 0x40013c08
080365f4  int32_t data_80365f4 = 0x40013c0c
080365f8  int32_t data_80365f8 = 0x40013c14
080365fc    void* sub_80365fc(int32_t* arg1, int32_t* arg2)
080365fc  {
08036620      *(uint32_t*)arg1 = (*(uint32_t*)arg1 & 0x3040) | *(uint32_t*)arg2 | arg2[1] | arg2[2]
08036620          | arg2[3] | arg2[4] | arg2[5] | arg2[6];
0803662e      arg1[7] &= 0xfffff7ff;
08036630      return &arg1[7];
080365fc  }
08036632    void sub_8036632(int32_t* arg1)
08036632  {
08036638      *(uint32_t*)arg1 |= 0x40;
08036632  }
0803663c    uint32_t* sub_803663c(void* arg1, int16_t arg2)
0803663c  {
08036640      *(uint32_t*)((char*)arg1 + 0xc) = (uint32_t)arg2;
08036642      return (char*)arg1 + 0xc;
0803663c  }
08036644    uint32_t sub_8036644(void* arg1)
08036644  {
0803664a      return (uint32_t)(uint16_t)*(uint32_t*)((char*)arg1 + 0xc);
08036644  }
0803664c    int32_t sub_803664c(void* arg1, int32_t arg2)
0803664c  {
08036652      if (!(*(uint32_t*)((char*)arg1 + 8) & arg2))
08036658          return 0;
08036658      
08036654      return 1;
0803664c  }
0803665c    void* sub_803665c(int32_t* arg1, int16_t arg2)
0803665c  {
08036662      *(uint32_t*)arg1 |= 0x2000;
08036668      arg1[4] = (uint32_t)arg2;
0803666a      return &arg1[4];
0803665c  }
0803666c    int32_t sub_803666c(int32_t arg1)
0803666c  {
0803666e      sub_80360bc();
08036674      data_20000d58 = 0x21;
08036676      return arg1;
0803666c  }
08036678    int32_t sub_8036678(int32_t arg1, int32_t arg2) __pure
08036678  {
08036678      int32_t var_8 = arg1;
0803667e      int32_t r1 = arg2 >> 0x14 & 0x7ff;
0803667e      
08036688      if (r1 == 0x7ff)
08036688      {
0803669e          if (arg1 | (arg2 & 0xfffff))
080366a0              return 2;
080366a0          
080366a2          return 1;
08036688      }
08036688      
0803668a      if (r1)
080366ae          return 0xffffffff;
080366ae      
08036692      int32_t result = arg1 | (arg2 & 0xfffff);
08036692      
08036694      if (!result)
080366a6          return result;
080366a6      
080366b6      return 0xfffffffe;
08036678  }
080366b8    int32_t sub_80366b8(int32_t arg1, int32_t arg2, int32_t arg3, int128_t arg4 @ q4)
080366b8  {
080366ba      int32_t r4 = arg3;
080366c0      sub_80360c8(arg1, arg2, 0x5e9ecd57, 0x3fd12614);
080366c4      dbl_bits b;
080366c4      b.lo = (uint32_t)arg4;
080366c4      b.hi = *(uint32_t*)((char*)arg4)[4];
080366c4      dbl_bits a;
080366c4      a.lo = *(uint32_t*)((char*)arg4)[8];
080366c4      a.hi = *(uint32_t*)((char*)arg4)[0xc];
080366c8      (uint64_t)arg4 = (arg2 << 32) | arg1;
080366cc      bool z;
080366cc      bool c;
080366cc      
080366cc      if (z || !c)
080366cc      {
080366ce          *(uint64_t*)((char*)arg4)[8] = 0xb67ae858;
080366da          int32_t r0_1;
080366da          int32_t r1_1;
080366da          r0_1 = soft_dmul(a, b);
080366e2          int32_t r0_2;
080366e2          int32_t r1_2;
080366e2          r0_2 = sub_802ecf4(r0_1, r1_1, 0, 0xbff00000);
080366ea          int32_t r2_1;
080366ea          int32_t r3_2;
080366ea          r3_2 = HIGHD((uint64_t)arg4);
080366ea          r2_1 = LOWD((uint64_t)arg4);
080366f2          int32_t r0_4;
080366f2          int32_t r1_4;
080366f2          r0_4 = sub_802ecf4(0xb67ae858, 0, r2_1, r3_2);
080366fe          int32_t r0_6;
080366fe          int32_t r1_6;
080366fe          r0_6 = soft_dadd();
08036702          (uint64_t)arg4 = (r1_6 << 32) | r0_6;
08036706          r4 |= 1;
080366cc      }
080366cc      
0803670a      int32_t r0_7;
0803670a      int32_t r1_7;
0803670a      r1_7 = HIGHD((uint64_t)arg4);
0803670a      r0_7 = LOWD((uint64_t)arg4);
08036712      sub_8031ac8(r0_7, r1_7, 0, 0xbe400000);
08036712      
08036716      if (c)
0803671e          sub_80360c8(r0_7, r1_7, 1, 0x3e400000);
0803671e      
08036722      if (!c || !c)
08036722      {
08036728          int32_t r0_8;
08036728          int32_t r1_8;
08036728          r0_8 = soft_dmul(a, b);
0803672c          *(uint64_t*)((char*)arg4)[8] = (r1_8 << 32) | r0_8;
08036734          int32_t r0_9;
08036734          int32_t r1_9;
08036734          r0_9 = soft_dmul();
08036744          int32_t r0_11;
08036744          int32_t r1_11;
08036744          r0_11 = soft_dmul();
0803674c          sub_802ecf4(r0_11, r1_11, 0x194c93b2, 0x3fe45eed);
08036754          int32_t r0_12;
08036754          int32_t r1_12;
08036754          r0_12 = soft_dmul();
0803675c          sub_802ecf4(r0_12, r1_12, 0xb902debe, 0x3ff84002);
08036764          int32_t r0_13;
08036764          int32_t r1_13;
08036764          r0_13 = soft_dmul();
08036768          int32_t r2_8;
08036768          int32_t r3_9;
08036768          r3_9 = HIGHD((uint64_t)arg4);
08036768          r2_8 = LOWD((uint64_t)arg4);
0803676c          int32_t r0_14;
0803676c          int32_t r1_14;
0803676c          r0_14 = sub_802ecf4(r0_13, r1_13, r2_8, r3_9);
0803677c          int32_t r0_16;
0803677c          int32_t r1_16;
0803677c          r0_16 = soft_dmul();
08036784          sub_802ecf4(r0_16, r1_16, 0x8312ab8a, 0x3fc80c00);
0803678c          int32_t r0_17;
0803678c          int32_t r1_17;
0803678c          r0_17 = soft_dmul();
08036794          sub_802ecf4(r0_17, r1_17, 0x8e5d724, 0x3ff0d8b6);
0803679c          int32_t r0_18;
0803679c          int32_t r1_18;
0803679c          r0_18 = soft_dmul();
080367a4          sub_802ecf4(r0_18, r1_18, 0xe58340f, 0x3ffd9558);
080367ac          int32_t r0_19;
080367ac          int32_t r1_19;
080367ac          r0_19 = soft_dmul();
080367b4          int32_t r0_20;
080367b4          int32_t r1_20;
080367b4          r0_20 = sub_802ecf4(r0_19, r1_19, 0, 0x3ff00000);
080367c0          int32_t r0_22;
080367c0          int32_t r1_22;
080367c0          r0_22 = soft_dadd();
080367c4          (uint64_t)arg4 = (r1_22 << 32) | r0_22;
08036722      }
08036722      
080367ca      if (r4 << 0x1e < 0)
080367d4          (uint64_t)arg4 = (uint64_t)arg4;
080367d4      
080367d8      int32_t r2_14 = r4 & 7;
080367d8      
080367dc      if (r2_14)
080367dc      {
080367e6          int32_t r0_25;
080367e6          int32_t r1_25;
080367e6          r1_25 = HIGHD((uint64_t)arg4);
080367e6          r0_25 = LOWD((uint64_t)arg4);
080367ea          void* r2_16 = *(uint32_t*)(0x8036868 + (r2_14 << 3));
080367ee          int32_t r0_26;
080367ee          int32_t r1_26;
080367ee          r0_26 = sub_802ecf4(r0_25, r1_25, r2_16, *(uint32_t*)((char*)r2_16 + 4), a, b);
080367f2          (uint64_t)arg4 = (r1_26 << 32) | r0_26;
080367dc      }
080367dc      
080367f8      if (r4 << 0x1c < 0)
08036802          (uint64_t)arg4 = (uint64_t)arg4;
08036802      
08036806      int32_t result;
08036806      int32_t r1_29;
08036806      r1_29 = HIGHD((uint64_t)arg4);
08036806      result = LOWD((uint64_t)arg4);
0803680a      (uint32_t)arg4 = a.lo;
0803680a      *(uint32_t*)((char*)arg4)[4] = a.hi;
0803680a      *(uint32_t*)((char*)arg4)[8] = b.lo;
0803680a      *(uint32_t*)((char*)arg4)[0xc] = b.hi;
0803680e      return result;
080366b8  }
08036810  int32_t data_8036810 = 0x5e9ecd57
08036814  int32_t data_8036814 = 0x3fd12614
08036818                                                                          aa 4c                                            .L
0803681a  int32_t data_803681a = -0x498517a8
0803681e                                                                                            fb 3f                                .?
08036820  int32_t data_8036820 = -0x40100000
08036824  int32_t data_8036824 = -0x41c00000
08036828  int32_t data_8036828 = 0x13575d84
0803682c  int32_t data_803682c = 0x3fb0574b
08036830  int32_t data_8036830 = 0x194c93b2
08036834  int32_t data_8036834 = 0x3fe45eed
08036838  int32_t data_8036838 = -0x46fd2142
0803683c  int32_t data_803683c = 0x3ff84002
08036840  int32_t data_8036840 = -0x70fdc622
08036844  int32_t data_8036844 = 0x3f74c0c7
08036848  int32_t data_8036848 = -0x7ced5476
0803684c  int32_t data_803684c = 0x3fc80c00
08036850  int32_t data_8036850 = 0x8e5d724
08036854  int32_t data_8036854 = 0x3ff0d8b6
08036858  int32_t data_8036858 = 0xe58340f
0803685c  int32_t data_803685c = 0x3ffd9558
08036860  int32_t data_8036860 = 0x3ff00000
08036864              00 00 00 00 00 00 00 00 00 00 00 00                                                      ............
08036870    uint32_t sub_8036870(int32_t arg1, int32_t* arg2, int32_t arg3, int32_t arg4, void* arg5 @ r4, int32_t arg6 @ r5, int32_t* arg7 @ r6, int32_t arg8 @ r7)
08036870  {
08036870      *(uint8_t*)((char*)arg5 + 0xd) = (char)arg7;
08036874      *(uint32_t*)arg2 = arg2;
08036874      arg2[1] = arg5;
08036874      arg2[2] = arg7;
0803687a      *(uint8_t*)(arg1 - 0x2d + arg2) = (char)arg5;
08036880      *(uint8_t*)((char*)arg5 + 0xd) = (char)arg7;
08036884      *(uint32_t*)0xfb = 0xfb;
08036884      *(uint32_t*)0xff = arg5;
08036884      *(uint32_t*)0x103 = arg7;
0803688a      *(uint8_t*)(arg1 + 0xa1) = (char)arg5;
08036890      *(uint8_t*)((char*)arg5 + 0xd) = (char)arg7;
08036894      *(uint32_t*)0xfb = 0xfb;
08036894      *(uint32_t*)0xff = arg5;
08036894      *(uint32_t*)0x103 = arg7;
0803689a      *(uint8_t*)(arg1 + 0x74) = (char)arg5;
080368a2      *(uint32_t*)arg7 = arg4;
080368a2      arg7[1] = arg5;
080368a2      arg7[2] = arg6;
080368a4      /* tailcall */
080368a4      return sub_80368a8((char*)arg7 + 0x7c00000c, 0xfb, arg3);
08036870  }
080368a8    void sub_80368a8(char* arg1, int32_t arg2, int32_t arg3)
080368a8  {
080368ba      int32_t i;
080368ba      
080368ba      do
080368ba      {
080368b2          i = arg2;
080368b2          arg2 -= 0x10;
080368b2          
080368b4          if (i >= 0x10)
080368b4          {
080368b6              *(uint32_t*)arg1 = arg3;
080368b6              *(uint32_t*)(arg1 + 4) = arg3;
080368b6              *(uint32_t*)(arg1 + 8) = arg3;
080368b6              *(uint32_t*)(arg1 + 0xc) = arg3;
080368b6              arg1 = &arg1[0x10];
080368b4          }
080368ba      } while (i > 0x10);
080368ba      
080368c0      if (TEST_BIT(arg2, 3))
080368c0      {
080368c2          *(uint32_t*)arg1 = arg3;
080368c2          *(uint32_t*)(arg1 + 4) = arg3;
080368c2          arg1 = &arg1[8];
080368c0      }
080368c0      
080368c4      if (arg2 << 0x1d < 0)
080368c4      {
080368c6          *(uint32_t*)arg1 = arg3;
080368c6          arg1 = &arg1[4];
080368c4      }
080368c4      
080368cc      if (TEST_BIT(arg2, 1))
080368cc      {
080368ce          *(uint16_t*)arg1 = (int16_t)arg3;
080368ce          arg1 = &arg1[2];
080368cc      }
080368cc      
080368d2      if (arg2 << 0x1f < 0)
080368d4          *(uint8_t*)arg1 = (char)arg3;
080368a8  }
080368da                                                                                00 00                                        ..
080368dc    void* sub_80368dc(int32_t arg1 @ r4, int32_t arg2 @ r5, int32_t arg3 @ r6, int32_t arg4 @ r7, int32_t arg5 @ r8, int32_t arg6 @ r9, int32_t arg7 @ r10, int32_t arg8 @ r11)
080368dc  {
080368dc      uint32_t r0_3 = __mrs(psp);
080368e0      __isb();
080368e6      int32_t** r2 = data_2000e38c;
080368f2      *(uint32_t*)(r0_3 - 0x24) = arg1;
080368f2      *(uint32_t*)(r0_3 - 0x20) = arg2;
080368f2      *(uint32_t*)(r0_3 - 0x1c) = arg3;
080368f2      *(uint32_t*)(r0_3 - 0x18) = arg4;
080368f2      *(uint32_t*)(r0_3 - 0x14) = arg5;
080368f2      *(uint32_t*)(r0_3 - 0x10) = arg6;
080368f2      *(uint32_t*)(r0_3 - 0xc) = arg7;
080368f2      *(uint32_t*)(r0_3 - 8) = arg8;
080368f2      int32_t lr;
080368f2      *(uint32_t*)(r0_3 - 4) = lr;
080368f6      *(uint32_t*)r2 = r0_3 - 0x24;
080368f8      int32_t* var_8 = r0_3 - 0x24;
080368fe      __msr(basepri, 0x20);
08036902      __dsb_SY();
08036906      __isb();
0803690a      sub_8029a58();
08036912      __msr(basepri, 0);
0803691a      int32_t* r0_1 = **(uint32_t**)&data_2000e38c;
0803691c      *(uint32_t*)r0_1;
0803691c      r0_1[1];
0803691c      r0_1[2];
0803691c      r0_1[3];
0803691c      r0_1[4];
0803691c      r0_1[5];
0803691c      r0_1[6];
0803691c      r0_1[7];
0803691c      
08036924      if (!(r0_1[8] & 0x10))
08036924      {
08036926          int128_t q4;
08036926          (uint32_t)q4 = r0_1[9];
08036926          *(uint32_t*)((char*)q4)[4] = r0_1[0xa];
08036926          *(uint32_t*)((char*)q4)[8] = r0_1[0xb];
08036926          *(uint32_t*)((char*)q4)[0xc] = r0_1[0xc];
08036926          int128_t q5;
08036926          (uint32_t)q5 = r0_1[0xd];
08036926          *(uint32_t*)((char*)q5)[4] = r0_1[0xe];
08036926          *(uint32_t*)((char*)q5)[8] = r0_1[0xf];
08036926          *(uint32_t*)((char*)q5)[0xc] = r0_1[0x10];
08036926          int128_t q6;
08036926          (uint32_t)q6 = r0_1[0x11];
08036926          *(uint32_t*)((char*)q6)[4] = r0_1[0x12];
08036926          *(uint32_t*)((char*)q6)[8] = r0_1[0x13];
08036926          *(uint32_t*)((char*)q6)[0xc] = r0_1[0x14];
08036926          int128_t q7;
08036926          (uint32_t)q7 = r0_1[0x15];
08036926          *(uint32_t*)((char*)q7)[4] = r0_1[0x16];
08036926          *(uint32_t*)((char*)q7)[8] = r0_1[0x17];
08036926          *(uint32_t*)((char*)q7)[0xc] = r0_1[0x18];
08036924      }
08036924      
0803692a      __msr(psp, &r0_1[9]);
0803692e      __isb();
08036932      return &r0_1[9];
080368dc  }
08036934    int32_t sub_8036934()
08036934  {
08036938      int32_t* r0 = **(uint32_t**)&data_2000e38c;
0803693a      *(uint32_t*)r0;
0803693a      r0[1];
0803693a      r0[2];
0803693a      r0[3];
0803693a      r0[4];
0803693a      r0[5];
0803693a      r0[6];
0803693a      r0[7];
0803693e      __msr(psp, &r0[9]);
08036942      __isb();
0803694a      __msr(basepri, 0);
0803694e      return 0;
08036934  }
08036950    int32_t sub_8036950()
08036950  {
08036956      __msr(msp, **(uint32_t**)&SCB_VTOR);
0803695e      __msr(control, 0);
08036962      /* unimplemented  {cpsie I} */
08036964      /* unimplemented  {cpsie F} */
08036966      __dsb_SY();
0803696a      __isb();
0803696e      syscall(0);
0803696e      /* tailcall */
0803696e      return sub_8036970();
08036950  }
08036970    int32_t sub_8036970()
08036970  {
0803697a      *(uint32_t*)0xe000ed88 |= 0xf00000;
0803697c      return 0xe000ed88;
08036970  }
0803697e                                                                                            00 00                                ..
08036980  int32_t data_8036980 = 0x2000e38c
08036984  int32_t data_8036984 = -0x1fff12f8
08036988  int32_t data_8036988 = -0x1fff1278
0803698c    void sub_803698c(char* arg1, char arg2)
0803698c  {
08036992      for (uint32_t i = (uint32_t)*(uint8_t*)arg1; i; i = (uint32_t)*(uint8_t*)arg1)
08036992      {
08036994          if (i == (uint32_t)arg2)
08036994              break;
08036994          
08036996          arg1 = &arg1[1];
08036992      }
0803698c  }
080369a2        00 00                                                                                        ..
080369a4    void* sub_80369a4(char* arg1, char arg2, int32_t arg3)
080369a4  {
080369a4      uint32_t r1_2 = (uint32_t)arg2;
080369a4      
080369a8      while (true)
080369a8      {
080369a8          bool cond:0_1;
080369a8          
080369a8          if (!(arg1 << 0x1e))
080369a8          {
080369b8              int32_t r2 = arg3 - 8;
080369b8              
080369ba              if (arg3 >= 8)
080369ba              {
080369bc                  r2 += 4;
080369c0                  uint32_t r1 = r1_2 | r1_2 << 8;
080369c4                  uint32_t r1_1 = r1 | r1 << 0x10;
080369de                  bool cond:2_1;
080369de                  
080369de                  do
080369de                  {
080369c8                      int32_t r3_3 = *(uint32_t*)arg1;
080369c8                      arg1 = &arg1[4];
080369cc                      int32_t temp3_1 = r2;
080369cc                      r2 -= 4;
080369cc                      cond:2_1 = temp3_1 == 4;
080369cc                      
080369ce                      if (temp3_1 >= 4)
080369ce                      {
080369d0                          int32_t r3_4 = r3_3 ^ r1_1;
080369da                          cond:2_1 = !((r3_4 - 0x1010101) & ~r3_4 & 0x80808080);
080369ce                      }
080369de                  } while (cond:2_1);
080369e0                  r1_2 = (uint32_t)(uint8_t)r1_1;
080369e2                  arg1 -= 4;
080369ba              }
080369ba              
080369e4              int32_t r2_1 = r2 + 8;
080369f2              bool cond:1_1;
080369f2              
080369f2              do
080369f2              {
080369e6                  uint32_t r3_5 = (uint32_t)*(uint8_t*)arg1;
080369e6                  arg1 = &arg1[1];
080369ea                  int32_t temp2_1 = r2_1;
080369ea                  r2_1 -= 1;
080369ea                  cond:0_1 = temp2_1 != 1;
080369ea                  cond:1_1 = temp2_1 > 1;
080369ea                  
080369ec                  if (temp2_1 >= 1)
080369ec                  {
080369ee                      uint32_t temp4_1 = r1_2 ^ r3_5;
080369ee                      cond:0_1 = temp4_1;
080369ee                      cond:1_1 = temp4_1 > 0;
080369ec                  }
080369f2              } while (cond:1_1);
080369a8          }
080369a8          else
080369a8          {
080369aa              int32_t temp1_1 = arg3;
080369aa              arg3 -= 1;
080369aa              cond:0_1 = temp1_1 != 1;
080369aa              
080369ac              if (temp1_1 >= 1)
080369ac              {
080369ae                  uint32_t r3_2 = (uint32_t)*(uint8_t*)arg1;
080369ae                  arg1 = &arg1[1];
080369ae                  
080369b4                  if (r1_2 == r3_2)
080369b4                      break;
080369b4                  
080369b4                  continue;
080369ac              }
080369a8          }
080369a8          
080369f4          if (!cond:0_1)
080369f4              break;
080369f4          
080369f6          arg1 = 1;
080369f6          break;
080369a8      }
080369a8      
080369fa      return arg1 - 1;
080369a4  }
080369fc    void sub_80369fc(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
080369fc  {
080369fe      int32_t r4_2;
080369fe      int32_t var_10;
080369fe      int32_t var_c;
080369fe      int32_t var_8;
080369fe      int32_t r4;
080369fe      int32_t r5;
080369fe      int32_t r6;
080369fe      
080369fe      if (arg4)
080369fe      {
08036a28          bool c_1 = arg1 >= arg3;
08036a2a          bool cond:1_1 = ~c_1;
08036a2a          
08036a2e          if (arg2 - arg4 >= arg2 && (arg2 - arg4 != arg2 || !c_1))
08036a26              return;
08036a26          
08036a30          var_8 = r6;
08036a30          var_c = r5;
08036a30          var_10 = r4;
08036a32          int32_t r4_1 = __clz(arg2);
08036a3a          r4_2 = __clz(arg4) - r4_1;
08036a3c          arg4 <<= r4_2;
080369fe      }
080369fe      else
080369fe      {
08036a02          if (!arg2)
08036a02          {
08036a04              if (arg3)
08036a10                  return;
08036a10              
08036a12              /* tailcall */
08036a12              return sub_8037844();
08036a02          }
08036a02          
08036a74          if (arg3 <= 1)
08036a74          {
08036a16              if (arg3 >= 1)
08036a1c                  return;
08036a1c              
08036a12              /* tailcall */
08036a12              return sub_8037844();
08036a74          }
08036a74          
08036a76          var_8 = r6;
08036a76          var_c = r5;
08036a76          var_10 = r4;
08036a76          
08036a7a          if (!(arg3 >> 0x10))
08036ae8              return;
08036ae8          
08036a88          r4_2 = 0x20 - __clz(arg2) + __clz(arg3);
08036a88          
08036a8e          if (r4_2 >= 0x20)
08036a8e          {
08036a90              int32_t r2_5 = arg3 << (r4_2 - 0x20);
08036a96              uint32_t r4_8 = 0x80000000 >> (r4_2 - 0x20);
08036a98              int32_t r5_6 = 0;
08036a98              
08036aa2              while (true)
08036aa2              {
08036aa2                  bool c_6 = arg1 >= arg4;
08036aa4                  bool cond:4_1 = ~c_6;
08036aa4                  bool c_7 = arg2 - r2_5 < arg2 || (arg2 - r2_5 == arg2 && c_6);
08036aa4                  
08036aa8                  if (c_7)
08036aa8                  {
08036aaa                      arg1 -= arg4;
08036aac                      arg2 = arg2 - r2_5;
08036aa8                  }
08036aa8                  
08036aae                  uint32_t temp2_1 = r4_8;
08036aae                  uint32_t temp3_1 = r4_8;
08036aae                  r4_8 = temp2_1 + temp3_1;
08036aae                  bool c_8 =
08036aae                      temp2_1 + temp3_1 < temp2_1 || (c_7 && temp2_1 + temp3_1 == temp2_1);
08036ab0                  int32_t temp4_1 = r5_6;
08036ab0                  int32_t temp5_1 = r5_6;
08036ab0                  r5_6 = temp4_1 + temp5_1;
08036ab0                  
08036ab2                  if (temp4_1 + temp5_1 < temp4_1 || (c_8 && temp4_1 + temp5_1 == temp4_1))
08036ab2                      break;
08036ab2                  
08036a9c                  r2_5 u>>= 1;
08036a9e                  arg4 <<= 1;
08036aa2              }
08036aa2              
08036abc              return;
08036a8e          }
080369fe      }
08036a46      int32_t r3_2 = arg4 | arg3 >> (0x20 - r4_2);
08036a48      int32_t r2_3 = arg3 << r4_2;
08036a4e      uint32_t r6_2 = 0x80000000 >> r4_2;
08036a4e      
08036a58      while (true)
08036a58      {
08036a58          bool c_3 = arg1 >= r2_3;
08036a5a          bool cond:2_1 = ~c_3;
08036a5a          bool c_4 = arg2 - r3_2 < arg2 || (arg2 - r3_2 == arg2 && c_3);
08036a5a          
08036a5e          if (c_4)
08036a5e          {
08036a60              arg1 -= r2_3;
08036a62              arg2 = arg2 - r3_2;
08036a5e          }
08036a5e          
08036a64          uint32_t temp0_1 = r6_2;
08036a64          uint32_t temp1_1 = r6_2;
08036a64          r6_2 = temp0_1 + temp1_1;
08036a64          
08036a66          if (temp0_1 + temp1_1 < temp0_1 || (c_4 && temp0_1 + temp1_1 == temp0_1))
08036a66              break;
08036a66          
08036a52          r3_2 u>>= 1;
08036a54          r2_3 <<= 1;
08036a58      }
080369fc  }
08036aea                                00 00                                                                        ..
08036aec    int32_t sub_8036aec(int32_t* arg1, int32_t arg2)
08036aec  {
08036af4      int32_t r0_1 = arg1[1] >> 0x14 & 0x7ff;
08036af4      
08036afe      if (r0_1 != 0x7ff)
08036afe      {
08036b10          if (!r0_1)
08036b10          {
08036b14              r0_1 = sub_8035fdc(arg1);
08036b14              
08036b1a              if (r0_1 >= 1)
08036bec                  return 0;
08036b10          }
08036b10          
08036b28          if (arg2 < 1 || arg2 < 0x7ff - r0_1)
08036b28          {
08036b44              int32_t r1_2 = arg1[1];
08036b44              
08036b46              if (0 - r0_1 < arg2)
08036b46              {
08036b52                  arg1[1] = (r1_2 & 0x800fffff) | (r0_1 + arg2) << 0x14;
08036bdc                  return 0xffffffff;
08036b46              }
08036b46              
08036b5a              int32_t r5_1 = r0_1 - 1 + arg2;
08036b62              int32_t r3_2 = (arg1[1] & 0xfffff) | 0x100000;
08036b68              int32_t r1_4 = r1_2 & 0x80000000;
08036b6c              arg1[1] = r3_2;
08036b6c              
08036b6e              if (r5_1 + 0x35 >= 0x35)
08036b6e              {
08036b70                  arg1[1] = r1_4;
08036b74                  *(uint32_t*)arg1 = 0;
08036b76                  return 0;
08036b6e              }
08036b6e              
08036b78              int32_t r0_13 = 0;
08036b78              
08036b7e              if (r5_1 < 0xffffffe1)
08036b7e              {
08036b80                  r0_13 = *(uint32_t*)arg1;
08036b82                  *(uint32_t*)arg1 = r3_2;
08036b86                  r5_1 += 0x20;
08036b88                  arg1[1] = 0;
08036b7e              }
08036b7e              
08036b8c              if (0 != r5_1)
08036b8c              {
08036b9c                  r0_13 = *(uint32_t*)arg1 << (0x20 - (0 - r5_1))
08036b9c                      | ~(r0_13 - 1 - (r0_13 - 1)) >> 0x1f;
08036bac                  *(uint32_t*)arg1 =
08036bac                      arg1[1] << (0x20 - (0 - r5_1)) | *(uint32_t*)arg1 >> (0 - r5_1);
08036bb2                  arg1[1] u>>= 0 - r5_1;
08036b8c              }
08036b8c              
08036bbc              arg1[1] |= r1_4;
08036bbc              
08036bc6              if (r0_13 > 0x80000000
08036bc6                      || (r0_13 == 0x80000000 && (uint32_t)*(uint8_t*)arg1 << 0x1f < 0))
08036bcc                  *(uint32_t*)arg1 += 1;
08036bcc              
08036bc6              if ((r0_13 > 0x80000000
08036bc6                  || (r0_13 == 0x80000000 && (uint32_t)*(uint8_t*)arg1 << 0x1f < 0))
08036bc6                  && !*(uint32_t*)arg1)
08036bc6              {
08036bd6                  arg1[1] += 1;
08036bdc                  return 0xffffffff;
08036bc6              }
08036bc6              
08036bde              int32_t r0_25 = arg1[1];
08036be0              bool cond:5_1 = r0_25 != r1_4;
08036be0              
08036be2              if (r0_25 == r1_4)
08036be6                  cond:5_1 = *(uint32_t*)arg1;
08036be6              
08036be8              if (cond:5_1)
08036bdc                  return 0xffffffff;
08036bdc              
08036bec              return 0;
08036b28          }
08036b28          
08036b2e          int64_t q0;
08036b2e          
08036b2e          if (arg1[1] < 0)
08036b30              q0 = 0;
08036b2e          else
08036b34              q0 = 0;
08036b34          
08036b38          *(uint32_t*)arg1 = q0;
08036afe      }
08036afe      else
08036afe      {
08036b02          int32_t r0_3 = arg1[1] << 0xc;
08036b02          bool cond:0_1 = !r0_3;
08036b02          
08036b04          if (!r0_3)
08036b08              cond:0_1 = !*(uint32_t*)arg1;
08036b08          
08036b0a          if (!cond:0_1)
08036b0e              return 2;
08036afe      }
08036afe      
08036b3e      return 1;
08036aec  }
08036bee                                            00 bf                                                                ..
08036bf0  int32_t data_8036bf0 = 0x0
08036bf4                                                              00 00 f0 ff                                              ....
08036bf8  int32_t data_8036bf8 = 0x0
08036bfc                                                                                      00 00 f0 7f                              ....
08036c00    int32_t sub_8036c00(int32_t arg1 @ r7)
08036c00  {
08036c10      data_20000d5c = 0x8036c54;
08036c12      data_20000d80 = &data_8036c58;
08036c14      data_20000d60 = 0x8036c54;
08036c1a      data_20000d94 = "false";
08036c1c      __builtin_memcpy(&data_20000d64, 
08036c1c          "\x54\x6c\x03\x08\x54\x6c\x03\x08\x54\x6c\x03\x08\x54\x6c\x03\x08\x54\x6c\x03\x08", 
08036c1c          0x14);
08036c2a      data_20000d84 = 0x8036c54;
08036c2c      data_20000d88 = 0x8036c54;
08036c2e      data_20000d8c = 0x8036c54;
08036c30      data_20000d90 = 0x8036c54;
08036c32      data_20000d98 = "true";
08036c34      data_20000d9c = 0x8036c54;
08036c36      data_20000da0 = 0x8036c54;
08036c38      return arg1;
08036c00  }
08036c3a    int32_t sub_8036c3a()
08036c3a  {
08036c46      int32_t r7;
08036c46      
08036c46      if (!data_20000d5c)
08036c48          sub_8036c00(r7);
08036c4e      return &data_20000d5c;
08036c3a  }
08036c50  int32_t data_8036c50 = 0x20000d5c
08036c54                                                              00 00 00 00                                              ....
08036c58  data_8036c58:
08036c58                                                                          2e 00 00 00                                      ....
08036c5c  data_8036c5c:
08036c5c                                                                                      66 61 6c 73                              fals
08036c60  65 00 00 00                                                                                      e...
08036c64  data_8036c64:
08036c64              74 72 75 65 00 00 00 00                                                                  true....
08036c6c    void sub_8036c6c(int32_t* arg1, int32_t arg2, int32_t arg3)
08036c6c  {
08036c74      *(uint32_t*)arg1 = arg2 / arg3;
08036c74      arg1[1] = arg2 % arg3;
08036c6c  }
08036c7a                                                                                00 00                                        ..
08036c7c    int32_t sub_8036c7c(int32_t arg1)
08036c7c  {
08036c7e      int32_t result;
08036c7e      
08036c7e      if (arg1)
08036c7e      {
08036c98          result = data_40007400 | 0x10000;
08036ca0          data_40007400 = result;
08036c7e      }
08036c7e      else
08036c7e      {
08036c86          result = data_40007400 | 1;
08036c8e          data_40007400 = result;
08036c7e      }
08036c7e      
08036ca2      return result;
08036c7c  }
08036ca4    int32_t sub_8036ca4(int32_t arg1)
08036ca4  {
08036ca6      int32_t result;
08036ca6      
08036ca6      if (arg1)
08036ca6      {
08036cc0          result = data_40007400 & 0xfffdffff;
08036cc8          data_40007400 = result;
08036ca6      }
08036ca6      else
08036ca6      {
08036cae          result = data_40007400 & 0xfffffffd;
08036cb6          data_40007400 = result;
08036ca6      }
08036ca6      
08036cca      return result;
08036ca4  }
08036ccc    int32_t sub_8036ccc(int32_t arg1)
08036ccc  {
08036cce      int32_t result;
08036cce      
08036cce      if (arg1)
08036cce      {
08036ce8          result = data_40007400 & 0xfffbffff;
08036cf0          data_40007400 = result;
08036cce      }
08036cce      else
08036cce      {
08036cd6          result = data_40007400 & 0xfffffffb;
08036cde          data_40007400 = result;
08036cce      }
08036cce      
08036cf2      return result;
08036ccc  }
08036cf4    int32_t sub_8036cf4(int32_t arg1, int32_t arg2)
08036cf4  {
08036cf6      int32_t result;
08036cf6      
08036cf6      if (arg1)
08036cf6      {
08036d1a          data_40007400 &= 0xff3fffff;
08036d20          result = data_40007400 | arg2 << 0x10;
08036d26          data_40007400 = result;
08036cf6      }
08036cf6      else
08036cf6      {
08036d02          data_40007400 &= 0xffffff3f;
08036d08          result = data_40007400 | arg2;
08036d0c          data_40007400 = result;
08036cf6      }
08036cf6      
08036d28      return result;
08036cf4  }
08036d2a    void sub_8036d2a(int32_t* arg1, int32_t arg2, int16_t arg3)
08036d2a  {
08036d2c      if (arg1)
08036d2c      {
08036d56          if (!arg2)
08036d64              data_40007414 = (uint32_t)arg3;
08036d56          else if (arg2 == 2)
08036d74              data_4000741c = (uint32_t)arg3;
08036d5a          else if (arg2 < 2)
08036d6c              data_40007418 = (uint32_t)arg3;
08036d2c      }
08036d2c      else if (!arg2)
08036d3e          data_40007408 = (uint32_t)arg3;
08036d30      else if (arg2 == 2)
08036d4e          data_40007410 = (uint32_t)arg3;
08036d34      else if (arg2 < 2)
08036d46          data_4000740c = (uint32_t)arg3;
08036d2a  }
08036d7a                                                                                00 00                                        ..
08036d7c  int32_t data_8036d7c = 0x40007400
08036d80  int32_t data_8036d80 = 0x40007408
08036d84  int32_t data_8036d84 = 0x4000740c
08036d88  int32_t data_8036d88 = 0x40007410
08036d8c  int32_t data_8036d8c = 0x40007414
08036d90  int32_t data_8036d90 = 0x40007418
08036d94  int32_t data_8036d94 = 0x4000741c
08036d98    int32_t sub_8036d98(int32_t arg1, int32_t arg2 @ r7)
08036d98  {
08036d9e      switch (arg1)
08036d9e      {
08036d9a          case 0x40000000:
08036d9a          {
08036e26              BN_CODE_start_0x80300a0_size_0x2(0x800);
08036e2e              sub_80300c8(0x800);
08036d9a              break;
08036d9a          }
08036da4          case 0x40000400:
08036da4          {
08036e38              BN_CODE_start_0x80300a0_size_0x2(0x801);
08036e40              sub_80300c8(0x801);
08036da4              break;
08036da4          }
08036dac          case 0x40000800:
08036dac          {
08036e4a              BN_CODE_start_0x80300a0_size_0x2(0x802);
08036e52              sub_80300c8(0x802);
08036dac              break;
08036dac          }
08036db4          case 0x40000c00:
08036db4          {
08036e5c              BN_CODE_start_0x80300a0_size_0x2(0x803);
08036e64              sub_80300c8(0x803);
08036db4              break;
08036db4          }
08036dbc          case 0x40001000:
08036dbc          {
08036e6e              BN_CODE_start_0x80300a0_size_0x2(0x804);
08036e76              sub_80300c8(0x804);
08036dbc              break;
08036dbc          }
08036dc4          case 0x40001400:
08036dc4          {
08036e80              BN_CODE_start_0x80300a0_size_0x2(0x805);
08036e88              sub_80300c8(0x805);
08036dc4              break;
08036dc4          }
08036dcc          case 0x40001800:
08036dcc          {
08036eda              BN_CODE_start_0x80300a0_size_0x2(0x806);
08036ee2              sub_80300c8(0x806);
08036dcc              break;
08036dcc          }
08036dd6          case 0x40001c00:
08036dd6          {
08036eec              BN_CODE_start_0x80300a0_size_0x2(0x807);
08036ef4              sub_80300c8(0x807);
08036dd6              break;
08036dd6          }
08036de0          case 0x40002000:
08036de0          {
08036efe              BN_CODE_start_0x80300a0_size_0x2(0x808);
08036f06              sub_80300c8(0x808);
08036de0              break;
08036de0          }
08036dea          case 0x40010000:
08036dea          {
08036e14              BN_CODE_start_0x80300a0_size_0x2(0x900);
08036e1c              sub_80300c8(0x900);
08036dea              break;
08036dea          }
08036df2          case 0x40010400:
08036df2          {
08036e92              BN_CODE_start_0x80300a0_size_0x2(0x901);
08036e9a              sub_80300c8(0x901);
08036df2              break;
08036df2          }
08036dfa          case 0x40014000:
08036dfa          {
08036ea4              BN_CODE_start_0x80300a0_size_0x2(0x910);
08036eac              sub_80300c8(0x910);
08036dfa              break;
08036dfa          }
08036e02          case 0x40014400:
08036e02          {
08036eb6              BN_CODE_start_0x80300a0_size_0x2(0x911);
08036ebe              sub_80300c8(0x911);
08036e02              break;
08036e02          }
08036e0a          case 0x40014800:
08036e0a          {
08036ec8              BN_CODE_start_0x80300a0_size_0x2(0x912);
08036ed0              sub_80300c8(0x912);
08036e0a              break;
08036e0a          }
08036d9e      }
08036d9e      
08036f0c      return arg2;
08036d98  }
08036f0e    void* sub_8036f0e(int32_t* arg1, int16_t* arg2)
08036f0e  {
08036f14      arg1[0xa] = (uint32_t)*(uint16_t*)arg2;
08036f14      
08036f42      if (arg1 == 0x40010000 || arg1 == 0x40000000 || arg1 == 0x40000400
08036f42          || arg1 == 0x40000800 || arg1 == 0x40000c00 || arg1 == 0x40010400)
08036f42      {
08036f4a          *(uint32_t*)arg1 &= 0xffffff8f;
08036f52          *(uint32_t*)arg1 |= (uint32_t)arg2[1];
08036f5a          *(uint32_t*)arg1 |= (uint32_t)arg2[2];
08036f42      }
08036f42      
08036f62      arg1[0xb] = *(uint32_t*)((char*)arg2 + 8);
08036f62      
08036f72      if (arg1 != 0x40001000 && arg1 != 0x40001400)
08036f72      {
08036f7a          *(uint32_t*)arg1 &= 0xfffffcff;
08036f82          *(uint32_t*)arg1 |= (uint32_t)arg2[6];
08036f72      }
08036f72      
08036f92      if (arg1 == 0x40010000 || arg1 == 0x40010400)
08036f9a          arg1[0xc] = (uint32_t)arg2[7];
08036f9a      
08036fa8      arg1[5] |= 1;
08036faa      return &arg1[5];
08036f0e  }
08036fac    void sub_8036fac(int32_t* arg1)
08036fac  {
08036fb2      *(uint32_t*)arg1 |= 1;
08036fac  }
08036fb6    void sub_8036fb6(int32_t* arg1)
08036fb6  {
08036fbc      *(uint32_t*)arg1 = *(uint32_t*)arg1 >> 1 << 1;
08036fb6  }
08036fc0    void sub_8036fc0(int32_t* arg1)
08036fc0  {
08036fc6      *(uint32_t*)arg1 |= 0x80;
08036fc0  }
08036fca    void* sub_8036fca(void* arg1, int32_t arg2)
08036fca  {
08036fd4      *(uint32_t*)((char*)arg1 + 0xc) |= arg2;
08036fd6      return (char*)arg1 + 0xc;
08036fca  }
08036fd8    void* sub_8036fd8(void* arg1, int32_t arg2)
08036fd8  {
08036fe4      *(uint32_t*)((char*)arg1 + 0xc) &= ~arg2;
08036fe6      return (char*)arg1 + 0xc;
08036fd8  }
08036fe8    int32_t sub_8036fe8(void* arg1, int32_t arg2)
08036fe8  {
08036ffa      if (*(uint32_t*)((char*)arg1 + 0x10) & arg2 && *(uint32_t*)((char*)arg1 + 0xc) & arg2)
08036ffc          return 1;
08036ffc      
08037000      return 0;
08036fe8  }
08037004    void* sub_8037004(void* arg1, int32_t arg2)
08037004  {
08037010      *(uint32_t*)((char*)arg1 + 0x10) &= ~arg2;
08037012      return (char*)arg1 + 0x10;
08037004  }
08037014    void* sub_8037014(void* arg1, char arg2)
08037014  {
08037018      void* result;
08037018      
08037018      if ((uint32_t)arg2 != 1)
08037018      {
08037034          result = (char*)arg1 + 0x44;
08037036          *(uint32_t*)result = *(uint32_t*)((char*)arg1 + 0x44) & 0xffff7fff;
08037018      }
08037018      else
08037018      {
08037024          result = (char*)arg1 + 0x44;
08037026          *(uint32_t*)result = *(uint32_t*)((char*)arg1 + 0x44) | 0x8000;
08037018      }
08037018      
08037038      return result;
08037014  }
0803703a    void sub_803703a(void* arg1, int16_t arg2, int32_t* arg3)
0803703a  {
0803703a      uint32_t r1_141 = (uint32_t)arg2;
0803703a      
0803703e      if (!r1_141)
0803703e      {
0803705e          *(uint32_t*)((char*)arg1 + 0x20) = *(uint32_t*)((char*)arg1 + 0x20) >> 1 << 1;
0803706e          *(uint32_t*)((char*)arg1 + 0x20) |= *(uint32_t*)arg3;
0803707e          *(uint32_t*)((char*)arg1 + 0x20) &= 0xfffffffd;
0803708e          *(uint32_t*)((char*)arg1 + 0x20) |= (uint32_t)*(uint16_t*)((char*)arg3 + 6);
0803708e          
0803709a          if (arg1 == 0x40010000 || arg1 == 0x40010400)
0803709a          {
080370aa              *(uint32_t*)((char*)arg1 + 0x20) &= 0xfffffffb;
080370ba              *(uint32_t*)((char*)arg1 + 0x20) |= (uint32_t)arg3[1];
080370ca              *(uint32_t*)((char*)arg1 + 0x20) &= 0xfffffff7;
080370da              *(uint32_t*)((char*)arg1 + 0x20) |= (uint32_t)arg3[2];
080370e6              *(uint32_t*)((char*)arg1 + 4) &= 0xfffffeff;
080370f2              *(uint32_t*)((char*)arg1 + 4) |= (uint32_t)*(uint16_t*)((char*)arg3 + 0xa);
080370fe              *(uint32_t*)((char*)arg1 + 4) &= 0xfffffdff;
0803710a              *(uint32_t*)((char*)arg1 + 4) |= (uint32_t)arg3[3];
0803709a          }
0803709a          
08037118          *(uint32_t*)((char*)arg1 + 0x18) = *(uint32_t*)((char*)arg1 + 0x18) >> 2 << 2;
0803703e      }
0803703e      else if (r1_141 == 2)
08037042      {
08037202          *(uint32_t*)((char*)arg1 + 0x20) &= 0xfffffeff;
08037214          *(uint32_t*)((char*)arg1 + 0x20) |= *(uint32_t*)arg3 << 8;
08037224          *(uint32_t*)((char*)arg1 + 0x20) &= 0xfffffdff;
08037236          *(uint32_t*)((char*)arg1 + 0x20) |= (uint32_t)*(uint16_t*)((char*)arg3 + 6) << 8;
08037236          
08037242          if (arg1 == 0x40010000 || arg1 == 0x40010400)
08037242          {
08037252              *(uint32_t*)((char*)arg1 + 0x20) &= 0xfffffbff;
08037264              *(uint32_t*)((char*)arg1 + 0x20) |= (uint32_t)arg3[1] << 8;
08037274              *(uint32_t*)((char*)arg1 + 0x20) &= 0xfffff7ff;
08037286              *(uint32_t*)((char*)arg1 + 0x20) |= (uint32_t)arg3[2] << 8;
08037292              *(uint32_t*)((char*)arg1 + 4) &= 0xffffefff;
080372a0              *(uint32_t*)((char*)arg1 + 4) |=
080372a0                  (uint32_t)*(uint16_t*)((char*)arg3 + 0xa) << 4;
080372ac              *(uint32_t*)((char*)arg1 + 4) &= 0xffffdfff;
080372ba              *(uint32_t*)((char*)arg1 + 4) |= (uint32_t)arg3[3] << 4;
08037242          }
08037242          
080372c8          *(uint32_t*)((char*)arg1 + 0x1c) = *(uint32_t*)((char*)arg1 + 0x1c) >> 2 << 2;
08037042      }
08037042      else if (r1_141 < 2)
08037046      {
0803712a          *(uint32_t*)((char*)arg1 + 0x20) &= 0xffffffef;
0803713c          *(uint32_t*)((char*)arg1 + 0x20) |= *(uint32_t*)arg3 << 4;
0803714c          *(uint32_t*)((char*)arg1 + 0x20) &= 0xffffffdf;
0803715e          *(uint32_t*)((char*)arg1 + 0x20) |= (uint32_t)*(uint16_t*)((char*)arg3 + 6) << 4;
0803715e          
0803716a          if (arg1 == 0x40010000 || arg1 == 0x40010400)
0803716a          {
0803717a              *(uint32_t*)((char*)arg1 + 0x20) &= 0xffffffbf;
0803718c              *(uint32_t*)((char*)arg1 + 0x20) |= (uint32_t)arg3[1] << 4;
0803719c              *(uint32_t*)((char*)arg1 + 0x20) &= 0xffffff7f;
080371ae              *(uint32_t*)((char*)arg1 + 0x20) |= (uint32_t)arg3[2] << 4;
080371ba              *(uint32_t*)((char*)arg1 + 4) &= 0xfffffbff;
080371c8              *(uint32_t*)((char*)arg1 + 4) |=
080371c8                  (uint32_t)*(uint16_t*)((char*)arg3 + 0xa) << 2;
080371d4              *(uint32_t*)((char*)arg1 + 4) &= 0xfffff7ff;
080371e2              *(uint32_t*)((char*)arg1 + 4) |= (uint32_t)arg3[3] << 2;
0803716a          }
0803716a          
080371f0          *(uint32_t*)((char*)arg1 + 0x18) &= 0xfffffcff;
08037046      }
08037046      else if (r1_141 == 3)
0803704a      {
080372da          *(uint32_t*)((char*)arg1 + 0x20) &= 0xffffefff;
080372ec          *(uint32_t*)((char*)arg1 + 0x20) |= *(uint32_t*)arg3 << 0xc;
080372fc          *(uint32_t*)((char*)arg1 + 0x20) &= 0xffffdfff;
0803730e          *(uint32_t*)((char*)arg1 + 0x20) |=
0803730e              (uint32_t)*(uint16_t*)((char*)arg3 + 6) << 0xc;
0803730e          
0803731a          if (arg1 == 0x40010000 || arg1 == 0x40010400)
0803731a          {
08037326              *(uint32_t*)((char*)arg1 + 4) &= 0xffffbfff;
08037334              *(uint32_t*)((char*)arg1 + 4) |=
08037334                  (uint32_t)*(uint16_t*)((char*)arg3 + 0xa) << 6;
0803731a          }
0803731a          
08037342          *(uint32_t*)((char*)arg1 + 0x1c) &= 0xfffffcff;
0803704a      }
0803703a  }
08037348                          00 00 00 00                                                                      ....
0803734c  int32_t data_803734c = 0x40000400
08037350  int32_t data_8037350 = 0x40000800
08037354  int32_t data_8037354 = 0x40000c00
08037358  int32_t data_8037358 = 0x40001000
0803735c  int32_t data_803735c = 0x40001400
08037360  int32_t data_8037360 = 0x40001800
08037364  int32_t data_8037364 = 0x40001c00
08037368  int32_t data_8037368 = 0x40002000
0803736c  int32_t data_803736c = 0x40010000
08037370  int32_t data_8037370 = 0x40010400
08037374  int32_t data_8037374 = 0x40014000
08037378  int32_t data_8037378 = 0x40014400
0803737c  int32_t data_803737c = 0x40014800
08037380    void sub_8037380(void* arg1, int16_t arg2, int16_t arg3)
08037380  {
08037380      uint32_t r1_24 = (uint32_t)arg2;
08037380      
08037384      if (!r1_24)
08037384      {
080373a0          *(uint32_t*)((char*)arg1 + 0x18) &= 0xffffff8f;
080373ae          *(uint32_t*)((char*)arg1 + 0x18) |= (uint32_t)arg3;
08037384      }
08037384      else if (r1_24 == 2)
08037388      {
080373e2          *(uint32_t*)((char*)arg1 + 0x1c) &= 0xffffff8f;
080373f0          *(uint32_t*)((char*)arg1 + 0x1c) |= (uint32_t)arg3;
08037388      }
08037388      else if (r1_24 < 2)
0803738a      {
080373c0          *(uint32_t*)((char*)arg1 + 0x18) &= 0xffff8fff;
080373d0          *(uint32_t*)((char*)arg1 + 0x18) |= (uint32_t)arg3 << 8;
0803738a      }
0803738a      else if (r1_24 == 3)
0803738e      {
08037402          *(uint32_t*)((char*)arg1 + 0x1c) &= 0xffff8fff;
08037412          *(uint32_t*)((char*)arg1 + 0x1c) |= (uint32_t)arg3 << 8;
0803738e      }
08037380  }
08037418    void sub_8037418(int32_t* arg1, int16_t arg2, int32_t arg3)
08037418  {
08037418      uint32_t r1 = (uint32_t)arg2;
08037418      
0803741c      if (!r1)
0803742c          arg1[0xd] = arg3;
0803741c      else if (r1 == 2)
08037438          arg1[0xf] = arg3;
08037420      else if (r1 < 2)
08037432          arg1[0xe] = arg3;
08037422      else if (r1 == 3)
0803743e          arg1[0x10] = arg3;
08037418  }
08037444    void sub_8037444(void* arg1, int16_t arg2, int16_t arg3)
08037444  {
08037444      uint32_t r1_24 = (uint32_t)arg2;
08037444      
08037448      if (!r1_24)
08037448      {
08037464          *(uint32_t*)((char*)arg1 + 0x18) &= 0xfffffff7;
08037472          *(uint32_t*)((char*)arg1 + 0x18) |= (uint32_t)arg3;
08037448      }
08037448      else if (r1_24 == 2)
0803744c      {
080374a6          *(uint32_t*)((char*)arg1 + 0x1c) &= 0xfffffff7;
080374b4          *(uint32_t*)((char*)arg1 + 0x1c) |= (uint32_t)arg3;
0803744c      }
0803744c      else if (r1_24 < 2)
0803744e      {
08037484          *(uint32_t*)((char*)arg1 + 0x18) &= 0xfffff7ff;
08037494          *(uint32_t*)((char*)arg1 + 0x18) |= (uint32_t)arg3 << 8;
0803744e      }
0803744e      else if (r1_24 == 3)
08037452      {
080374c6          *(uint32_t*)((char*)arg1 + 0x1c) &= 0xfffff7ff;
080374d6          *(uint32_t*)((char*)arg1 + 0x1c) |= (uint32_t)arg3 << 8;
08037452      }
08037444  }
080374dc    int32_t sub_80374dc(void* arg1, int16_t arg2, int16_t* arg3)
080374dc  {
080374de      uint32_t r1 = (uint32_t)arg2;
080374de      
080374e2      if (!r1)
080374e2      {
08037502          *(uint32_t*)((char*)arg1 + 0x20) = *(uint32_t*)((char*)arg1 + 0x20) >> 1 << 1;
08037512          *(uint32_t*)((char*)arg1 + 0x20) &= 0xfffffff5;
08037522          *(uint32_t*)((char*)arg1 + 0x20) |= (uint32_t)*(uint16_t*)arg3;
08037532          *(uint32_t*)((char*)arg1 + 0x18) = *(uint32_t*)((char*)arg1 + 0x18) >> 2 << 2;
08037542          *(uint32_t*)((char*)arg1 + 0x18) |= (uint32_t)arg3[1];
08037552          *(uint32_t*)((char*)arg1 + 0x18) &= 0xffffff0f;
08037564          *(uint32_t*)((char*)arg1 + 0x18) |= (uint32_t)arg3[3] << 4;
08037574          *(uint32_t*)((char*)arg1 + 0x20) |= 1;
080374e2      }
080374e2      else if (r1 == 2)
080374e6      {
0803760e          *(uint32_t*)((char*)arg1 + 0x20) &= 0xfffffeff;
0803761e          *(uint32_t*)((char*)arg1 + 0x20) &= 0xfffff5ff;
08037630          *(uint32_t*)((char*)arg1 + 0x20) |= (uint32_t)*(uint16_t*)arg3 << 8;
08037640          *(uint32_t*)((char*)arg1 + 0x1c) = *(uint32_t*)((char*)arg1 + 0x1c) >> 2 << 2;
08037650          *(uint32_t*)((char*)arg1 + 0x1c) |= (uint32_t)arg3[1];
08037660          *(uint32_t*)((char*)arg1 + 0x1c) &= 0xffffff0f;
08037672          *(uint32_t*)((char*)arg1 + 0x1c) |= (uint32_t)arg3[3] << 4;
08037682          *(uint32_t*)((char*)arg1 + 0x20) |= 0x100;
080374e6      }
080374e6      else if (r1 < 2)
080374ea      {
08037586          *(uint32_t*)((char*)arg1 + 0x20) &= 0xffffffef;
08037596          *(uint32_t*)((char*)arg1 + 0x20) &= 0xffffff5f;
080375a8          *(uint32_t*)((char*)arg1 + 0x20) |= (uint32_t)*(uint16_t*)arg3 << 4;
080375b8          *(uint32_t*)((char*)arg1 + 0x18) &= 0xfffffcff;
080375ca          *(uint32_t*)((char*)arg1 + 0x18) |= (uint32_t)arg3[1] << 8;
080375da          *(uint32_t*)((char*)arg1 + 0x18) &= 0xffff0fff;
080375ec          *(uint32_t*)((char*)arg1 + 0x18) |= (uint32_t)arg3[3] << 0xc;
080375fc          *(uint32_t*)((char*)arg1 + 0x20) |= 0x10;
080374ea      }
080374ea      else if (r1 == 3)
080374ee      {
08037694          *(uint32_t*)((char*)arg1 + 0x20) &= 0xffffefff;
080376a4          *(uint32_t*)((char*)arg1 + 0x20) &= 0xffffdfff;
080376b6          *(uint32_t*)((char*)arg1 + 0x20) |= (uint32_t)*(uint16_t*)arg3 << 0xc;
080376c6          *(uint32_t*)((char*)arg1 + 0x1c) &= 0xfffffcff;
080376d8          *(uint32_t*)((char*)arg1 + 0x1c) |= (uint32_t)arg3[1] << 8;
080376e8          *(uint32_t*)((char*)arg1 + 0x1c) &= 0xffff0fff;
080376fa          *(uint32_t*)((char*)arg1 + 0x1c) |= (uint32_t)arg3[3] << 0xc;
0803770a          *(uint32_t*)((char*)arg1 + 0x20) |= 0x1000;
080374ee      }
080374ee      
08037716      return sub_8037718(arg1, (int16_t)r1, arg3[2]);
080374dc  }
08037718    void sub_8037718(void* arg1, int16_t arg2, int16_t arg3)
08037718  {
08037718      uint32_t r1_24 = (uint32_t)arg2;
08037718      
0803771c      if (!r1_24)
0803771c      {
08037738          *(uint32_t*)((char*)arg1 + 0x18) &= 0xfffffff3;
08037746          *(uint32_t*)((char*)arg1 + 0x18) |= (uint32_t)arg3;
0803771c      }
0803771c      else if (r1_24 == 2)
08037720      {
0803777a          *(uint32_t*)((char*)arg1 + 0x1c) &= 0xfffffff3;
08037788          *(uint32_t*)((char*)arg1 + 0x1c) |= (uint32_t)arg3;
08037720      }
08037720      else if (r1_24 < 2)
08037722      {
08037758          *(uint32_t*)((char*)arg1 + 0x18) &= 0xfffff3ff;
08037768          *(uint32_t*)((char*)arg1 + 0x18) |= (uint32_t)arg3 << 8;
08037722      }
08037722      else if (r1_24 == 3)
08037726      {
0803779a          *(uint32_t*)((char*)arg1 + 0x1c) &= 0xfffff3ff;
080377aa          *(uint32_t*)((char*)arg1 + 0x1c) |= (uint32_t)arg3 << 8;
08037726      }
08037718  }
080377b0    int32_t sub_80377b0(void* arg1, int16_t arg2)
080377b0  {
080377b2      uint32_t r1 = (uint32_t)arg2;
080377b2      
080377b6      if (!r1)
080377c6          return *(uint32_t*)((char*)arg1 + 0x34);
080377c6      
080377ba      if (r1 == 2)
080377d2          return *(uint32_t*)((char*)arg1 + 0x3c);
080377d2      
080377bc      if (r1 < 2)
080377cc          return *(uint32_t*)((char*)arg1 + 0x38);
080377cc      
080377c0      if (r1 == 3)
080377d8          return *(uint32_t*)((char*)arg1 + 0x40);
080377d8      
080377de      return 0;
080377b0  }
080377e0    void sub_80377e0() __noreturn
080377e0  {
080377e2      /* tailcall */
080377e2      return sub_8037848();
080377e0  }
080377e6                    00 00                                                                                ..
080377e8    int32_t sub_80377e8()
080377e8  {
080377ec      if (data_2000e410)
080377f0          return 0;
080377f0      
080377f8      data_2000e410 = &data_20002df0;
08037802      data_20002df0 = 0x2000;
08037804      return &data_20002df0;
080377e8  }
08037806                    00 bf                                                                                ..
08037808  int32_t data_8037808 = 0x2000e410
0803780c  int32_t data_803780c = 0x20002df7
08037810  int32_t data_8037810 = 0x20004df0
08037814    int32_t sub_8037814() __pure
08037814  {
08037814      return;
08037814  }
08037816    void sub_8037816(char* arg1, char* arg2)
08037816  {
0803781a      uint32_t r5 = (uint32_t)*(uint8_t*)arg2;
0803781a      
0803781e      if (!r5)
08037820          return;
08037820      
08037830      while (true)
08037830      {
08037830          char* r0 = sub_803698c(arg1, (uint8_t)r5);
08037830          
08037834          if (!r0)
08037834              break;
08037834          
08037836          char* r1_1 = r0;
08037838          char* r2_1 = arg2;
08037838          
0803782a          do
0803782a          {
0803783a              r2_1 = &r2_1[1];
0803783a              
08037840              if (!(uint32_t)*(uint8_t*)r2_1)
08037842                  return;
08037842              
08037822              r1_1 = &r1_1[1];
0803782a          } while ((uint32_t)*(uint8_t*)r1_1 == (uint32_t)*(uint8_t*)r2_1);
0803782a          
0803782c          arg1 = &r0[1];
08037830      }
08037816  }
08037844    int32_t sub_8037844() __pure
08037844  {
08037844      return;
08037844  }
08037846                    00 00                                                                                ..
08037848    void sub_8037848() __noreturn
08037848  {
08037854      breakpoint();
08037848  }
08037858  int32_t data_8037858 = 0x20026
0803785c    int32_t sub_803785c(void* arg1)
0803785c  {
08037860      int32_t result = 0;
08037860      
0803786c      if (*(uint32_t*)0x50000014 << 0x1f < 0)
0803786c      {
0803787a          int32_t r6_1 = *(uint32_t*)0x50000018 & *(uint32_t*)0x50000014;
0803787a          
08037880          if (!r6_1)
08037882              return 0;
08037882          
08037888          if (r6_1 << 0x1c < 0)
08037890              result = sub_80378ea();
08037890          
08037894          if (r6_1 << 0x1b < 0)
0803789c              result |= sub_80381a6(arg1);
0803789c          
080378a0          if (r6_1 << 0x1a < 0)
080378a8              result |= sub_8037978(arg1);
080378a8          
080378ac          if (r6_1 << 5 < 0)
080378b4              result |= sub_8037a04(arg1);
080378b4          
080378b8          if (r6_1 << 6 < 0)
080378c0              result |= sub_8037902(arg1);
080378c0          
080378c4          if (r6_1 << 7 < 0)
080378cc              result |= sub_8037a90(arg1);
080378cc          
080378d0          if (r6_1 << 2 < 0)
080378d8              result |= sub_803795e();
080378d8          
080378dc          if (r6_1 << 0xa < 0)
080378dc          {
080378e0              sub_8038266();
080378e4              return result | 1;
080378dc          }
0803786c      }
0803786c      
080378e6      return result;
0803785c  }
080378ea    int32_t sub_80378ea()
080378ea  {
080378ea      int32_t r7;
080378ea      int32_t var_8 = r7;
080378f4      (**(uint32_t**)&data_200005c8)();
080378fc      *(uint32_t*)0x50000014 = 8;
08037900      return 1;
080378ea  }
08037902    int32_t sub_8037902(void* arg1)
08037902  {
08037908      int32_t result = 0;
0803790a      uint32_t r6 = 0;
0803790a      
08037924      while ((uint32_t)(uint8_t)r6 < (uint32_t)*(uint8_t*)((char*)arg1 + 3))
08037924      {
08037934          if ((*(uint32_t*)0x50000414 & 1 << r6) << 0x14)
08037934          {
08037936              r6 = (uint32_t)(uint8_t)r6;
08037936              
0803794a              if (!(*(uint32_t*)((r6 << 5) + 0x50000500) >> 0xf & 1))
08037918                  result |= sub_8037b90(arg1, (uint8_t)r6);
0803794a              else
08037956                  result |= sub_8037e92(arg1, (uint8_t)r6);
08037934          }
08037934          
0803791a          r6 += 1;
08037924      }
08037924      
0803795c      return result;
08037902  }
0803795e    int32_t sub_803795e()
0803795e  {
0803795e      int32_t r7;
0803795e      int32_t var_8 = r7;
08037968      (*(uint32_t*)(data_200005c8 + 8))();
08037972      *(uint32_t*)0x50000014 = &turnTable;
08037976      return 1;
0803795e  }
08037978    int32_t sub_8037978(void* arg1)
08037978  {
08037978      int32_t r3;
08037978      int32_t var_18 = r3;
0803798c      uint32_t r4_1 = (uint32_t)(uint8_t)(*(uint32_t*)0x5000002c >> 0x1b) & 0xf;
080379a2      uint32_t i = (*(uint32_t*)((char*)arg1 + 0x24 * r4_1 + 0x220) + 3) >> 2;
080379a2      
080379f8      while (i < (uint32_t)(uint16_t)*(uint32_t*)0x5000002c)
080379f8      {
080379fe          if (!*(uint32_t*)((char*)arg1 + 0x24 * r4_1 + 0x220))
080379fe              break;
080379fe          
080379ae          uint32_t r6_1 = (uint32_t)(uint16_t)*(uint32_t*)0x5000002c << 2;
080379ae          
080379b4          if (*(uint32_t*)((char*)arg1 + 0x24 * r4_1 + 0x220) < r6_1)
080379b4          {
080379b6              r6_1 = (uint32_t)*(uint16_t*)((char*)arg1 + 0x24 * r4_1 + 0x220);
080379c6              *(uint32_t*)0x50000018 &= 0xffffffdf;
080379b4          }
080379b4          
080379cc          i = (*(uint32_t*)((char*)arg1 + 0x24 * r4_1 + 0x220) + 3) >> 2;
080379d8          sub_802351c(*(uint32_t*)((char*)arg1 + 0x24 * r4_1 + 0x21c), (uint8_t)r4_1, 
080379d8              (uint16_t)r6_1);
080379e0          *(uint32_t*)((char*)arg1 + 0x24 * r4_1 + 0x21c) += r6_1;
080379e6          *(uint32_t*)((char*)arg1 + 0x24 * r4_1 + 0x220) -= r6_1;
080379ec          *(uint32_t*)((char*)arg1 + 0x24 * r4_1 + 0x224) += r6_1;
080379f8      }
080379f8      
08037a02      return 1;
08037978  }
08037a04    int32_t sub_8037a04(void* arg1)
08037a04  {
08037a04      int32_t r3;
08037a04      int32_t var_18 = r3;
08037a18      uint32_t r4_1 = (uint32_t)(uint8_t)(*(uint32_t*)0x50000410 >> 0x1b) & 0xf;
08037a2e      uint32_t i = (*(uint32_t*)((char*)arg1 + 0x24 * r4_1 + 0x220) + 3) >> 2;
08037a2e      
08037a84      while (i < (uint32_t)(uint16_t)*(uint32_t*)0x50000410)
08037a84      {
08037a8a          if (!*(uint32_t*)((char*)arg1 + 0x24 * r4_1 + 0x220))
08037a8a              break;
08037a8a          
08037a3a          uint32_t r6_1 = (uint32_t)(uint16_t)*(uint32_t*)0x50000410 << 2;
08037a3a          
08037a40          if (*(uint32_t*)((char*)arg1 + 0x24 * r4_1 + 0x220) < r6_1)
08037a40          {
08037a42              r6_1 = *(uint32_t*)((char*)arg1 + 0x24 * r4_1 + 0x220);
08037a52              *(uint32_t*)0x50000018 &= 0xfbffffff;
08037a40          }
08037a40          
08037a58          i = (*(uint32_t*)((char*)arg1 + 0x24 * r4_1 + 0x220) + 3) >> 2;
08037a64          sub_802351c(*(uint32_t*)((char*)arg1 + 0x24 * r4_1 + 0x21c), (uint8_t)r4_1, 
08037a64              (uint16_t)r6_1);
08037a6c          *(uint32_t*)((char*)arg1 + 0x24 * r4_1 + 0x21c) += r6_1;
08037a72          *(uint32_t*)((char*)arg1 + 0x24 * r4_1 + 0x220) -= r6_1;
08037a78          *(uint32_t*)((char*)arg1 + 0x24 * r4_1 + 0x224) += r6_1;
08037a84      }
08037a84      
08037a8e      return 1;
08037a04  }
08037a90    int32_t sub_8037a90(void* arg1)
08037a90  {
08037a98      char r5 = 0;
08037a9a      int32_t result = 0;
08037aba      int32_t var_18_3 = *(uint32_t*)0x50000440 & 0xfffffff1;
08037aba      
08037ac4      if (*(uint32_t*)0x50000440 << 0x1e < 0)
08037ac4      {
08037acc          var_18_3 |= 2;
08037ad8          (*(uint32_t*)(data_200005c8 + 4))(arg1);
08037ada          result = 1;
08037ac4      }
08037ac4      
08037ae6      if (*(uint32_t*)0x50000440 << 0x1c < 0)
08037ae6      {
08037aee          var_18_3 |= 8;
08037aee          
08037af8          if (*(uint32_t*)0x50000440 << 0x1d < 0)
08037af8          {
08037b06              uint32_t r0_21 = (uint32_t)(uint8_t)(*(uint32_t*)0x50000440 >> 0x11) & 3;
08037b06              
08037b0a              if (r0_21 == 2)
08037b0a              {
08037b14                  *(uint32_t*)0x50000404 = 0x1770;
08037b14                  
08037b22                  if ((*(uint32_t*)0x50000400 & 3) != 2)
08037b22                  {
08037b28                      if ((uint32_t)*(uint8_t*)((char*)arg1 + 2) == 2)
08037b38                          *(uint32_t*)0x50000400 = *(uint32_t*)0x50000400 >> 1 << 1;
08037b38                      
08037b3a                      r5 = 1;
08037b22                  }
08037b0a              }
08037b0a              else if ((uint32_t)(uint8_t)r0_21 != 1)
08037b76                  r5 = 1;
08037b42              else
08037b42              {
08037b4c                  *(uint32_t*)0x50000404 = 0xbb80;
08037b4c                  
08037b5a                  if ((*(uint32_t*)0x50000400 & 3) != 1)
08037b5a                  {
08037b60                      if ((uint32_t)*(uint8_t*)((char*)arg1 + 2) == 2)
08037b70                          *(uint32_t*)0x50000400 &= 0xfffffffd;
08037b70                      
08037b72                      r5 = 1;
08037b5a                  }
08037b42              }
08037af8          }
08037ae6      }
08037ae6      
08037b7c      if ((uint32_t)r5)
08037b80          sub_8023914(arg1);
08037b80      
08037b8a      *(uint32_t*)0x50000440 = var_18_3;
08037b8e      return result;
08037a90  }
08037b90    int32_t sub_8037b90(int32_t arg1, char arg2)
08037b90  {
08037b90      int32_t r3;
08037b90      int32_t var_10 = r3;
08037b94      uint32_t r4_1 = (uint32_t)arg2;
08037ba0      uint32_t r4_2 = (uint32_t)(uint8_t)r4_1;
08037bb2      uint32_t r4_3 = (uint32_t)(uint8_t)r4_2;
08037bbe      int32_t r1_2 =
08037bbe          *(uint32_t*)(0x50000508 + (r4_1 << 5)) & *(uint32_t*)(0x5000050c + (r4_3 << 5));
08037bbe      
08037bc2      if (r1_2 << 0x1a < 0)
08037bc2      {
08037bca          if ((uint32_t)*(uint8_t*)(0x24 * r4_2 + arg1 + 0x231) == 5)
08037bca          {
08037bce              *(uint32_t*)(0x24 * r4_2 + arg1 + 0x228) = 0;
08037bd0              uint32_t r4_4 = (uint32_t)(uint8_t)r4_3;
08037be0              uint32_t r4_5 = (uint32_t)(uint8_t)r4_4;
08037bea              *(uint32_t*)(0x5000050c + (r4_5 << 5)) =
08037bea                  *(uint32_t*)(0x5000050c + (r4_4 << 5)) | 2;
08037bf0              sub_8023c18(arg1, (uint8_t)r4_5);
08037bf6              r4_3 = (uint32_t)(uint8_t)r4_5;
08037c00              *(uint32_t*)(0x50000508 + (r4_3 << 5)) = 1;
08037c04              *(uint8_t*)(0x24 * r4_2 + arg1 + 0x230) = 1;
08037bca          }
08037bca          
08037c14          *(uint32_t*)(0x50000508 + ((uint32_t)(uint8_t)r4_3 << 5)) = 0x20;
08037bc2      }
08037bc2      else if (r1_2 << 0x16 < 0)
08037c1a      {
08037c1c          uint32_t r4_7 = (uint32_t)(uint8_t)r4_3;
08037c2c          uint32_t r4_8 = (uint32_t)(uint8_t)r4_7;
08037c36          *(uint32_t*)(0x5000050c + (r4_8 << 5)) =
08037c36              *(uint32_t*)(0x5000050c + (r4_7 << 5)) | 2;
08037c3c          sub_8023c18(arg1, (uint8_t)r4_8);
08037c4e          *(uint32_t*)(0x50000508 + ((uint32_t)(uint8_t)r4_8 << 5)) = 0x200;
08037c1a      }
08037c1a      else if (r1_2 << 0x1f < 0)
08037c54      {
08037c58          *(uint32_t*)(0x24 * r4_2 + arg1 + 0x228) = 0;
08037c5a          uint32_t r4_10 = (uint32_t)(uint8_t)r4_3;
08037c6a          uint32_t r4_11 = (uint32_t)(uint8_t)r4_10;
08037c74          *(uint32_t*)(0x5000050c + (r4_11 << 5)) =
08037c74              *(uint32_t*)(0x5000050c + (r4_10 << 5)) | 2;
08037c7a          sub_8023c18(arg1, (uint8_t)r4_11);
08037c8a          *(uint32_t*)(0x50000508 + ((uint32_t)(uint8_t)r4_11 << 5)) = 1;
08037c8e          *(uint8_t*)(0x24 * r4_2 + arg1 + 0x230) = 1;
08037c54      }
08037c54      else if (r1_2 << 0x1c < 0)
08037c96      {
08037c98          uint32_t r4_13 = (uint32_t)(uint8_t)r4_3;
08037ca8          uint32_t r4_14 = (uint32_t)(uint8_t)r4_13;
08037cb2          *(uint32_t*)(0x5000050c + (r4_14 << 5)) =
08037cb2              *(uint32_t*)(0x5000050c + (r4_13 << 5)) | 2;
08037cb6          uint32_t r4_15 = (uint32_t)(uint8_t)r4_14;
08037cc0          *(uint32_t*)(0x50000508 + (r4_15 << 5)) = 8;
08037cc6          sub_8023c18(arg1, (uint8_t)r4_15);
08037ccc          *(uint8_t*)(0x24 * r4_2 + arg1 + 0x230) = 5;
08037c96      }
08037c96      else if (r1_2 << 0x1b < 0)
08037cd4      {
08037cd8          *(uint32_t*)(0x24 * r4_2 + arg1 + 0x228) = 0;
08037cda          uint32_t r4_16 = (uint32_t)(uint8_t)r4_3;
08037cea          uint32_t r4_17 = (uint32_t)(uint8_t)r4_16;
08037cf4          *(uint32_t*)(0x5000050c + (r4_17 << 5)) =
08037cf4              *(uint32_t*)(0x5000050c + (r4_16 << 5)) | 2;
08037cfa          sub_8023c18(arg1, (uint8_t)r4_17);
08037d0a          *(uint32_t*)(0x50000508 + ((uint32_t)(uint8_t)r4_17 << 5)) = 0x10;
08037d0e          *(uint8_t*)(0x24 * r4_2 + arg1 + 0x230) = 3;
08037cd4      }
08037cd4      else if (r1_2 << 0x18 < 0)
08037d16      {
08037d18          uint32_t r4_19 = (uint32_t)(uint8_t)r4_3;
08037d28          uint32_t r4_20 = (uint32_t)(uint8_t)r4_19;
08037d32          *(uint32_t*)(0x5000050c + (r4_20 << 5)) =
08037d32              *(uint32_t*)(0x5000050c + (r4_19 << 5)) | 2;
08037d38          sub_8023c18(arg1, (uint8_t)r4_20);
08037d40          *(uint32_t*)(0x24 * r4_2 + arg1 + 0x228) += 1;
08037d44          *(uint8_t*)(0x24 * r4_2 + arg1 + 0x230) = 6;
08037d54          *(uint32_t*)(0x50000508 + ((uint32_t)(uint8_t)r4_20 << 5)) = 0x80;
08037d16      }
08037d16      else if (r1_2 << 0x19 < 0)
08037d5a      {
08037d5e          *(uint32_t*)(0x24 * r4_2 + arg1 + 0x228) = 0;
08037d60          uint32_t r4_22 = (uint32_t)(uint8_t)r4_3;
08037d70          uint32_t r4_23 = (uint32_t)(uint8_t)r4_22;
08037d7a          *(uint32_t*)(0x5000050c + (r4_23 << 5)) =
08037d7a              *(uint32_t*)(0x5000050c + (r4_22 << 5)) | 2;
08037d7e          *(uint8_t*)(0x24 * r4_2 + arg1 + 0x230) = 4;
08037d8e          *(uint32_t*)(0x50000508 + ((uint32_t)(uint8_t)r4_23 << 5)) = 0x40;
08037d5a      }
08037d5a      else if (r1_2 << 0x15 < 0)
08037d94      {
08037d96          uint32_t r4_25 = (uint32_t)(uint8_t)r4_3;
08037da6          uint32_t r4_26 = (uint32_t)(uint8_t)r4_25;
08037db0          *(uint32_t*)(0x5000050c + (r4_26 << 5)) =
08037db0              *(uint32_t*)(0x5000050c + (r4_25 << 5)) | 2;
08037db6          sub_8023c18(arg1, (uint8_t)r4_26);
08037dbc          *(uint8_t*)(0x24 * r4_2 + arg1 + 0x230) = 8;
08037dce          *(uint32_t*)(0x50000508 + ((uint32_t)(uint8_t)r4_26 << 5)) = 0x400;
08037d94      }
08037d94      else if (r1_2 << 0x1e < 0)
08037dd4      {
08037dd6          uint32_t r4_28 = (uint32_t)(uint8_t)r4_3;
08037de6          uint32_t r4_29 = (uint32_t)(uint8_t)r4_28;
08037df0          *(uint32_t*)(0x5000050c + (r4_29 << 5)) =
08037df0              *(uint32_t*)(0x5000050c + (r4_28 << 5)) & 0xfffffffd;
08037df2          uint32_t r1_52 = (uint32_t)*(uint8_t*)(0x24 * r4_2 + arg1 + 0x230);
08037df2          
08037df8          if (r1_52 == 1)
08037df8          {
08037e0e              *(uint8_t*)(0x24 * r4_2 + arg1 + 0x231) = 1;
08037e12              r4_29 = (uint32_t)(uint8_t)r4_29;
08037e12              
08037e26              if ((*(uint32_t*)((r4_29 << 5) + 0x50000500) >> 0x12 & 3) == 2)
08037e30                  *(uint8_t*)(0x24 * r4_2 + arg1 + 0x233) ^= 1;
08037df8          }
08037df8          else if (r1_52 == 3)
08037dfc          {
08037e3c              if ((uint32_t)*(uint8_t*)(0x24 * r4_2 + arg1 + 0x231) != 5)
08037e4a                  *(uint8_t*)(0x24 * r4_2 + arg1 + 0x231) = 2;
08037e3c              else
08037e42                  sub_8023c80(arg1, (uint8_t)r4_29);
08037dfc          }
08037dfc          else if (r1_52 == 4)
08037e00          {
08037e54              if ((uint32_t)*(uint8_t*)(0x24 * r4_2 + arg1 + 0x21a) == 1)
08037e54              {
08037e5a                  sub_8023c80(arg1, (uint8_t)r4_29);
08037e60                  *(uint8_t*)(0x24 * r4_2 + arg1 + 0x231) = 5;
08037e54              }
08037e00          }
08037e00          else if (r1_52 == 5)
08037e68              *(uint8_t*)(0x24 * r4_2 + arg1 + 0x231) = 4;
08037e04          else if (r1_52 == 6 && *(uint32_t*)(0x24 * r4_2 + arg1 + 0x228) == 3)
08037e72          {
08037e76              *(uint8_t*)(0x24 * r4_2 + arg1 + 0x231) = 3;
08037e7c              *(uint32_t*)(0x24 * r4_2 + arg1 + 0x228) = 0;
08037e72          }
08037e72          
08037e8c          *(uint32_t*)(0x50000508 + ((uint32_t)(uint8_t)r4_29 << 5)) = 2;
08037dd4      }
08037dd4      
08037e90      return 1;
08037b90  }
08037e92    int32_t sub_8037e92(void* arg1, char arg2)
08037e92  {
08037ea0      uint32_t r4_1 = (uint32_t)arg2;
08037eb2      uint32_t r4_2 = (uint32_t)(uint8_t)r4_1;
08037ebe      uint32_t r4_3 = (uint32_t)(uint8_t)r4_2;
08037ecc      int32_t var_20 = *(uint32_t*)((r4_3 << 5) + 0x50000500);
08037ece      uint32_t r4_4 = (uint32_t)(uint8_t)r4_3;
08037eda      int32_t r7_1 =
08037eda          *(uint32_t*)(0x50000508 + (r4_2 << 5)) & *(uint32_t*)(0x5000050c + (r4_4 << 5));
08037ee0      char r8 = (char)(var_20 >> 0x12) & 3;
08037ee0      
08037ee6      if (r7_1 << 0x1a < 0)
08037ee6      {
08037eea          r4_4 = (uint32_t)(uint8_t)r4_4;
08037ef4          *(uint32_t*)(0x50000508 + (r4_4 << 5)) = 0x20;
08037ee6      }
08037ee6      else if (r7_1 << 0x1c < 0)
08037efa      {
08037efc          uint32_t r4_5 = (uint32_t)(uint8_t)r4_4;
08037f0c          uint32_t r4_6 = (uint32_t)(uint8_t)r4_5;
08037f16          *(uint32_t*)(0x5000050c + (r4_6 << 5)) =
08037f16              *(uint32_t*)(0x5000050c + (r4_5 << 5)) | 2;
08037f1a          *(uint8_t*)(0x24 * r4_1 + arg1 + 0x230) = 5;
08037f20          uint32_t r4_7 = (uint32_t)(uint8_t)r4_6;
08037f2a          *(uint32_t*)(0x50000508 + (r4_7 << 5)) = 0x10;
08037f2e          r4_4 = (uint32_t)(uint8_t)r4_7;
08037f38          *(uint32_t*)(0x50000508 + (r4_4 << 5)) = 8;
08037f3a          r7_1 &= 0xffffffef;
08037f44          sub_8023c18(arg1, (uint8_t)r4_4);
08037efa      }
08037efa      else if (r7_1 << 0x15 < 0)
08037f4c      {
08037f4e          uint32_t r4_8 = (uint32_t)(uint8_t)r4_4;
08037f5c          uint32_t r4_9 = (uint32_t)(uint8_t)r4_8;
08037f64          *(uint32_t*)(0x5000050c + (r4_9 << 5)) =
08037f64              *(uint32_t*)(0x5000050c + (r4_8 << 5)) | 2;
08037f6c          sub_8023c18(arg1, (uint8_t)r4_9);
08037f72          uint32_t r4_10 = (uint32_t)(uint8_t)r4_9;
08037f7a          *(uint32_t*)(0x50000508 + (r4_10 << 5)) = 0x10;
08037f7e          *(uint8_t*)(0x24 * r4_1 + arg1 + 0x230) = 8;
08037f86          r4_4 = (uint32_t)(uint8_t)r4_10;
08037f8e          *(uint32_t*)(0x50000508 + (r4_4 << 5)) = 0x400;
08037f4c      }
08037f4c      
08037f92      if (r7_1 << 0x16 < 0)
08037f92      {
08037f94          uint32_t r4_11 = (uint32_t)(uint8_t)r4_4;
08037fa2          uint32_t r4_12 = (uint32_t)(uint8_t)r4_11;
08037faa          *(uint32_t*)(0x5000050c + (r4_12 << 5)) =
08037faa              *(uint32_t*)(0x5000050c + (r4_11 << 5)) | 2;
08037fb2          sub_8023c18(arg1, (uint8_t)r4_12);
08037fc2          *(uint32_t*)(0x50000508 + ((uint32_t)(uint8_t)r4_12 << 5)) = 0x200;
08037f92      }
08037f92      else if (r7_1 << 0x1f < 0)
08037fc8      {
08037fce          if ((uint32_t)*(uint8_t*)((char*)arg1 + 5) == 1)
08037fce          {
08037fd0              r4_4 = (uint32_t)(uint8_t)r4_4;
08037fe2              *(uint32_t*)(0x24 * r4_1 + arg1 + 0x224) =
08037fe2                  *(uint32_t*)(0x24 * r4_1 + arg1 + 0x220)
08037fe2                  - (*(uint32_t*)(0x50000510 + (r4_4 << 5)) << 0xd >> 0xd);
08037fce          }
08037fce          
08037fe6          *(uint8_t*)(0x24 * r4_1 + arg1 + 0x230) = 1;
08037fec          *(uint32_t*)(0x24 * r4_1 + arg1 + 0x228) = 0;
08037ff0          uint32_t r4_14 = (uint32_t)(uint8_t)r4_4;
08037ff8          *(uint32_t*)(0x50000508 + (r4_14 << 5)) = 1;
08037ffa          uint32_t r8_1 = (uint32_t)r8;
08038002          uint32_t r8_2;
08038002          
08038002          if (r8_1)
08038004              r8_2 = (uint32_t)(uint8_t)r8_1;
08038004          
0803800c          if (!r8_1 || r8_2 == 2)
0803800c          {
0803800e              uint32_t r4_15 = (uint32_t)(uint8_t)r4_14;
0803801c              uint32_t r4_16 = (uint32_t)(uint8_t)r4_15;
08038024              *(uint32_t*)(0x5000050c + (r4_16 << 5)) =
08038024                  *(uint32_t*)(0x5000050c + (r4_15 << 5)) | 2;
0803802c              sub_8023c18(arg1, (uint8_t)r4_16);
0803803a              *(uint32_t*)(0x50000508 + ((uint32_t)(uint8_t)r4_16 << 5)) = 0x10;
08038044              *(uint8_t*)(0x24 * r4_1 + arg1 + 0x232) ^= 1;
0803800c          }
0803800c          else if ((uint32_t)(uint8_t)r8_2 == 3)
08038052          {
0803806c              *(uint32_t*)(((uint32_t)(uint8_t)r4_14 << 5) + 0x50000500) =
0803806c                  var_20 | &turnTable;
08038070              *(uint8_t*)(0x24 * r4_1 + arg1 + 0x231) = 1;
08038052          }
08037fc8      }
08037fc8      else if (r7_1 << 0x1e < 0)
08038078      {
0803807a          uint32_t r4_19 = (uint32_t)(uint8_t)r4_4;
08038088          uint32_t r4_20 = (uint32_t)(uint8_t)r4_19;
08038090          *(uint32_t*)(0x5000050c + (r4_20 << 5)) =
08038090              *(uint32_t*)(0x5000050c + (r4_19 << 5)) & 0xfffffffd;
08038092          uint32_t r0_47 = (uint32_t)*(uint8_t*)(0x24 * r4_1 + arg1 + 0x230);
08038092          
08038098          if (r0_47 == 1)
080380aa              *(uint8_t*)(0x24 * r4_1 + arg1 + 0x231) = 1;
08038098          else if (r0_47 == 5)
080380be              *(uint8_t*)(0x24 * r4_1 + arg1 + 0x231) = 4;
0803809c          else if (r0_47 == 6 || r0_47 == 8)
080380a4          {
080380b2              *(uint32_t*)(0x24 * r4_1 + arg1 + 0x228) = 0;
080380b6              *(uint8_t*)(0x24 * r4_1 + arg1 + 0x231) = 3;
080380a4          }
080380a4          else if ((uint32_t)r8 == 3)
080380d6              *(uint8_t*)(0x24 * r4_1 + arg1 + 0x232) ^= 1;
080380d6          
080380e4          *(uint32_t*)(0x50000508 + ((uint32_t)(uint8_t)r4_20 << 5)) = 2;
08038078      }
08038078      else if (r7_1 << 0x18 < 0)
080380ea      {
080380ec          uint32_t r4_22 = (uint32_t)(uint8_t)r4_4;
080380fa          uint32_t r4_23 = (uint32_t)(uint8_t)r4_22;
08038102          *(uint32_t*)(0x5000050c + (r4_23 << 5)) =
08038102              *(uint32_t*)(0x5000050c + (r4_22 << 5)) | 2;
08038108          *(uint32_t*)(0x24 * r4_1 + arg1 + 0x228) += 1;
0803810c          *(uint8_t*)(0x24 * r4_1 + arg1 + 0x230) = 6;
08038116          sub_8023c18(arg1, (uint8_t)r4_23);
08038124          *(uint32_t*)(0x50000508 + ((uint32_t)(uint8_t)r4_23 << 5)) = 0x80;
080380ea      }
080380ea      else if (r7_1 << 0x1b < 0)
0803812a      {
0803812c          uint32_t r8_5 = (uint32_t)r8;
0803812c          
08038134          if (r8_5 != 3)
08038134          {
0803815a              uint32_t r8_6 = (uint32_t)(uint8_t)r8_5;
0803815a              
0803816c              if (!r8_6 || (uint32_t)(uint8_t)r8_6 == 2)
0803816c              {
08038180                  r4_4 = (uint32_t)(uint8_t)r4_4;
0803818c                  *(uint32_t*)((r4_4 << 5) + 0x50000500) =
0803818c                      (var_20 | 0x80000000) & 0xbfffffff;
0803816c              }
08038134          }
08038134          else
08038134          {
08038136              uint32_t r4_25 = (uint32_t)(uint8_t)r4_4;
08038144              r4_4 = (uint32_t)(uint8_t)r4_25;
0803814c              *(uint32_t*)(0x5000050c + (r4_4 << 5)) =
0803814c                  *(uint32_t*)(0x5000050c + (r4_25 << 5)) | 2;
08038154              sub_8023c18(arg1, (uint8_t)r4_4);
08038134          }
08038134          
08038190          *(uint8_t*)(0x24 * r4_1 + arg1 + 0x230) = 3;
0803819e          *(uint32_t*)(0x50000508 + ((uint32_t)(uint8_t)r4_4 << 5)) = 0x10;
0803812a      }
0803812a      
080381a2      return 1;
08037e92  }
080381a6    int32_t sub_80381a6(void* arg1)
080381a6  {
080381ae      char var_18 = 0;
080381b4      int32_t var_14 = 0;
080381c2      *(uint32_t*)0x50000018 &= 0xffffffef;
080381c6      int32_t r1_2 = *(uint32_t*)0x50000020;
080381cc      char r1_4 = (uint8_t)r1_2 & 0xf;
080381cc      
080381ee      if ((r1_2 >> 0x11 & 0xf) == 2)
080381ee      {
080381f2          int32_t r5_1 = r1_2 >> 4 & 0x7ff;
080381f2          
080381fe          if (r5_1 && *(uint32_t*)((char*)arg1 + 0x24 * (uint32_t)r1_4 + 0x21c))
080381fe          {
08038206              sub_802354a(*(uint32_t*)((char*)arg1 + 0x24 * (uint32_t)r1_4 + 0x21c), 
08038206                  (uint16_t)r5_1);
0803820e              *(uint32_t*)((char*)arg1 + 0x24 * (uint32_t)r1_4 + 0x21c) += r5_1;
08038214              *(uint32_t*)((char*)arg1 + 0x24 * (uint32_t)r1_4 + 0x224) += r5_1;
08038214              
08038228              if (*(uint32_t*)(0x50000510 + ((uint32_t)r1_4 << 5)) & 0x1ff80000)
08038252                  *(uint32_t*)(((uint32_t)r1_4 << 5) + 0x50000500) = (
08038252                      *(uint32_t*)(((uint32_t)r1_4 << 5) + 0x50000500) | 0x80000000)
08038252                      & 0xbfffffff;
080381fe          }
080381ee      }
080381ee      
08038260      *(uint32_t*)0x50000018 |= 0x10;
08038264      return 1;
080381a6  }
08038266    int32_t sub_8038266()
08038266  {
0803826a      int32_t var_4 = 0;
08038270      int32_t var_4_1 = *(uint32_t*)0x50000500;
08038276      *(uint32_t*)0x50000500 = 0;
08038288      *(uint32_t*)0x50000014 = 0x200000;
0803828e      return 1;
08038266  }
08038290  int32_t data_8038290 = 0x50000014
08038294  int32_t data_8038294 = 0x50000018
08038298  int32_t data_8038298 = 0x200005c8
0803829c  int32_t data_803829c = 0x50000414
080382a0  int32_t data_80382a0 = 0x5000002c
080382a4  int32_t data_80382a4 = 0x50000410
080382a8  int32_t data_80382a8 = 0x50000440
080382ac  int32_t data_80382ac = 0x50000404
080382b0  int32_t data_80382b0 = 0x50000400
080382b4  int32_t data_80382b4 = 0x50000508
080382b8  int32_t data_80382b8 = 0x5000050c
080382bc  int32_t data_80382bc = 0x50000510
080382c0  int32_t data_80382c0 = 0x50000020
080382c4  int32_t data_80382c4 = 0x1ff80000
080382c8  int32_t data_80382c8 = 0x50000500
080382cc    int32_t sub_80382cc(char* arg1)
080382cc  {
080382ce      *(uint8_t*)arg1 = 5;
080382d2      return 1;
080382cc  }
080382d4    int32_t sub_80382d4(int32_t arg1 @ r7)
080382d4  {
080382dc      driveState = 1;
080382e4      turnRetryCounter = 0;
080382ec      noObstacleGraceCounter = 0;
080382f4      turnInProgressFlag = 0;
080382f6      sub_8028ae4();
08038302      tStartWalk_ms = TickType_t xTaskGetTickCount(void)();
0803830a      data_2000e2a0 = 0;
08038314      data_2000e2a8 = 0x1770;
08038316      return arg1;
080382d4  }
08038318    int32_t mowing_state_machine(int32_t headingOrModeByte, int32_t arg2, int32_t obstacleOrEdgeSeenA, int32_t highLevelMode, int32_t arg5 @ r4, int32_t arg6 @ r5, int32_t arg7 @ r6)
08038318  {
08038318      int32_t r7;
08038318      int32_t var_8 = r7;
08038318      
0803832c      if (!isFaultActive())
0803832c      {
0803832e          uint32_t r6_1 = (uint32_t)(uint8_t)highLevelMode;
0803832e          
08038332          if (r6_1 != 5)
08038332          {
08038342              if ((uint32_t)(uint8_t)r6_1 == 4)
08038342              {
08038344                  motorStop();
08038348                  motorBrake();
08038350                  logging_wrapper(sub_803af88+8);
08038354                  return 0;
08038342              }
08038342              
08038358              uint32_t obstacleOrEdgeSeen = (uint32_t)(uint8_t)obstacleOrEdgeSeenA;
08038358              
0803835c              if (obstacleOrEdgeSeen)
080383b4                  noObstacleGraceCounter = 0;
0803835c              else
0803835c              {
0803836a                  noObstacleGraceCounter += 1;
0803836a                  
08038374                  if ((uint32_t)noObstacleGraceCounter >= 6)
08038374                  {
0803837c                      noObstacleGraceCounter = 0;
0803837e                      motorStop();
08038382                      motorBrake();
0803838c                      driveState = 1;
08038392                      doBeep(&turnTable);
0803839a                      logging_wrapper("MOWING_STOP 2\r\n");
080383a0                      ui_set_stop_indicator(1);
080383a6                      ui_set_run_indicator(0);
080383aa                      return 6;
08038374                  }
0803835c              }
0803835c              
080383b8              int32_t r0_5;
080383b8              int32_t r1;
080383b8              char r2;
080383b8              r0_5 = safetyCheck(3);
080383b8              
080383be              if (r0_5 != 1)
080383c0                  /* tailcall */
080383c0                  return mowing_state_step(4, r1, r2, highLevelMode, headingOrModeByte, 
080383c0                      arg2, obstacleOrEdgeSeenA, arg5, arg6, arg7);
080383c0              
080383e0              tStartWalk_ms = TickType_t xTaskGetTickCount(void)();
080383e4              uint32_t r0_8;
080383e4              int32_t r2_2;
080383e4              r0_8 = isDriveSubsystemReady(2);
080383ea              int128_t q0;
080383ea              
080383ea              if (!r0_8)
080383ea              {
080383ee                  int32_t r0_9;
080383ee                  r0_9 = safetyCheck(0xa);
080383ee                  
080383f4                  if (r0_9 != 1)
080383f4                  {
080383f6                      int32_t r0_10 = TickType_t xTaskGetTickCount(void)();
080383f6                      
08038404                      if (r0_10 >= tStartWalk_ms)
0803841c                          r7 = r0_10 - tStartWalk_ms;
08038404                      else
08038412                          r7 = r0_10 + 0xffffffff - tStartWalk_ms;
08038412                      
08038424                      r2_2 = logging_wrapper("walkTime : %d ms\r\n", r7);
08038424                      
0803843c                      if (r7 / 0x3e8 || (uint32_t)data_2000e429 == 1)
0803843c                      {
0803843e                          obstacleOrEdgeSeen = (uint32_t)(uint8_t)obstacleOrEdgeSeen;
0803843e                          
08038442                          if (obstacleOrEdgeSeen == 1 && sub_8028b08() != 1)
08038442                          {
0803844e                              int32_t r0_17;
0803844e                              r0_17 = safetyCheck(4);
0803844e                              
08038454                              if (r0_17 != 1)
08038454                              {
08038458                                  int32_t r0_18;
08038458                                  r0_18 = safetyCheck(3);
08038458                                  
0803845e                                  if (r0_18 != 1)
0803845e                                  {
08038466                                      if (beep_enabled_get() == 1 && beep_guard_get() != 1)
08038466                                      {
08038474                                          r2_2 = doBeep(0x10000000);
0803847a                                          beep_guard_set(1);
08038466                                      }
08038466                                      
08038480                                      beep_enabled_set(1);
08038480                                      
0803848c                                      if (get_beep_event_flags() != 0x10000000)
0803848c                                      {
08038496                                          tLastReinit_ms =
08038496                                              TickType_t xTaskGetTickCount(void)();
08038498                                          (uint32_t)q0 = 0x42c80000;
0803849c                                          r2_2 = beeper_config_apply((uint32_t)q0);
080384a6                                          data_2000e429 = 0;
0803848c                                      }
0803845e                                  }
08038454                              }
08038442                          }
0803843c                      }
080383f4                  }
080383ea              }
080383ea              
080384ac              uint32_t driveState_1 = (uint32_t)driveState;
080384ac              
080384b0              if (driveState_1 == 1)
080384b0              {
080384de                  logging_wrapper("MOWING_STOP\r\n");
080384e2                  uint32_t r4_1 = (uint32_t)(uint8_t)obstacleOrEdgeSeen;
080384e2                  
080384e6                  if (r4_1 == 1)
080384e6                  {
08038552                      int64_t q0_2;
08038552                      *(uint32_t*)((char*)q0_2)[4] = 0x48b643af;
08038556                      (uint32_t)q0_2 = 0x48b643af;
0803855a                      sub_802d226(q0_2);
08038564                      driveState = 2;
0803856e                      tStateStart_ms = TickType_t xTaskGetTickCount(void)();
080384e6                  }
080384e6                  else
080384e6                  {
080384f2                      if (!turnCooldownActive(&data_2000e2a0))
080384f2                      {
080384f8                          if ((uint32_t)(uint8_t)r4_1 != 3)
0803850a                              turnSide = 5;
080384f8                          else
08038500                              turnSide = 4;
080384f2                      }
080384f2                      
0803850c                      int32_t r1_4;
0803850c                      int32_t r2_3;
0803850c                      int128_t q0_3;
0803850c                      r1_4 = computeTurnCommand(r7);
0803850c                      
08038518                      if ((uint32_t)turnSide != 4)
08038518                      {
08038536                          *(uint32_t*)((char*)q0_3)[8] = fabsf((uint32_t)q0_3);
0803853a                          *(uint32_t*)((char*)q0_3)[4] = 0;
0803853e                          (uint32_t)q0_3 = 0x4348;
08038544                          commandMotion(4, r1_4, r2_3, q0_3);
0803854e                          driveState = 5;
08038518                      }
08038518                      else
08038518                      {
0803851a                          *(uint32_t*)((char*)q0_3)[8] = fabsf((uint32_t)q0_3);
0803851e                          *(uint32_t*)((char*)q0_3)[4] = 0;
08038522                          (uint32_t)q0_3 = 0x4348;
08038528                          commandMotion(3, r1_4, r2_3, q0_3);
08038532                          driveState = 4;
08038518                      }
080384e6                  }
080384e6                  
08038578                  tStartWalk_ms = TickType_t xTaskGetTickCount(void)();
080384b0              }
080384b0              else if (driveState_1 >= 1)
080384b2              {
080384b8                  if (driveState_1 == 3)
080384b8                  {
0803880c                      logging_wrapper("MOWING_BACKWARD\r\n");
0803880c                      
08038816                      if (!driveSubsystemState())
08038816                      {
0803881e                          backoffCounter = 0;
08038826                          driveState = 7;
08038816                      }
080384b8                  }
080384b8                  else if (driveState_1 < 3)
080384bc                  {
08038580                      logging_wrapper("MOWING_FORWARD\r\n");
08038584                      uint32_t r4_3 = (uint32_t)(uint8_t)obstacleOrEdgeSeen;
08038584                      
08038588                      if (r4_3 != 1 && !turnCooldownActive(&data_2000e2a0))
08038588                      {
08038596                          r4_3 = (uint32_t)(uint8_t)r4_3;
08038596                          
0803859a                          if (r4_3 != 3)
080385ac                              turnSide = 5;
0803859a                          else
080385a2                              turnSide = 4;
08038588                      }
08038588                      
080385ae                      uint32_t r5 = (uint32_t)*(uint8_t*)((char*)headingOrModeByte)[2];
080385ae                      
080385b2                      if (!r5)
080385b2                      {
080385d4                          uint32_t r0_28;
080385d4                          
080385d4                          if ((uint32_t)(uint8_t)r4_3 == 1)
080385d6                              r0_28 = sub_802ac98();
080385d6                          
080385dc                          if ((uint32_t)(uint8_t)r4_3 == 1 && !r0_28)
080385dc                          {
0803863a                              reduceSpeedOrGuard(2);
0803863e                              int128_t q0_5;
0803863e                              *(uint32_t*)((char*)q0_5)[4] = 0xf7f444fa;
08038642                              /* unimplemented  {vcmp.f32.F32 s0, s1} */
08038646                              /* unimplemented  {vmrs apsr_nzcv, fpscr} */
080386b6                              int32_t r0_37 = TickType_t xTaskGetTickCount(void)();
080386c4                              int32_t r7_1;
080386c4                              bool c_1;
080386c4                              
080386c4                              if (r0_37 >= tLastReinit_ms)
080386c4                              {
080386da                                  int32_t tLastReinit_ms_1 = tLastReinit_ms;
080386dc                                  r7_1 = r0_37 - tLastReinit_ms_1;
080386dc                                  c_1 = r0_37 >= tLastReinit_ms_1;
080386c4                              }
080386c4                              else
080386c4                              {
080386d0                                  int32_t r0_39 = 0xffffffff - tLastReinit_ms;
080386d2                                  r7_1 = r0_37 + r0_39;
080386d2                                  c_1 = r0_37 + r0_39 < r0_37;
080386c4                              }
080386c4                              
080386e0                              sub_802e6b8(r7_1);
080386ea                              soft_dadd(headingOrModeByte, obstacleOrEdgeSeenA);
080386f4                              int32_t r0_41;
080386f4                              int32_t r1_7;
080386f4                              r0_41 = soft_dadd();
080386fe                              sub_80360c8(r0_41, r1_7, 1, 0x403e0000);
080386fe                              
08038702                              if (!c_1)
08038702                              {
08038704                                  motorStop();
08038708                                  sub_802717c();
0803870e                                  rtos_delay_ticks(0x64);
08038712                                  sub_802718c();
08038718                                  beep_enabled_set(0);
08038720                                  tStartWalk_ms = r0_37;
08038726                                  tLastReinit_ms = r0_37;
08038702                              }
08038702                              
0803872e                              phaseCounter = 0;
08038730                              int32_t r2_8;
08038730                              int128_t q0_7;
08038730                              r2_8 = sub_8038a30();
08038736                              sub_802d0c0(1);
0803873a                              int32_t r0_42 = TickType_t xTaskGetTickCount(void)();
08038748                              int32_t r7_2;
08038748                              
08038748                              if (r0_42 >= tStateStart_ms)
08038760                                  r7_2 = r0_42 - tStateStart_ms;
08038748                              else
08038756                                  r7_2 = r0_42 + 0xffffffff - tStateStart_ms;
08038756                              
0803876c                              if (r7_2 / 0x3e8 >= 0x79)
0803876c                              {
08038776                                  if ((uint32_t)turnInProgressFlag == 1)
08038776                                  {
0803877e                                      turnInProgressFlag = 0;
08038780                                      motorStop();
08038784                                      int32_t r3_3 = motorBrake();
0803878a                                      doBeep(0x20);
08038790                                      sub_8028be8(1);
0803879a                                      sub_80282e4(0x31, 0, 1, r3_3, r5);
080387a2                                      sub_80283b6(0, 1);
080387a6                                      return 0;
08038776                                  }
08038776                                  
080387b6                                  turnInProgressFlag = 1;
080387b8                                  *(uint32_t*)((char*)q0_7)[8] = 0x43070000;
080387bc                                  *(uint32_t*)((char*)q0_7)[4] = 0;
080387c0                                  (uint32_t)q0_7 = 0x43480000;
080387c6                                  commandMotion(4, &turnInProgressFlag, r2_8, q0_7);
080387d0                                  driveState = 5;
0803876c                              }
080385dc                          }
080385dc                          else
080385dc                          {
080385de                              int32_t r2_4;
080385de                              int128_t q0_4;
080385de                              r2_4 = motorBrake();
080385de                              
080385ea                              if ((uint32_t)phaseCounter < 0x15)
080385ea                              {
08038624                                  phaseCounter += 1;
08038624                                  
0803862e                                  if ((uint32_t)phaseCounter >= 0xb)
08038632                                      sub_802ac90(0);
080385ea                              }
080385ea                              else
080385ea                              {
080385f2                                  phaseCounter = 0;
080385f4                                  *(uint32_t*)((char*)q0_4)[8] = 0;
080385f8                                  *(uint32_t*)((char*)q0_4)[4] = 0x41200000;
080385fc                                  (uint32_t)q0_4 = 0x437a0000;
08038602                                  commandMotion(2, &phaseCounter, r2_4, q0_4);
0803860c                                  turnInProgressFlag = 0;
08038614                                  driveState = 3;
080385ea                              }
080385dc                          }
080385b2                      }
080385b2                      else
080385b2                      {
080385b4                          motorBrake();
080385be                          backoffCounter = 0;
080385c6                          driveState = 6;
080385ca                          sub_802ac90(0);
080385b2                      }
080384bc                  }
080384bc                  else if (driveState_1 == 5 || driveState_1 < 5)
080384c4                  {
0803893e                      if (!driveSubsystemState())
0803893e                      {
08038946                          if ((uint32_t)phaseCounter == 0xa)
08038946                          {
08038948                              motorBrake();
08038954                              phaseCounter += 1;
08038946                          }
08038946                          else if ((uint32_t)phaseCounter < 0x15)
0803899e                              phaseCounter += 1;
0803895e                          else
0803895e                          {
08038964                              phaseCounter = 0;
0803896e                              turnRetryCounter += 1;
0803896e                              
08038974                              if ((uint32_t)(uint8_t)obstacleOrEdgeSeen != 1)
08038974                              {
080389a8                                  if ((uint32_t)turnRetryCounter >= 0xa)
080389aa                                      motorStop();
080389aa                                  
080389b4                                  if ((uint32_t)turnRetryCounter >= 0x13)
080389b4                                  {
080389ba                                      turnRetryCounter = 0;
080389bc                                      motorStop();
080389c0                                      motorBrake();
080389c8                                      doBeep(&turnTable);
080389d0                                      driveState = 1;
080389d4                                      logging_wrapper("MOWING_STOP 3\r\n", &driveState);
080389da                                      ui_set_stop_indicator(1);
080389e0                                      ui_set_run_indicator(0);
080389e4                                      return 6;
080389b4                                  }
080389b4                                  
080389ea                                  int32_t r1_10;
080389ea                                  int32_t r2_10;
080389ea                                  r1_10 = turnCooldownActive(&data_2000e2a0);
080389ea                                  
080389f4                                  if ((uint32_t)turnSide != 4)
080389f4                                  {
08038a10                                      *(uint32_t*)((char*)q0)[8] = 0x41a00000;
08038a14                                      *(uint32_t*)((char*)q0)[4] = 0;
08038a18                                      (uint32_t)q0 = 0x43480000;
08038a1e                                      commandMotion(4, r1_10, r2_10, q0);
08038a24                                      logging_wrapper("MOWING_TURN_RIGHT\r\n");
080389f4                                  }
080389f4                                  else
080389f4                                  {
080389f6                                      *(uint32_t*)((char*)q0)[8] = 0x41a00000;
080389fa                                      *(uint32_t*)((char*)q0)[4] = 0;
080389fe                                      (uint32_t)q0 = 0xb5804348;
08038a04                                      commandMotion(3, r1_10, r2_10, q0);
08038a0a                                      logging_wrapper("MOWING_TURN_LEFT\r\n");
080389f4                                  }
08038974                              }
08038974                              else
08038974                              {
0803897a                                  turnRetryCounter = 0;
0803897c                                  sub_8038a30();
08038984                                  driveState = 2;
0803898c                                  tStateStart_ms = TickType_t xTaskGetTickCount(void)();
08038990                                  logging_wrapper("MOWING_FORWARD\r\n", &tStartWalk_ms);
08038974                              }
0803895e                          }
0803893e                      }
080384c4                  }
080384c4                  else if (driveState_1 == 7)
080384ca                  {
08038836                      backoffCounter += 1;
08038836                      
08038840                      if (backoffCounter == 0xa)
08038842                          motorBrake();
08038840                      else if (backoffCounter >= 0x15)
08038850                      {
08038858                          backoffCounter = 0;
0803885a                          int32_t r1_9;
0803885a                          int32_t r2_9;
0803885a                          int128_t q0_8;
0803885a                          r1_9 = computeTurnCommand(r7);
0803885a                          
08038864                          if ((uint32_t)turnSide != 4)
08038864                          {
08038880                              *(uint32_t*)((char*)q0_8)[8] = fabsf((uint32_t)q0_8);
08038884                              *(uint32_t*)((char*)q0_8)[4] = 0;
08038888                              (uint32_t)q0_8 = 0x43480000;
0803888e                              commandMotion(4, r1_9, r2_9, q0_8);
08038896                              driveState = 5;
08038864                          }
08038864                          else
08038864                          {
08038866                              *(uint32_t*)((char*)q0_8)[8] = fabsf((uint32_t)q0_8);
0803886a                              *(uint32_t*)((char*)q0_8)[4] = 0;
0803886e                              (uint32_t)q0_8 = 0x4348;
08038874                              commandMotion(3, r1_9, r2_9, q0_8);
0803887c                              driveState = 4;
08038864                          }
08038850                      }
080384ca                  }
080384ca                  else if (driveState_1 < 7)
080384ce                  {
080387e0                      backoffCounter += 1;
080387e0                      
080387ea                      if (backoffCounter >= 0x15)
080387ea                      {
080387ec                          *(uint32_t*)((char*)q0)[8] = 0;
080387f0                          *(uint32_t*)((char*)q0)[4] = 0x41200000;
080387f4                          (uint32_t)q0 = 0x437a0000;
080387fa                          commandMotion(2, &backoffCounter, r2_2, q0);
08038804                          driveState = 3;
080387ea                      }
080384ce                  }
080384ce                  else if (driveState_1 == 8)
080384d4                  {
080388b0                      lockRecoveryCounters2 += 1;
080388b4                      uint32_t r0_59 = isDriveSubsystemReady(2);
080388b4                      
080388ba                      if (r0_59 != 1)
080388ba                      {
080388ca                          reduceSpeedOrGuard(2);
080388ce                          int128_t q0_9;
080388ce                          *(uint32_t*)((char*)q0_9)[4] = 0x451c;
080388d2                          /* unimplemented  {vcmp.f32.F32 s0, s1} */
080388d6                          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
080388d6                          
080388da                          if (false == r0_59 - 1)
080388da                          {
080388e0                              lockRecoveryCounters1 = 0;
080388e6                              lockRecoveryCounters2 = 0;
080388ee                              tStateStart_ms = TickType_t xTaskGetTickCount(void)();
080388f4                              driveState = 2;
080388f8                              logging_wrapper("MOWING_FORWARD\r\n", &driveState);
080388da                          }
080388da                          else if ((uint32_t)lockRecoveryCounters2 >= 0x65)
08038904                          {
0803890a                              lockRecoveryCounters1 = 0;
08038910                              lockRecoveryCounters2 = 0;
08038912                              motorStop();
08038916                              motorBrake();
08038920                              tStartWalk_ms = TickType_t xTaskGetTickCount(void)();
08038926                              driveState = 3;
0803892a                              logging_wrapper("MOWING_BACKWARD\r\n", &driveState);
08038904                          }
080388ba                      }
080388ba                      else
080388ba                      {
080388bc                          motorStop();
080388c2                          logging_wrapper("MOTOR_STATE_LOCKED --> MOTOR_STATE_STOPPED\r\n");
080388ba                      }
080384d4                  }
080384b2              }
080384b2              
08038a28              return 5;
08038332          }
0803832c      }
0803832c      
08038336      ui_set_run_indicator(0);
0803833a      return 6;
08038318  }
080383a8    int32_t sub_80383a8()
080383a8  {
080383a8      /* undefined */
080383a8  }
080383c2    int32_t mowing_state_step(int32_t safety_req, uint32_t grass_mode, uint8_t edge_flag, int32_t turnArgA, int32_t turnArgB, int32_t ctx6, int32_t ctx7, int32_t ctx8, int32_t ctx9, int32_t ctx10)
080383c2  {
080383c8      uint32_t entry_r4;
080383c8      
080383c8      if (safetyCheck(safety_req) == 1)
080383e0          tStartWalk_ms = TickType_t xTaskGetTickCount(void)();
080383c8      else if (sub_8028b08() == 1)
080383e0          tStartWalk_ms = TickType_t xTaskGetTickCount(void)();
080383d0      else
080383d0      {
080383d2          entry_r4 = (uint32_t)(uint8_t)entry_r4;
080383d2          
080383d6          if (entry_r4 != 1)
080383e0              tStartWalk_ms = TickType_t xTaskGetTickCount(void)();
080383d0      }
080383d0      
080383e4      uint32_t r0_2;
080383e4      int32_t r2;
080383e4      r0_2 = isDriveSubsystemReady(2);
080383ea      int32_t r7;
080383ea      int128_t q0;
080383ea      
080383ea      if (!r0_2)
080383ea      {
080383ee          int32_t r0_3;
080383ee          r0_3 = safetyCheck(0xa);
080383ee          
080383f4          if (r0_3 != 1)
080383f4          {
080383f6              int32_t r0_4 = TickType_t xTaskGetTickCount(void)();
080383f6              
08038404              if (r0_4 >= tStartWalk_ms)
0803841c                  r7 = r0_4 - tStartWalk_ms;
08038404              else
08038412                  r7 = r0_4 + 0xffffffff - tStartWalk_ms;
08038412              
08038424              r2 = logging_wrapper("walkTime : %d ms\r\n", r7);
08038424              
0803843c              if (r7 / 0x3e8 || (uint32_t)data_2000e429 == 1)
0803843c              {
0803843e                  entry_r4 = (uint32_t)(uint8_t)entry_r4;
0803843e                  
08038442                  if (entry_r4 == 1 && sub_8028b08() != 1)
08038442                  {
0803844e                      int32_t r0_11;
0803844e                      r0_11 = safetyCheck(4);
0803844e                      
08038454                      if (r0_11 != 1)
08038454                      {
08038458                          int32_t r0_12;
08038458                          r0_12 = safetyCheck(3);
08038458                          
0803845e                          if (r0_12 != 1)
0803845e                          {
08038466                              if (beep_enabled_get() == 1 && beep_guard_get() != 1)
08038466                              {
08038474                                  r2 = doBeep(0x10000000);
0803847a                                  beep_guard_set(1);
08038466                              }
08038466                              
08038480                              beep_enabled_set(1);
08038480                              
0803848c                              if (get_beep_event_flags() != 0x10000000)
0803848c                              {
08038496                                  tLastReinit_ms = TickType_t xTaskGetTickCount(void)();
08038498                                  (uint32_t)q0 = 0x42c80000;
0803849c                                  r2 = beeper_config_apply((uint32_t)q0);
080384a6                                  data_2000e429 = 0;
0803848c                              }
0803845e                          }
08038454                      }
08038442                  }
0803843c              }
080383f4          }
080383ea      }
080383ea      
080384ac      uint32_t driveState_1 = (uint32_t)driveState;
080384ac      
080384b0      if (driveState_1 == 1)
080384b0      {
080384de          logging_wrapper("MOWING_STOP\r\n");
080384e2          uint32_t r4 = (uint32_t)(uint8_t)entry_r4;
080384e2          
080384e6          if (r4 == 1)
080384e6          {
08038552              int64_t q0_1;
08038552              *(uint32_t*)((char*)q0_1)[4] = 0x48b643af;
08038556              (uint32_t)q0_1 = 0x48b643af;
0803855a              sub_802d226(q0_1);
08038564              driveState = 2;
0803856e              tStateStart_ms = TickType_t xTaskGetTickCount(void)();
080384e6          }
080384e6          else
080384e6          {
080384f2              if (!turnCooldownActive(&data_2000e2a0))
080384f2              {
080384f8                  if ((uint32_t)(uint8_t)r4 != 3)
0803850a                      turnSide = 5;
080384f8                  else
08038500                      turnSide = 4;
080384f2              }
080384f2              
0803850c              int32_t r1_2;
0803850c              int32_t r2_1;
0803850c              int128_t q0_2;
0803850c              r1_2 = computeTurnCommand(r7);
0803850c              
08038518              if ((uint32_t)turnSide != 4)
08038518              {
08038536                  *(uint32_t*)((char*)q0_2)[8] = fabsf((uint32_t)q0_2);
0803853a                  *(uint32_t*)((char*)q0_2)[4] = 0;
0803853e                  (uint32_t)q0_2 = 0x4348;
08038544                  commandMotion(4, r1_2, r2_1, q0_2);
0803854e                  driveState = 5;
08038518              }
08038518              else
08038518              {
0803851a                  *(uint32_t*)((char*)q0_2)[8] = fabsf((uint32_t)q0_2);
0803851e                  *(uint32_t*)((char*)q0_2)[4] = 0;
08038522                  (uint32_t)q0_2 = 0x4348;
08038528                  commandMotion(3, r1_2, r2_1, q0_2);
08038532                  driveState = 4;
08038518              }
080384e6          }
080384e6          
08038578          tStartWalk_ms = TickType_t xTaskGetTickCount(void)();
080384b0      }
080384b0      else if (driveState_1 >= 1)
080384b2      {
080384b8          if (driveState_1 == 3)
080384b8          {
0803880c              logging_wrapper("MOWING_BACKWARD\r\n");
0803880c              
08038816              if (!driveSubsystemState())
08038816              {
0803881e                  backoffCounter = 0;
08038826                  driveState = 7;
08038816              }
080384b8          }
080384b8          else if (driveState_1 < 3)
080384bc          {
08038580              logging_wrapper("MOWING_FORWARD\r\n");
08038584              uint32_t r4_2 = (uint32_t)(uint8_t)entry_r4;
08038584              
08038588              if (r4_2 != 1 && !turnCooldownActive(&data_2000e2a0))
08038588              {
08038596                  r4_2 = (uint32_t)(uint8_t)r4_2;
08038596                  
0803859a                  if (r4_2 != 3)
080385ac                      turnSide = 5;
0803859a                  else
080385a2                      turnSide = 4;
08038588              }
08038588              
080385ae              char entry_r5;
080385ae              uint32_t r5 = (uint32_t)entry_r5;
080385ae              
080385b2              if (!r5)
080385b2              {
080385d4                  uint32_t r0_22;
080385d4                  
080385d4                  if ((uint32_t)(uint8_t)r4_2 == 1)
080385d6                      r0_22 = sub_802ac98();
080385d6                  
080385dc                  if ((uint32_t)(uint8_t)r4_2 == 1 && !r0_22)
080385dc                  {
0803863a                      reduceSpeedOrGuard(2);
0803863e                      int128_t q0_4;
0803863e                      *(uint32_t*)((char*)q0_4)[4] = 0xf7f444fa;
08038642                      /* unimplemented  {vcmp.f32.F32 s0, s1} */
08038646                      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
080386b6                      int32_t r0_31 = TickType_t xTaskGetTickCount(void)();
080386c4                      int32_t r7_1;
080386c4                      bool c_1;
080386c4                      
080386c4                      if (r0_31 >= tLastReinit_ms)
080386c4                      {
080386da                          int32_t tLastReinit_ms_1 = tLastReinit_ms;
080386dc                          r7_1 = r0_31 - tLastReinit_ms_1;
080386dc                          c_1 = r0_31 >= tLastReinit_ms_1;
080386c4                      }
080386c4                      else
080386c4                      {
080386d0                          int32_t r0_33 = 0xffffffff - tLastReinit_ms;
080386d2                          r7_1 = r0_31 + r0_33;
080386d2                          c_1 = r0_31 + r0_33 < r0_31;
080386c4                      }
080386c4                      
080386e0                      sub_802e6b8(r7_1);
080386ea                      soft_dadd(turnArgB, ctx7);
080386f4                      int32_t r0_35;
080386f4                      int32_t r1_5;
080386f4                      r0_35 = soft_dadd();
080386fe                      sub_80360c8(r0_35, r1_5, 1, 0x403e0000);
080386fe                      
08038702                      if (!c_1)
08038702                      {
08038704                          motorStop();
08038708                          sub_802717c();
0803870e                          rtos_delay_ticks(0x64);
08038712                          sub_802718c();
08038718                          beep_enabled_set(0);
08038720                          tStartWalk_ms = r0_31;
08038726                          tLastReinit_ms = r0_31;
08038702                      }
08038702                      
0803872e                      phaseCounter = 0;
08038730                      int32_t r2_6;
08038730                      int128_t q0_6;
08038730                      r2_6 = sub_8038a30();
08038736                      sub_802d0c0(1);
0803873a                      int32_t r0_36 = TickType_t xTaskGetTickCount(void)();
08038748                      int32_t r7_2;
08038748                      
08038748                      if (r0_36 >= tStateStart_ms)
08038760                          r7_2 = r0_36 - tStateStart_ms;
08038748                      else
08038756                          r7_2 = r0_36 + 0xffffffff - tStateStart_ms;
08038756                      
0803876c                      if (r7_2 / 0x3e8 >= 0x79)
0803876c                      {
08038776                          if ((uint32_t)turnInProgressFlag == 1)
08038776                          {
0803877e                              turnInProgressFlag = 0;
08038780                              motorStop();
08038784                              int32_t r3_2 = motorBrake();
0803878a                              doBeep(0x20);
08038790                              sub_8028be8(1);
0803879a                              sub_80282e4(0x31, 0, 1, r3_2, r5);
080387a2                              sub_80283b6(0, 1);
080387a6                              return 0;
08038776                          }
08038776                          
080387b6                          turnInProgressFlag = 1;
080387b8                          *(uint32_t*)((char*)q0_6)[8] = 0x43070000;
080387bc                          *(uint32_t*)((char*)q0_6)[4] = 0;
080387c0                          (uint32_t)q0_6 = 0x43480000;
080387c6                          commandMotion(4, &turnInProgressFlag, r2_6, q0_6);
080387d0                          driveState = 5;
0803876c                      }
080385dc                  }
080385dc                  else
080385dc                  {
080385de                      int32_t r2_2;
080385de                      int128_t q0_3;
080385de                      r2_2 = motorBrake();
080385de                      
080385ea                      if ((uint32_t)phaseCounter < 0x15)
080385ea                      {
08038624                          phaseCounter += 1;
08038624                          
0803862e                          if ((uint32_t)phaseCounter >= 0xb)
08038632                              sub_802ac90(0);
080385ea                      }
080385ea                      else
080385ea                      {
080385f2                          phaseCounter = 0;
080385f4                          *(uint32_t*)((char*)q0_3)[8] = 0;
080385f8                          *(uint32_t*)((char*)q0_3)[4] = 0x41200000;
080385fc                          (uint32_t)q0_3 = 0x437a0000;
08038602                          commandMotion(2, &phaseCounter, r2_2, q0_3);
0803860c                          turnInProgressFlag = 0;
08038614                          driveState = 3;
080385ea                      }
080385dc                  }
080385b2              }
080385b2              else
080385b2              {
080385b4                  motorBrake();
080385be                  backoffCounter = 0;
080385c6                  driveState = 6;
080385ca                  sub_802ac90(0);
080385b2              }
080384bc          }
080384bc          else if (driveState_1 == 5 || driveState_1 < 5)
080384c4          {
0803893e              if (!driveSubsystemState())
0803893e              {
08038946                  if ((uint32_t)phaseCounter == 0xa)
08038946                  {
08038948                      motorBrake();
08038954                      phaseCounter += 1;
08038946                  }
08038946                  else if ((uint32_t)phaseCounter < 0x15)
0803899e                      phaseCounter += 1;
0803895e                  else
0803895e                  {
08038964                      phaseCounter = 0;
0803896e                      turnRetryCounter += 1;
0803896e                      
08038974                      if ((uint32_t)(uint8_t)entry_r4 != 1)
08038974                      {
080389a8                          if ((uint32_t)turnRetryCounter >= 0xa)
080389aa                              motorStop();
080389aa                          
080389b4                          if ((uint32_t)turnRetryCounter >= 0x13)
080389b4                          {
080389ba                              turnRetryCounter = 0;
080389bc                              motorStop();
080389c0                              motorBrake();
080389c8                              doBeep(&turnTable);
080389d0                              driveState = 1;
080389d4                              logging_wrapper("MOWING_STOP 3\r\n", &driveState);
080389da                              ui_set_stop_indicator(1);
080389e0                              ui_set_run_indicator(0);
080389e4                              return 6;
080389b4                          }
080389b4                          
080389ea                          int32_t r1_8;
080389ea                          int32_t r2_8;
080389ea                          r1_8 = turnCooldownActive(&data_2000e2a0);
080389ea                          
080389f4                          if ((uint32_t)turnSide != 4)
080389f4                          {
08038a10                              *(uint32_t*)((char*)q0)[8] = 0x41a00000;
08038a14                              *(uint32_t*)((char*)q0)[4] = 0;
08038a18                              (uint32_t)q0 = 0x43480000;
08038a1e                              commandMotion(4, r1_8, r2_8, q0);
08038a24                              logging_wrapper("MOWING_TURN_RIGHT\r\n");
080389f4                          }
080389f4                          else
080389f4                          {
080389f6                              *(uint32_t*)((char*)q0)[8] = 0x41a00000;
080389fa                              *(uint32_t*)((char*)q0)[4] = 0;
080389fe                              (uint32_t)q0 = 0xb5804348;
08038a04                              commandMotion(3, r1_8, r2_8, q0);
08038a0a                              logging_wrapper("MOWING_TURN_LEFT\r\n");
080389f4                          }
08038974                      }
08038974                      else
08038974                      {
0803897a                          turnRetryCounter = 0;
0803897c                          sub_8038a30();
08038984                          driveState = 2;
0803898c                          tStateStart_ms = TickType_t xTaskGetTickCount(void)();
08038990                          logging_wrapper("MOWING_FORWARD\r\n", &tStartWalk_ms);
08038974                      }
0803895e                  }
0803893e              }
080384c4          }
080384c4          else if (driveState_1 == 7)
080384ca          {
08038836              backoffCounter += 1;
08038836              
08038840              if (backoffCounter == 0xa)
08038842                  motorBrake();
08038840              else if (backoffCounter >= 0x15)
08038850              {
08038858                  backoffCounter = 0;
0803885a                  int32_t r1_7;
0803885a                  int32_t r2_7;
0803885a                  int128_t q0_7;
0803885a                  r1_7 = computeTurnCommand(r7);
0803885a                  
08038864                  if ((uint32_t)turnSide != 4)
08038864                  {
08038880                      *(uint32_t*)((char*)q0_7)[8] = fabsf((uint32_t)q0_7);
08038884                      *(uint32_t*)((char*)q0_7)[4] = 0;
08038888                      (uint32_t)q0_7 = 0x43480000;
0803888e                      commandMotion(4, r1_7, r2_7, q0_7);
08038896                      driveState = 5;
08038864                  }
08038864                  else
08038864                  {
08038866                      *(uint32_t*)((char*)q0_7)[8] = fabsf((uint32_t)q0_7);
0803886a                      *(uint32_t*)((char*)q0_7)[4] = 0;
0803886e                      (uint32_t)q0_7 = 0x4348;
08038874                      commandMotion(3, r1_7, r2_7, q0_7);
0803887c                      driveState = 4;
08038864                  }
08038850              }
080384ca          }
080384ca          else if (driveState_1 < 7)
080384ce          {
080387e0              backoffCounter += 1;
080387e0              
080387ea              if (backoffCounter >= 0x15)
080387ea              {
080387ec                  *(uint32_t*)((char*)q0)[8] = 0;
080387f0                  *(uint32_t*)((char*)q0)[4] = 0x41200000;
080387f4                  (uint32_t)q0 = 0x437a0000;
080387fa                  commandMotion(2, &backoffCounter, r2, q0);
08038804                  driveState = 3;
080387ea              }
080384ce          }
080384ce          else if (driveState_1 == 8)
080384d4          {
080388b0              lockRecoveryCounters2 += 1;
080388b4              uint32_t r0_54 = isDriveSubsystemReady(2);
080388b4              
080388ba              if (r0_54 != 1)
080388ba              {
080388ca                  reduceSpeedOrGuard(2);
080388ce                  int128_t q0_8;
080388ce                  *(uint32_t*)((char*)q0_8)[4] = 0x451c;
080388d2                  /* unimplemented  {vcmp.f32.F32 s0, s1} */
080388d6                  /* unimplemented  {vmrs apsr_nzcv, fpscr} */
080388d6                  
080388da                  if (false == r0_54 - 1)
080388da                  {
080388e0                      lockRecoveryCounters1 = 0;
080388e6                      lockRecoveryCounters2 = 0;
080388ee                      tStateStart_ms = TickType_t xTaskGetTickCount(void)();
080388f4                      driveState = 2;
080388f8                      logging_wrapper("MOWING_FORWARD\r\n", &driveState);
080388da                  }
080388da                  else if ((uint32_t)lockRecoveryCounters2 >= 0x65)
08038904                  {
0803890a                      lockRecoveryCounters1 = 0;
08038910                      lockRecoveryCounters2 = 0;
08038912                      motorStop();
08038916                      motorBrake();
08038920                      tStartWalk_ms = TickType_t xTaskGetTickCount(void)();
08038926                      driveState = 3;
0803892a                      logging_wrapper("MOWING_BACKWARD\r\n", &driveState);
08038904                  }
080388ba              }
080388ba              else
080388ba              {
080388bc                  motorStop();
080388c2                  logging_wrapper("MOTOR_STATE_LOCKED --> MOTOR_STATE_STOPPED\r\n");
080388ba              }
080384d4          }
080384b2      }
080384b2      
08038a28      return 5;
080383c2  }
080387aa                                00 bf                                                                        ..
080387ac  int32_t data_80387ac = 0x42c80000
080387ae    int32_t sub_80387ae(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7)
080387ae  {
080387b6      turnInProgressFlag = 1;
080387b8      int128_t q0;
080387b8      *(uint32_t*)((char*)q0)[8] = 0x43070000;
080387bc      *(uint32_t*)((char*)q0)[4] = 0;
080387c0      (uint32_t)q0 = 0x43480000;
080387c6      int32_t entry_r2;
080387c6      commandMotion(4, &turnInProgressFlag, entry_r2, q0);
080387d0      driveState = 5;
08038a2a      return 5;
080387ae  }
0803889a                                                                                00 bf                                        ..
0803889c  int32_t data_803889c = 0x0
080388a0  int32_t data_80388a0 = 0x43480000
080388a2    int32_t sub_80388a2(int32_t arg1 @ r5, int32_t arg2 @ r7, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, int32_t arg8, int32_t arg9)
080388a2  {
080388b0      lockRecoveryCounters2 += 1;
080388b4      uint32_t r0_2 = isDriveSubsystemReady(2);
080388b4      
080388ba      if (r0_2 != 1)
080388ba      {
080388ca          reduceSpeedOrGuard(2);
080388ce          int128_t q0_1;
080388ce          *(uint32_t*)((char*)q0_1)[4] = 0x451c;
080388d2          /* unimplemented  {vcmp.f32.F32 s0, s1} */
080388d6          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
080388d6          
080388da          if (false == r0_2 - 1)
080388da          {
080388e0              lockRecoveryCounters1 = 0;
080388e6              lockRecoveryCounters2 = 0;
080388ee              tStateStart_ms = TickType_t xTaskGetTickCount(void)();
080388f4              driveState = 2;
080388f8              logging_wrapper("MOWING_FORWARD\r\n", &driveState);
080388da          }
080388da          else if ((uint32_t)lockRecoveryCounters2 >= 0x65)
08038904          {
0803890a              lockRecoveryCounters1 = 0;
08038910              lockRecoveryCounters2 = 0;
08038912              motorStop();
08038916              motorBrake();
08038920              tStartWalk_ms = TickType_t xTaskGetTickCount(void)();
08038926              driveState = 3;
0803892a              logging_wrapper("MOWING_BACKWARD\r\n", &driveState);
08038904          }
080388ba      }
080388ba      else
080388ba      {
080388bc          motorStop();
080388c2          logging_wrapper("MOTOR_STATE_LOCKED --> MOTOR_STATE_STOPPED\r\n");
080388ba      }
080388ba      
08038a2a      return 5;
080388a2  }
08038930  int32_t data_8038930 = 0x437a0000
08038932    int32_t sub_8038932(int32_t arg1, int32_t arg2, int32_t arg3, char arg4 @ r4, int32_t arg5 @ r7, int32_t arg6 @ r10, int32_t arg7, int32_t arg8, int32_t arg9, int32_t arg10, int32_t arg11, int32_t arg12, int32_t arg13)
08038932  {
0803893e      if (!driveSubsystemState())
0803893e      {
08038946          if ((uint32_t)phaseCounter == 0xa)
08038946          {
08038948              motorBrake();
08038954              phaseCounter += 1;
08038946          }
08038946          else if ((uint32_t)phaseCounter < 0x15)
0803899e              phaseCounter += 1;
0803895e          else
0803895e          {
08038964              phaseCounter = 0;
0803896e              turnRetryCounter += 1;
0803896e              
08038974              if ((uint32_t)arg4 != 1)
08038974              {
080389a8                  if ((uint32_t)turnRetryCounter >= 0xa)
080389aa                      motorStop();
080389aa                  
080389b4                  if ((uint32_t)turnRetryCounter >= 0x13)
080389b4                  {
080389ba                      turnRetryCounter = 0;
080389bc                      motorStop();
080389c0                      motorBrake();
080389c8                      doBeep(&turnTable);
080389d0                      driveState = 1;
080389d4                      logging_wrapper("MOWING_STOP 3\r\n", &driveState);
080389da                      ui_set_stop_indicator(1);
080389e0                      ui_set_run_indicator(0);
080389e4                      return 6;
080389b4                  }
080389b4                  
080389ea                  int32_t r1;
080389ea                  int32_t r2;
080389ea                  r1 = turnCooldownActive(&data_2000e2a0);
080389f4                  int128_t q0;
080389f4                  
080389f4                  if ((uint32_t)turnSide != 4)
080389f4                  {
08038a10                      *(uint32_t*)((char*)q0)[8] = 0x41a00000;
08038a14                      *(uint32_t*)((char*)q0)[4] = 0;
08038a18                      (uint32_t)q0 = 0x43480000;
08038a1e                      commandMotion(4, r1, r2, q0);
08038a24                      logging_wrapper("MOWING_TURN_RIGHT\r\n");
080389f4                  }
080389f4                  else
080389f4                  {
080389f6                      *(uint32_t*)((char*)q0)[8] = 0x41a00000;
080389fa                      *(uint32_t*)((char*)q0)[4] = 0;
080389fe                      (uint32_t)q0 = 0xb5804348;
08038a04                      commandMotion(3, r1, r2, q0);
08038a0a                      logging_wrapper("MOWING_TURN_LEFT\r\n");
080389f4                  }
08038974              }
08038974              else
08038974              {
0803897a                  turnRetryCounter = 0;
0803897c                  sub_8038a30();
08038984                  driveState = 2;
0803898c                  tStateStart_ms = TickType_t xTaskGetTickCount(void)();
08038990                  logging_wrapper("MOWING_FORWARD\r\n", &tStartWalk_ms);
08038974              }
0803895e          }
0803893e      }
0803893e      
08038a28      return 5;
08038932  }
08038a2c  int32_t data_8038a2c = 0x43070000
08038a30    int32_t sub_8038a30()
08038a30  {
08038a3a      int64_t q0;
08038a3a      
08038a3a      if (!isDriveSubsystemReady(2))
08038a94          lockRecoveryCounters1 = 0;
08038a3a      else
08038a3a      {
08038a46          if (TickType_t xTaskGetTickCount(void)() >= tStartWalk_ms)
08038a58              tStartWalk_ms;
08038a46          else
08038a4e              tStartWalk_ms;
08038a4e          
08038a5e          reduceSpeedOrGuard(2);
08038a62          *(uint32_t*)((char*)q0)[4] = 0x44fa;
08038a66          /* unimplemented  {vcmp.f32.F32 s0, s1} */
08038a6a          /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08038a8c          lockRecoveryCounters1 = 0;
08038a3a      }
08038a3a      
08038a9c      if (!driveSubsystemState())
08038a9c      {
08038a9e          *(uint32_t*)((char*)q0)[4] = 0xe30843af;
08038aa2          (uint32_t)q0 = 0xe30843af;
08038aa6          sub_802d226(q0);
08038ab0          tStateStart_ms = TickType_t xTaskGetTickCount(void)();
08038a9c      }
08038a9c      
08038ab4      return 1;
08038a30  }
08038ab6                                                                    00 00 01 40                                          ...@
08038aba  int32_t data_8038aba = 0x451c
08038abe  int32_t data_8038abe = 0x0
08038ac2  int32_t data_8038ac2 = -0x4a7fbcb8
08038ac4  // // Advances through a 7-entry float table in RAM every ~240 s and feeds it to
08038ac4  // the turn controller.
08038ac4  // // Returns arg1 unchanged (likely fluent interface / placeholder).
08038ac4  
08038ac4    int32_t computeTurnCommand(int32_t arg1 @ r7)
08038ac4  {
08038aca      int32_t r0 = TickType_t xTaskGetTickCount(void)();
08038ad4      int32_t r1_2;
08038ad4      
08038ad4      if (r0 >= lastSampleTick)
08038ae8          r1_2 = r0 - lastSampleTick;
08038ad4      else
08038ae0          r1_2 = r0 + 0xffffffff - lastSampleTick;
08038ae0      
08038aee      if (r1_2 >= 0x3a981)
08038aee      {
08038b06          if ((uint32_t)currentIndex1 >= 7 || !(lastSampleTick / 0x3e8))
08038b0c              currentIndex1 = 0;
08038b06          else
08038b18              currentIndex1 += 1;
08038b18          
08038b1c          lastSampleTick = r0;
08038aee      }
08038aee      
08038b28      int64_t q4;
08038b28      (uint32_t)q4 = turnTable[(uint32_t)currentIndex1];
08038b30      float32_process((uint32_t)q4);
08038b3a      logging_wrapper("%f\r\n");
08038b3e      int128_t q0;
08038b3e      (uint32_t)q0 = (uint32_t)q4;
08038b46      return arg1;
08038ac4  }
08038b48                          00 00                                                                            ..
08038b4a    int32_t sub_8038b4a(int32_t arg1, int32_t arg2 @ r5, int32_t arg3 @ r7, int32_t arg4 @ r10)
08038b4a  {
08038b50      /* tailcall */
08038b50      return sub_8039164(arg1);
08038b4a  }
08038b52    int32_t sub_8038b52()
08038b52  {
08038b54      /* tailcall */
08038b54      return sub_80383a8();
08038b52  }
08038b56                                                                    00 20                                                . 
08038b58  int32_t data_8038b58 = 0x2000e148
08038b5c    int32_t j_sub_80190a0(int128_t arg1 @ q0)
08038b5c  {
08038b5c      /* tailcall */
08038b5c      return sub_80390a0(arg1);
08038b5c  }
08038b5e    int32_t sub_8038b5e(int32_t arg1, int32_t arg2, int32_t arg3) __pure
08038b5e  {
08038b64      return 0;
08038b5e  }
08038b66                    03 08                                                                                ..
08038b68  int32_t data_8038b68 = 0x803bab8
08038b6a    int32_t sub_8038b6a(int32_t arg1, int32_t arg2, int32_t arg3)
08038b6a  {
08038b6c      /* tailcall */
08038b6c      return mowing_state_step(arg1, arg2, arg3, arg1 >> 0x20);
08038b6a  }
08038b6e                                            00 20                                                                . 
08038b70  int32_t data_8038b70 = 0x803bd80
08038b74  int32_t data_8038b74 = 0x803bacc
08038b78  int32_t data_8038b78 = 0x2000e30c
08038b7c  int32_t data_8038b7c = 0x2000e42c
08038b80  int32_t data_8038b80 = 0x2000e42a
08038b84  int32_t data_8038b84 = 0x2000e42b
08038b88  int32_t data_8038b88 = 0x408f4000
08038b8c  int32_t data_8038b8c = 0x404e0000
08038b90  int32_t data_8038b90 = 0x403e0000
08038b94  int32_t data_8038b94 = 0x803bae0
08038b98  int32_t data_8038b98 = 0x803ac68
08038b9c  int32_t data_8038b9c = 0x803bd90
08038ba0  int32_t data_8038ba0 = 0x803baf4
08038ba4  int32_t data_8038ba4 = 0x803bb08
08038ba8  int32_t data_8038ba8 = 0x3a981
08038bac  int32_t data_8038bac = 0x20000000
08038bb0  int32_t data_8038bb0 = 0x803c050
08038bb4    int32_t sub_8038bb4(char* arg1)
08038bb4  {
08038bb6      *(uint8_t*)arg1 = 6;
08038bba      return 0;
08038bb4  }
08038bbc    int32_t sub_8038bbc()
08038bbc  {
08038bc2      data_2000e2dc = 0;
08038bca      data_2000e2dd = 0;
08038bd2      data_2000e2de = 0;
08038bda      data_2000e2df = 0;
08038be2      data_2000e2e0 = 0;
08038be4      return 0;
08038bbc  }
08038be6    int32_t ui_set_run_indicator(char arg1)
08038be6  {
08038bea      data_2000e433 = arg1;
08038bee      return 1;
08038be6  }
08038bf0    int32_t ui_set_stop_indicator(char arg1)
08038bf0  {
08038bf4      data_2000e431 = arg1;
08038bf8      return 1;
08038bf0  }
08038bfa    uint32_t sub_8038bfa(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
08038bfa  {
08038bfa      int32_t var_1c = arg2;
08038bfa      int32_t var_20 = arg1;
08038bfe      char r4 = 6;
08038c00      uint32_t r0 = sub_8032034();
08038c12      uint32_t r6_2 = (uint32_t)sub_8038dca((uint8_t)arg4, arg2, arg3, arg4);
08038c12      
08038c16      if (r6_2 != 0xb)
08038c16      {
08038c18          uint32_t r6_3 = (uint32_t)(uint8_t)r6_2;
08038c18          
08038c1c          if (r6_3 != 0xa)
08038c1c          {
08038c1e              uint32_t r6_4 = (uint32_t)(uint8_t)r6_3;
08038c1e              
08038c22              if (r6_4 != 8)
08038c22              {
08038c24                  uint32_t r6_5 = (uint32_t)(uint8_t)r6_4;
08038c24                  
08038c28                  if (r6_5 != 9)
08038c28                  {
08038c36                      uint32_t r7_1 = 0;
08038c36                      
08038c44                      if (!(uint32_t)data_2000e433)
08038c46                          r7_1 = (uint32_t)(uint8_t)arg3;
08038c46                      
08038c54                      if ((uint32_t)data_2000e2dc >= (uint32_t)(uint8_t)r6_5)
08038c54                      {
08038d10                          uint32_t r1_3 = (uint32_t)data_2000e2dc;
08038d10                          
08038d16                          if ((uint32_t)(uint8_t)r6_5 != r1_3)
08038d16                          {
08038d48                              if ((uint32_t)(uint8_t)r6_5 < (uint32_t)data_2000e2dc)
08038d4e                                  logging_wrapper("overlook this error\r\n", r1_3);
08038d16                          }
08038d16                          else if ((uint32_t)(uint8_t)r6_5 - 5 <= 1
08038d16                                  && (uint32_t)data_2000e2dd == 5
08038d16                                  && (uint32_t)data_2000e2de >= 3)
08038d3a                              data_2000e2dd = 0;
08038c54                      }
08038c54                      else
08038c54                      {
08038c56                          uint32_t r6_6 = (uint32_t)(uint8_t)r6_5;
08038c56                          
08038c5a                          if (r6_6 == 4)
08038c5a                          {
08038c70                              data_2000e2dd = 0;
08038c76                              logging_wrapper("[ERROR_HANDLING_COLLISION]ReturnHMI\r\n", 
08038c76                                  &data_2000e2dc);
08038c7a                              int32_t r3 = sub_8038fa8(r7_1);
08038c80                              doBeep(1);
08038c8a                              sub_80282e4(0x58, 0, 1, r3, r0);
08038c92                              sub_80283b6(0, 1);
08038c96                              return 0;
08038c5a                          }
08038c5a                          
08038c5c                          if (r6_6 >= 4)
08038c5c                          {
08038c60                              if (r6_6 == 6)
08038c60                              {
08038ce8                                  motorStop();
08038cec                                  motorBrake();
08038cf6                                  data_2000e2dd = 0;
08038c60                              }
08038c60                              else if (r6_6 < 6)
08038c62                              {
08038c9a                                  motorStop();
08038c9e                                  motorBrake();
08038ca8                                  data_2000e2dd = 0;
08038cae                                  data_2000e433;
08038cae                                  
08038cbc                                  if (sub_8038fba((uint32_t)(uint8_t)r0, 5) == 1)
08038cbc                                  {
08038cc2                                      logging_wrapper(sub_803af88+0x2c);
08038cc6                                      int32_t r3_1 = sub_8038fa8(r7_1);
08038ccc                                      doBeep(2);
08038cd6                                      sub_80282e4(0x4c, 0, 1, r3_1, r0);
08038cde                                      sub_80283b6(0, 1);
08038ce2                                      return 0;
08038cbc                                  }
08038c62                              }
08038c62                              else if (r6_6 == 7)
08038d00                                  data_2000e2dd = 0;
08038c5c                          }
08038c5c                          
08038d06                          data_2000e2dc = (char)r6_6;
08038c54                      }
08038c54                      
08038d5c                      int32_t r2_1 =
08038d5c                          logging_wrapper("[debug]EHMType:%d\r\n", (uint32_t)data_2000e2dc);
08038d66                      int32_t r0_16 = (uint32_t)data_2000e2dc - 1;
08038d66                      
08038d6a                      if (r0_16 <= 1)
08038d6a                      {
08038da2                          motorStop();
08038da6                          motorBrake();
08038dae                          sub_80283b6(0, 1);
08038db2                          return 0;
08038d6a                      }
08038d6a                      
08038d74                      if (r0_16 != 2 && r0_16 - 4 > 1)
08038d74                      {
08038d78                          if (r0_16 != 6)
08038dc6                              return 7;
08038dc6                          
08038dc2                          r4 = sub_8039124((uint8_t)r7_1, (uint32_t)(uint8_t)r0, r2_1);
08038d74                      }
08038d74                      else if (!(uint32_t)data_2000e433)
08038d92                          r4 = sub_803902c((uint8_t)r7_1, (uint32_t)(uint8_t)r0, r2_1);
08038d92                      
08038d94                      uint32_t r4_1 = (uint32_t)r4;
08038d94                      
08038d98                      if (r4_1 == 0xf)
08038d9a                          r4_1 = 5;
08038d9a                      
08038d9e                      return (uint32_t)(uint8_t)r4_1;
08038c28                  }
08038c22              }
08038c1c          }
08038c16      }
08038c16      
08038c2e      sub_80283b6(0, 1);
08038c32      return 0;
08038bfa  }
08038dca    uint32_t sub_8038dca(char arg1, int32_t arg2, int32_t arg3, int32_t arg4)
08038dca  {
08038dca      int32_t var_10 = arg4;
08038dce      int32_t r5 = 0;
08038dce      
08038dd8      if (safetyCheck(5) != 1)
08038dd8      {
08038e08          int32_t r7;
08038e08          
08038e08          if (safetyCheck(2) != 1)
08038e08          {
08038e32              if (safetyCheck(7) != 1)
08038e32              {
08038e5c                  if (safetyCheck(8) != 1)
08038e5c                  {
08038e86                      if (safetyCheck(6) == 1)
08038e86                      {
08038e8e                          sub_80282e4(0x9f, 0, 1, arg4, 0);
08038e92                          r5 = 1;
08038e98                          arg4 = logging_wrapper("[ERROR_HANDLING_RAIN]\r\n");
08038e86                      }
08038e86                      
08038ea0                      if ((uint32_t)arg1 == 5)
08038ea0                      {
08038ea8                          sub_80282e4(0xa0, 0, 1, arg4, r5);
08038eac                          r5 = 2;
08038eb2                          arg4 = logging_wrapper("[BATTERY_WORKING_ERROR]\r\n");
08038ea0                      }
08038ea0                      
08038ebe                      if (safetyCheck(0) == 1)
08038ebe                      {
08038ec6                          sub_80282e4(0x81, 0, 1, arg4, r5);
08038eca                          r5 = 3;
08038ed0                          arg4 = logging_wrapper("[ERROR_HANDLING_CRASH]\r\n");
08038ed8                          safetyEventSet(0, 0);
08038ebe                      }
08038ebe                      
08038ee4                      if (safetyCheck(0xb) == 1)
08038ee4                      {
08038eec                          sub_80282e4(0x81, 0, 1, arg4, r5);
08038ef0                          r5 = 4;
08038ef6                          arg4 = logging_wrapper("[ERROR_HANDLING_10S_CRASH]\r\n");
08038efe                          safetyEventSet(0, 0);
08038f06                          safetyEventSet(0xa, 0);
08038f0e                          safetyEventSet(0xb, 0);
08038ee4                      }
08038ee4                      
08038f1a                      if (safetyCheck(3) == 1 && safetyCheck(4) == 1)
08038f1a                      {
08038f2c                          sub_80282e4(0x82, 0, 1, arg4, r5);
08038f30                          r5 = 5;
08038f36                          arg4 = logging_wrapper("[ERROR_HANDLING_LIFT]\r\n");
08038f3e                          safetyEventSet(3, 0);
08038f46                          safetyEventSet(4, 0);
08038f1a                      }
08038f1a                      
08038f52                      if (safetyCheck(1) == 1)
08038f52                      {
08038f5a                          sub_80282e4(0x83, 0, 1, arg4, r5);
08038f5e                          r5 = 6;
08038f64                          arg4 = logging_wrapper("[ERROR_HANDLING_LEAN]\r\n");
08038f6c                          safetyEventSet(1, 0);
08038f52                      }
08038f52                      
08038f78                      if ((uint32_t)data_2000e431 == 1)
08038f78                      {
08038f80                          sub_80282e4(0x84, 0, 1, arg4, r5);
08038f84                          r5 = 7;
08038f8a                          logging_wrapper("[ERROR_HANDLING_BORDER]\r\n");
08038f94                          data_2000e431 = 0;
08038f78                      }
08038e5c                  }
08038e5c                  else
08038e5c                  {
08038e62                      logging_wrapper("[ERROR_HANDLING_CONT_LEAN]\r\n");
08038e66                      r5 = 9;
08038e68                      int32_t r3_3 = sub_8038fa8(r7);
08038e6e                      doBeep(4);
08038e78                      sub_80282e4(0x54, 0, 1, r3_3, 9);
08038e5c                  }
08038e32              }
08038e32              else
08038e32              {
08038e38                  logging_wrapper("[ERROR_HANDLING_CONT_LIFT]\r\n");
08038e3c                  r5 = 8;
08038e3e                  int32_t r3_2 = sub_8038fa8(r7);
08038e44                  doBeep(2);
08038e4e                  sub_80282e4(0x4c, 0, 1, r3_2, 8);
08038e32              }
08038e08          }
08038e08          else
08038e08          {
08038e0e              logging_wrapper("[ERROR_HANDLING_TURN_OVER]\r\n");
08038e12              r5 = 0xa;
08038e14              int32_t r3_1 = sub_8038fa8(r7);
08038e1a              doBeep(8);
08038e24              sub_80282e4(0x52, 0, 1, r3_1, 0xa);
08038e08          }
08038dd8      }
08038dd8      else
08038dd8      {
08038dde          logging_wrapper("[ERROR_HANDLING_STOP_BUTTON]\r\n");
08038de2          r5 = 0xb;
08038de4          motorStop();
08038de8          int32_t r3 = motorBrake();
08038df0          doBeep(0x8000000);
08038dfa          sub_80282e4(0x8a, 0, 1, r3, 0xb);
08038dd8      }
08038dd8      
08038f96      uint32_t r5_1 = (uint32_t)(uint8_t)r5;
08038f9e      logging_wrapper("[debug]curErrType:%d\r\n", r5_1);
08038fa6      return (uint32_t)(uint8_t)r5_1;
08038dca  }
08038fa8    int32_t sub_8038fa8(int32_t arg1 @ r7)
08038fa8  {
08038faa      motorStop();
08038fae      motorBrake();
08038fb4      sub_8028be8(1);
08038fb8      return arg1;
08038fa8  }
08038fba    int32_t sub_8038fba(int32_t arg1, char arg2)
08038fba  {
08038fba      int32_t r7;
08038fba      int32_t var_8 = r7;
08038fba      
08038fc0      if ((uint32_t)arg2 == 3)
08038fc0      {
08038fc2          int32_t r0 = TickType_t xTaskGetTickCount(void)();
08038fce          int32_t r1_3;
08038fce          
08038fce          if (r0 >= data_2000e318)
08038fe6              r1_3 = r0 - data_2000e318;
08038fce          else
08038fdc              r1_3 = r0 + 0xffffffff - data_2000e318;
08038fdc          
08038fec          data_2000e318 = r0;
08038fec          
08038ff8          if (r1_3 / 0x3e8 >= 5)
08039010              data_2000e432 = 0;
08038ff8          else
08039006              data_2000e432 += 1;
08039006          
0803901a          if ((uint32_t)data_2000e432 >= 6)
0803901a          {
08039022              data_2000e432 = 0;
08039024              return 1;
0803901a          }
08038fc0      }
08038fc0      
08039028      return 0;
08038fba  }
0803902c    uint32_t sub_803902c(char arg1, int32_t arg2, int32_t arg3)
0803902c  {
08039036      uint32_t r1 = (uint32_t)data_2000e2dd;
08039036      
0803903a      if (!r1)
0803903a      {
08039052          int128_t q0;
08039052          *(uint32_t*)((char*)q0)[8] = 0;
08039056          *(uint32_t*)((char*)q0)[4] = 0x41a00000;
0803905a          (uint32_t)q0 = 0xb580437a;
08039060          int32_t r0_2 = commandMotion(2, r1, arg3, q0);
0803906a          data_2000e2dd = 2;
08039072          data_2000e2df = 0;
08039072          /* tailcall */
08039072          return sub_8039074(r0_2);
0803903a      }
0803903a      
0803903e      if (r1 != 2)
0803903e      {
08039046          if (r1 != 3 && r1 != 4)
08039046          {
0803904a              if (r1 != 5)
0803904a              {
0803904e                  if (r1 == 6)
08039076                      return (uint32_t)(uint8_t)arg2;
08039076                  
08039050                  /* tailcall */
08039050                  return sub_8039074(arg2);
0803904a              }
0803904a              
08039106              data_2000e2de += 1;
0803910a              uint32_t r0_15 = (uint32_t)data_2000e2de;
0803910a              
0803910e              if (r0_15 >= 6)
0803910e              {
08039114                  data_2000e2de = 0;
0803911a                  data_2000e2dd = 6;
0803910e              }
0803910e              
0803911c              /* tailcall */
0803911c              return sub_8039074(r0_15);
08039046          }
08039046          
080390e8          int32_t r0_11 = driveSubsystemState();
080390e8          
080390ee          if (!r0_11)
080390ee          {
080390f4              data_2000e2dd = 5;
080390fa              data_2000e2de = 0;
080390ee          }
080390ee          
080390fc          /* tailcall */
080390fc          return sub_8039074(r0_11);
0803903e      }
0803903e      
08039078      int32_t r0_4 = driveSubsystemState();
08039078      
0803907e      if (!r0_4)
0803907e      {
08039088          if ((uint32_t)data_2000e2df < 6)
08039088          {
080390ae              int32_t r0_8 = (uint32_t)data_2000e2df + 1;
080390b2              data_2000e2df = (char)r0_8;
080390b4              /* tailcall */
080390b4              return sub_8039074(r0_8);
08039088          }
08039088          
08039090          data_2000e2df = 0;
08039092          int32_t r1_1;
08039092          int32_t r2;
08039092          int32_t r7;
08039092          int128_t q0_1;
08039092          r1_1 = sub_80392c4(r7);
08039096          *(uint32_t*)((char*)q0_1)[8] = (uint32_t)q0_1;
0803909a          uint32_t r4_1 = (uint32_t)arg1;
0803909a          
0803909e          if (r4_1 == 1)
0803909e              /* tailcall */
0803909e              return sub_80390a0(q0_1);
0803909e          
080390ba          if ((uint32_t)(uint8_t)r4_1 != 3)
080390ba          {
080390d2              *(uint32_t*)((char*)q0_1)[4] = 0;
080390d6              (uint32_t)q0_1 = 0x4348;
080390dc              r0_4 = commandMotion(4, r1_1, r2, q0_1);
080390e4              data_2000e2dd = 4;
080390ba          }
080390ba          else
080390ba          {
080390bc              *(uint32_t*)((char*)q0_1)[4] = 0;
080390c0              (uint32_t)q0_1 = 0x43480000;
080390c6              r0_4 = commandMotion(3, r1_1, r2, q0_1);
080390ce              data_2000e2dd = 3;
080390ba          }
0803907e      }
0803907e      
080390e6      /* tailcall */
080390e6      return sub_8039074(r0_4);
0803902c  }
08039074    int32_t sub_8039074(int32_t arg1) __pure
08039074  {
08039076      return 6;
08039074  }
080390a0    int32_t sub_80390a0(int128_t arg1 @ q0)
080390a0  {
080390a0      (uint32_t)arg1 = *(uint32_t*)((char*)arg1)[8];
080390a8      /* tailcall */
080390a8      return sub_8039074(sub_8039324(arg1));
080390a0  }
08039122        00 00                                                                                        ..
08039124    uint32_t sub_8039124(char arg1, int32_t arg2, int32_t arg3)
08039124  {
0803912e      uint32_t r1 = (uint32_t)data_2000e2dd;
08039132      int128_t q0;
08039132      
08039132      if (!r1)
08039132      {
08039144          *(uint32_t*)((char*)q0)[8] = 0x42100000;
08039148          *(uint32_t*)((char*)q0)[4] = 0;
0803914c          (uint32_t)q0 = 0x43480000;
08039152          commandMotion(3, r1, arg3, q0);
0803915a          data_2000e2dd = 3;
08039160          data_2000e2df = 0;
08039162          /* tailcall */
08039162          return sub_8039164(0);
08039132      }
08039132      
08039136      if (r1 == 3)
08039136      {
0803916a          uint32_t r0_3;
0803916a          int32_t r2;
0803916a          r0_3 = driveSubsystemState();
0803916a          
08039170          if (!r0_3)
08039170          {
08039174              r0_3 = (uint32_t)data_2000e2df;
08039174              
08039178              if (r0_3 < 6)
08039178              {
08039192                  int32_t r0_5 = (uint32_t)data_2000e2df + 1;
08039196                  data_2000e2df = (char)r0_5;
08039198                  /* tailcall */
08039198                  return sub_8039260(r0_5);
08039178              }
08039178              
0803917e              data_2000e2df = 0;
0803917e              
08039184              if ((uint32_t)arg1 == 1)
0803918a                  data_2000e2dd = 6;
08039184              else if ((uint32_t)data_2000e2e0 < 0xb)
080391a0              {
080391bc                  *(uint32_t*)((char*)q0)[8] = 0x42100000;
080391c0                  *(uint32_t*)((char*)q0)[4] = 0;
080391c4                  (uint32_t)q0 = 0x43480000;
080391ca                  commandMotion(3, &data_2000e2dc, r2, q0);
080391d2                  data_2000e2dd = 3;
080391d8                  r0_3 = (uint32_t)data_2000e2e0 + 1;
080391dc                  data_2000e2e0 = (char)r0_3;
080391a0              }
080391a0              else
080391a0              {
080391a2                  *(uint32_t*)((char*)q0)[8] = 0x4210;
080391a6                  *(uint32_t*)((char*)q0)[4] = 0;
080391aa                  (uint32_t)q0 = 0x4348;
080391b0                  r0_3 = commandMotion(4, &data_2000e2dc, r2, q0);
080391b8                  data_2000e2dd = 4;
080391a0              }
08039170          }
08039170          
080391de          /* tailcall */
080391de          return sub_8039260(r0_3);
08039136      }
08039136      
0803913a      if (r1 == 4)
0803913a      {
080391e0          uint32_t r0_10;
080391e0          int32_t r2_1;
080391e0          r0_10 = driveSubsystemState();
080391e0          
080391e6          if (!r0_10)
080391e6          {
080391ea              r0_10 = (uint32_t)data_2000e2df;
080391ea              
080391ee              if (r0_10 < 6)
080391ee              {
08039208                  int32_t r0_12 = (uint32_t)data_2000e2df + 1;
0803920c                  data_2000e2df = (char)r0_12;
0803920e                  /* tailcall */
0803920e                  return sub_8039260(r0_12);
080391ee              }
080391ee              
080391f4              data_2000e2df = 0;
080391f4              
080391fa              if ((uint32_t)arg1 != 1)
080391fa              {
08039212                  r0_10 = (uint32_t)data_2000e2e0;
08039212                  
08039216                  if (r0_10 < 0x15)
08039216                  {
08039220                      *(uint32_t*)((char*)q0)[8] = 0x42100000;
08039224                      *(uint32_t*)((char*)q0)[4] = 0;
08039228                      (uint32_t)q0 = 0x43480000;
0803922e                      commandMotion(4, &data_2000e2dc, r2_1, q0);
08039236                      data_2000e2dd = 4;
0803923c                      r0_10 = (uint32_t)data_2000e2e0 + 1;
08039240                      data_2000e2e0 = (char)r0_10;
08039216                  }
08039216                  else
0803921c                      data_2000e2dd = 6;
080391fa              }
080391fa              else
08039200                  data_2000e2dd = 6;
080391e6          }
080391e6          
08039242          /* tailcall */
08039242          return sub_8039260(r0_10);
0803913a      }
0803913a      
0803913e      if (r1 != 6)
08039142          /* tailcall */
08039142          return sub_8039260(arg2);
08039142      
08039244      uint32_t r4_3 = (uint32_t)arg1;
08039244      
08039248      if (r4_3 == 1)
0803924a          return (uint32_t)(uint8_t)arg2;
0803924a      
08039252      if (!(uint32_t)(uint8_t)r4_3)
08039252      {
08039256          int32_t r0_17 = logging_wrapper("wait border");
0803925e          data_2000e2e0 = 1;
0803925e          /* tailcall */
0803925e          return sub_8039260(r0_17);
08039252      }
08039252      
08039268      uint32_t r0_19 = (uint32_t)data_2000e2e0;
08039268      
0803926c      if (r0_19 < 0x15)
0803926c      {
08039272          data_2000e2dd = 0;
08039274          /* tailcall */
08039274          return sub_8039260(r0_19);
0803926c      }
0803926c      
08039276      motorStop();
0803927a      motorBrake();
08039280      sub_8028be8(1);
08039286      doBeep(0x10);
0803928c      char var_18;
0803928c      int32_t r3_1 = sub_8033e3c(&var_18);
08039296      int32_t r5;
08039296      char var_16;
08039296      
08039296      if ((uint32_t)var_18 != 1)
0803929e          sub_80282e4(0x37, 0, 1, r3_1, r5);
08039296      else if ((uint32_t)var_16)
080392b2          sub_80282e4(0xb4, 0, 1, r3_1, r5);
080392ba      sub_80283b6(0, 1);
080392be      return 0;
08039124  }
08039164    int32_t sub_8039164(int32_t arg1)
08039164  {
08039166      data_2000e2e0 = (char)arg1;
08039168      /* tailcall */
08039168      return sub_8039260(arg1);
08039164  }
08039260    int32_t sub_8039260(int32_t arg1) __pure
08039260  {
08039264      return 6;
08039260  }
080392c2        00 00                                                                                        ..
080392c4    int32_t sub_80392c4(int32_t arg1 @ r7)
080392c4  {
080392cc      uint32_t r0_1;
080392cc      
080392cc      if ((uint32_t)data_2000e2dc == 3)
080392ce          r0_1 = sub_8028b00();
080392ce      
080392d4      int128_t q0;
080392d4      
080392d4      if ((uint32_t)data_2000e2dc != 3 || !r0_1)
080392d4      {
080392ec          uint32_t r0_5 = (uint32_t)(uint8_t)(sub_8039454() % 4);
080392ec          
080392f0          if (!r0_5)
080392fe              (uint32_t)q0 = 0x41f00000;
080392f0          else if (r0_5 == 2)
0803930a              (uint32_t)q0 = 0x42c8;
080392f4          else if (r0_5 < 2)
08039304              (uint32_t)q0 = 0x42a00000;
080392f6          else if (r0_5 == 3)
08039310              (uint32_t)q0 = 0x42700000;
080392fa          else
08039316              (uint32_t)q0 = 0x41f00000;
080392d4      }
080392d4      else
080392d6          (uint32_t)q0 = 0x41200000;
0803931a      return arg1;
080392c4  }
0803931c  int32_t data_803931c = 0x0
08039320  00 00                                                                                            ..
08039322    int32_t sub_8039322(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4 @ r7)
08039322  {
08039322      int128_t q0;
08039322      /* tailcall */
08039322      return sub_8039324(q0);
08039322  }
08039324    int32_t sub_8039324(int128_t arg1 @ q0)
08039324  {
08039324      int32_t r7;
08039324      int32_t var_8 = r7;
0803932c      int32_t entry_r1;
0803932c      int32_t entry_r2;
0803932c      
0803932c      if ((uint32_t)data_2000e434 < 4)
0803932c      {
0803932e          *(uint32_t*)((char*)arg1)[8] = (uint32_t)arg1;
08039332          *(uint32_t*)((char*)arg1)[4] = 0xe2dc0000;
08039336          (uint32_t)arg1 = 0x4348;
0803933c          commandMotion(3, entry_r1, entry_r2, arg1);
08039344          data_2000e2dd = 3;
0803934e          data_2000e434 += 1;
0803934e          
08039356          if ((uint32_t)data_2000e434 >= 4)
0803935c              data_2000e434 = 4;
0803932c      }
0803932c      else if ((uint32_t)data_2000e434 >= 4)
08039366      {
08039368          *(uint32_t*)((char*)arg1)[8] = (uint32_t)arg1;
0803936c          *(uint32_t*)((char*)arg1)[4] = 0;
08039370          (uint32_t)arg1 = 0x43480000;
08039376          commandMotion(4, entry_r1, entry_r2, arg1);
0803937e          data_2000e2dd = 4;
08039388          data_2000e434 += 1;
08039388          
08039390          if ((uint32_t)data_2000e434 >= 8)
08039396              data_2000e434 = 0;
08039366      }
0803939a      return 1;
08039324  }
0803939c  int32_t data_803939c = 0x43480000
0803939e    int32_t sub_803939e(int32_t arg1 @ r6)
0803939e  {
080393b4      /* tailcall */
080393b4      return sub_8039970();
0803939e  }
080393b6                                                                    00 20                                                . 
080393b8  int32_t data_80393b8 = 0x2000e433
080393bc  int32_t data_80393bc = 0x2000e431
080393c0  int32_t data_80393c0 = 0x803ae28
080393c4  int32_t data_80393c4 = 0x803afb4
080393c8  int32_t data_80393c8 = 0x803b854
080393cc  int32_t data_80393cc = 0x803bb30
080393d0  int32_t data_80393d0 = 0x803b230
080393d4  int32_t data_80393d4 = 0x803b250
080393d8  int32_t data_80393d8 = 0x803b270
080393dc  int32_t data_80393dc = 0x803b290
080393e0  int32_t data_80393e0 = 0x803b86c
080393e4  int32_t data_80393e4 = 0x803b448
080393e8  int32_t data_80393e8 = 0x803b464
080393ec  int32_t data_80393ec = 0x803b2b0
080393f0  int32_t data_80393f0 = 0x803b884
080393f4  int32_t data_80393f4 = 0x803b89c
080393f8  int32_t data_80393f8 = 0x803b480
080393fc  int32_t data_80393fc = 0x803b8b4
08039400  int32_t data_8039400 = 0x2000e318
08039404  int32_t data_8039404 = 0x2000e432
08039408  int32_t data_8039408 = 0x803bf60
0803940c  int32_t data_803940c = 0x2000e434
08039410    int32_t turnCooldownActive(TurnCooldown* cd)
08039410  {
08039418      if (!(uint32_t)cd->init)
08039418      {
0803941c          cd->init = 1;
08039422          cd->lastTick = TickType_t xTaskGetTickCount(void)();
08039424          return 0;
08039418      }
08039418      
08039428      uint32_t r0_3 = TickType_t xTaskGetTickCount(void)();
08039430      uint32_t r1_3;
08039430      
08039430      if (r0_3 >= cd->lastTick)
08039440          r1_3 = r0_3 - cd->lastTick;
08039430      else
0803943a          r1_3 = r0_3 + 0xffffffff - cd->lastTick;
0803943a      
08039442      cd->lastTick = r0_3;
08039442      
08039448      if (cd->timeout < r1_3)
0803944e          return 0;
0803944e      
0803944a      return 1;
08039410  }
08039452                                                        00 00                                                        ..
08039454    int32_t sub_8039454()
08039454  {
08039454      int32_t r3;
08039454      int32_t var_18 = r3;
08039454      
08039482      if (!(uint32_t)data_20000ccc)
08039482      {
08039486          int32_t r3_3 = 0x3c6ef35f + 0x19660d * data_20000cd0;
0803948a          data_20000cd0 = r3_3;
0803948c          int32_t i_1 = 8;
08039492          data_20000cd0 = 0x3c6ef35f + 0x19660d * r3_3;
08039498          data_20000cd0 = 0x3c6ef35f + 0x19660d * (0x3c6ef35f + 0x19660d * r3_3);
0803949e          data_20000cd0 = 0x3c6ef35f
0803949e              + 0x19660d * (0x3c6ef35f + 0x19660d * (0x3c6ef35f + 0x19660d * r3_3));
080394a4          data_20000cd0 = 0x3c6ef35f + 0x19660d * (0x3c6ef35f
080394a4              + 0x19660d * (0x3c6ef35f + 0x19660d * (0x3c6ef35f + 0x19660d * r3_3)));
080394aa          data_20000cd0 = 0x3c6ef35f + 0x19660d * (0x3c6ef35f + 0x19660d * (0x3c6ef35f
080394aa              + 0x19660d * (0x3c6ef35f + 0x19660d * (0x3c6ef35f + 0x19660d * r3_3))));
080394b0          data_20000cd0 = 0x3c6ef35f + 0x19660d * (0x3c6ef35f + 0x19660d * (0x3c6ef35f
080394b0              + 0x19660d * (0x3c6ef35f
080394b0              + 0x19660d * (0x3c6ef35f + 0x19660d * (0x3c6ef35f + 0x19660d * r3_3)))));
080394b6          data_20000cd0 = 0x3c6ef35f + 0x19660d * (0x3c6ef35f + 0x19660d * (0x3c6ef35f
080394b6              + 0x19660d * (0x3c6ef35f + 0x19660d * (0x3c6ef35f
080394b6              + 0x19660d * (0x3c6ef35f + 0x19660d * (0x3c6ef35f + 0x19660d * r3_3))))));
080394b8          void* r3_11 = &data_20000cd8;
080394fc          int32_t i;
080394fc          
080394fc          do
080394fc          {
080394be              int32_t r12_2 = 0x3c6ef35f + 0x19660d * data_20000cd0;
080394c2              data_20000cd0 = r12_2;
080394c6              *(uint32_t*)r3_11 = r12_2;
080394ca              i = i_1;
080394ca              i_1 -= 1;
080394d0              int32_t r12_4 = 0x3c6ef35f + 0x19660d * data_20000cd0;
080394d4              data_20000cd0 = r12_4;
080394d8              *(uint32_t*)((char*)r3_11 + 4) = r12_4;
080394e0              int32_t r12_6 = 0x3c6ef35f + 0x19660d * data_20000cd0;
080394e4              data_20000cd0 = r12_6;
080394e8              *(uint32_t*)((char*)r3_11 + 8) = r12_6;
080394f0              int32_t r12_8 = 0x3c6ef35f + 0x19660d * data_20000cd0;
080394f4              data_20000cd0 = r12_8;
080394f8              *(uint32_t*)((char*)r3_11 + 0xc) = r12_8;
080394f8              r3_11 += 0x10;
080394fc          } while (i != 1);
08039500          (*(uint32_t*)data_20000cd4) = data_20000d54;
08039504          data_20000ccc = 1;
08039482      }
08039482      
0803950c      data_20000cd0 = 0x3c6ef35f + 0x19660d * data_20000cd0;
08039510      int32_t r1_2 = (uint32_t)data_20000cd4 & 0x1f;
08039518      (*(uint32_t*)data_20000cd4) = *(uint32_t*)(&data_20000cd8 + (r1_2 << 2));
0803951c      *(uint32_t*)(&data_20000cd8 + (r1_2 << 2)) = data_20000cd0;
08039526      return (*(uint32_t*)data_20000cd4) & 0x3fffffff;
08039454  }
08039528  int32_t data_8039528 = 0x20000ccc
0803952c  int32_t data_803952c = 0x3c6ef35f
08039530  int32_t data_8039530 = 0x19660d
08039534    int32_t sub_8039534(char* arg1)
08039534  {
08039536      *(uint8_t*)arg1 = 7;
0803953a      return 0;
08039534  }
0803953c    int32_t sub_803953c()
0803953c  {
08039542      data_2000e310 = 0;
0803954a      data_2000e42e = 0;
0803954c      return 0;
0803953c  }
0803954e    uint32_t sub_803954e(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
0803954e  {
0803954e      int32_t var_14 = arg2;
0803954e      int32_t var_18 = arg1;
08039550      char r4 = 7;
08039560      char r0_3 = 0;
08039566      uint32_t r5_2 = (uint32_t)sub_80395cc(sub_8032034(), arg2, arg3, arg4);
08039566      
0803956a      if (r5_2 == 5)
08039572          r0_3 = (uint8_t)arg3;
0803956a      else
0803956a      {
0803956c          r5_2 = (uint32_t)(uint8_t)r5_2;
0803956c          
08039570          if (r5_2 == 0xf)
08039572              r0_3 = (uint8_t)arg3;
0803956a      }
0803956a      
08039578      uint32_t r1_1 = (uint32_t)data_2000e42e;
08039578      
0803957c      if (!r1_1)
0803958a          r4 = (uint8_t)r5_2;
0803957c      else if (r1_1 == 2)
080395a0          r4 = sub_8039746();
08039580      else if (r1_1 < 2)
08039598          r4 = sub_803975c(r0_3, (uint32_t)(uint8_t)r5_2);
08039582      else if (r1_1 == 3)
08039586      {
080395a8          r4 = sub_8039746();
080395ac          sub_8028642(1);
08039586      }
08039586      
080395b0      uint32_t r4_1 = (uint32_t)r4;
080395b0      
080395b4      if (r4_1 == 0xf)
080395b6          r4_1 = 5;
080395b6      
080395b8      uint32_t r4_2 = (uint32_t)(uint8_t)r4_1;
080395b8      
080395bc      if (!r4_2)
080395c2          sub_80283b6(0, 1);
080395c2      
080395ca      return (uint32_t)(uint8_t)r4_2;
0803954e  }
080395cc    int32_t sub_80395cc(char arg1, int32_t arg2, int32_t arg3, int32_t arg4)
080395cc  {
080395cc      int32_t var_10 = arg4;
080395d0      char r5 = 0;
080395d0      
080395da      if (safetyEvent2_isSet(0) == 1)
080395da      {
080395ee          r5 = 3;
080395f6          arg4 = sub_80282e4(0x4d, 0, 1, arg4, 3);
080395da      }
080395da      else
080395da      {
080395dc          int32_t r0_1;
080395dc          r0_1 = driveSubsystemState();
080395dc          
080395e2          if (r0_1 == 3)
080395e2          {
080395ee              r5 = 3;
080395f6              arg4 = sub_80282e4(0x4d, 0, 1, arg4, 3);
080395e2          }
080395e2          else if (isDriveSubsystemReady(2) != 3)
080395ec          {
08039604              if (sub_8031c0c(3))
08039604              {
0803961c                  if (sub_8031c0c(0))
0803961c                  {
08039634                      if (sub_8031c0c(2))
08039634                      {
0803964c                          if (safetyEvent2_isSet(9) != 1)
0803964c                          {
08039664                              if (safetyEvent2_isSet(5) != 1)
08039664                              {
0803967c                                  if (safetyEvent2_isSet(1) != 1)
0803967c                                  {
08039692                                      if (sub_802cf46() != 1)
08039692                                      {
080396aa                                          if (safetyEvent2_isSet(0xc) != 1)
080396aa                                          {
080396bc                                              int32_t r0_11 = safetyEvent2_isSet(3);
080396c2                                              int32_t r0_12;
080396c2                                              
080396c2                                              if (r0_11 != 1)
080396c6                                                  r0_12 = safetyEvent2_isSet(4);
080396c6                                              
080396cc                                              if (r0_11 == 1 || r0_12 == 1)
080396cc                                              {
080396d6                                                  int32_t r0_14;
080396d6                                                  int32_t r1;
080396d6                                                  int32_t r2;
080396d6                                                  
080396d6                                                  if (safetyEvent2_isSet(3) != 1)
080396ea                                                      r0_14 =
080396ea                                                          sub_80282e4(0x98, 0, 1, arg4, 0);
080396d6                                                  else
080396de                                                      r0_14 =
080396de                                                          sub_80282e4(0x97, 0, 1, arg4, 0);
080396de                                                  
080396f0                                                  /* tailcall */
080396f0                                                  return sub_80396f2(r0_14, r1, r2);
080396cc                                              }
080396aa                                          }
080396aa                                          else
080396aa                                          {
080396ac                                              r5 = 2;
080396b4                                              arg4 = sub_80282e4(0xa7, 0, 1, arg4, 2);
080396aa                                          }
08039692                                      }
08039692                                      else
08039692                                      {
08039694                                          r5 = 2;
0803969c                                          arg4 = sub_80282e4(0x99, 0, 1, arg4, 2);
08039692                                      }
0803967c                                  }
0803967c                                  else
0803967c                                  {
0803967e                                      r5 = 2;
08039686                                      arg4 = sub_80282e4(0x36, 0, 1, arg4, 2);
0803967c                                  }
08039664                              }
08039664                              else
08039664                              {
08039666                                  r5 = 2;
0803966e                                  arg4 = sub_80282e4(0x61, 0, 1, arg4, 2);
08039664                              }
0803964c                          }
0803964c                          else
0803964c                          {
0803964e                              r5 = 2;
08039656                              arg4 = sub_80282e4(0x72, 0, 1, arg4, 2);
0803964c                          }
08039634                      }
08039634                      else
08039634                      {
08039636                          r5 = 2;
0803963e                          arg4 = sub_80282e4(0x71, 0, 1, arg4, 2);
08039634                      }
0803961c                  }
0803961c                  else
0803961c                  {
0803961e                      r5 = 2;
08039626                      arg4 = sub_80282e4(0x62, 0, 1, arg4, 2);
0803961c                  }
08039604              }
08039604              else
08039604              {
08039606                  r5 = 2;
0803960e                  arg4 = sub_80282e4(0x70, 0, 1, arg4, 2);
08039604              }
080395ec          }
080395ec          else
080395ec          {
080395ee              r5 = 3;
080395f6              arg4 = sub_80282e4(0x4d, 0, 1, arg4, 3);
080395ec          }
080395da      }
080395da      
0803970e      if ((uint32_t)data_2000e42e >= (uint32_t)r5)
0803970e      {
08039724          uint32_t r5_2 = (uint32_t)r5;
08039724          
08039730          if (!r5_2 && !(uint32_t)data_2000e42e)
08039730          {
08039736              data_2000e42e = 2;
0803973e              sub_80282e4(0x73, 0, 1, arg4, r5_2);
08039730          }
0803970e      }
0803970e      else
0803970e      {
08039710          uint32_t r5_1 = (uint32_t)r5;
08039710          
08039714          if (r5_1 == 1)
0803971c              data_2000e314 = TickType_t xTaskGetTickCount(void)();
0803971c          
08039720          data_2000e42e = (char)r5_1;
0803970e      }
0803970e      
08039744      return 1;
080395cc  }
080396f2    int32_t sub_80396f2(int32_t arg1, int32_t arg2, int32_t arg3)
080396f2  {
080396f2      int32_t entry_r3;
080396f2      char r5;
080396f2      bool z;
080396f2      
080396f2      if (!z)
08039702          r5 = 1;
080396f2      else
080396f2      {
080396f4          r5 = 2;
080396fc          entry_r3 = sub_80282e4(0x35, 0, 1, entry_r3, 2);
080396f2      }
080396f2      
0803970e      if ((uint32_t)data_2000e42e >= (uint32_t)r5)
0803970e      {
08039724          uint32_t r5_2 = (uint32_t)r5;
08039724          
08039730          if (!r5_2 && !(uint32_t)data_2000e42e)
08039730          {
08039736              data_2000e42e = 2;
0803973e              sub_80282e4(0x73, 0, 1, entry_r3, r5_2);
08039730          }
0803970e      }
0803970e      else
0803970e      {
08039710          uint32_t r5_1 = (uint32_t)r5;
08039710          
08039714          if (r5_1 == 1)
0803971c              data_2000e314 = TickType_t xTaskGetTickCount(void)();
0803971c          
08039720          data_2000e42e = (char)r5_1;
0803970e      }
0803970e      
08039744      return 1;
080396f2  }
08039746    int32_t sub_8039746()
08039746  {
08039746      int32_t r7;
08039746      int32_t var_8 = r7;
08039748      motorStop();
0803974c      motorBrake();
08039752      sub_8028be8(2);
08039758      return 0;
08039746  }
0803975a                                                                                00 00                                        ..
0803975c    uint32_t sub_803975c(char arg1, int32_t arg2)
0803975c  {
0803975c      int32_t r3;
0803975c      int32_t var_10 = r3;
0803975c      
0803976a      if (safetyCheck(5) == 1)
0803976a      {
0803976c          motorStop();
08039770          int32_t r3_1 = motorBrake();
08039778          doBeep(0x8000000);
08039782          sub_80282e4(0x8a, 0, 1, r3_1, arg2);
08039786          return 0;
0803976a      }
0803976a      
08039792      if (safetyCheck(2) == 1)
08039792      {
08039794          motorStop();
08039798          int32_t r3_2 = motorBrake();
0803979e          sub_8028be8(1);
080397a4          doBeep(8);
080397ae          sub_80282e4(0x52, 0, 1, r3_2, arg2);
080397b2          return 0;
08039792      }
08039792      
080397be      if (safetyCheck(7) == 1)
080397be      {
080397c0          motorStop();
080397c4          int32_t r3_3 = motorBrake();
080397ca          sub_8028be8(1);
080397d0          doBeep(2);
080397da          sub_80282e4(0x4c, 0, 1, r3_3, arg2);
080397de          return 0;
080397be      }
080397be      
080397ea      if (safetyCheck(8) == 1)
080397ea      {
080397ec          motorStop();
080397f0          int32_t r3_4 = motorBrake();
080397f6          sub_8028be8(1);
080397fc          doBeep(4);
08039806          sub_80282e4(0x54, 0, 1, r3_4, arg2);
0803980a          return 0;
080397ea      }
080397ea      
08039810      int32_t r0_5;
08039810      int32_t r2_1;
08039810      r0_5 = safetyEvent2_isSet(3);
08039816      int32_t r0_6;
08039816      
08039816      if (r0_5 != 1)
0803981a          r0_6 = safetyEvent2_isSet(4);
0803981a      
08039820      int32_t* r1_4;
08039820      int128_t q0;
08039820      
08039820      if (r0_5 != 1 && r0_6 != 1)
08039820      {
0803989a          r1_4 = &data_2000e314;
0803989c          data_2000e314 = TickType_t xTaskGetTickCount(void)();
08039820      }
08039820      else
08039820      {
08039822          int32_t r0_7 = TickType_t xTaskGetTickCount(void)();
0803982c          int32_t r0_8;
0803982c          
0803982c          if (r0_7 >= data_2000e314)
08039840              r0_8 = r0_7 - data_2000e314;
0803982c          else
0803982c          {
08039834              r2_1 = data_2000e314;
08039838              r0_8 = r0_7 + 0xffffffff - r2_1;
0803982c          }
0803982c          
0803984c          if (r0_8 / 0x3e8 >= 0xc)
0803984c          {
08039856              if (safetyEvent2_isSet(3) != 1 && safetyEvent2_isSet(4) != 1)
08039880                  return (uint32_t)(uint8_t)arg2;
08039880              
08039862              motorStop();
08039866              int32_t r3_5 = motorBrake();
0803986c              sub_8028be8(2);
08039876              sub_80282e4(0x35, 0, 1, r3_5, arg2);
0803987a              return 0;
0803984c          }
0803984c          
08039884          r1_4 = 0x3e8;
08039884          
0803988e          if (r0_8 / 0x3e8 >= 0xb)
08039890              r1_4 = motorBrake();
08039820      }
08039820      
080398a0      uint32_t r0_14 = (uint32_t)data_2000e310;
080398a0      
080398a4      if (!r0_14)
080398a4      {
080398bc          if ((uint32_t)arg1 == 1)
080398bc          {
080398c4              *(uint32_t*)((char*)q0)[8] = 0;
080398c8              *(uint32_t*)((char*)q0)[4] = 0x41a00000;
080398cc              (uint32_t)q0 = 0x43480000;
080398d2              commandMotion(2, r1_4, r2_1, q0);
080398da              data_2000e310 = 2;
080398bc          }
080398bc          else
080398be              sub_8039970();
080398a4      }
080398a4      else if (r0_14 == 2)
080398a8      {
080398e4          if (!driveSubsystemState())
080398e6              sub_8039970();
080398e4          else if ((uint32_t)arg1 == 2)
080398f0          {
080398f2              int32_t r1_5;
080398f2              int32_t r2_2;
080398f2              int128_t q0_1;
080398f2              r1_5 = motorBrake();
080398f6              *(uint32_t*)((char*)q0_1)[8] = 0;
080398fa              *(uint32_t*)((char*)q0_1)[4] = 0x41200000;
080398fe              (uint32_t)q0_1 = 0x4348;
08039904              commandMotion(1, r1_5, r2_2, q0_1);
0803990c              data_2000e310 = 1;
080398f0          }
080398a8      }
080398a8      else if (r0_14 < 2)
080398aa      {
08039916          if (!driveSubsystemState())
08039918              sub_8039970();
080398aa      }
080398aa      else if (r0_14 == 4 || r0_14 < 4)
080398b0      {
08039924          if (!driveSubsystemState())
08039924          {
0803992a              data_2000e311 = 0;
08039930              data_2000e310 = 5;
08039924          }
080398b0      }
080398b0      else if (r0_14 == 5)
080398b4      {
0803993c          data_2000e311 += 1;
0803993c          
08039944          if ((uint32_t)data_2000e311 >= 5)
08039944          {
0803994a              data_2000e311 = 0;
0803994a              
08039954              if (safetyEvent2_isSet(3) != 1 && safetyEvent2_isSet(4) != 1)
0803996c                  return (uint32_t)(uint8_t)arg2;
0803996c              
08039964              data_2000e310 = 0;
08039944          }
080398b4      }
080398b4      
08039966      return 7;
0803975c  }
08039970    int32_t sub_8039970()
08039970  {
08039970      int32_t r7;
08039970      int32_t var_8 = r7;
08039978      int32_t entry_r1;
08039978      int32_t entry_r2;
08039978      int128_t q0;
08039978      
08039978      if ((uint32_t)data_2000e42f < 6)
08039978      {
0803997a          *(uint32_t*)((char*)q0)[8] = 0x4270;
0803997e          *(uint32_t*)((char*)q0)[4] = 0;
08039982          (uint32_t)q0 = 0xe3104316;
08039988          commandMotion(3, entry_r1, entry_r2, q0);
08039990          data_2000e310 = 3;
0803999a          data_2000e42f += 1;
0803999a          
080399a2          if ((uint32_t)data_2000e42f >= 6)
080399a8              data_2000e42f = 6;
08039978      }
08039978      else if ((uint32_t)data_2000e42f >= 6)
080399b2      {
080399b4          *(uint32_t*)((char*)q0)[8] = 0x42700000;
080399b8          *(uint32_t*)((char*)q0)[4] = 0;
080399bc          (uint32_t)q0 = 0x43160000;
080399c2          commandMotion(4, entry_r1, entry_r2, q0);
080399ca          data_2000e310 = 4;
080399d4          data_2000e42f += 1;
080399d4          
080399dc          if ((uint32_t)data_2000e42f >= 0xb)
080399e2              data_2000e42f = 0;
080399b2      }
080399e6      return 1;
08039970  }
080399e8  int32_t data_80399e8 = 0x0
080399ec  int32_t data_80399ec = 0x43480000
080399f0  int32_t data_80399f0 = 0x42700000
080399f4  int32_t data_80399f4 = 0x43160000
080399f8  int32_t data_80399f8 = 0x2000e310
080399fc  int32_t data_80399fc = 0x2000e42e
08039a00  int32_t data_8039a00 = 0x2000e314
08039a04  int32_t data_8039a04 = 0x2000e42f
08039a08    int32_t sub_8039a08(int32_t arg1 @ r7)
08039a08  {
08039a0a      sub_8039a3c();
08039a0e      sub_8028ae4();
08039a18      data_2000e436 = 0;
08039a20      data_2000e43a = 0;
08039a28      data_2000e437 = 0;
08039a30      data_2000e43c = 0;
08039a32      return arg1;
08039a08  }
08039a34    int32_t sub_8039a34(char* arg1)
08039a34  {
08039a36      *(uint8_t*)arg1 = 0;
08039a3a      return 1;
08039a34  }
08039a3c    int32_t sub_8039a3c()
08039a3c  {
08039a3c      int32_t r7;
08039a3c      int32_t var_8 = r7;
08039a46      data_2000e344 = TickType_t xTaskGetTickCount(void)();
08039a4a      return 1;
08039a3c  }
08039a4c    uint32_t sub_8039a4c()
08039a4c  {
08039a4c      int32_t r7;
08039a4c      int32_t var_8 = r7;
08039a56      data_2000e348 = TickType_t xTaskGetTickCount(void)();
08039a66      int32_t r0_3;
08039a66      
08039a66      if (data_2000e348 >= data_2000e344)
08039a8a          r0_3 = data_2000e348 - data_2000e344;
08039a66      else
08039a7a          r0_3 = data_2000e348 + 0xffffffff - data_2000e344;
08039a7a      
08039a94      return r0_3 / 0x3e8;
08039a4c  }
08039a96    int32_t sub_8039a96(int32_t arg1, int32_t arg2, char arg3, char arg4)
08039a96  {
08039a9e      char r0;
08039a9e      int32_t r2;
08039a9e      int32_t r3;
08039a9e      r0 = sub_802cea6();
08039a9e      
08039aa6      if ((uint32_t)r0)
08039aa6      {
08039b14          data_2000e437 = 0;
08039b18          sub_80271b6(0x3f);
08039b18          
08039b22          if (sub_8028bf2() != 2)
08039b26              sub_8028be8(0);
08039b26          
08039b2a          sub_8039a3c();
08039aa6      }
08039aa6      else
08039aa6      {
08039aae          data_2000e438 = 1;
08039aae          
08039ab8          if ((uint32_t)data_2000e439)
08039ab8          {
08039ac2              if ((uint32_t)data_2000e436 != 5)
08039ac2              {
08039aca                  if (!sub_802c5e2())
08039ae6                      sub_802c5da(1);
08039aca                  else
08039aca                  {
08039ad2                      if (!sub_8033b3e())
08039ad8                          sub_8033e90(1, 1, r2, r3);
08039ad8                      
08039ade                      sub_802c5da(0);
08039aca                  }
08039ac2              }
08039ac2              
08039af0              data_2000e439 = 0;
08039ab8          }
08039ab8          
08039af2          sub_8039d7c();
08039af2          
08039afe          if (sub_8039a4c() > 0x258)
08039b00              return 9;
08039b00          
08039b0a          data_2000e43b = 0;
08039aa6      }
08039aa6      
08039b36      if (!(uint32_t)data_2000e438)
08039b38          return 0;
08039b38      
08039b42      if (sub_8028bf2() == 2)
08039b42      {
08039b4c          if ((uint32_t)data_2000e43c != 1)
08039b4c          {
08039b54              data_2000e43c = 1;
08039b58              sub_802ce3e(4);
08039b4c          }
08039b4c          
08039b60          logging_wrapper("****Machine Breakdown********\n");
08039b60          
08039b6c          if (sub_8039a4c() <= 0x258)
08039b72              return 0;
08039b72          
08039b6e          return 9;
08039b42      }
08039b42      
08039b84      if (sub_8028bf2() == 1 && (uint32_t)data_2000e43c != 1)
08039b84      {
08039b8a          data_2000e43c = 1;
08039b8e          sub_802ce3e(1);
08039b84      }
08039b84      
08039b98      if (sub_8033faa())
08039b98      {
08039cd2          if (sub_802cea6())
08039cd4              sub_80271f6();
08039b98      }
08039b98      else
08039b98      {
08039ba2          if (sub_802cf4c())
08039ba2          {
08039baa              if (!(uint32_t)data_2000e439)
08039baa              {
08039bac                  sub_80271d8();
08039bb6                  data_2000e338 = TickType_t xTaskGetTickCount(void)();
08039baa              }
08039baa              
08039bbe              data_2000e33c = TickType_t xTaskGetTickCount(void)();
08039bbe              
08039bca              if (data_2000e33c >= data_2000e338)
08039bee                  data_2000e340 = data_2000e33c - data_2000e338;
08039bca              else
08039bde                  data_2000e340 = data_2000e33c + 0xffffffff - data_2000e338;
08039bde              
08039bfa              if (data_2000e340 < 0x2711)
08039c10                  data_2000e439 = 1;
08039bfa              else
08039bfa              {
08039c00                  doBeep(&turnTable);
08039c08                  data_2000e436 = 5;
08039bfa              }
08039ba2          }
08039ba2          
08039c18          if (sub_802cf64() == 1)
08039c18          {
08039c1a              sub_80271d8();
08039c22              data_2000e436 = 2;
08039c18          }
08039c18          
08039c34          if (sub_802cf52() >= 0x3e8 && !(uint32_t)data_2000e43b)
08039c34          {
08039c36              sub_80271d8();
08039c3e              data_2000e436 = 3;
08039c44              data_2000e43b = 1;
08039c34          }
08039c34          
08039c56          if (sub_802cf58() >= 0x3e8 && !(uint32_t)data_2000e43b)
08039c56          {
08039c58              sub_80271d8();
08039c60              data_2000e436 = 4;
08039c66              data_2000e43b = 1;
08039c56          }
08039c56          
08039c6e          if (sub_802cf5e() == 1)
08039c6e          {
08039c70              int32_t r2_1;
08039c70              int32_t r3_1;
08039c70              r2_1 = sub_80271d8();
08039c70              
08039c7a              if ((uint32_t)data_2000e436 != 2)
08039c7a              {
08039c82                  if ((uint32_t)data_2000e436 == 5)
08039c82                  {
08039c8a                      if (!sub_8033b3e())
08039ca8                          sub_8033e90(1, 1, r2_1, r3_1);
08039c8a                      else
08039c8a                      {
08039c92                          if (!sub_802c5e2())
08039c96                              sub_802c5da(1);
08039c96                          
08039c9e                          sub_8033e90(1, 0, r2_1, r3_1);
08039c8a                      }
08039c8a                      
08039cb0                      data_2000e436 = 0;
08039c82                  }
08039c82                  else if ((uint32_t)data_2000e436 == 3 || (uint32_t)data_2000e436 == 4)
08039cc8                      data_2000e43a = 1;
08039c7a              }
08039c6e          }
08039b98      }
08039b98      
08039ce6      if ((uint32_t)data_2000e436 && (uint32_t)data_2000e43a)
08039ce6      {
08039cee          if ((uint32_t)data_2000e436 == 3)
08039cee          {
08039cf2              int32_t var_1c_1 = 1;
08039cf6              uint32_t var_20_1 = (uint32_t)arg4;
08039d06              uint32_t r5_2 = (uint32_t)sub_8039de8(1, arg1, arg2, arg3);
08039d0c              logging_wrapper("[debug]checkState:%d\r\n", r5_2);
08039d10              uint32_t r5_3 = (uint32_t)(uint8_t)r5_2;
08039d10              
08039d14              if (!r5_3)
08039d14              {
08039d18                  beep_enabled_set(1);
08039d1e                  sub_802ce3e(0);
08039d22                  return 0xf;
08039d14              }
08039d14              
08039d2a              sub_8039e46((uint8_t)r5_3);
08039cee          }
08039cee          else if ((uint32_t)data_2000e436 == 4)
08039d36          {
08039d3a              int32_t var_1c_2 = 1;
08039d3e              uint32_t var_20_2 = (uint32_t)arg4;
08039d4e              uint32_t r5_5 = (uint32_t)sub_8039de8(1, arg1, arg2, arg3);
08039d54              logging_wrapper("[debug]checkState:%d\r\n", r5_5);
08039d58              uint32_t r5_6 = (uint32_t)(uint8_t)r5_5;
08039d58              
08039d5c              if (!r5_6)
08039d5c              {
08039d60                  beep_enabled_set(1);
08039d66                  sub_802ce3e(0);
08039d6a                  return 5;
08039d5c              }
08039d5c              
08039d72              sub_8039e46((uint8_t)r5_6);
08039d36          }
08039ce6      }
08039ce6      
08039d76      return 0;
08039a96  }
08039d7c    int32_t sub_8039d7c()
08039d7c  {
08039d7c      int32_t r7;
08039d7c      int32_t var_8 = r7;
08039d7c      
08039d84      if (!(uint32_t)data_2000e437)
08039d84      {
08039d8c          data_2000e32c = TickType_t xTaskGetTickCount(void)();
08039d92          data_2000e437 = 1;
08039d84      }
08039d84      
08039d9a      data_2000e330 = TickType_t xTaskGetTickCount(void)();
08039d9a      
08039da6      if (data_2000e330 >= data_2000e32c)
08039dca          data_2000e334 = data_2000e330 - data_2000e32c;
08039da6      else
08039dba          data_2000e334 = data_2000e330 + 0xffffffff - data_2000e32c;
08039dba      
08039dd6      if (data_2000e334 >= 0x1389)
08039dd6      {
08039ddc          data_2000e437 = 0;
08039de2          data_2000e436 = 0;
08039dd6      }
08039dd6      
08039de6      return 1;
08039d7c  }
08039de8    uint32_t sub_8039de8(char arg1, int32_t arg2, int32_t arg3, char arg4)
08039de8  {
08039df0      int32_t r0_1;
08039df0      int32_t r3;
08039df0      r0_1 = sensor_check_sequence(arg4);
08039df4      int32_t r5_1 = r0_1;
08039df6      sub_8028bc6();
08039dfa      int128_t q0;
08039dfa      *(uint32_t*)((char*)q0)[4] = 0x41500000;
08039dfe      /* unimplemented  {vcmp.f32.F32 s0, s1} */
08039e02      /* unimplemented  {vmrs apsr_nzcv, fpscr} */
08039e02      
08039e06      if (r5_1 < 0)
08039e06      {
08039e08          r5_1 = 0xf;
08039e10          r3 = sub_80282e4(0x42, 0, 1, r3, 0xf);
08039e06      }
08039e06      
08039e18      if (arg3 == 5)
08039e18      {
08039e1a          r5_1 = 0xd;
08039e22          r3 = sub_80282e4(0x53, 0, 1, r3, 0xd);
08039e18      }
08039e18      
08039e32      if ((uint32_t)arg1 == 1 && !(uint32_t)(uint8_t)arg2)
08039e32      {
08039e34          r5_1 = 0xe;
08039e3c          sub_80282e4(0xa1, 0, 1, r3, 0xe);
08039e32      }
08039e32      
08039e44      return (uint32_t)(uint8_t)r5_1;
08039de8  }
08039e46    int32_t sub_8039e46(char arg1)
08039e46  {
08039e46      int32_t r7;
08039e46      int32_t var_8 = r7;
08039e48      uint32_t r0 = (uint32_t)arg1;
08039e48      
08039e4c      if (r0)
08039e4c      {
08039e52          data_2000e436 = 0;
08039e58          data_2000e43a = 0;
08039e58          
08039e5e          if ((uint32_t)(uint8_t)r0 != 6)
08039e62              sub_8028be8(1);
08039e62          
08039e6a          doBeep(&turnTable);
08039e70          logging_wrapper("
08039e70              \r\n!!!!!!!!!!!!!Sensor Trigger::::::StartButton NO Success!\r\n");
08039e4c      }
08039e4c      
08039e76      return 1;
08039e46  }
08039e78  int32_t data_8039e78 = 0x2000e436
08039e7c  int32_t data_8039e7c = 0x2000e43a
08039e80    int32_t j_sub_80196f2(int32_t arg1, int32_t arg2, int32_t arg3)
08039e80  {
08039e80      /* tailcall */
08039e80      return sub_80396f2(arg1, arg2, arg3);
08039e80  }
08039e82        00 20                                                                                        . 
08039e84  int32_t data_8039e84 = 0x2000e43c
08039e88  int32_t data_8039e88 = 0x2000e344
08039e8c  int32_t data_8039e8c = 0x2000e348
08039e90  int32_t data_8039e90 = 0x2000e438
08039e94  int32_t data_8039e94 = 0x2000e439
08039e98  int32_t data_8039e98 = 0x2000e43b
08039e9a    int32_t sub_8039e9a(int32_t arg1, int32_t arg2, char arg3)
08039e9a  {
08039ea0      /* tailcall */
08039ea0      return sub_803a514((uint32_t)arg3, arg2);
08039e9a  }
08039ea2        00 20                                                                                        . 
08039ea4  int32_t data_8039ea4 = 0x2000e33c
08039ea8  int32_t data_8039ea8 = 0x2000e340
08039eac  int32_t data_8039eac = 0x803b8cc
08039eae    int32_t sub_8039eae(int32_t arg1, int32_t arg2)
08039eae  {
08039eb0      /* tailcall */
08039eb0      return sub_803a50c(arg1, arg2);
08039eae  }
08039eb2                                                        00 20                                                        . 
08039eb4  int32_t data_8039eb4 = 0x2000e330
08039eb8  int32_t data_8039eb8 = 0x2000e334
08039ebc  int32_t data_8039ebc = 0x803abe8
08039ec0    int32_t sub_8039ec0(char* arg1)
08039ec0  {
08039ec2      *(uint8_t*)arg1 = 0xf;
08039ec6      return 1;
08039ec0  }
08039ec8    int32_t sub_8039ec8(int32_t arg1 @ r7)
08039ec8  {
08039ed0      data_2000e0e8 = 1;
08039ed8      data_2000e0ec = 0;
08039ee0      data_2000e0f0 = 0;
08039ee8      data_2000e0e9 = 0;
08039ef0      data_2000e0ea = 0;
08039ef8      data_2000e0f4 = 0;
08039f02      data_2000e100 = 0x43200000;
08039f04      sub_8028ae4();
08039f10      data_2000e388 = TickType_t xTaskGetTickCount(void)();
08039f16      doBeep(0x10000000);
08039f1a      return arg1;
08039ec8  }
08039f1c    int32_t sub_8039f1c(int24_t arg1, int32_t arg2, char arg3, char arg4)
08039f1c  {
08039f1c      int32_t var_18 = arg2;
08039f28      int64_t q4;
08039f28      (uint32_t)q4 = 0;
08039f28      
08039f3a      if (sub_8028ace(0x40) || (uint32_t)arg4 == 5)
08039f3a      {
08039f3e          ui_set_run_indicator(0);
08039f42          return 6;
08039f3a      }
08039f3a      
08039f58      char r4_3;
08039f58      
08039f58      if (data_2000e0ec < 0x7530)
08039f60          r4_3 = 1;
08039f58      else
08039f5a          r4_3 = arg3;
08039f5a      
08039f66      int32_t r1_1 = data_2000e0ec;
08039f66      
08039f6e      if (r1_1 >= 0x2bf20)
08039f6e      {
08039f74          logging_wrapper("over time\n", r1_1, 0x2bf20);
08039f78          motorStop();
08039f7c          motorBrake();
08039f80          return 5;
08039f6e      }
08039f6e      
08039f84      uint32_t r4_4 = (uint32_t)r4_3;
08039f8e      int32_t r7;
08039f8e      
08039f8e      if (r4_4 != 1 || (uint32_t)*(uint8_t*)((char*)arg1)[2])
08039f8e      {
08039f98          data_2000e0e9 += 1;
08039f98          
08039fa0          if ((uint32_t)data_2000e0e9 >= 6)
08039fa0          {
08039fa2              sub_803a278(r7);
08039fa6              return 5;
08039fa0          }
08039f8e      }
08039f8e      else
08039fae          data_2000e0e9 = 0;
08039fae      
08039fb2      uint32_t r0_7;
08039fb2      int32_t r1_2;
08039fb2      int32_t r2;
08039fb2      r0_7 = isDriveSubsystemReady(2);
08039fc0      int128_t q0;
08039fc0      
08039fc0      if (!r0_7 && (uint32_t)arg3 == 1)
08039fc0      {
08039fc4          int32_t r0_9;
08039fc4          r0_9 = safetyCheck(3);
08039fc4          
08039fca          if (!r0_9)
08039fca          {
08039fce              int32_t r0_10;
08039fce              r0_10 = safetyCheck(4);
08039fce              
08039fd4              if (!r0_10 && !sub_8028b08())
08039fd4              {
08039fde                  (uint32_t)q0 = 0xb58042c8;
08039fe2                  beeper_config_apply((uint32_t)q0);
08039fe8                  r1_2 = logging_wrapper("start cutter\n");
08039fd4              }
08039fca          }
08039fc0      }
08039fc0      
08039fee      uint32_t r0_12 = (uint32_t)data_2000e0e8;
08039fee      
08039ff2      if (r0_12 == 1)
08039ff2      {
0803a008          if ((uint32_t)arg3 != 1)
0803a008          {
0803a024              sub_803a278(r7);
0803a028              return 5;
0803a008          }
0803a008          
0803a00a          *(uint32_t*)((char*)q0)[8] = 0x49630000;
0803a00e          *(uint32_t*)((char*)q0)[4] = 0x41f00000;
0803a012          (uint32_t)q0 = 0x437a;
0803a018          commandMotion(1, r1_2, r2, q0);
0803a020          data_2000e0e8 = 2;
08039ff2      }
08039ff2      else if (r0_12 >= 1)
08039ff4      {
08039ffa          int32_t a;
08039ffa          int32_t b;
08039ffa          
08039ffa          if (r0_12 == 3)
08039ffa          {
0803a106              int32_t r0_28 = TickType_t xTaskGetTickCount(void)();
0803a110              int32_t r6_2;
0803a110              
0803a110              if (r0_28 >= data_2000e388)
0803a128                  r6_2 = r0_28 - data_2000e388;
0803a110              else
0803a11c                  r6_2 = r0_28 + 0xffffffff - data_2000e388;
0803a11c              
0803a130              sub_802bd04(1, "[helix]percircleTime: %d\r\n", r7);
0803a130              
0803a13a              if (r6_2 >= data_2000e0f0)
0803a13a              {
0803a142                  data_2000e100 = 0x43200000;
0803a152                  (uint32_t)q4 = (float)(0x4d * (uint32_t)data_2000e0f4 + 0x9b);
0803a15e                  data_2000e0f4 += 1;
0803a164                  float32_process((uint32_t)q4);
0803a16c                  int32_t r0_36;
0803a16c                  int32_t r1_16;
0803a16c                  r0_36 = soft_dmul(a, b);
0803a178                  int32_t r0_38;
0803a178                  int32_t r1_17;
0803a178                  r0_38 = float32_process(data_2000e100);
0803a184                  soft_dadd();
0803a18c                  int32_t r0_40;
0803a18c                  int32_t r1_19;
0803a18c                  r0_40 = soft_dmul();
0803a196                  data_2000e0f0 = sub_802ffa0(r0_40, r1_19);
0803a19c                  int32_t r0_43;
0803a19c                  int32_t r1_20;
0803a19c                  r0_43 = float32_process(data_2000e100);
0803a1b8                  int32_t r0_45;
0803a1b8                  int32_t r1_21;
0803a1b8                  r0_45 = float32_process(310f / 0x439b0000);
0803a1c0                  sub_802ecf4(r0_45, r1_21, 0, 0x3ff00000);
0803a1c8                  int32_t r0_46;
0803a1c8                  int32_t r1_22;
0803a1c8                  r0_46 = soft_dmul();
0803a1d2                  data_2000e0f8 = sub_802ead0(r0_46, r1_22);
0803a1d8                  int32_t r0_49;
0803a1d8                  int32_t r1_23;
0803a1d8                  r0_49 = float32_process(data_2000e100);
0803a1f4                  int32_t r0_51;
0803a1f4                  int32_t r1_24;
0803a1f4                  r0_51 = float32_process(310f / 0x439b0000);
0803a200                  sub_802eb60(0, 0x3ff00000, r0_51, r1_24);
0803a208                  int32_t r0_52;
0803a208                  int32_t r1_25;
0803a208                  r0_52 = soft_dmul();
0803a212                  data_2000e0fc = sub_802ead0(r0_52, r1_25);
0803a218                  int32_t var_30_1 = data_2000e0f0;
0803a21e                  int32_t r0_56;
0803a21e                  int32_t r1_26;
0803a21e                  r0_56 = float32_process(data_2000e0fc);
0803a222                  int32_t var_38_1 = r0_56;
0803a222                  int32_t var_34_2 = r1_26;
0803a22a                  int32_t r0_58;
0803a22a                  int32_t r1_27;
0803a22a                  r0_58 = float32_process(data_2000e0f8);
0803a236                  sub_802bd04(1, "[helix]r:%f l:%f time:%d \r\n", r7);
0803a23c                  int64_t q0_3;
0803a23c                  *(uint32_t*)((char*)q0_3)[4] = data_2000e0f8;
0803a242                  (uint32_t)q0_3 = data_2000e0fc;
0803a246                  sub_802d226(q0_3);
0803a250                  data_2000e388 = TickType_t xTaskGetTickCount(void)();
0803a25a                  data_2000e0ec += r6_2;
0803a25e                  data_2000e0ec;
0803a264                  sub_802bd04(1, "[helix]walkTime:%d \r\n", r7);
0803a13a              }
08039ffa          }
08039ffa          else if (r0_12 < 3 && (uint32_t)(uint8_t)r4_4 == 1 && !driveSubsystemState())
0803a030          {
0803a03a              int32_t r0_15 = TickType_t xTaskGetTickCount(void)();
0803a044              int32_t r6_1;
0803a044              
0803a044              if (r0_15 >= data_2000e388)
0803a058                  r6_1 = r0_15 - data_2000e388;
0803a044              else
0803a050                  r6_1 = r0_15 + 0xffffffff - data_2000e388;
0803a050              
0803a05c              data_2000e0ec = r6_1;
0803a05c              
0803a064              if (r6_1 >= 0x1388)
0803a064              {
0803a06a                  data_2000e100 = 0x43200000;
0803a074                  float32_process(0x431b0000);
0803a07c                  int32_t r0_16;
0803a07c                  int32_t r1_6;
0803a07c                  r0_16 = soft_dmul(a, b);
0803a088                  int32_t r0_18;
0803a088                  int32_t r1_7;
0803a088                  r0_18 = float32_process(data_2000e100);
0803a094                  soft_dadd();
0803a09c                  int32_t r0_20;
0803a09c                  int32_t r1_9;
0803a09c                  r0_20 = soft_dmul();
0803a0a6                  data_2000e0f0 = sub_802ffa0(r0_20, r1_9);
0803a0ae                  data_2000e0f8 = data_2000e100;
0803a0b4                  (uint32_t)q0 = data_2000e100;
0803a0b8                  (uint32_t)q0 = -((uint32_t)q0);
0803a0bc                  data_2000e0fc = (uint32_t)q0;
0803a0c4                  int32_t var_30 = data_2000e0f0;
0803a0ca                  int32_t r0_24;
0803a0ca                  int32_t r1_11;
0803a0ca                  r0_24 = float32_process(data_2000e0fc);
0803a0ce                  int32_t var_38 = r0_24;
0803a0ce                  int32_t var_34_1 = r1_11;
0803a0d6                  int32_t r0_26;
0803a0d6                  int32_t r1_12;
0803a0d6                  r0_26 = float32_process(data_2000e0f8);
0803a0e2                  sub_802bd04(1, "[helix]r:%f l:%f time:%d \r\n", r7);
0803a0e8                  int64_t q0_1;
0803a0e8                  *(uint32_t*)((char*)q0_1)[4] = data_2000e0f8;
0803a0ee                  (uint32_t)q0_1 = data_2000e0fc;
0803a0f2                  sub_802d226(q0_1);
0803a0fc                  data_2000e388 = TickType_t xTaskGetTickCount(void)();
0803a102                  data_2000e0e8 = 3;
0803a064              }
0803a030          }
08039ff4      }
08039ff4      
0803a268      return 0xf;
08039f1c  }
0803a120  int32_t data_803a120 = 0x0
0803a274                                                              00 00                                                    ..
0803a276  int32_t data_803a276 = -0x4a7fbd38
0803a278    int32_t sub_803a278(int32_t arg1 @ r7)
0803a278  {
0803a27e      data_2000e0e9 = 0;
0803a280      motorStop();
0803a284      motorBrake();
0803a28c      data_2000e0e8 = 1;
0803a292      doBeep(&turnTable);
0803a298      logging_wrapper("SPOT_MOWING_STOP_ERROR_BORDER\n");
0803a29c      return arg1;
0803a278  }
0803a29e                                                                                            00 00                                ..
0803a2a0  00 00                                                                                            ..
0803a2a2  int32_t data_803a2a2 = 0x437a
0803a2a6                    1b 43                                                                                .C
0803a2a8  int32_t data_803a2a8 = 0x439b0000
0803a2ac  int32_t data_803a2ac = 0x2000e0e8
0803a2b0  int32_t data_803a2b0 = 0x43200000
0803a2b4  int32_t data_803a2b4 = 0x2000e388
0803a2b8  int32_t data_803a2b8 = 0x2bf20
0803a2bc  int32_t data_803a2bc = 0x803bfc0
0803a2c0  int32_t data_803a2c0 = 0x803bec0
0803a2c4  int32_t data_803a2c4 = 0x4d12d84a
0803a2c8  int32_t data_803a2c8 = 0x401921fb
0803a2cc  int32_t data_803a2cc = 0x408f4000
0803a2d0  int32_t data_803a2d0 = 0x803b6cc
0803a2d4  int32_t data_803a2d4 = 0x803b6e8
0803a2d8  int32_t data_803a2d8 = 0x3ff00000
0803a2dc  int32_t data_803a2dc = 0x803ba04
0803a2e0  int32_t data_803a2e0 = 0x803b390
0803a2e4  data_803a2e4:
0803a2e4              61 00 62 00 63 00 64 00 65 00 66 00 67 00 68 00 69 00 6a 00 6b 00 6c 00 6d 00 6e 00      a.b.c.d.e.f.g.h.i.j.k.l.m.n.
0803a300  6f 00 70 00 71 00 72 00 73 00 74 00 75 00 76 00 77 00 78 00 79 00 7a 00 a1 00 a2 00 a3 00 a5 00  o.p.q.r.s.t.u.v.w.x.y.z.........
0803a320  ac 00 af 00 e0 00 e1 00 e2 00 e3 00 e4 00 e5 00 e6 00 e7 00 e8 00 e9 00 ea 00 eb 00 ec 00 ed 00  ................................
0803a340  ee 00 ef 00 f0 00 f1 00 f2 00 f3 00 f4 00 f5 00 f6 00 f8 00 f9 00 fa 00 fb 00 fc 00 fd 00 fe 00  ................................
0803a360  ff 00 01 01 03 01 05 01 07 01 09 01 0b 01 0d 01 0f 01 11 01 13 01 15 01 17 01 19 01 1b 01 1d 01  ................................
0803a380  1f 01 21 01 23 01 25 01 27 01 29 01 2b 01 2d 01 2f 01 31 01 33 01 35 01 37 01 3a 01 3c 01 3e 01  ..!.#.%.'.).+.-./.1.3.5.7.:.<.>.
0803a3a0  40 01 42 01 44 01 46 01 48 01 4b 01 4d 01 4f 01 51 01 53 01 55 01 57 01 59 01 5b 01 5d 01 5f 01  @.B.D.F.H.K.M.O.Q.S.U.W.Y.[.]._.
0803a3c0  61 01 63 01 65 01 67 01 69 01 6b 01 6d 01 6f 01 71 01 73 01 75 01 77 01 7a 01 7c 01 7e 01 92 01  a.c.e.g.i.k.m.o.q.s.u.w.z.|.~...
0803a3e0  b1 03 b2 03 b3 03 b4 03 b5 03 b6 03 b7 03 b8 03 b9 03 ba 03 bb 03 bc 03 bd 03 be 03 bf 03 c0 03  ................................
0803a400  c1 03 c3 03 c4 03 c5 03 c6 03 c7 03 c8 03 c9 03 ca 03 30 04 31 04 32 04 33 04 34 04 35 04 36 04  ..................0.1.2.3.4.5.6.
0803a420  37 04 38 04 39 04 3a 04 3b 04 3c 04 3d 04 3e 04 3f 04 40 04 41 04 42 04 43 04 44 04 45 04 46 04  7.8.9.:.;.<.=.>.?.@.A.B.C.D.E.F.
0803a440  47 04 48 04 49 04 4a 04 4b 04 4c 04 4d 04 4e 04 4f 04 51 04 52 04 53 04 54 04 55 04 56 04 57 04  G.H.I.J.K.L.M.N.O.Q.R.S.T.U.V.W.
0803a460  58 04 59 04 5a 04 5b 04 5c 04 5e 04 5f 04 70 21 71 21 72 21 73 21 74 21 75 21 76 21 77 21 78 21  X.Y.Z.[.\.^._.p!q!r!s!t!u!v!w!x!
0803a480  79 21 7a 21 7b 21 7c 21 7d 21 7e 21 7f 21 41 ff 42 ff 43 ff 44 ff 45 ff 46 ff 47 ff 48 ff 49 ff  y!z!{!|!}!~!.!A.B.C.D.E.F.G.H.I.
0803a4a0  4a ff 4b ff 4c ff 4d ff 4e ff 4f ff 50 ff 51 ff 52 ff 53 ff 54 ff 55 ff 56 ff 57 ff 58 ff 59 ff  J.K.L.M.N.O.P.Q.R.S.T.U.V.W.X.Y.
0803a4c0  5a ff 00 00                                                                                      Z...
0803a4c4  data_803a4c4:
0803a4c4              41 00 42 00 43 00 44 00 45 00 46 00 47 00 48 00 49 00 4a 00 4b 00 4c 00 4d 00 4e 00      A.B.C.D.E.F.G.H.I.J.K.L.M.N.
0803a4e0  4f 00 50 00 51 00 52 00 53 00 54 00 55 00 56 00 57 00 58 00 59 00 5a 00 21 00 e0 ff e1 ff e5 ff  O.P.Q.R.S.T.U.V.W.X.Y.Z.!.......
0803a500  e2 ff e3 ff c0 00 c1 00 c2 00 c3 00                                                              ............
0803a50c    int32_t sub_803a50c(int32_t arg1, int32_t arg2)
0803a50c  {
0803a512      /* tailcall */
0803a512      return sub_803a514(arg1, arg2);
0803a50c  }
0803a514    int32_t sub_803a514(int32_t arg1, int32_t arg2)
0803a514  {
0803a66e      /* unimplemented  {vpmin.f32.F32 d15, d1, d18} */
0803a672      /* unimplemented  {vpmin.f32.F32 d15, d3, d20} */
0803a676      /* unimplemented  {vpmin.f32.F32 d15, d5, d22} */
0803a67a      /* unimplemented  {vpmin.f32.F32 d15, d7, d24} */
0803a67e      /* unimplemented  {vpmin.f32.F32 d15, d9, d26} */
0803a682      /* unimplemented  {vpmin.f32.F32 d15, d11, d28} */
0803a686      /* unimplemented  {vpmin.f32.F32 d15, d13, d30} */
0803a68a      /* undefined */
0803a514  }
0803a68c                                      30 ff 31 ff 32 ff 33 ff 34 ff 35 ff 36 ff 37 ff 38 ff 39 ff              0.1.2.3.4.5.6.7.8.9.
0803a6a0  3a ff 00 00                                                                                      :...
0803a6a4    int32_t SystemInit(int32_t arg1 @ r7)
0803a6a4  {
0803a6ae      setupVtor(0x8000000, 0x20000);
0803a6bc      *(uint32_t*)0xe000ed88 |= 0xf00000;
0803a6c8      RCC.CR |= 1;
0803a6ce      RCC.CFGR = 0;
0803a6da      RCC.CR &= 0xfef6ffff;
0803a6e0      RCC.PLLCFGR = 0x24003010;
0803a6ec      RCC.CR &= 0xfffbffff;
0803a6f2      RCC.CIR = 0;
0803a6f4      SystemClock_Config_sub(arg1);
0803a6f8      return arg1;
0803a6a4  }
0803a6fa    int32_t SystemClock_Config_sub(int32_t arg1 @ r7)
0803a6fa  {
0803a6fc      SystemClock_Config();
0803a700      return arg1;
0803a6fa  }
0803a702    uint32_t SystemClock_Config()
0803a702  {
0803a702      int32_t i = 0;
0803a710      RCC.CR |= 0x10000;
0803a710      
0803a724      do
0803a724      {
0803a712          i += 1;
0803a712          
0803a71e          if (RCC.CR & 0x20000)
0803a71e              break;
0803a724      } while (i != 0x800);
0803a724      
0803a72c      if (RCC.CR << 0xe < 0)
0803a72c      {
0803a73a          RCC.APB1ENR |= 0x10000000;
0803a746          data_40007000 |= 0xc000;
0803a74e          RCC.CFGR = RCC.CFGR;
0803a75a          RCC.CFGR |= 0x8000;
0803a766          RCC.CFGR |= 0x1400;
0803a76c          RCC.PLLCFGR = 0x740540c;
0803a778          RCC.CR |= 0x1000000;
0803a778          
0803a77e          while (RCC.CR << 6 >= 0)
0803a77e              /* nop */
0803a77e          
0803a78c          data_40007000 |= 0x10000;
0803a78c          
0803a792          while (data_40007004 << 0xf >= 0)
0803a792              /* nop */
0803a792          
0803a7a0          data_40007000 |= 0x20000;
0803a7a0          
0803a7a6          while (data_40007004 << 0xe >= 0)
0803a7a6              /* nop */
0803a7a6          
0803a7b4          RCC.CFGR = RCC.CFGR >> 2 << 2;
0803a7c0          RCC.CFGR |= 2;
0803a7c8          uint32_t i_1;
0803a7c8          
0803a7c8          do
0803a7c6              i_1 = RCC.CFGR << 0x1c;
0803a7c8           while (i_1 >= 0);
0803a7c8          
0803a7ca          return i_1;
0803a72c      }
0803a72c      
0803a72e      while (true)
0803a72e          /* nop */
0803a702  }
0803a7cc  int32_t data_803a7cc = -0x1fff1278
0803a7d0  int32_t data_803a7d0 = 0x40023800
0803a7d4  int32_t data_803a7d4 = 0x40023808
0803a7d8  int32_t data_803a7d8 = -0x1090001
0803a7dc  int32_t data_803a7dc = 0x24003010
0803a7e0  int32_t data_803a7e0 = 0x40023804
0803a7e4  int32_t data_803a7e4 = 0x4002380c
0803a7e8  int32_t data_803a7e8 = 0x40023840
0803a7ec  int32_t data_803a7ec = 0x40007000
0803a7f0  int32_t data_803a7f0 = 0x740540c
0803a7f4  int32_t data_803a7f4 = 0x40007004
0803a7f8  data_803a7f8:
0803a7f8                                                                          ac 20 00 00 1a 20 92 01                          . ... ..
0803a800  1e 20 26 20 20 20 21 20 c6 02 30 20 60 01 39 20 52 01 00 00 7d 01 00 00 00 00 18 20 19 20 1c 20  . &   ! ..0 `.9 R...}...... . . 
0803a820  1d 20 22 20 13 20 14 20 dc 02 22 21 61 01 3a 20 53 01 00 00 7e 01 78 01 a0 00 a1 00 a2 00 a3 00  . " . . .."!a.: S...~.x.........
0803a840  a4 00 a5 00 a6 00 a7 00 a8 00 a9 00 aa 00 ab 00 ac 00 ad 00 ae 00 af 00 b0 00 b1 00 b2 00 b3 00  ................................
0803a860  b4 00 b5 00 b6 00 b7 00 b8 00 b9 00 ba 00 bb 00 bc 00 bd 00 be 00 bf 00 c0 00 c1 00 c2 00 c3 00  ................................
0803a880  c4 00 c5 00 c6 00 c7 00 c8 00 c9 00 ca 00 cb 00 cc 00 cd 00 ce 00 cf 00 d0 00 d1 00 d2 00 d3 00  ................................
0803a8a0  d4 00 d5 00 d6 00 d7 00 d8 00 d9 00 da 00 bd 00 dc 00 dd 00 de 00 df 00 e0 00 e1 00 e2 00 e3 00  ................................
0803a8c0  e4 00 e5 00 e6 00 e7 00 e8 00 e9 00 ea 00 eb 00 ec 00 ed 00 ee 00 ef 00 f0 00 f1 00 f2 00 f3 00  ................................
0803a8e0  f4 00 f5 00 f6 00 f7 00 f8 00 f9 00 fa 00 fb 00 fc 00 fd 00 fe 00 ff 00 bf f3 4f 8f 18 48 00 68  ..........................O..H.h
0803a900  10 f4 e0 60 17 49 08 43 15 49 08 60 bf f3 4f 8f fe e7 70 47 fe e7 fe e7 fe e7 fe e7 70 47 70 47  ...`.I.C.I.`..O...pG........pGpG
0803a920  80 b5 01 21 10 48 fc f7 5f fb 00 28 10 d0 01 21 0d 48 fc f7 67 fb 0d 48 00 68 00 28 05 d0 0b 48  ...!.H.._..(...!.H..g..H.h.(...H
0803a940  00 68 40 1e 09 49 08 60 02 e0 07 48 fc f7 33 fb 01 bd 80 b5 06 48 fc f7 81 ff f5 f7 02 f8 01 bd  .h@..I.`...H..3......H..........
0803a960  0c ed 00 e0 04 00 fa 05 00 44 01 40 d0 e3 00 20 40 07 00 20 80 b5 5f f4 80 30 fb f7 23 fe 00 28  .........D.@... @.. .._..0..#..(
0803a980  09 d0 5f f4 80 30 fb f7 2b fe ef f7 a2 fb 01 28 01 d1 ff f7 b1 ff 01 bd 80 81 82 83 84 85 86 87  .._..0..+......(................
0803a9a0  88 89 8a 8b 8c 8d 8e 8f 90 91 92 93 94 95 96 97 98 99 ad 9b 8c 9d ae 9f a0 21 a2 a3 a4 a5 a6 a7  .........................!......
0803a9c0  a8 a9 aa ab ac ad ae af b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 ba bb bc bd be bf c0 c1 c2 c3 c4 c5 c6 c7  ................................
0803a9e0  c8 c9 ca cb cc cd ce cf d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 da db dc dd de df c0 c1 c2 c3 c4 c5 c6 c7  ................................
0803aa00  c8 c9 ca cb cc cd ce cf d0 d1 d2 d3 d4 d5 d6 f7 d8 d9 da db dc dd de 9f f0 b4 01 68 44 68 83 68  ...........................hDh.h
0803aa20  01 44 01 eb 54 02 e4 07 48 bf 4b 44 91 42 02 d1 f0 bc 0c 30 70 47 11 f8 01 5b 15 f0 03 06 04 bf  .D..T...H.KD.B.....0pG...[......
0803aa40  11 f8 01 4b e6 1c 2c 09 0f 2c 07 d1 11 f8 01 4b 0f 34 03 e0 11 f8 01 7b 03 f8 01 7b 76 1e f9 d1  ...K..,..,.....K.4.....{...{v...
0803aa60  00 2c e3 d0 ad 08 11 f8 01 6b 05 f0 03 05 03 2d 08 bf 11 f8 01 5b 06 eb 05 25 6d 42 a4 1c 1d 44  .,.......k.....-.....[...%mB...D
0803aa80  d4 d0 15 f8 01 6b 03 f8 01 6b 64 1e f9 d1 cd e7                                                  .....k...kd.....
0803aa90    void rtos_boot() __noreturn
0803aa90  {
0803aa98      nvic_set_priority_grouping(0x300);
0803aaa2      nvic_enable_irq_with_priority(1, 0, 0);
0803aaae      exti_config(0x10000, 0, 2);
0803aab4      pwr_pvd_config_enable(0);
0803aab8      cam_uart_boot();
0803aace      rtos_xTaskCreate(system_bootstrap, "INIT", 0x200, nullptr, 9, nullptr);
0803aad2      rtos_vTaskStartScheduler();
0803aad2      
0803aad6      while (true)
0803aad6          /* nop */
0803aa90  }
0803aad8  int32_t data_803aad8 = 0x803c0b0
0803aadc  int32_t data_803aadc = 0x802c62f
0803aae0    int32_t pwr_pvd_config_enable(uint32_t pls_bits)
0803aae0  {
0803aaea      data_40007000 &= 0xffffffef;
0803aaf6      data_40007000 &= 0xffffff1f;
0803ab00      data_40007000 |= pls_bits;
0803ab06      int32_t result = data_40007000 | 0x10;
0803ab0c      data_40007000 = result;
0803ab0e      return result;
0803aae0  }
0803ab10  int32_t data_803ab10 = 0x40007000
0803ab14                                                              0d 0a 2d 2d 2d 2d 2d 4f 6e 63 65 57                      ..-----OnceW
0803ab20  6f 72 6b 54 69 6d 65 20 3d 20 25 64 20 20 20 4f 6e 63 65 52 75 6e 6e 69 6e 67 54 69 6d 65 20 3d  orkTime = %d   OnceRunningTime =
0803ab40  20 25 64 20 20 20 4f 6e 63 65 42 6c 61 64 65 54 69 6d 65 20 3d 25 64 0d 0a 00 00 00               %d   OnceBladeTime =%d.....
0803ab5c  char data_803ab5c[0x47] = "\r\n-----TotalWorkTime = %d  TotalRunningTime = %d  TotalBladeTime =%d\r\n", 0
0803aba3           00 09 21 01 70 01 20 70 47                                                                 ..!.p. pG
0803abac    int32_t sub_803abac()
0803abac  {
0803abac      int32_t r7;
0803abac      int32_t var_8 = r7;
0803abae      motorStop();
0803abb2      motorBrake();
0803abbe      data_2000e458 += 1;
0803abbe      
0803abc6      if ((uint32_t)data_2000e458 == 1)
0803abcc          sub_80283b6(0, 1);
0803abcc      
0803abd6      if (!sub_802f8e0())
0803abda          sub_802a0d8(0, r7);
0803abda      
0803abe0      return 9;
0803abac  }
0803abe2        00 00                                                                                        ..
0803abe4  int32_t data_803abe4 = 0x2000e458
0803abe8  char sensor_trg_no_success[0x3d] = "\r\n!!!!!!!!!!!!!Sensor Trigger::::::StartButton NO Success!\r\n", 0
0803ac25                 00 00 00 19 e0 50 f8 04 1b cb 07 44 bf a9 f1 01 03 59 18 12 1f 00 23 04 2a 41 f8       .....P.....D.....Y....#.*A.
0803ac40  04 3b f9 d2 5f ea 82 7c 0b 46 04 d5 4f f0 00 0c a1 f8 00 c0 9b 1c d1 07 44 bf 00 21 19 70 50 f8  .;.._..|.F..O...........D..!.pP.
0803ac60  04 2b 00 2a e1 d1 70 47                                                                          .+.*..pG
0803ac68  char motor_state_locked_to_stopped[0x2d] = "MOTOR_STATE_LOCKED --> MOTOR_STATE_STOPPED\r\n", 0
0803ac95                                                                 00 00 00                                               ...
0803ac98  char BorderDataStateStr[0x2d] = "********************uBorderData.state = %d\r\n", 0
0803acc5                 00 00 00                                                                               ...
0803acc8  char data_803acc8[0x2f] = "============================================\r\n", 0
0803acf7                                                                       00                                                 .
0803acf8  char vbs_plus_log_str[0x2d] = "[++VBS]:%d %d C %d pici:%d FWV:%d_%d_%d_%d\r\n", 0
0803ad25                 00 00 00                                                                               ...
0803ad28  char data_803ad28[0x29] = "BORDER_STATE_ON_BORDER_BACKWARD_GARAGE\r\n", 0
0803ad51                                                     00 00 00                                                       ...
0803ad54  char data_803ad54[0x29] = "vbCommMoudlePowerInit vbCommMoudleInit\r\n", 0
0803ad7d                                                                                         00 00 00                               ...
0803ad80  char data_803ad80[0x2c] = "[createQueue]CRITICAL_ERROR_LACK_OF_MEMORY\n", 0
0803adac  char data_803adac[0x2c] = "=========================================\r\n", 0
0803add8  char data_803add8[0x26] = "[debug][border]ultrasonic error %d!\r\n", 0
0803adfe                                                                                            00 00                                ..
0803ae00  char data_803ae00[0x28] = "BORDER_STATE_ON_BORDER_FORWARD_GARAGE\r\n", 0
0803ae28  char data_803ae28[0x26] = "[ERROR_HANDLING_COLLISION]ReturnHMI\r\n", 0
0803ae4e                                            00 00                                                                ..
0803ae50  char data_803ae50[0x25] = "================================%d\r\n", 0
0803ae75                                                                 00 00 00                                               ...
0803ae78  char data_803ae78[0x26] = "2 left tarspeed %f %f tarDist %f %f\r\n", 0
0803ae9e                                                                                            00 00                                ..
0803aea0  char data_803aea0[0x28] = "2 right tarspeed %f %f tarcount %f %f\r\n", 0
0803aec8  char data_803aec8[0x28] = "[enqueue]CRITICAL_ERROR_LACK_OF_MEMORY\n", 0
0803aef0  char data_803aef0[0x25] = "##### USB Host library started #####", 0
0803af15                                                                 00 00 00                                               ...
0803af18  char cam_parse_log_string[0x27] = "[++VBS]:BS:%d Temp:%dC BC:%d Pici:%d\r\n", 0
0803af3f                                                                                               00                                 .
0803af40  char data_803af40[0x26] = "[Update] Direct Read File CRC Error\r\n", 0
0803af66                    00 00                                                                                ..
0803af68    void sub_803af68()
0803af68  {
0803af84      for (int32_t (* i)(int32_t arg1 @ r9) = sub_803b1d0; 
0803af84          i != "BORDER_STATE_INSIDE_BORDER\r\n"; 
0803af84          i = ((char*)i + *(uint32_t*)i)((char*)i + 4))
0803af84      {
0803af84      }
0803af68  }
0803af88    int32_t sub_803af88(int32_t arg1, int16_t* arg2, int32_t* arg3, void* arg4, int32_t arg5 @ r4, int32_t arg6 @ r5, void* arg7 @ r6, int32_t arg8 @ r9)
0803af88  {
0803af90      *(uint32_t*)((char*)arg4 + 0x44) = arg4;
0803af92      *(uint32_t*)((arg5 << 9) + 0x24) = arg6;
0803af94      *(uint32_t*)((char*)arg7 + 0x74) = arg6;
0803af98      *(uint8_t*)(arg2 * 0x201) = (char)arg2;
0803af9c      int16_t* r2 = *(uint32_t*)((char*)arg3 + 0 - arg4);
0803afa0      int32_t r7 = (int32_t)*(uint8_t*)((char*)arg2 + 0 - arg4);
0803afa4      *(uint32_t*)0x626564af = 0 - arg4;
0803afa8      void* r3 = *(uint32_t*)0x6265645f;
0803afaa      *(uint8_t*)0x62656464 = (char)arg2;
0803afac      *(uint32_t*)0x626564af = r7;
0803afae      uint32_t r5_1 = arg2 >> 8;
0803afb6      *(uint16_t*)((char*)r2 + arg2) = (int16_t)r2;
0803afb8      *(uint16_t*)(arg2 * 2) = (int16_t)r7;
0803afc2      int32_t r7_1 = (int32_t)*(uint16_t*)(0xa0d3d3d + r5_1);
0803afc6      *(uint8_t*)0x79709cb0 = 0x4c;
0803afc8      *(uint16_t*)((char*)r3 + 0x6f635f73) = (int16_t)r5_1;
0803afca      *(uint8_t*)0xa1e = (char)r5_1;
0803afcc      *(uint8_t*)0x53494c55 = (char)r5_1;
0803afd8      *(uint32_t*)((char*)r3 + 0x54) = r3;
0803afda      *(uint8_t*)0x53494c55 = (char)r2;
0803afdc      *(uint8_t*)0x74537b = (char)r7_1;
0803afde      *(uint8_t*)((char*)r3 + 0xd) = 0x72;
0803afe0      *(uint32_t*)0x7453d6 = r7_1;
0803afe2      *(uint8_t*)0x53494c69 = 0xd;
0803afe4      *(uint8_t*)0xa16 = 0x65;
0803afe8      *(uint32_t*)0x53494c60 = r7_1;
0803afea      *(uint32_t*)0x53494c80 = 0xa0d;
0803afee      void* r4_1 = *(uint32_t*)0xa81;
0803aff2      *(uint8_t*)((char*)r4_1 + 9) = 0x72;
0803affc      *(uint32_t*)((char*)r3 + 0x44) = r3;
0803affe      *(uint32_t*)((char*)r4_1 + 0x24) = 0x745372;
0803b000      *(uint32_t*)0x53494cc0 = 0x745372;
0803b002      void* r5_2 = *(uint32_t*)((char*)r3 + 0x14);
0803b004      void* r6 = 0x53494c4c + r4_1;
0803b006      void* r3_1 = *(uint32_t*)((char*)r4_1 + 4);
0803b008      __builtin_strncpy((char*)r5_2 + 0x54, "erSt", 4);
0803b00a      *(uint32_t*)((char*)r6 + 0x54) = r6;
0803b00c      *(uint32_t*)0x29a4ba = r4_1;
0803b010      *(uint8_t*)((char*)r5_2 + 0x15) = (char)r7_1;
0803b012      *(uint8_t*)((char*)r5_2 + 0x11) = (char)r6;
0803b01a      uint32_t r6_1 = r4_1 >> 0x15;
0803b020      *(uint32_t*)((char*)r3_1 + 0x44) = r3_1;
0803b022      *(uint32_t*)((char*)r4_1 + 0x24) = 0x20;
0803b024      *(uint32_t*)(r6_1 + 0x74) = 0x20;
0803b02a      void* r4_2 = *(uint32_t*)0xffffffd7;
0803b02c      *(uint8_t*)((char*)r4_2 + 0x11) = (char)r6_1;
0803b030      *(uint32_t*)((char*)r4_2 + 0x64) = 0xffffffc3;
0803b034      *(uint16_t*)0x745372d9 = 0x7265;
0803b038      void* r3_2 = (char*)r3_1 + arg8;
0803b044      *(uint32_t*)((char*)r3_2 + 0x44) = r3_2;
0803b046      *(uint32_t*)((char*)r4_2 + 0x24) = 0x745372;
0803b048      *(uint32_t*)(r6_1 + 0x74) = 0x745372;
0803b04e      void* r4_3 = *(uint32_t*)0x745329;
0803b050      *(uint8_t*)((char*)r4_3 + 0x11) = (char)r6_1;
0803b052      *(uint8_t*)((char*)r4_3 + 8) = 0x3d;
0803b054      __builtin_strncpy(0x745389, "erSt", 4);
0803b056      *(uint8_t*)0x745326 = 0x3d;
0803b068      __builtin_strncpy(0xa0d0a51, "\r\n\r\n", 4);
0803b06a      *(uint32_t*)((char*)r4_3 + 0x24) = 0x206;
0803b06c      *(uint32_t*)0x8f6ff433 = 0x206;
0803b072      *(uint8_t*)0x8f6ff3d0 = 0xd;
0803b074      *(uint8_t*)0x1aa = 0x69;
0803b076      *(uint32_t*)((char*)r4_3 + 0x20) = 0x3d;
0803b078      *(uint8_t*)0x8f6ff3d0 = 0xa9;
0803b07e      *(uint16_t*)0xe8a6e4ca = (int16_t)*(uint32_t*)0x8f6ff433;
0803b080      /* jump -> arg8 */
0803af88  }
0803b082        47 45 52 20 3d 3d 0d 0a 00 00 5b 64 65 62 75 67 5d 3d 3d 20 73 74 6f 70 20 62 75 74 74 6f    GER ==....[debug]== stop butto
0803b0a0  6e 20 45 52 52 4f 52 20 3d 3d 0d 0a 00 00 00 00 4d 4f 44 55 4c 45 5f 53 45 4e 53 4f 52 5f 33 53  n ERROR ==......MODULE_SENSOR_3S
0803b0c0  5f 43 4f 4c                                                                                      _COL
0803b0c4  int32_t data_803b0c4 = 0x4953494c
0803b0c8                          4f 4e 5f 53 48 49 46 54                                                          ON_SHIFT
0803b0d0  int32_t data_803b0d0 = 0xa0d
0803b0d4                                                              4d 4f 44 55 4c 45 5f 53 45 4e 53 4f                      MODULE_SENSO
0803b0e0  52 5f 31 30 53 5f 43 4f                                                                          R_10S_CO
0803b0e8  int32_t data_803b0e8 = 0x53494c4c
0803b0ec                                      49 4f 4e 5f 53 48 49 46 54 0d 0a 00                                      ION_SHIFT...
0803b0f8  int32_t data_803b0f8 = 0x6f635f73
0803b0fc                                                                                      6c 6c 69 73                              llis
0803b100  69 6f 6e 54 72 69 67 67                                                                          ionTrigg
0803b108  int32_t data_803b108 = 0x74537265
0803b10c                                      61 72 74 54 69 6d 65 20 72 65 73 65 74 0d 0a 00                          artTime reset...
0803b11c  int32_t data_803b11c = 0x6265645b
0803b120  75 67 5d 3d 3d 20 63 6f 6c 6c 69 73 69 6f 6e 20 54 52 49 47 47 45 52 20                          ug]== collision TRIGGER 
0803b138  int32_t data_803b138 = 0xa0d3d3d
0803b13c                                                                                      00 00 00 00                              ....
0803b140  5b 64 65 62 75 67 5d 63 68 65 63 6b 53 65 6e 73 6f 72 3a 5b 74 75 72 6e 4f 76 65 72 5d 3a 25 64  [debug]checkSensor:[turnOver]:%d
0803b160  0d 0a 00 00                                                                                      ....
0803b164  int32_t data_803b164 = 0xa0d0a0d
0803b168                          63 72 65 61 74 65 20 66                                                          create f
0803b170  int32_t data_803b170 = 0x20656c69
0803b174                                                              28 62 6f 61 64 54 65 73 74 2e 74 78                      (boadTest.tx
0803b180  74 29 20 2e 2e 2e 20 00                                                                          t) ... .
0803b188  int32_t data_803b188 = 0x614d203e
0803b18c                                      73 73 20 73 74 6f 72 61 67 65 20 64 65 76 69 63 65 20 63 6f              ss storage device co
0803b1a0  6e 6e 65 63 74 65 64 2e 00 00 00 00                                                              nnected.....
0803b1ac    int32_t sub_803b1ac()
0803b1ac  {
0803b1ba      *(uint32_t*)0xe000ed88 |= 0xf00000;
0803b1bc      __dsb_SY();
0803b1c0      __isb();
0803b1c0      /* tailcall */
0803b1c0      return sub_803b1c4();
0803b1ac  }
0803b1c4    int32_t sub_803b1c4()
0803b1c4  {
0803b1c8      /* unimplemented  {vmsr fpscr, r0} */
0803b1cc      return 0x2000000;
0803b1c4  }
0803b1ce                                            00 00                                                                ..
0803b1d0    int32_t sub_803b1d0(int32_t arg1 @ r9)
0803b1d0  {
0803b1d0      /* jump -> arg1 + 1 */
0803b1d0  }
0803b1d4  data_803b1d4:
0803b1d4                                                              80 96 00 00 f0 4d 00 20 00 00 00 00                      .....M. ....
0803b1e0  39 f8 ff ff 5c 10 00 00 4a 08 00 00 00 00 00 20                                                  9...\...J...... 
0803b1f0  data_803b1f0:
0803b1f0                                                  42 4f 52 44 45 52 5f 53 54 41 54 45 5f 49 4e 53                  BORDER_STATE_INS
0803b200  49 44 45 5f 42 4f 52 44 45 52 0d 0a 00 00 00 00 42 4f 52 44 45 52 5f 53 54 41 54 45 5f 4f 55 54  IDE_BORDER......BORDER_STATE_OUT
0803b220  53 49 44 45 5f 42 4f 52 44 45 52 0d 0a 00 00 00 5b 45 52 52 4f 52 5f 48 41 4e 44 4c 49 4e 47 5f  SIDE_BORDER.....[ERROR_HANDLING_
0803b240  53 54 4f 50 5f 42 55 54 54 4f 4e 5d 0d 0a 00 00 5b 45 52 52 4f 52 5f 48 41 4e 44 4c 49 4e 47 5f  STOP_BUTTON]....[ERROR_HANDLING_
0803b260  54 55 52 4e 5f 4f 56 45 52 5d 0d 0a 00 00 00 00 5b 45 52 52 4f 52 5f 48 41 4e 44 4c 49 4e 47 5f  TURN_OVER]......[ERROR_HANDLING_
0803b280  43 4f 4e 54 5f 4c 49 46 54 5d 0d 0a 00 00 00 00 5b 45 52 52 4f 52 5f 48 41 4e 44 4c 49 4e 47 5f  CONT_LIFT]......[ERROR_HANDLING_
0803b2a0  43 4f 4e 54 5f 4c 45 41 4e 5d 0d 0a 00 00 00 00 5b 45 52 52 4f 52 5f 48 41 4e 44 4c 49 4e 47 5f  CONT_LEAN]......[ERROR_HANDLING_
0803b2c0  31 30 53 5f 43 52 41 53 48 5d 0d 0a 00 00 00 00 2a 2a 2a 2a 4d 61 63 68 69 6e 65 20 42 72 65 61  10S_CRASH]......****Machine Brea
0803b2e0  6b 64 6f 77 6e 2a 2a 2a 2a 2a 2a 2a 2a 0a 00 00 52 55 4e 4e 49 4e 47 5f 53 54 41 54 45 5f 48 4d  kdown********...RUNNING_STATE_HM
0803b300  49 5f 4f 52 44 45 52 5f 47 4f 54 54 45 4e 00 00 6d 6f 64 75 6c 65 4d 6f 74 6f 72 53 74 6f 70 43  I_ORDER_GOTTEN..moduleMotorStopC
0803b320  75 74 74 65 72 45 6e 64 6c 6f 67 69 63 0d 0a 00 31 20 72 69 67 68 74 20 73 70 65 65 64 20 25 66  utterEndlogic...1 right speed %f
0803b340  20 61 6e 67 6c 65 20 25 66 20 0d 0a 00 00 00 00 5b 64 65 62 75 67 5d 3d 3d 20 74 75 72 6e 4f 76   angle %f ......[debug]== turnOv
0803b360  65 72 20 54 52 49 47 47 45 52 20 3d 3d 0d 0a 00 5b 64 65 62 75 67 5d 3d 3d 20 6c 69 66 74 20 42  er TRIGGER ==...[debug]== lift B
0803b380  52 45 41 4b 44 4f 57 4e 20 3d 3d 0d 0a 00 00 00 53 50 4f 54 5f 4d 4f 57 49 4e 47 5f 53 54 4f 50  REAKDOWN ==.....SPOT_MOWING_STOP
0803b3a0  5f 45 52 52 4f 52 5f 42 4f 52 44 45 52 0a 00 00                                                  _ERROR_BORDER...
0803b3b0  data_803b3b0:
0803b3b0                                                  3e 20 48 69 67 68 20 73 70 65 65 64 20 64 65 76                  > High speed dev
0803b3c0  69 63 65 20 64 65 74 65 63 74 65 64 2e 00 00 00                                                  ice detected....
0803b3d0  data_803b3d0:
0803b3d0                                                  3e 20 46 75 6c 6c 20 73 70 65 65 64 20 64 65 76                  > Full speed dev
0803b3e0  69 63 65 20 64 65 74 65 63 74 65 64 2e 00 00 00                                                  ice detected....
0803b3f0  data_803b3f0:
0803b3f0                                                  3e 20 4c 6f 77 20 73 70 65 65 64 20 64 65 76 69                  > Low speed devi
0803b400  63 65 20 64 65 74 65 63 74 65 64 2e 00 00 00 00 72 65 61 64 20 78 79 7a 20 72 65 61 64 20 72 65  ce detected.....read xyz read re
0803b420  67 20 65 72 72 6f 72 21 21 21 0a 00 43 72 65 61 74 65 20 53 65 6d 61 70 68 6f 72 65 20 45 72 72  g error!!!..Create Semaphore Err
0803b440  6f 72 21 0d 0a 00 00 00 5b 42 41 54 54 45 52 59 5f 57 4f 52 4b 49 4e 47 5f 45 52 52 4f 52 5d 0d  or!.....[BATTERY_WORKING_ERROR].
0803b460  0a 00 00 00 5b 45 52 52 4f 52 5f 48 41 4e 44 4c 49 4e 47 5f 43 52 41 53 48 5d 0d 0a 00 00 00 00  ....[ERROR_HANDLING_CRASH]......
0803b480  5b 45 52 52 4f 52 5f 48 41 4e 44 4c 49 4e 47 5f 42 4f 52 44 45 52 5d 0d 0a 00 00 00 73 5f 68 6d  [ERROR_HANDLING_BORDER].....s_hm
0803b4a0  69 4c 65 64 4d 75 74 65 78 20 45 72 72 6f 72 21 21 21 0d 0a 00 00 00 00 73 5f 68 6d 69 4b 65 79  iLedMutex Error!!!......s_hmiKey
0803b4c0  4d 75 74 65 78 20 45 72 72 6f 72 21 21 21 0d 0a 00 00 00 00 3d 3d 3d 3d 3d 3d 20 25 64 20 25 73  Mutex Error!!!......====== %d %s
0803b4e0  20 25 64 20 25 64 20 25 64 20 25 64 0d 0a 00 00 73 74 61 72 74 20 66 61 63 74 6f 72 79 54 65 73   %d %d %d %d....start factoryTes
0803b500  74 4c 6f 67 69 63 0d 0a 00 00 00 00 6d 6f 64 75 6c 65 4d 6f 74 6f 72 53 74 61 72 74 43 75 74 74  tLogic......moduleMotorStartCutt
0803b520  65 72 20 25 66 0d 0a 00 74 65 73 74 20 61 63 63 65 6c 65 72 6f 6d 65 74 65 72 20 6d 6f 64 75 6c  er %f...test accelerometer modul
0803b540  65 3a 0a 00 73 75 6d 58 20 25 66 2c 20 73 75 6d 59 20 25 66 2c 20 73 75 6d 5a 20 25 66 0d 0a 00  e:..sumX %f, sumY %f, sumZ %f...
0803b560  56 65 72 73 69 6f 6e 20 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64 2e 25 64 0a 00 00 00 52 55 4e 4e  Version : %d.%d.%d.%d.%d....RUNN
0803b580  49 4e 47 5f 53 54 41 54 45 5f 41 55 54 4f 5f 4d 4f 57 49 4e 47 00 00 00 52 55 4e 4e 49 4e 47 5f  ING_STATE_AUTO_MOWING...RUNNING_
0803b5a0  53 54 41 54 45 5f 42 52 45 41 4b 5f 44 4f 57 4e 00 00 00 00 52 55 4e 4e 49 4e 47 5f 53 54 41 54  STATE_BREAK_DOWN....RUNNING_STAT
0803b5c0  45 5f 53 50 4f 54 5f 4d 4f 57 49 4e 47 00 00 00 5b 65 72 72 6f 72 5d 48 61 72 64 77 61 72 65 53  E_SPOT_MOWING...[error]HardwareS
0803b5e0  74 61 74 65 20 65 72 72 6f 72 0a 00 45 72 72 6f 72 20 4e 6f 20 4d 6f 64 65 20 4c 6f 67 69 63 20  tate error..Error No Mode Logic 
0803b600  46 75 6e 63 0d 0a 00 00 41 25 2e 32 66 20 42 25 2e 32 66 20 43 25 2e 32 66 20 74 20 25 64 0d 0a  Func....A%.2f B%.2f C%.2f t %d..
0803b620  00 00 00 00 31 20 6c 65 66 74 20 73 70 65 65 64 20 25 66 20 61 6e 67 6c 65 20 25 66 20 0d 0a 00  ....1 left speed %f angle %f ...
0803b640  6d 6f 74 6f 72 43 74 72 6c 45 72 72 6f 72 54 69 6d 65 73 20 25 64 20 25 64 0a 00 00 5b 64 65 62  motorCtrlErrorTimes %d %d...[deb
0803b660  75 67 5d 3d 3d 20 6c 65 61 6e 20 45 52 52 4f 52 20 3d 3d 0d 0a 00 00 00 5b 64 65 62 75 67 5d 3d  ug]== lean ERROR ==.....[debug]=
0803b680  3d 20 6c 65 61 6e 20 54 52 49 47 47 45 52 20 3d 3d 0d 0a 00 5b 64 65 62 75 67 5d 3d 3d 20 6c 69  = lean TRIGGER ==...[debug]== li
0803b6a0  66 74 20 54 52 49 47 47 45 52 20 3d 3d 0d 0a 00 53 6f 66 74 77 64 67 20 4d 75 74 65 78 20 45 72  ft TRIGGER ==...Softwdg Mutex Er
0803b6c0  72 6f 72 21 21 21 0d 0a 00 00 00 00 5b 68 65 6c 69 78 5d 72 3a 25 66 20 6c 3a 25 66 20 74 69 6d  ror!!!......[helix]r:%f l:%f tim
0803b6e0  65 3a 25 64 20 0d 0a 00 5b 68 65 6c 69 78 5d 70 65 72 63 69 72 63 6c 65 54 69 6d 65 3a 20 25 64  e:%d ...[helix]percircleTime: %d
0803b700  0d 0a 00 00 57 6f 72 6b 69 6e 67 20 54 69 6d 65 20 3a 20 25 64 28 73 65 63 29 0d 0a 00 00 00 00  ....Working Time : %d(sec)......
0803b720  52 75 6e 6e 69 6e 67 20 54 69 6d 65 20 3a 20 25 64 28 73 65 63 29 0d 0a 00 00 00 00 42 6c 61 64  Running Time : %d(sec)......Blad
0803b740  65 20 20 20 54 69 6d 65 20 3a 20 25 64 28 73 65 63 29 0d 0a 00 00 00 00                          e   Time : %d(sec)......
0803b758  data_803b758:
0803b758                                                                          3e 20 55 4e 52 45 43 4f                          > UNRECO
0803b760  56 45 52 45 44 20 45 52 52 4f 52 20 53 54 41 54 45 2e 00 00 73 5f 76 62 43 6f 6d 6d 44 61 74 61  VERED ERROR STATE...s_vbCommData
0803b780  4d 75 74 65 78 20 65 72 72 6f 72 0d 0a 00 00 00 66 77 53 69 7a 65 20 25 78 20 20 63 68 65 63 6b  Mutex error.....fwSize %x  check
0803b7a0  53 75 6d 20 25 78 0d 0a 00 00 00 00                                                              Sum %x......
0803b7ac    void sub_803b7ac() __noreturn
0803b7ac  {
0803b7b4      sub_803af68();
0803b7be      rtos_boot();
0803b7be      /* no return */
0803b7ac  }
0803b7c2        00 f0 02 f8                                                                                  ....
0803b7c6    int32_t sub_803b7c6() __pure
0803b7c6  {
0803b7c8      return 1;
0803b7c6  }
0803b7ca                                00 f0 01 b8 00 00 07 46 38 46 fc f7 38 f8 fb e7 00 00 78 53 65 6d            .......F8F..8.....xSem
0803b7e0  61 70 68 6f 72 65 54 61 6b 65 20 45 72 72 6f 72 0d 0a 00 00 62 6f 72 64 65 72 44 61 74 61 4d 75  aphoreTake Error....borderDataMu
0803b800  74 65 78 20 65 72 72 6f 72 0d 0a 00 42 4f 52 44 45 52 5f 53 54 41 54 45 5f 55 4e 4b 4e 4f 57 4e  tex error...BORDER_STATE_UNKNOWN
0803b820  0d 0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0803b840  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 6f 76 65 72 6c 6f 6f 6b 20 74 68 69  ....................overlook thi
0803b860  73 20 65 72 72 6f 72 0d 0a 00 00 00 5b 45 52 52 4f 52 5f 48 41 4e 44 4c 49 4e 47 5f 52 41 49 4e  s error.....[ERROR_HANDLING_RAIN
0803b880  5d 0d 0a 00 5b 45 52 52 4f 52 5f 48 41 4e 44 4c 49 4e 47 5f 4c 49 46 54 5d 0d 0a 00 5b 45 52 52  ]...[ERROR_HANDLING_LIFT]...[ERR
0803b8a0  4f 52 5f 48 41 4e 44 4c 49 4e 47 5f 4c 45 41 4e 5d 0d 0a 00 5b 64 65 62 75 67 5d 63 75 72 45 72  OR_HANDLING_LEAN]...[debug]curEr
0803b8c0  72 54 79 70 65 3a 25 64 0d 0a 00 00 5b 64 65 62 75 67 5d 63 68 65 63 6b 53 74 61 74 65 3a 25 64  rType:%d....[debug]checkState:%d
0803b8e0  0d 0a 00 00 73 5f 68 6d 69 4c 65 64 4d 75 74 65 78 20 65 72 72 6f 72 0d 0a 00 00 00 73 5f 68 6d  ....s_hmiLedMutex error.....s_hm
0803b900  69 4b 65 79 4d 75 74 65 78 20 65 72 72 6f 72 0d 0a 00 00 00 48 4d 49 20 54 55 52 4e 20 4f 4e 20  iKeyMutex error.....HMI TURN ON 
0803b920  41 4c 4c 20 4c 45 44 0d 0a 00 00 00 64 65 76 41 63 63 65 6c 65 72 6d 65 74 65 72 49 6e 69 74 0d  ALL LED.....devAccelermeterInit.
0803b940  0a 00 00 00 6d 6f 64 75 6c 65 4d 6f 74 6f 72 46 6f 72 77 61 72 64 20 25 66 0d 0a 00 43 75 72 72  ....moduleMotorForward %f...Curr
0803b960  65 6e 74 53 70 65 65 64 20 3a 20 25 66 20 25 66 0d 0a 00 00 61 6e 67 6c 65 20 3a 20 25 66 20 20  entSpeed : %f %f....angle : %f  
0803b980  28 25 66 2c 20 25 66 29 0d 0a 00 00 25 64 20 46 20 25 66 20 6d 69 6e 20 25 64 20 6d 61 78 20 25  (%f, %f)....%d F %f min %d max %
0803b9a0  64 0d 0a 00 25 64 20 42 20 25 66 20 6d 69 6e 20 25 64 20 6d 61 78 20 25 64 0d 0a 00 52 55 4e 4e  d...%d B %f min %d max %d...RUNN
0803b9c0  49 4e 47 5f 53 54 41 54 45 5f 4c 4f 57 5f 50 4f 57 45 52 00 42 41 54 54 45 52 59 5f 57 4f 52 4b  ING_STATE_LOW_POWER.BATTERY_WORK
0803b9e0  49 4e 47 5f 45 52 52 4f 52 0d 0a 00 53 6f 66 74 77 64 67 20 4d 75 74 65 78 20 65 72 72 6f 72 0d  ING_ERROR...Softwdg Mutex error.
0803ba00  0a 00 00 00 5b 68 65 6c 69 78 5d 77 61 6c 6b 54 69 6d 65 3a 25 64 20 0d 0a 00 00 00 72 6d 31 32  ....[helix]walkTime:%d .....rm12
0803ba20  76 73 5f 25 64 2e 25 64 2e 25 64 2e 25 64 0d 0a 00 00 00 00                                      vs_%d.%d.%d.%d......
0803ba34  data_803ba34:
0803ba34                                                              3e 20 44 65 76 69 63 65 20 44 69 73                      > Device Dis
0803ba40  63 6f 6e 6e 65 63 74 65 64 2e 00 00                                                              connected...
0803ba4c  data_803ba4c:
0803ba4c                                      3e 20 52 65 73 65 74 20 74 68 65 20 55 53 42 20 64 65 76 69              > Reset the USB devi
0803ba60  63 65 2e 00                                                                                      ce..
0803ba64  data_803ba64:
0803ba64              3e 20 48 49 44 20 64 65 76 69 63 65 20 63 6f 6e 6e 65 63 74 65 64 2e 00 5b 76 62 5d      > HID device connected..[vb]
0803ba80  69 6e 74 65 72 76 61 6c 3a 20 25 64 20 25 64 0d 0a 00 00 00                                      interval: %d %d.....
0803ba94    int32_t console_putc_stateful(int32_t state, int32_t ch)
0803ba94  {
0803ba94      int32_t r3;
0803ba94      int32_t var_10 = r3;
0803ba94      
0803baa2      if (console_write_char(ch) != ch)
0803baa4          return 0;
0803baa4      
0803baa8      return state;
0803ba94  }
0803baaa                                00 00                                                                        ..
0803baac    int32_t console_write_char(int32_t arg1)
0803baac  {
0803baae      /* tailcall */
0803baae      return uart_send_blocking(arg1, 0x20000c8c);
0803baac  }
0803bab2                                                        00 bf                                                        ..
0803bab4  int32_t data_803bab4 = 0x20000c8c
0803bab8  char data_803bab8[0x13] = "walkTime : %d ms\r\n", 0
0803bacb                                   00                                                                         .
0803bacc  char data_803bacc[0x11] = "MOWING_FORWARD\r\n", 0
0803badd                                                                                         00 00 00                               ...
0803bae0  char data_803bae0[0x12] = "MOWING_BACKWARD\r\n", 0
0803baf2                                                        00 00                                                        ..
0803baf4  char data_803baf4[0x13] = "MOWING_TURN_LEFT\r\n", 0
0803bb07                       00                                                                                 .
0803bb08  char data_803bb08[0x14] = "MOWING_TURN_RIGHT\r\n", 0
0803bb1c  char data_803bb1c[0x11] = "Mutex Error!!!\r\n", 0
0803bb2d                                         00 00 00                                                               ...
0803bb30  char data_803bb30[0x14] = "[debug]EHMType:%d\r\n", 0
0803bb44  char data_803bb44[0x11] = "wait start com\r\n", 0
0803bb55                                                                 00 00 00                                               ...
0803bb58  char data_803bb58[0x13] = "start board test\r\n", 0
0803bb6b                                   00                                                                         .
0803bb6c  char data_803bb6c[0x14] = "%d %d %d %d %d %d\r\n", 0
0803bb80  char data_803bb80[0x12] = "moduleMotorInit\r\n", 0
0803bb92                                                        00 00                                                        ..
0803bb94  char data_803bb94[0x14] = "devSamplerAdcInit\r\n", 0
0803bba8  char data_803bba8[0x14] = "devUltrasonicInit\r\n", 0
0803bbbc  char data_803bbbc[0x13] = "walk motor %d %d\r\n", 0
0803bbcf                                               00                                                                 .
0803bbd0  char data_803bbd0[0x11] = "lift Sensor %d\r\n", 0
0803bbe1     00 00 00                                                                                       ...
0803bbe4  char data_803bbe4[0x11] = "stop button %d\r\n", 0
0803bbf5                                                                 00 00 00                                               ...
0803bbf8  char data_803bbf8[0x12] = "battery %d %.2f\r\n", 0
0803bc0a                                00 00                                                                        ..
0803bc0c  char data_803bc0c[0x13] = "Accelerometer %d\r\n", 0
0803bc1f                                                                                               00                                 .
0803bc20  char data_803bc20[0x13] = "device init fail\r\n", 0
0803bc33                                                           00                                                         .
0803bc34  char data_803bc34[0x13] = "moduleBorderInit\r\n", 0
0803bc47                       00                                                                                 .
0803bc48  char data_803bc48[0x13] = "moduleSensorInit\r\n", 0
0803bc5b                                                                                   00                                         .
0803bc5c  char data_803bc5c[0x13] = "vbCommMoudleInit\r\n", 0
0803bc6f                                               00                                                                 .
0803bc70  char data_803bc70[0x14] = "RUNNING_STATE_ERROR", 0
0803bc84  char data_803bc84[0x14] = "RUNNING_STATE_SLEEP", 0
0803bc98  char data_803bc98[0x14] = "Cutter RUNNING %d\r\n", 0
0803bcac  char data_803bcac[0x14] = "Cutter STOPPED %d\r\n", 0
0803bcc0  char data_803bcc0[0x13] = "lean 10s trigger\r\n", 0
0803bcd3                                                           00                                                         .
0803bcd4  char data_803bcd4[0x11] = "\r\n > VID: %04Xh ", 0
0803bce5                 00 00 00                                                                               ...
0803bce8  char data_803bce8[0x11] = "\r\n > PID: %04Xh ", 0
0803bcf9                                                                             00 00 00                                       ...
0803bcfc  char data_803bcfc[0x14] = "Cam_%d.%d.%d.%d\r\n\r\n", 0
0803bd10  data_803bd10:
0803bd10                                                  3e 20 44 65 76 69 63 65 20 41 74 74 61 63 68 65                  > Device Attache
0803bd20  64 2e 00 00                                                                                      d...
0803bd24  char data_803bd24[0x11] = "Mutex Error!!!\r\n", 0
0803bd35                                                                 00 00 00                                               ...
0803bd38  char data_803bd38[0x14] = "[++VBS]:%d %d C %d\n", 0
0803bd4c  char data_803bd4c[0x13] = "delete pics done\r\n", 0
0803bd5f                                                                                               00                                 .
0803bd60  0f 10 11 17 18 1a 1c 20 43 45 4a 50 56 57 00 00                                                  ....... CEJPVW..
0803bd70  char data_803bd70[0x10] = "MOWING_STOP 2\r\n", 0
0803bd80  char data_803bd80[0xe] = "MOWING_STOP\r\n", 0
0803bd8e                                            00 00                                                                ..
0803bd90  char data_803bd90[0x10] = "MOWING_STOP 3\r\n", 0
0803bda0  char data_803bda0[0x10] = "BorderCheckTask", 0
0803bdb0  data_803bdb0:
0803bdb0                                                  01 03 05 07 09 0e 10 12 14 16 18 1c 1e 00 00 00                  ................
0803bdc0  00 00 00 00 00 00 00 00 01 02 03 04 06 07 08 09                                                  ................
0803bdd0  char data_803bdd0[0x10] = "devSensorInit\r\n", 0
0803bde0  char data_803bde0[0x10] = "moduleSpkInit\r\n", 0
0803bdf0  char data_803bdf0[0xf] = "rain %d %.2f\r\n", 0
0803bdff                                                                                               00                                 .
0803be00  char data_803be00[0xe] = "ntc %d %.2f\r\n", 0
0803be0e                                            00 00                                                                ..
0803be10  char data_803be10[0xd] = "UV %d %.2f\r\n", 0
0803be1d                                                                                         00 00 00                               ...
0803be20  char data_803be20[0x10] = "ultrasonic %d\r\n", 0
0803be30  char data_803be30[0xd] = "%d %d HIGH\r\n", 0
0803be3d                                                                                         00 00 00                               ...
0803be40  char MotorCtrlTaskStr[0xe] = "MotorCtrlTask", 0
0803be4e                                            00 00                                                                ..
0803be50  char data_803be50[0xe] = "[BV]: %.2f \r\n", 0
0803be5e                                                                                            00 00                                ..
0803be60  char data_803be60[0xe] = "[UV]: %.2f \r\n", 0
0803be6e                                            00 00                                                                ..
0803be70  char data_803be70[0xe] = "BATTERY_LOW\r\n", 0
0803be7e                                                                                            00 00                                ..
0803be80  char data_803be80[0xd] = "[BT]:%.2f \r\n", 0
0803be8d                                         00 00 00                                                               ...
0803be90  char data_803be90[0xf] = "[%d] %f %.2f\r\n", 0
0803be9f                                                                                               00                                 .
0803bea0  char data_803bea0[0xf] = "%d %d %d %d \r\n", 0
0803beaf                                               00                                                                 .
0803beb0  char data_803beb0[0xd] = "lift alarm\r\n", 0
0803bebd                                                                                         00 00 00                               ...
0803bec0  char data_803bec0[0xe] = "start cutter\n", 0
0803bece                                            00 00                                                                ..
0803bed0  char data_803bed0[0xd] = "board test  ", 0
0803bedd                                                                                         00 00 00                               ...
0803bee0  char data_803bee0[0xf] = "0:boadTest.TXT", 0
0803beef                                               00                                                                 .
0803bef0  char data_803bef0[0xf] = "ErrorLog Yes\r\n", 0
0803beff                                                                                               00                                 .
0803bf00  char data_803bf00[0xe] = "ErrorLog No\r\n", 0
0803bf0e                                            00 00                                                                ..
0803bf10  data_803bf10:
0803bf10                                                  3e 20 44 65 76 69 63 65 20 66 61 75 6c 74 2e 00                  > Device fault..
0803bf20  char data_803bf20[0x10] = "\r\n FW Tag ERROR", 0
0803bf30  char data_803bf30[0xf] = "f_read error\r\n", 0
0803bf3f                                                                                               00                                 .
0803bf40  char data_803bf40[0xe] = "[PCBT]:%.4f\r\n", 0
0803bf4e                                            00 00                                                                ..
0803bf50    void Reset_Handler() __noreturn
0803bf50  {
0803bf52      SystemInit();
0803c048      sub_803b1ac();
0803c04c      sub_803b7ac();
0803c04c      /* no return */
0803bf50  }
0803bf58  int32_t data_803bf58 = 0x803a6a5
0803bf5c  int32_t data_803bf5c = 0x803c045
0803bf60  char wait_border[0xc] = "wait border", 0
0803bf6c  char data_803bf6c[0x9] = "\"*:<>?|\x7f", 0
0803bf75                                                                 00 00 00                                               ...
0803bf78  char data_803bf78[0xc] = "%d %d LOW\r\n", 0
0803bf84  char ModeTaskNameStr[0x9] = "ModeTask", 0
0803bf8d                                         00 00 00                                                               ...
0803bf90  char data_803bf90[0xc] = "Mode : %s\r\n", 0
0803bf9c  char data_803bf9c[0xc] = "pwm %d %d\r\n", 0
0803bfa8  char SensorTaskStr[0xb] = "SensorTask", 0
0803bfb3                                                           00                                                         .
0803bfb4  char SpeakerTaskStr[0xc] = "SpeakerTask", 0
0803bfc0  char over_time[0xb] = "over time\n", 0
0803bfcb                                   00                                                                         .
0803bfcc  char data_803bfcc[0x9] = "Cam_WDR0", 0
0803bfd5                                                                 00 00 00                                               ...
0803bfd8  char data_803bfd8[0xa] = "0:ERR_LOG", 0
0803bfe2        00 00                                                                                        ..
0803bfe4  char data_803bfe4[0xc] = "[%d] %s %s\n", 0
0803bff0  char data_803bff0[0xb] = "TEST Yes\r\n", 0
0803bffb                                                                                   00                                         .
0803bffc  char data_803bffc[0xa] = "TEST No\r\n", 0
0803c006                    00 00                                                                                ..
0803c008  char data_803c008[0xa] = "PUK Yes\r\n", 0
0803c012                                                        00 00                                                        ..
0803c014  char data_803c014[0x9] = "PUK No\r\n", 0
0803c01d                                                                                         00 00 00                               ...
0803c020  char data_803c020[0xb] = "VbCommTask", 0
0803c02b                                   00                                                                         .
0803c02c  char data_803c02c[0xa] = "success\r\n", 0
0803c036                                                                    00 00 43 61 6d 5f 57 44 52 30                        ..Cam_WDR0
0803c040  00 00 00 00                                                                                      ....
0803c050  char data_803c050[0x5] = "%f\r\n", 0
0803c055                                                                 00 00 00                                               ...
0803c058  char data_803c058[0x7] = "+,;[=]", 0
0803c05f                                                                                               00                                 .
0803c060  00 00 00 00 01 02 03 04 00 00 00 00 01 02 03 04                                                  ................
0803c070  char data_803c070[0x8] = "HmiTask", 0
0803c078  char data_803c078[0x8] = "VB %d\r\n", 0
0803c080  char data_803c080[0x8] = "%d %d\r\n", 0
0803c088  char data_803c088[0x6] = "%d \r\n", 0
0803c08e                                            00 00 0d 0a 25 73 00 00 00 00                                        ....%s....
0803c098  char data_803c098[0x5] = "LOFF", 0
0803c09d                                                                                         00 00 00                               ...
0803c0a0  char data_803c0a0[0x8] = "t: %d\r\n", 0
0803c0a8                          00 00 00 40 00 00 00 00                                                          ...@....
0803c0b0  char data_803c0b0[0x5] = "INIT", 0
0803c0b5                                                                 00 00 00                                               ...
0803c0b8  char data_803c0b8[0x5] = "IDLE", 0
0803c0bd                                                                                         00 00 00                               ...
0803c0c0  char data_803c0c0[0x7] = "\r\n %s ", 0
0803c0c7                       00                                                                                 .
0803c0c8  char data_803c0c8[0x8] = "UsbTask", 0
0803c0d0  char data_803c0d0[0x6] = "Yes\r\n", 0
0803c0d6                                                                    00 00                                                ..
0803c0d8  char data_803c0d8[0x5] = "No\r\n", 0
0803c0dd                                                                                         00 00 00                               ...
0803c0e0  char data_803c0e0[0x7] = "rm12vs", 0
0803c0e7                       00                                                                                 .
0803c0e8  char data_803c0e8[0x8] = "Model_L", 0
0803c0f0  char data_803c0f0[0x5] = "%.6f", 0
0803c0f5                                                                 00 00 00                                               ...
0803c0f8  char data_803c0f8[0x5] = "%.2f", 0
0803c0fd                                                                                         00 00 00                               ...
0803c100  char data_803c100[0x7] = "0:TEST", 0
0803c107                       00                                                                                 .
0803c108  char data_803c108[0x5] = "%s\r\n", 0
0803c10d                                         00 00 00                                                               ...
0803c110  char data_803c110[0x5] = "test", 0
0803c115                                                                 00 00 00                                               ...
0803c118  char data_803c118[0x6] = "0:PUK", 0
0803c11e                                                                                            00 00                                ..
0803c120  char data_803c120[0x8] = "error\r\n", 0
0803c128  char data_803c128[0x8] = "Model_L", 0
0803c130                                                  08 00 00 00 f0 e3 00 e0 ff f7 fe bf ff f7 fe bf                  ................
0803c140  ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf  ................................
0803c160  ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf  ................................
0803c180  ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf  ................................
0803c1a0  ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf  ................................
0803c1c0  ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf  ................................
0803c1e0  ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf  ................................
0803c200  ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf  ................................
0803c220  ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf ff f7 fe bf  ................................
0803c240  f0 06 08 00 00 a0 41 00 00 02 43 04 10 02 04 00 40 00 01 20 02 01 10 9f 02 08 21 05 21 04 22 1d  ......A...C.....@.. ......!.!.".
0803c260  0d 50 02 04 02 40 10 10 11 01 23 40 01 08 51 28 43 04 00 04 52 1c 28 12 08 08 31 20 33 40 01 50  .P...@....#@..Q(C...R.(...1 3@.P
0803c280  a0 02 10 11 17 01 50 32 18 15 10 01 02 40 20 08 22 03 0c 20 01 08 00 40 18 12 d1 04 53 c8 00 01  ......P2.....@ .".. ...@....S...
0803c2a0  11 48 53 00 01 70 11 20 f2 03 03 20 82 02 20 e2 01 20 12 0c 20 82 20 20 21 07 f1 00 20 62 10 d0  .HS..p. ... .. .. .. .  !... b..
0803c2c0  41 a8 a2 f9 20 42 10 60 21 58 70 01 1d 10 00 01 44 04 fe 0f 00 0c 00 00 0c 53 1d 10 e8 11 01 61  A... B.`!Xp.....D........S.....a
0803c2e0  18 21 d4 31 5c 11 04 12 80 0c 21 59 30 02 03 0c 03 0c 50 11 04 21 30 21 74 60 02 04 0c 04 0c 28  .!.1\.....!Y0.....P..!0!t`.....(
0803c300  21 4c 62 20 28 a0 05 01 02 03 56 65 72 00 01 90 03 35 76 20 55 4c 12 11 10 50 04 56 42 20 4f 46  !Lb (.....Ver....5v UL...P.VB OF
0803c320  46 14 51 10 62 4e 23 11 10 70 01 4d 41 49 0f 40 09 00 33 2e 33 76 20 48 41 4c 4c 31 13 71 10 42  F.Q.bN#..p.MAI.@..3.3v HALL1.q.B
0803c340  32 10 b0 01 55 53 42 70 b0 01 41 43 43 10 a0 02 4c 69 66 74 11 c0 02 31 2e 31 76 10 b2 35 10 70  2...USBp..ACC...Lift...1.1v..5.p
0803c360  05 42 41 54 54 45 52 59 13 c3 4e 54 50 90 03 52 61 69 6e 31 12 21 10 92 32 10 b0 01 4f 56 00 01  .BATTERY..NTP..Rain1.!..2...OV..
0803c380  c3 49 44 10 a0 03 46 6c 61 73 68 40 d1 60 80 04 4d 20 4c 20 66 62 13 d0 01 4d 20 52 10 a3 4c 20  .ID...Flash@.`..M L fb...M R..L 
0803c3a0  32 21 20 a1 10 c6 56 0f 80 05 00 53 57 2b 48 4d 49 14 a0 02 53 54 4f 50 22 a0 02 53 4c 45 45 11  2! ...V....SW+HMI...STOP"..SLEE.
0803c3c0  70 05 43 55 52 52 45 4e 54 12 16 10 e1 10 07 f0 b2 03 08 97 9a 03 08 09 04 12 35 04 12 3c 1e a0  p.CURRENT.................5..<..
0803c3e0  02 62 6b 02 08 48 f1 2f 14 40 0c 7c b5 03 08 19 83 03 08 d5 82 03 08 cd 82 64 10 07 70 bc 03 08  .bk..H./.@.|.............d..p...
0803c400  fb 8b 03 08 bd 04 43 b5 8b 14 12 98 28 10 03 4f 95 03 08 3d 04 43 35 95 14 10 07 bc b9 03 08 7f  ......C.....(..O...=.C5.........
0803c420  21 02 08 8b 04 12 83 04 21 14 12 84 3c 30 01 ad ab 03 68 f3 45 a5 ab b4 f1 03 14 12 b4 a0 f0 08  !.......!...<0....h.E...........
0803c440  09 1d 9f 03 08 c9 9e 03 08 c1 9e 78 12 aa 01 21 14 12 ff 01 6d 88 03 f1 10 0c 4c 03 7a 03 0a 00  ...........x...!....m.....L.z...
0803c460  50 10 04 2e 14 79 03 1e e1 90 03 1d ba 03 4f 00 08 10 04 21 65 22 03 10 1d 98 03 43 04 00 10 22  P....y........O....!e".....C..."
0803c480  15 10 42 60 10 12 04 3c 83 04 0f 8a 31 10 52 0b 10 3f 14 01 e0 03 c3 05 11 58 52 40 48 61 10 52  ..B`...<....1.R..?.......XR@Ha.R
0803c4a0  80 10 22 16 10 20 02 64 02 40 07 58 11 3c 5e 05 d1 03 62 01 10 42 39 10 12 14 07 10 07 11 26 02  ..".. .d.@.X.<^...b..B9.......&.
0803c4c0  08 fd 25 02 08 07 08 10 07 bc 05 00 20 31 24 02 08 67 04 12 b9 14 12 fb 04 12 ed 0c 12 4f 08 12  ..%......... 1$..g...........O..
0803c4e0  79 04 12 1d 04 12 81 04 12 83 04 21 4e 30 05 8d 28 02 08 01 01 04 08 30 01 04 02 07 08 30 01 07  y..........!N0..(......0.....0..
0803c500  03 05 08 30 01 05 04 06 08 30 01 06 05 09 08 12 09 8d 21 08 52 02 08 52 05 18 10 03 77 45 02 08  ...0.....0........!.R..R....wE..
0803c520  89 04 10 0b 33 46 02 08 8d 47 02 08 39 49 02 08 63 04 12 75 04 53 00 01 64 43 02 02 08 43 03 03  ....3F...G..9I..c..u.S..dC...C..
0803c540  08 42 05 74 52 02 10 62 02 10 42 06 7c 52 03 7c 52 03 18 52 03 18 20 03 04 64 64 00 91 7c 51 08  .B.tR..b..B.|R.|R..R.. ..dd..|Q.
0803c560  52 06 08 10 03 d3 4b 02 08 df 04 10 07 9b 3d 02 08 9d 3e 02 08 3b 04 10 03 2b 3f 02 08 ab 04 10  R.....K.......=...>..;...+?.....
0803c580  03 41 40 02 08 c3 04 10 03 49 41 02 08 d5 04 f3 01 17 42 98 61 88 57 03 04 0c 56 05 04 56 06 04  .A@......IA.......B.a.W...V..V..
0803c5a0  56 07 1c 33 08 08 08 57 08 09 14 51 80 f2 ff 00 01 f1 ff 01 f1 ff 01 f1 ea 01 fc 09 58 dd f8 02  V..3...W...Q................X...
0803c5c0  08 d7 63 03 08 e1 63 03 38 04 1c 07 ec 0b 00 20 b1 4a 02 08 7d 24 05 10 03 01 f7 02 08 5b 84 12  ..c...c.8...... .J..}$.......[..
0803c5e0  11 08 12 41 04 12 31 04 12 f5 04 12 51 04 12 9d 04 12 b7 04 12 b9 04 12 e3 04 12 e5 04 12 e7 04  ...A..1.....Q...................
0803c600  12 e9 04 12 ed 04 12 f7 04 12 eb 04 12 21 04 4f 00 4c 5c 0b 2e 13 2c 07 8f c2 01 2c 07 ce 04 d4  .............!.O.L\...,....,....
0803c620  06 21 0d fd 00 2c 07 8e 4c 2c 07 62 02 10 52 0d 10 10 06 04 01 01 a0 df 00 20 f0 04 92 a0 04 10  .!...,..L,.b..R.......... ......
0803c640  03 c9 0c 00 20 b0 04 f5 13 34 fe 96 01 91 05 52 ff 01 f1 13 af 41 2c f1 29 d9 00 07 03 08 06 06  .... ....4.....R.....A,.).......
0803c660  01 01 03 32 64                                                                                   ...2d
.synthetic_builtins section started  {0x803c670-0x803c688}
0803c670  extern void* __builtin_memcpy(void* dest, void const* src, uint32_t count)
0803c674  extern void* __builtin_memset(void* dest, int32_t ch, uint32_t count)
0803c678  extern char* __builtin_strcpy(char* dest, char const* src)
0803c67c  extern char* __builtin_strncpy(char* dest, char const* src, uint32_t count)
0803c680  extern wchar32* __builtin_wcscpy(wchar32* dest, wchar32 const* src)
0803c684  extern wchar32* __builtin_wmemcpy(wchar32* dest, wchar32 const* src, uint32_t count)
.synthetic_builtins section ended  {0x803c670-0x803c688}
20000000  float turnTable[0x7] = 
20000000  {
20000000      [0x0] = 0
20000004      [0x1] = 0
20000008      [0x2] = 0
2000000c      [0x3] = 0
20000010      [0x4] = 0
20000014      [0x5] = 0
20000018      [0x6] = 0
2000001c  }
2000001c                                                                                      00 00 00 00                              ....
20000020  data_20000020:
20000080  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ........................
20000098  int32_t data_20000098 = 0x0
2000009c                                                                                      00 00 00 00                              ....
200000a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ........................
200000b8  int32_t data_200000b8 = 0x0
200000bc                                                                                      00 00 00 00                              ....
200000c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ........................
200000d8  int32_t data_200000d8 = 0x0
200000dc                                                                                      00 00 00 00                              ....
200000e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ........................
200000f8  int32_t data_200000f8 = 0x0
200000fc                                                                                      00 00 00 00                              ....
20000100  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ........................
20000118  int32_t data_20000118 = 0x0
2000011c                                                                                      00 00 00 00                              ....
20000160  00 00 00 00 00 00 00 00                                                                          ........
20000168  int32_t data_20000168 = 0x0
2000016c  int32_t data_2000016c = 0x0
20000170  int32_t data_20000170 = 0x0
20000174  int32_t data_20000174 = 0x0
20000178  int16_t data_20000178 = 0x0
2000017a  int16_t data_2000017a = 0x0
2000017c  int32_t data_2000017c = 0x0
20000180  int32_t data_20000180 = 0x0
20000184  int32_t data_20000184 = 0x0
20000188  int32_t data_20000188 = 0x0
2000018c  int16_t data_2000018c = 0x0
2000018e  int16_t data_2000018e = 0x0
20000190  int32_t data_20000190 = 0x0
20000194  int32_t data_20000194 = 0x0
20000198  int32_t data_20000198 = 0x0
2000019c  int32_t data_2000019c = 0x0
200001a0  int16_t data_200001a0 = 0x0
200001a2  int16_t data_200001a2 = 0x0
200001a4  data_200001a4:
200001a4              00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00      ............................
20000360  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ........................
20000378  char g_currentModeIndex = 0x0
20000379  char data_20000379 = 0x0
2000037a                                                                                00 00 00 00 00 00                            ......
200004c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................
200004d0  int32_t data_200004d0 = 0x0
200004d4  data_200004d4:
200004d4                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............
20000500  00 00 00 00                                                                                      ....
20000504  int32_t data_20000504 = 0x0
20000508  uint32_t CAM_USART_BASE = 0x0
2000050c                                      00 00 00 00                                                              ....
20000510  struct CamLinkCfg cam_uart_cfg_default = 
20000510  {
20000510      uint32_t usart_base = 0x0
20000514      uint32_t tx_gpio_base = 0x0
20000518      uint32_t rx_gpio_base = 0x0
2000051c      uint32_t baud = 0x0
20000520      uint32_t field_10 = 0x0
20000524      uint32_t field_14 = 0x0
20000528      uint32_t field_18 = 0x0
2000052c      uint32_t field_1c = 0x0
20000530      uint32_t field_20 = 0x0
20000534  }
20000534                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............
20000560  int32_t data_20000560 = 0x0
20000564              00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00      ............................
20000580  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................
20000590  data_20000590:
20000590                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
200005a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ........................
200005b8  int32_t data_200005b8 = 0x0
200005bc                                                                                      00 00 00 00                              ....
200005c0  00 00 00 00 00 00 00 00                                                                          ........
200005c8  int32_t data_200005c8 = 0x0
200005cc  data_200005cc:
200005cc                                      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00              ....................
20000620  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00              ............................
2000063c  data_2000063c:
2000063c                                                                                      00 00 00 00                              ....
200006c0  int32_t data_200006c0 = 0x0
200006c4  int32_t data_200006c4 = 0x0
200006c8  data_200006c8:
200006c8                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
20000b60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                 ...........................
20000b7b  char data_20000b7b = 0x0
20000b7c  char data_20000b7c = 0x0
20000b7d                                                                                         00 00 00                               ...
20000be0  int32_t data_20000be0 = 0x0
20000be4              00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00      ............................
20000c20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                      ....................
20000c34  int32_t data_20000c34 = 0x0
20000c38                                                                          00 00 00 00 00 00 00 00                          ........
20000c60  00 00 00 00                                                                                      ....
20000c64  data_20000c64:
20000c64              00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00      ............................
20000cc0  00 00 00 00 00 00 00 00 00 00 00 00                                                              ............
20000ccc  char data_20000ccc = 0x0
20000ccd                                         00 00 00                                                               ...
20000cd0  int32_t data_20000cd0 = 0x0
20000cd4  char data_20000cd4 = 0x0
20000cd5                                                                 00 00 00                                               ...
20000cd8  data_20000cd8:
20000cd8                                                                          00 00 00 00 00 00 00 00                          ........
20000d40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                      ....................
20000d54  int32_t data_20000d54 = 0x0
20000d58  int32_t data_20000d58 = 0x0
20000d5c  int32_t data_20000d5c = 0x0
20000d60  int32_t data_20000d60 = 0x0
20000d64  int32_t data_20000d64 = 0x0
20000d68  int32_t data_20000d68 = 0x0
20000d6c  int32_t data_20000d6c = 0x0
20000d70  int32_t data_20000d70 = 0x0
20000d74  int32_t data_20000d74 = 0x0
20000d78                                                                          00 00 00 00 00 00 00 00                          ........
20000d80  int32_t data_20000d80 = 0x0
20000d84  int32_t data_20000d84 = 0x0
20000d88  int32_t data_20000d88 = 0x0
20000d8c  int32_t data_20000d8c = 0x0
20000d90  int32_t data_20000d90 = 0x0
20000d94  int32_t data_20000d94 = 0x0
20000d98  int32_t data_20000d98 = 0x0
20000d9c  int32_t data_20000d9c = 0x0
20000da0  int32_t data_20000da0 = 0x0
20000da4              00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00      ............................
20000de0  00 00 00 00                                                                                      ....
20000de4  char data_20000de4 = 0x0
20000de5  char data_20000de5 = 0x0
20000de6  char data_20000de6 = 0x0
20000de7  char data_20000de7 = 0x0
20000de8  char data_20000de8 = 0x0
20000de9  char data_20000de9 = 0x0
20000dea  char data_20000dea = 0x0
20000deb  char data_20000deb = 0x0
20000dec  char data_20000dec = 0x0
20000ded                                         00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00               ...................
20002de0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................
20002df0  int32_t data_20002df0 = 0x0
20002df4                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............
20004de0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................
20004df0  int32_t data_20004df0 = 0x0
20004df4  int32_t data_20004df4 = 0x0
20004df8                                                                          00 00 00 00 00 00 00 00                          ........
2000d020  00 00 00 00 00 00 00 00 00 00 00 00                                                              ............
2000d02c  int32_t data_2000d02c = 0x0
2000d030                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
2000d240  00 00 00 00                                                                                      ....
2000d244  char data_2000d244 = 0x0
2000d245  char data_2000d245 = 0x0
2000d246  char data_2000d246 = 0x0
2000d247  char data_2000d247 = 0x0
2000d248  int16_t data_2000d248 = 0x0
2000d24a  int16_t data_2000d24a = 0x0
2000d24c  char data_2000d24c = 0x0
2000d24d                                         00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00               ...................
2000d440  00 00 00 00 00 00 00 00 00 00 00 00                                                              ............
2000d44c  char data_2000d44c = 0x0
2000d44d                                         00 00 00                                                               ...
2000d450  data_2000d450:
2000d450                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
2000d640  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................
2000d650  char data_2000d650 = 0x0
2000d651  char data_2000d651 = 0x0
2000d652  char data_2000d652 = 0x0
2000d653  char data_2000d653 = 0x0
2000d654                                                              00 00                                                    ..
2000d656  char data_2000d656 = 0x0
2000d657  char data_2000d657 = 0x0
2000d658                                                                          00 00 00 00 00 00 00 00                          ........
2000d840  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................
2000d850  data_2000d850:
2000d850                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
2000da40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................
2000da50  int32_t data_2000da50 = 0x0
2000da54  int32_t data_2000da54 = 0x0
2000da58  int32_t data_2000da58 = 0x0
2000da5c  int32_t data_2000da5c = 0x0
2000da60  int32_t data_2000da60 = 0x0
2000da64  int32_t data_2000da64 = 0x0
2000da68  int32_t data_2000da68 = 0x0
2000da6c  int32_t data_2000da6c = 0x0
2000da70  int32_t data_2000da70 = 0x0
2000da74                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............
2000dc00  00 00 00 00 00 00 00 00 00 00 00 00                                                              ............
2000dc0c  int32_t data_2000dc0c = 0x0
2000dc10                                                  00 00 00 00 00 00 00 00                                          ........
2000dc18  int32_t data_2000dc18 = 0x0
2000dc1c                                                                                      00 00 00 00                              ....
2000dde0  int32_t data_2000dde0 = 0x0
2000dde4  int32_t data_2000dde4 = 0x0
2000dde8                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
2000df00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00              ............................
2000df1c  char data_2000df1c = 0x0
2000df1d                                                                                         00 00 00                               ...
2000df20  int32_t data_2000df20 = 0x0
2000df24  int32_t data_2000df24 = 0x0
2000df28  int32_t data_2000df28 = 0x0
2000df2c  char data_2000df2c = 0x0
2000df2d                                         00 00 00                                                               ...
2000df30  int32_t data_2000df30 = 0x0
2000df34                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............
2000df40  00 00 00 00                                                                                      ....
2000df44  char data_2000df44 = 0x0
2000df45  char data_2000df45 = 0x0
2000df46                    00 00                                                                                ..
2000df48  char data_2000df48 = 0x0
2000df49                             00 00 00                                                                       ...
2000df4c  int32_t data_2000df4c = 0x0
2000df50  int32_t data_2000df50 = 0x0
2000df54  int32_t data_2000df54 = 0x0
2000df58  char data_2000df58 = 0x0
2000df59                                                                             00 00 00                                       ...
2000df5c  int32_t data_2000df5c = 0x0
2000df60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................
2000df70  char data_2000df70 = 0x0
2000df71  char data_2000df71 = 0x0
2000df72                                                        00 00                                                        ..
2000df74  char data_2000df74 = 0x0
2000df75                                                                 00 00 00                                               ...
2000df78  int32_t data_2000df78 = 0x0
2000df7c  int32_t data_2000df7c = 0x0
2000df80  int32_t data_2000df80 = 0x0
2000df84  char data_2000df84 = 0x0
2000df85                 00 00 00                                                                               ...
2000df88  int32_t data_2000df88 = 0x0
2000df8c                                      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ................
2000df9c  char data_2000df9c = 0x0
2000df9d  char data_2000df9d = 0x0
2000df9e                                                                                            00 00                                ..
2000dfe0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ........................
2000dff8  int32_t data_2000dff8 = 0x0
2000dffc                                                                                      00 00 00 00                              ....
2000e020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                      ....................
2000e034  int32_t data_2000e034 = 0x0
2000e038  int32_t data_2000e038 = 0x0
2000e03c  int32_t data_2000e03c = 0x0
2000e040  int32_t data_2000e040 = 0x0
2000e044  int32_t data_2000e044 = 0x0
2000e048  int32_t data_2000e048 = 0x0
2000e04c                                      00 00 00 00 00 00 00 00                                                  ........
2000e054  int32_t data_2000e054 = 0x0
2000e058  int32_t data_2000e058 = 0x0
2000e05c  char data_2000e05c = 0x0
2000e05d                                                                                         00 00 00                               ...
2000e060  00 00 00 00 00 00 00 00 00 00 00 00                                                              ............
2000e06c  int32_t data_2000e06c = 0x0
2000e070  int32_t data_2000e070 = 0x0
2000e074  int32_t data_2000e074 = 0x0
2000e078  int32_t data_2000e078 = 0x0
2000e07c  int32_t data_2000e07c = 0x0
2000e080  int32_t data_2000e080 = 0x0
2000e084  char data_2000e084 = 0x0
2000e085  char data_2000e085 = 0x0
2000e086                    00 00                                                                                ..
2000e088  int32_t data_2000e088 = 0x0
2000e08c                                      00 00 00 00 00 00 00 00                                                  ........
2000e094  int16_t data_2000e094 = 0x0
2000e096  int16_t data_2000e096 = 0x0
2000e098  int16_t data_2000e098 = 0x0
2000e09a                                                                                00 00                                        ..
2000e09c  int32_t data_2000e09c = 0x0
2000e0a0  int32_t data_2000e0a0 = 0x0
2000e0a4  int32_t data_2000e0a4 = 0x0
2000e0a8  int32_t data_2000e0a8 = 0x0
2000e0ac  int32_t data_2000e0ac = 0x0
2000e0b0  int32_t data_2000e0b0 = 0x0
2000e0b4  char data_2000e0b4 = 0x0
2000e0b5  char data_2000e0b5 = 0x0
2000e0b6  char data_2000e0b6 = 0x0
2000e0b7  char data_2000e0b7 = 0x0
2000e0b8  char data_2000e0b8 = 0x0
2000e0b9  char data_2000e0b9 = 0x0
2000e0ba  char data_2000e0ba = 0x0
2000e0bb  char data_2000e0bb = 0x0
2000e0bc  char data_2000e0bc = 0x0
2000e0bd                                                                                         00                                     .
2000e0be  char data_2000e0be = 0x0
2000e0bf  char data_2000e0bf = 0x0
2000e0e0  00 00 00 00 00 00 00 00                                                                          ........
2000e0e8  char data_2000e0e8 = 0x0
2000e0e9  char data_2000e0e9 = 0x0
2000e0ea  char data_2000e0ea = 0x0
2000e0eb                                   00                                                                         .
2000e0ec  int32_t data_2000e0ec = 0x0
2000e0f0  int32_t data_2000e0f0 = 0x0
2000e0f4  char data_2000e0f4 = 0x0
2000e0f5                                                                 00 00 00                                               ...
2000e0f8  int32_t data_2000e0f8 = 0x0
2000e0fc  int32_t data_2000e0fc = 0x0
2000e100  int32_t data_2000e100 = 0x0
2000e104  int32_t data_2000e104 = 0x0
2000e108  int32_t data_2000e108 = 0x0
2000e10c  int32_t data_2000e10c = 0x0
2000e110                                                  00 00 00 00 00 00 00 00 00 00 00 00                              ............
2000e11c  int32_t data_2000e11c = 0x0
2000e120  int32_t data_2000e120 = 0x0
2000e124  int32_t data_2000e124 = 0x0
2000e128  int32_t data_2000e128 = 0x0
2000e12c  int32_t data_2000e12c = 0x0
2000e130  int32_t data_2000e130 = 0x0
2000e134                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............
2000e140  00 00 00 00 00 00 00 00                                                                          ........
2000e148  int32_t tStartWalk_ms = 0x0
2000e14c  int32_t tStateStart_ms = 0x0
2000e150  int32_t tLastReinit_ms = 0x0
2000e154  int32_t lastSampleTick = 0x0
2000e158  char currentIndex1 = 0x0
2000e159                                                                             00 00 00                                       ...
2000e15c  char data_2000e15c = 0x0
2000e15d  char data_2000e15d = 0x0
2000e15e                                                                                            00 00                                ..
2000e160  int32_t data_2000e160 = 0x0
2000e164  char data_2000e164 = 0x0
2000e165                 00                                                                                     .
2000e166  char data_2000e166 = 0x0
2000e167                       00                                                                                 .
2000e168  int16_t data_2000e168 = 0x0
2000e16a  int16_t data_2000e16a = 0x0
2000e16c  char data_2000e16c = 0x0
2000e16d                                         00 00 00                                                               ...
2000e170  char data_2000e170 = 0x0
2000e171  char data_2000e171 = 0x0
2000e172  char data_2000e172 = 0x0
2000e173  char data_2000e173 = 0x0
2000e174  char data_2000e174 = 0x0
2000e175  char data_2000e175 = 0x0
2000e176  char data_2000e176 = 0x0
2000e177  char data_2000e177 = 0x0
2000e178  char data_2000e178 = 0x0
2000e179  char data_2000e179 = 0x0
2000e17a  char data_2000e17a = 0x0
2000e17b  char data_2000e17b = 0x0
2000e17c  char data_2000e17c = 0x0
2000e17d                                                                                         00 00 00                               ...
2000e180  char data_2000e180 = 0x0
2000e181  char data_2000e181 = 0x0
2000e182  char data_2000e182 = 0x0
2000e183  char data_2000e183 = 0x0
2000e184  char data_2000e184 = 0x0
2000e185  char data_2000e185 = 0x0
2000e186  char data_2000e186 = 0x0
2000e187  char data_2000e187 = 0x0
2000e188  char data_2000e188 = 0x0
2000e189  char data_2000e189 = 0x0
2000e18a  char data_2000e18a = 0x0
2000e18b  char data_2000e18b = 0x0
2000e18c  char data_2000e18c = 0x0
2000e18d  char data_2000e18d = 0x0
2000e18e  char data_2000e18e = 0x0
2000e18f  char data_2000e18f = 0x0
2000e190  char data_2000e190 = 0x0
2000e191                                                     00 00 00                                                       ...
2000e194  char data_2000e194 = 0x0
2000e195  char data_2000e195 = 0x0
2000e196  char data_2000e196 = 0x0
2000e197  char data_2000e197 = 0x0
2000e198                                                                          00 00 00 00 00 00 00 00                          ........
2000e1c0  int32_t data_2000e1c0 = 0x0
2000e1c4              00 00 00 00 00 00 00 00                                                                  ........
2000e1cc  int32_t data_2000e1cc = 0x0
2000e1d0                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
2000e1e0  int32_t data_2000e1e0 = 0x0
2000e1e4              00 00 00 00                                                                              ....
2000e1e8  data_2000e1e8:
2000e1e8                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                      ....................
2000e1fc  int16_t data_2000e1fc = 0x0
2000e1fe  int16_t data_2000e1fe = 0x0
2000e200  int16_t data_2000e200 = 0x0
2000e202        00 00                                                                                        ..
2000e204  int32_t data_2000e204 = 0x0
2000e208                          00 00 00 00                                                                      ....
2000e20c  int32_t data_2000e20c = 0x0
2000e210  int16_t data_2000e210 = 0x0
2000e212  int16_t data_2000e212 = 0x0
2000e214  int16_t data_2000e214 = 0x0
2000e216                                                                    00 00                                                ..
2000e218  int32_t data_2000e218 = 0x0
2000e21c                                                                                      00 00 00 00                              ....
2000e220  int32_t data_2000e220 = 0x0
2000e224  int16_t data_2000e224 = 0x0
2000e226  int16_t data_2000e226 = 0x0
2000e228  int16_t data_2000e228 = 0x0
2000e22a                                00 00                                                                        ..
2000e22c  int32_t data_2000e22c = 0x0
2000e230                                                  00 00 00 00                                                      ....
2000e234  int32_t data_2000e234 = 0x0
2000e238  data_2000e238:
2000e238                                                                          00 00 00 00                                      ....
2000e23c  int32_t data_2000e23c = 0x0
2000e240  int32_t data_2000e240 = 0x0
2000e244  char data_2000e244 = 0x0
2000e245  char data_2000e245 = 0x0
2000e246                    00 00                                                                                ..
2000e248  data_2000e248:
2000e248                          00 00 00                                                                         ...
2000e24b  char data_2000e24b = 0x0
2000e24c  char data_2000e24c = 0x0
2000e24d  char data_2000e24d = 0x0
2000e24e  char data_2000e24e = 0x0
2000e24f  char data_2000e24f = 0x0
2000e250  char data_2000e250 = 0x0
2000e251  char data_2000e251 = 0x0
2000e252  char data_2000e252 = 0x0
2000e253  char data_2000e253 = 0x0
2000e254                                                              00 00 00 00                                              ....
2000e258  int32_t data_2000e258 = 0x0
2000e25c  int32_t data_2000e25c = 0x0
2000e260  00 00 00 00                                                                                      ....
2000e264  char data_2000e264 = 0x0
2000e265                 00 00 00                                                                               ...
2000e268  char data_2000e268 = 0x0
2000e269  char data_2000e269 = 0x0
2000e26a  char data_2000e26a = 0x0
2000e26b  char data_2000e26b = 0x0
2000e26c  char data_2000e26c = 0x0
2000e26d  char data_2000e26d = 0x0
2000e26e                                            00 00                                                                ..
2000e270  int32_t data_2000e270 = 0x0
2000e274  int16_t data_2000e274 = 0x0
2000e276                                                                    00                                                   .
2000e277  char data_2000e277 = 0x0
2000e278  int32_t data_2000e278 = 0x0
2000e27c  char data_2000e27c = 0x0
2000e27d  char data_2000e27d = 0x0
2000e27e  char data_2000e27e = 0x0
2000e27f  char data_2000e27f = 0x0
2000e280  char data_2000e280 = 0x0
2000e281  char data_2000e281 = 0x0
2000e282        00 00                                                                                        ..
2000e284  char data_2000e284 = 0x0
2000e285                 00 00 00                                                                               ...
2000e288  int32_t data_2000e288 = 0x0
2000e28c  int32_t data_2000e28c = 0x0
2000e290  int32_t data_2000e290 = 0x0
2000e294                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............
2000e2a0  char data_2000e2a0 = 0x0
2000e2a1     00 00 00 00 00 00 00                                                                           .......
2000e2a8  int32_t data_2000e2a8 = 0x0
2000e2ac  int16_t data_2000e2ac = 0x0
2000e2ae  int16_t data_2000e2ae = 0x0
2000e2b0  int16_t data_2000e2b0 = 0x0
2000e2b2  int16_t data_2000e2b2 = 0x0
2000e2b4  int16_t data_2000e2b4 = 0x0
2000e2b6                                                                    00 00                                                ..
2000e2b8  char data_2000e2b8 = 0x0
2000e2b9                                                                             00 00 00                                       ...
2000e2bc  int32_t data_2000e2bc = 0x0
2000e2c0  00 00 00 00                                                                                      ....
2000e2c4  int16_t data_2000e2c4 = 0x0
2000e2c6  int16_t data_2000e2c6 = 0x0
2000e2c8  char data_2000e2c8 = 0x0
2000e2c9  char data_2000e2c9 = 0x0
2000e2ca                                00 00                                                                        ..
2000e2cc  int32_t data_2000e2cc = 0x0
2000e2d0  char data_2000e2d0 = 0x0
2000e2d1                                                     00 00 00                                                       ...
2000e2d4  int32_t data_2000e2d4 = 0x0
2000e2d8  int32_t data_2000e2d8 = 0x0
2000e2dc  char data_2000e2dc = 0x0
2000e2dd  char data_2000e2dd = 0x0
2000e2de  char data_2000e2de = 0x0
2000e2df  char data_2000e2df = 0x0
2000e2e0  char data_2000e2e0 = 0x0
2000e2e1     00 00 00                                                                                       ...
2000e2e4  volume_ctrl_block:
2000e2e4              00 00 00 00 00 00 00 00                                                                  ........
2000e2ec  int32_t data_2000e2ec = 0x0
2000e2f0  int32_t data_2000e2f0 = 0x0
2000e2f4  data_2000e2f4:
2000e2f4                                                              00 00 00 00 00 00 00 00                                  ........
2000e2fc  int16_t data_2000e2fc = 0x0
2000e2fe  int16_t data_2000e2fe = 0x0
2000e300  00 00 00 00                                                                                      ....
2000e304  int32_t data_2000e304 = 0x0
2000e308  char driveState = 0x0
2000e309  char turnRetryCounter = 0x0
2000e30a  char noObstacleGraceCounter = 0x0
2000e30b  char turnSide = 0x0
2000e30c  int32_t backoffCounter = 0x0
2000e310  char data_2000e310 = 0x0
2000e311  char data_2000e311 = 0x0
2000e312                                                        00 00                                                        ..
2000e314  int32_t data_2000e314 = 0x0
2000e318  int32_t data_2000e318 = 0x0
2000e31c  int32_t data_2000e31c = 0x0
2000e320  int32_t data_2000e320 = 0x0
2000e324  int32_t data_2000e324 = 0x0
2000e328  int32_t data_2000e328 = 0x0
2000e32c  int32_t data_2000e32c = 0x0
2000e330  int32_t data_2000e330 = 0x0
2000e334  int32_t data_2000e334 = 0x0
2000e338  int32_t data_2000e338 = 0x0
2000e33c  int32_t data_2000e33c = 0x0
2000e340  int32_t data_2000e340 = 0x0
2000e344  int32_t data_2000e344 = 0x0
2000e348  int32_t data_2000e348 = 0x0
2000e34c  char data_2000e34c = 0x0
2000e34d  char data_2000e34d = 0x0
2000e34e  char data_2000e34e = 0x0
2000e34f  char data_2000e34f = 0x0
2000e350  int32_t data_2000e350 = 0x0
2000e354  int32_t data_2000e354 = 0x0
2000e358  int32_t data_2000e358 = 0x0
2000e35c  int32_t data_2000e35c = 0x0
2000e360  int32_t data_2000e360 = 0x0
2000e364  int32_t data_2000e364 = 0x0
2000e368  int32_t data_2000e368 = 0x0
2000e36c  int32_t data_2000e36c = 0x0
2000e370  int32_t data_2000e370 = 0x0
2000e374  int32_t data_2000e374 = 0x0
2000e378  int32_t data_2000e378 = 0x0
2000e37c  int32_t data_2000e37c = 0x0
2000e380  int32_t beep_event_flags = 0x0
2000e384  int32_t data_2000e384 = 0x0
2000e388  int32_t data_2000e388 = 0x0
2000e38c  int32_t data_2000e38c = 0x0
2000e390  int32_t data_2000e390 = 0x0
2000e394  int32_t data_2000e394 = 0x0
2000e398  int32_t data_2000e398 = 0x0
2000e39c  int32_t data_2000e39c = 0x0
2000e3a0  int32_t data_2000e3a0 = 0x0
2000e3a4  int32_t data_2000e3a4 = 0x0
2000e3a8  int32_t data_2000e3a8 = 0x0
2000e3ac  int32_t data_2000e3ac = 0x0
2000e3b0  int32_t data_2000e3b0 = 0x0
2000e3b4  int32_t data_2000e3b4 = 0x0
2000e3b8  int32_t data_2000e3b8 = 0x0
2000e3bc  int32_t data_2000e3bc = 0x0
2000e3c0  00 00 00 00                                                                                      ....
2000e3c4  int32_t data_2000e3c4 = 0x0
2000e3c8  char data_2000e3c8 = 0x0
2000e3c9  char data_2000e3c9 = 0x0
2000e3ca  char data_2000e3ca = 0x0
2000e3cb  char data_2000e3cb = 0x0
2000e3cc  int32_t data_2000e3cc = 0x0
2000e3d0  int32_t data_2000e3d0 = 0x0
2000e3d4  int32_t data_2000e3d4 = 0x0
2000e3d8  int32_t data_2000e3d8 = 0x0
2000e3dc  int32_t data_2000e3dc = 0x0
2000e3e0  int32_t data_2000e3e0 = 0x0
2000e3e4  int32_t data_2000e3e4 = 0x0
2000e3e8  int32_t data_2000e3e8 = 0x0
2000e3ec  int32_t data_2000e3ec = 0x0
2000e3f0  char data_2000e3f0 = 0x0
2000e3f1  char data_2000e3f1 = 0x0
2000e3f2  char data_2000e3f2 = 0x0
2000e3f3  char data_2000e3f3 = 0x0
2000e3f4  int32_t cam_comms_mutex = 0x0
2000e3f8  int32_t data_2000e3f8 = 0x0
2000e3fc  int32_t data_2000e3fc = 0x0
2000e400  int32_t data_2000e400 = 0x0
2000e404  int32_t data_2000e404 = 0x0
2000e408  int32_t data_2000e408 = 0x0
2000e40c  int32_t data_2000e40c = 0x0
2000e410  int32_t data_2000e410 = 0x0
2000e414  int16_t data_2000e414 = 0x0
2000e416  data_2000e416:
2000e416                                                                    00 00                                                ..
2000e418  data_2000e418:
2000e418                                                                          00 00                                            ..
2000e41a  data_2000e41a:
2000e41a                                                                                00 00                                        ..
2000e41c  int16_t data_2000e41c = 0x0
2000e41e  char data_2000e41e = 0x0
2000e41f                                                                                               00                                 .
2000e420  int16_t data_2000e420 = 0x0
2000e422  int16_t usb_timeout_ms = 0x0
2000e424  int16_t data_2000e424 = 0x0
2000e426  int16_t data_2000e426 = 0x0
2000e428  char turnInProgressFlag = 0x0
2000e429  char data_2000e429 = 0x0
2000e42a  char lockRecoveryCounters1 = 0x0
2000e42b  char lockRecoveryCounters2 = 0x0
2000e42c  char phaseCounter = 0x0
2000e42d  char data_2000e42d = 0x0
2000e42e  char data_2000e42e = 0x0
2000e42f  char data_2000e42f = 0x0
2000e430  char data_2000e430 = 0x0
2000e431  char data_2000e431 = 0x0
2000e432  char data_2000e432 = 0x0
2000e433  char data_2000e433 = 0x0
2000e434  char data_2000e434 = 0x0
2000e435  char g_cam_link_busy = 0x0
2000e436  char data_2000e436 = 0x0
2000e437  char data_2000e437 = 0x0
2000e438  char data_2000e438 = 0x0
2000e439  char data_2000e439 = 0x0
2000e43a  char data_2000e43a = 0x0
2000e43b  char data_2000e43b = 0x0
2000e43c  char data_2000e43c = 0x0
2000e43d  char data_2000e43d = 0x0
2000e43e  char data_2000e43e = 0x0
2000e43f  char data_2000e43f = 0x0
2000e440  char data_2000e440 = 0x0
2000e441  char data_2000e441 = 0x0
2000e442  uint8_t logging_enabled = 0x0
2000e443  uint8_t logging_level_mask = 0x0
2000e444  char motion_state = 0x0
2000e445  char data_2000e445 = 0x0
2000e446  char data_2000e446 = 0x0
2000e447  char data_2000e447 = 0x0
2000e448  char data_2000e448 = 0x0
2000e449  char didWeBeep = 0x0
2000e44a  char data_2000e44a = 0x0
2000e44b  char data_2000e44b = 0x0
2000e44c  char data_2000e44c = 0x0
2000e44d  char data_2000e44d = 0x0
2000e44e  char data_2000e44e = 0x0
2000e44f  char data_2000e44f = 0x0
2000e450  char data_2000e450 = 0x0
2000e451  char data_2000e451 = 0x0
2000e452  char data_2000e452 = 0x0
2000e453  char data_2000e453 = 0x0
2000e454  char data_2000e454 = 0x0
2000e455  char data_2000e455 = 0x0
2000e456  char data_2000e456 = 0x0
2000e457  char data_2000e457 = 0x0
2000e458  char data_2000e458 = 0x0
2000e459  char beepbeep = 0x0
2000e45a  char data_2000e45a = 0x0
2000e45b  char data_2000e45b = 0x0
2000e45c  char data_2000e45c = 0x0
2000e45d  char data_2000e45d = 0x0
2000e45e  char data_2000e45e = 0x0
2000e45f  char data_2000e45f = 0x0
2000e460  char busy_in_progress_flag = 0x0
2000e461  char data_2000e461 = 0x0
2000e462  char data_2000e462 = 0x0
2000e463  char data_2000e463 = 0x0
2000e464  char data_2000e464 = 0x0
2000e465  char data_2000e465 = 0x0
2000e466  char data_2000e466 = 0x0
2000e467  char data_2000e467 = 0x0
2000e468  char data_2000e468 = 0x0
2000e469  char board_test_result = 0x0
2000e46a  char data_2000e46a = 0x0
2000e46b  char data_2000e46b = 0x0
2000e46c  char data_2000e46c = 0x0
2000e46d  char data_2000e46d = 0x0
2000e46e  char data_2000e46e = 0x0
2000e46f                                               00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                 .................
40003000  int32_t watchdog_reg = 0x0
40003004  int32_t data_40003004 = 0x0
40003008  int32_t data_40003008 = 0x0
4000300c  int32_t data_4000300c = 0x0
40003010                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
40004400  USART_TypeDef USART2 = 
40004400  {
40004400      uint32_t volatile SR = 0x0
40004404      uint32_t volatile DR = 0x0
40004408      uint32_t volatile BRR = 0x0
4000440c      uint32_t volatile CR1 = 0x0
40004410      uint32_t volatile CR2 = 0x0
40004414      uint32_t volatile CR3 = 0x0
40004418      uint32_t volatile GTPR = 0x0
4000441c  }
4000441c                                                                                      00 00 00 00                              ....
40004800  USART_TypeDef USART3 = 
40004800  {
40004800      uint32_t volatile SR = 0x0
40004804      uint32_t volatile DR = 0x0
40004808      uint32_t volatile BRR = 0x0
4000480c      uint32_t volatile CR1 = 0x0
40004810      uint32_t volatile CR2 = 0x0
40004814      uint32_t volatile CR3 = 0x0
40004818      uint32_t volatile GTPR = 0x0
4000481c  }
4000481c                                                                                      00 00 00 00                              ....
40004c00  USART_TypeDef UART4 = 
40004c00  {
40004c00      uint32_t volatile SR = 0x0
40004c04      uint32_t volatile DR = 0x0
40004c08      uint32_t volatile BRR = 0x0
40004c0c      uint32_t volatile CR1 = 0x0
40004c10      uint32_t volatile CR2 = 0x0
40004c14      uint32_t volatile CR3 = 0x0
40004c18      uint32_t volatile GTPR = 0x0
40004c1c  }
40004c1c                                                                                      00 00 00 00                              ....
40005000  USART_TypeDef UART5 = 
40005000  {
40005000      uint32_t volatile SR = 0x0
40005004      uint32_t volatile DR = 0x0
40005008      uint32_t volatile BRR = 0x0
4000500c      uint32_t volatile CR1 = 0x0
40005010      uint32_t volatile CR2 = 0x0
40005014      uint32_t volatile CR3 = 0x0
40005018      uint32_t volatile GTPR = 0x0
4000501c  }
4000501c                                                                                      00 00 00 00                              ....
40005400  int32_t data_40005400 = 0x0
40005404              00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00      ............................
40007000  int32_t data_40007000 = 0x0
40007004  int32_t data_40007004 = 0x0
40007008                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
40007400  int32_t data_40007400 = 0x0
40007404              00 00 00 00                                                                              ....
40007408  int32_t data_40007408 = 0x0
4000740c  int32_t data_4000740c = 0x0
40007410  int32_t data_40007410 = 0x0
40007414  int32_t data_40007414 = 0x0
40007418  int32_t data_40007418 = 0x0
4000741c  int32_t data_4000741c = 0x0
40007800  USART_TypeDef UART7 = 
40007800  {
40007800      uint32_t volatile SR = 0x0
40007804      uint32_t volatile DR = 0x0
40007808      uint32_t volatile BRR = 0x0
4000780c      uint32_t volatile CR1 = 0x0
40007810      uint32_t volatile CR2 = 0x0
40007814      uint32_t volatile CR3 = 0x0
40007818      uint32_t volatile GTPR = 0x0
4000781c  }
4000781c                                                                                      00 00 00 00                              ....
40007c00  USART_TypeDef UART4 = 
40007c00  {
40007c00      uint32_t volatile SR = 0x0
40007c04      uint32_t volatile DR = 0x0
40007c08      uint32_t volatile BRR = 0x0
40007c0c      uint32_t volatile CR1 = 0x0
40007c10      uint32_t volatile CR2 = 0x0
40007c14      uint32_t volatile CR3 = 0x0
40007c18      uint32_t volatile GTPR = 0x0
40007c1c  }
40007c1c                                                                                      00 00 00 00                              ....
40011000  USART_TypeDef USART1 = 
40011000  {
40011000      uint32_t volatile SR = 0x0
40011004      uint32_t volatile DR = 0x0
40011008      uint32_t volatile BRR = 0x0
4001100c      uint32_t volatile CR1 = 0x0
40011010      uint32_t volatile CR2 = 0x0
40011014      uint32_t volatile CR3 = 0x0
40011018      uint32_t volatile GTPR = 0x0
4001101c  }
4001101c                                                                                      00 00 00 00                              ....
40011400  USART_TypeDef USART6 = 
40011400  {
40011400      uint32_t volatile SR = 0x0
40011404      uint32_t volatile DR = 0x0
40011408      uint32_t volatile BRR = 0x0
4001140c      uint32_t volatile CR1 = 0x0
40011410      uint32_t volatile CR2 = 0x0
40011414      uint32_t volatile CR3 = 0x0
40011418      uint32_t volatile GTPR = 0x0
4001141c  }
4001141c                                                                                      00 00 00 00                              ....
40012300  00 00 00 00                                                                                      ....
40012304  int32_t data_40012304 = 0x0
40012308                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
40013c00  int32_t data_40013c00 = 0x0
40013c04  int32_t data_40013c04 = 0x0
40013c08  int32_t data_40013c08 = 0x0
40013c0c  int32_t data_40013c0c = 0x0
40013c10                                                  00 00 00 00                                                      ....
40013c14  int32_t data_40013c14 = 0x0
40013c18                                                                          00 00 00 00 00 00 00 00                          ........
40020000  uint8_t GPIOA[0x400] = 
40020000  {
40020000      [0x000] =  0x00
40020001      [0x001] =  0x00
40020002      [0x002] =  0x00
40020003      [0x003] =  0x00
40020004      [0x004] =  0x00
40020005      [0x005] =  0x00
40020006      [0x006] =  0x00
40020007      [0x007] =  0x00
40020008      [0x008] =  0x00
40020009      [0x009] =  0x00
4002000a      [0x00a] =  0x00
4002000b      [0x00b] =  0x00
4002000c      [0x00c] =  0x00
4002000d      [0x00d] =  0x00
4002000e      [0x00e] =  0x00
4002000f      [0x00f] =  0x00
40020010      [0x010] =  0x00
40020011      [0x011] =  0x00
40020012      [0x012] =  0x00
40020013      [0x013] =  0x00
40020014      [0x014] =  0x00
40020015      [0x015] =  0x00
40020016      [0x016] =  0x00
40020017      [0x017] =  0x00
40020018      [0x018] =  0x00
40020019      [0x019] =  0x00
4002001a      [0x01a] =  0x00
4002001b      [0x01b] =  0x00
4002001c      [0x01c] =  0x00
4002001d      [0x01d] =  0x00
4002001e      [0x01e] =  0x00
4002001f      [0x01f] =  0x00
40020020      [0x020] =  0x00
40020021      [0x021] =  0x00
40020022      [0x022] =  0x00
40020023      [0x023] =  0x00
40020024      [0x024] =  0x00
40020025      [0x025] =  0x00
40020026      [0x026] =  0x00
40020027      [0x027] =  0x00
40020028      [0x028] =  0x00
40020029      [0x029] =  0x00
4002002a      [0x02a] =  0x00
4002002b      [0x02b] =  0x00
4002002c      [0x02c] =  0x00
4002002d      [0x02d] =  0x00
4002002e      [0x02e] =  0x00
4002002f      [0x02f] =  0x00
40020030      [0x030] =  0x00
40020031      [0x031] =  0x00
40020032      [0x032] =  0x00
40020033      [0x033] =  0x00
40020034      [0x034] =  0x00
40020035      [0x035] =  0x00
40020036      [0x036] =  0x00
40020037      [0x037] =  0x00
40020038      [0x038] =  0x00
40020039      [0x039] =  0x00
4002003a      [0x03a] =  0x00
4002003b      [0x03b] =  0x00
4002003c      [0x03c] =  0x00
4002003d      [0x03d] =  0x00
4002003e      [0x03e] =  0x00
4002003f      [0x03f] =  0x00
40020040      [0x040] =  0x00
40020041      [0x041] =  0x00
40020042      [0x042] =  0x00
40020043      [0x043] =  0x00
40020044      [0x044] =  0x00
40020045      [0x045] =  0x00
40020046      [0x046] =  0x00
40020047      [0x047] =  0x00
40020048      [0x048] =  0x00
40020049      [0x049] =  0x00
4002004a      [0x04a] =  0x00
4002004b      [0x04b] =  0x00
4002004c      [0x04c] =  0x00
4002004d      [0x04d] =  0x00
4002004e      [0x04e] =  0x00
4002004f      [0x04f] =  0x00
40020050      [0x050] =  0x00
40020051      [0x051] =  0x00
40020052      [0x052] =  0x00
40020053      [0x053] =  0x00
40020054      [0x054] =  0x00
40020055      [0x055] =  0x00
40020056      [0x056] =  0x00
40020057      [0x057] =  0x00
40020058      [0x058] =  0x00
40020059      [0x059] =  0x00
4002005a      [0x05a] =  0x00
4002005b      [0x05b] =  0x00
4002005c      [0x05c] =  0x00
4002005d      [0x05d] =  0x00
4002005e      [0x05e] =  0x00
4002005f      [0x05f] =  0x00
40020060      [0x060] =  0x00
40020061      [0x061] =  0x00
40020062      [0x062] =  0x00
40020063      [0x063] =  0x00
40020064      [0x064] =  0x00
40020065      [0x065] =  0x00
40020066      [0x066] =  0x00
40020067      [0x067] =  0x00
40020068      [0x068] =  0x00
40020069      [0x069] =  0x00
4002006a      [0x06a] =  0x00
4002006b      [0x06b] =  0x00
4002006c      [0x06c] =  0x00
4002006d      [0x06d] =  0x00
4002006e      [0x06e] =  0x00
4002006f      [0x06f] =  0x00
40020070      [0x070] =  0x00
40020071      [0x071] =  0x00
40020072      [0x072] =  0x00
40020073      [0x073] =  0x00
40020074      [0x074] =  0x00
40020075      [0x075] =  0x00
40020076      [0x076] =  0x00
40020077      [0x077] =  0x00
40020078      [0x078] =  0x00
40020079      [0x079] =  0x00
4002007a      [0x07a] =  0x00
4002007b      [0x07b] =  0x00
4002007c      [0x07c] =  0x00
4002007d      [0x07d] =  0x00
4002007e      [0x07e] =  0x00
4002007f      [0x07f] =  0x00
40020080      [0x080] =  0x00
40020081      [0x081] =  0x00
40020082      [0x082] =  0x00
40020083      [0x083] =  0x00
40020084      [0x084] =  0x00
40020085      [0x085] =  0x00
40020086      [0x086] =  0x00
40020087      [0x087] =  0x00
40020088      [0x088] =  0x00
40020089      [0x089] =  0x00
4002008a      [0x08a] =  0x00
4002008b      [0x08b] =  0x00
4002008c      [0x08c] =  0x00
4002008d      [0x08d] =  0x00
4002008e      [0x08e] =  0x00
4002008f      [0x08f] =  0x00
40020090      [0x090] =  0x00
40020091      [0x091] =  0x00
40020092      [0x092] =  0x00
40020093      [0x093] =  0x00
40020094      [0x094] =  0x00
40020095      [0x095] =  0x00
40020096      [0x096] =  0x00
40020097      [0x097] =  0x00
40020098      [0x098] =  0x00
40020099      [0x099] =  0x00
4002009a      [0x09a] =  0x00
4002009b      [0x09b] =  0x00
4002009c      [0x09c] =  0x00
4002009d      [0x09d] =  0x00
4002009e      [0x09e] =  0x00
4002009f      [0x09f] =  0x00
400200a0      [0x0a0] =  0x00
400200a1      [0x0a1] =  0x00
400200a2      [0x0a2] =  0x00
400200a3      [0x0a3] =  0x00
400200a4      [0x0a4] =  0x00
400200a5      [0x0a5] =  0x00
400200a6      [0x0a6] =  0x00
400200a7      [0x0a7] =  0x00
400200a8      [0x0a8] =  0x00
400200a9      [0x0a9] =  0x00
400200aa      [0x0aa] =  0x00
400200ab      [0x0ab] =  0x00
400200ac      [0x0ac] =  0x00
400200ad      [0x0ad] =  0x00
400200ae      [0x0ae] =  0x00
400200af      [0x0af] =  0x00
400200b0      [0x0b0] =  0x00
400200b1      [0x0b1] =  0x00
400200b2      [0x0b2] =  0x00
400200b3      [0x0b3] =  0x00
400200b4      [0x0b4] =  0x00
400200b5      [0x0b5] =  0x00
400200b6      [0x0b6] =  0x00
400200b7      [0x0b7] =  0x00
400200b8      [0x0b8] =  0x00
400200b9      [0x0b9] =  0x00
400200ba      [0x0ba] =  0x00
400200bb      [0x0bb] =  0x00
400200bc      [0x0bc] =  0x00
400200bd      [0x0bd] =  0x00
400200be      [0x0be] =  0x00
400200bf      [0x0bf] =  0x00
400200c0      [0x0c0] =  0x00
400200c1      [0x0c1] =  0x00
400200c2      [0x0c2] =  0x00
400200c3      [0x0c3] =  0x00
400200c4      [0x0c4] =  0x00
400200c5      [0x0c5] =  0x00
400200c6      [0x0c6] =  0x00
400200c7      [0x0c7] =  0x00
400200c8      [0x0c8] =  0x00
400200c9      [0x0c9] =  0x00
400200ca      [0x0ca] =  0x00
400200cb      [0x0cb] =  0x00
400200cc      [0x0cc] =  0x00
400200cd      [0x0cd] =  0x00
400200ce      [0x0ce] =  0x00
400200cf      [0x0cf] =  0x00
400200d0      [0x0d0] =  0x00
400200d1      [0x0d1] =  0x00
400200d2      [0x0d2] =  0x00
400200d3      [0x0d3] =  0x00
400200d4      [0x0d4] =  0x00
400200d5      [0x0d5] =  0x00
400200d6      [0x0d6] =  0x00
400200d7      [0x0d7] =  0x00
400200d8      [0x0d8] =  0x00
400200d9      [0x0d9] =  0x00
400200da      [0x0da] =  0x00
400200db      [0x0db] =  0x00
400200dc      [0x0dc] =  0x00
400200dd      [0x0dd] =  0x00
400200de      [0x0de] =  0x00
400200df      [0x0df] =  0x00
400200e0      [0x0e0] =  0x00
400200e1      [0x0e1] =  0x00
400200e2      [0x0e2] =  0x00
400200e3      [0x0e3] =  0x00
400200e4      [0x0e4] =  0x00
400200e5      [0x0e5] =  0x00
400200e6      [0x0e6] =  0x00
400200e7      [0x0e7] =  0x00
400200e8      [0x0e8] =  0x00
400200e9      [0x0e9] =  0x00
400200ea      [0x0ea] =  0x00
400200eb      [0x0eb] =  0x00
400200ec      [0x0ec] =  0x00
400200ed      [0x0ed] =  0x00
400200ee      [0x0ee] =  0x00
400200ef      [0x0ef] =  0x00
400200f0      [0x0f0] =  0x00
400200f1      [0x0f1] =  0x00
400200f2      [0x0f2] =  0x00
400200f3      [0x0f3] =  0x00
400200f4      [0x0f4] =  0x00
400200f5      [0x0f5] =  0x00
400200f6      [0x0f6] =  0x00
400200f7      [0x0f7] =  0x00
400200f8      [0x0f8] =  0x00
400200f9      [0x0f9] =  0x00
400200fa      [0x0fa] =  0x00
400200fb      [0x0fb] =  0x00
400200fc      [0x0fc] =  0x00
400200fd      [0x0fd] =  0x00
400200fe      [0x0fe] =  0x00
400200ff      [0x0ff] =  0x00
40020100      [0x100] =  0x00
40020101      [0x101] =  0x00
40020102      [0x102] =  0x00
40020103      [0x103] =  0x00
40020104      [0x104] =  0x00
40020105      [0x105] =  0x00
40020106      [0x106] =  0x00
40020107      [0x107] =  0x00
40020108      [0x108] =  0x00
40020109      [0x109] =  0x00
4002010a      [0x10a] =  0x00
4002010b      [0x10b] =  0x00
4002010c      [0x10c] =  0x00
4002010d      [0x10d] =  0x00
4002010e      [0x10e] =  0x00
4002010f      [0x10f] =  0x00
40020110      [0x110] =  0x00
40020111      [0x111] =  0x00
40020112      [0x112] =  0x00
40020113      [0x113] =  0x00
40020114      [0x114] =  0x00
40020115      [0x115] =  0x00
40020116      [0x116] =  0x00
40020117      [0x117] =  0x00
40020118      [0x118] =  0x00
40020119      [0x119] =  0x00
4002011a      [0x11a] =  0x00
4002011b      [0x11b] =  0x00
4002011c      [0x11c] =  0x00
4002011d      [0x11d] =  0x00
4002011e      [0x11e] =  0x00
4002011f      [0x11f] =  0x00
40020120      [0x120] =  0x00
40020121      [0x121] =  0x00
40020122      [0x122] =  0x00
40020123      [0x123] =  0x00
40020124      [0x124] =  0x00
40020125      [0x125] =  0x00
40020126      [0x126] =  0x00
40020127      [0x127] =  0x00
40020128      [0x128] =  0x00
40020129      [0x129] =  0x00
4002012a      [0x12a] =  0x00
4002012b      [0x12b] =  0x00
4002012c      [0x12c] =  0x00
4002012d      [0x12d] =  0x00
4002012e      [0x12e] =  0x00
4002012f      [0x12f] =  0x00
40020130      [0x130] =  0x00
40020131      [0x131] =  0x00
40020132      [0x132] =  0x00
40020133      [0x133] =  0x00
40020134      [0x134] =  0x00
40020135      [0x135] =  0x00
40020136      [0x136] =  0x00
40020137      [0x137] =  0x00
40020138      [0x138] =  0x00
40020139      [0x139] =  0x00
4002013a      [0x13a] =  0x00
4002013b      [0x13b] =  0x00
4002013c      [0x13c] =  0x00
4002013d      [0x13d] =  0x00
4002013e      [0x13e] =  0x00
4002013f      [0x13f] =  0x00
40020140      [0x140] =  0x00
40020141      [0x141] =  0x00
40020142      [0x142] =  0x00
40020143      [0x143] =  0x00
40020144      [0x144] =  0x00
40020145      [0x145] =  0x00
40020146      [0x146] =  0x00
40020147      [0x147] =  0x00
40020148      [0x148] =  0x00
40020149      [0x149] =  0x00
4002014a      [0x14a] =  0x00
4002014b      [0x14b] =  0x00
4002014c      [0x14c] =  0x00
4002014d      [0x14d] =  0x00
4002014e      [0x14e] =  0x00
4002014f      [0x14f] =  0x00
40020150      [0x150] =  0x00
40020151      [0x151] =  0x00
40020152      [0x152] =  0x00
40020153      [0x153] =  0x00
40020154      [0x154] =  0x00
40020155      [0x155] =  0x00
40020156      [0x156] =  0x00
40020157      [0x157] =  0x00
40020158      [0x158] =  0x00
40020159      [0x159] =  0x00
4002015a      [0x15a] =  0x00
4002015b      [0x15b] =  0x00
4002015c      [0x15c] =  0x00
4002015d      [0x15d] =  0x00
4002015e      [0x15e] =  0x00
4002015f      [0x15f] =  0x00
40020160      [0x160] =  0x00
40020161      [0x161] =  0x00
40020162      [0x162] =  0x00
40020163      [0x163] =  0x00
40020164      [0x164] =  0x00
40020165      [0x165] =  0x00
40020166      [0x166] =  0x00
40020167      [0x167] =  0x00
40020168      [0x168] =  0x00
40020169      [0x169] =  0x00
4002016a      [0x16a] =  0x00
4002016b      [0x16b] =  0x00
4002016c      [0x16c] =  0x00
4002016d      [0x16d] =  0x00
4002016e      [0x16e] =  0x00
4002016f      [0x16f] =  0x00
40020170      [0x170] =  0x00
40020171      [0x171] =  0x00
40020172      [0x172] =  0x00
40020173      [0x173] =  0x00
40020174      [0x174] =  0x00
40020175      [0x175] =  0x00
40020176      [0x176] =  0x00
40020177      [0x177] =  0x00
40020178      [0x178] =  0x00
40020179      [0x179] =  0x00
4002017a      [0x17a] =  0x00
4002017b      [0x17b] =  0x00
4002017c      [0x17c] =  0x00
4002017d      [0x17d] =  0x00
4002017e      [0x17e] =  0x00
4002017f      [0x17f] =  0x00
40020180      [0x180] =  0x00
40020181      [0x181] =  0x00
40020182      [0x182] =  0x00
40020183      [0x183] =  0x00
40020184      [0x184] =  0x00
40020185      [0x185] =  0x00
40020186      [0x186] =  0x00
40020187      [0x187] =  0x00
40020188      [0x188] =  0x00
40020189      [0x189] =  0x00
4002018a      [0x18a] =  0x00
4002018b      [0x18b] =  0x00
4002018c      [0x18c] =  0x00
4002018d      [0x18d] =  0x00
4002018e      [0x18e] =  0x00
4002018f      [0x18f] =  0x00
40020190      [0x190] =  0x00
40020191      [0x191] =  0x00
40020192      [0x192] =  0x00
40020193      [0x193] =  0x00
40020194      [0x194] =  0x00
40020195      [0x195] =  0x00
40020196      [0x196] =  0x00
40020197      [0x197] =  0x00
40020198      [0x198] =  0x00
40020199      [0x199] =  0x00
4002019a      [0x19a] =  0x00
4002019b      [0x19b] =  0x00
4002019c      [0x19c] =  0x00
4002019d      [0x19d] =  0x00
4002019e      [0x19e] =  0x00
4002019f      [0x19f] =  0x00
400201a0      [0x1a0] =  0x00
400201a1      [0x1a1] =  0x00
400201a2      [0x1a2] =  0x00
400201a3      [0x1a3] =  0x00
400201a4      [0x1a4] =  0x00
400201a5      [0x1a5] =  0x00
400201a6      [0x1a6] =  0x00
400201a7      [0x1a7] =  0x00
400201a8      [0x1a8] =  0x00
400201a9      [0x1a9] =  0x00
400201aa      [0x1aa] =  0x00
400201ab      [0x1ab] =  0x00
400201ac      [0x1ac] =  0x00
400201ad      [0x1ad] =  0x00
400201ae      [0x1ae] =  0x00
400201af      [0x1af] =  0x00
400201b0      [0x1b0] =  0x00
400201b1      [0x1b1] =  0x00
400201b2      [0x1b2] =  0x00
400201b3      [0x1b3] =  0x00
400201b4      [0x1b4] =  0x00
400201b5      [0x1b5] =  0x00
400201b6      [0x1b6] =  0x00
400201b7      [0x1b7] =  0x00
400201b8      [0x1b8] =  0x00
400201b9      [0x1b9] =  0x00
400201ba      [0x1ba] =  0x00
400201bb      [0x1bb] =  0x00
400201bc      [0x1bc] =  0x00
400201bd      [0x1bd] =  0x00
400201be      [0x1be] =  0x00
400201bf      [0x1bf] =  0x00
400201c0      [0x1c0] =  0x00
400201c1      [0x1c1] =  0x00
400201c2      [0x1c2] =  0x00
400201c3      [0x1c3] =  0x00
400201c4      [0x1c4] =  0x00
400201c5      [0x1c5] =  0x00
400201c6      [0x1c6] =  0x00
400201c7      [0x1c7] =  0x00
400201c8      [0x1c8] =  0x00
400201c9      [0x1c9] =  0x00
400201ca      [0x1ca] =  0x00
400201cb      [0x1cb] =  0x00
400201cc      [0x1cc] =  0x00
400201cd      [0x1cd] =  0x00
400201ce      [0x1ce] =  0x00
400201cf      [0x1cf] =  0x00
400201d0      [0x1d0] =  0x00
400201d1      [0x1d1] =  0x00
400201d2      [0x1d2] =  0x00
400201d3      [0x1d3] =  0x00
400201d4      [0x1d4] =  0x00
400201d5      [0x1d5] =  0x00
400201d6      [0x1d6] =  0x00
400201d7      [0x1d7] =  0x00
400201d8      [0x1d8] =  0x00
400201d9      [0x1d9] =  0x00
400201da      [0x1da] =  0x00
400201db      [0x1db] =  0x00
400201dc      [0x1dc] =  0x00
400201dd      [0x1dd] =  0x00
400201de      [0x1de] =  0x00
400201df      [0x1df] =  0x00
400201e0      [0x1e0] =  0x00
400201e1      [0x1e1] =  0x00
400201e2      [0x1e2] =  0x00
400201e3      [0x1e3] =  0x00
400201e4      [0x1e4] =  0x00
400201e5      [0x1e5] =  0x00
400201e6      [0x1e6] =  0x00
400201e7      [0x1e7] =  0x00
400201e8      [0x1e8] =  0x00
400201e9      [0x1e9] =  0x00
400201ea      [0x1ea] =  0x00
400201eb      [0x1eb] =  0x00
400201ec      [0x1ec] =  0x00
400201ed      [0x1ed] =  0x00
400201ee      [0x1ee] =  0x00
400201ef      [0x1ef] =  0x00
400201f0      [0x1f0] =  0x00
400201f1      [0x1f1] =  0x00
400201f2      [0x1f2] =  0x00
400201f3      [0x1f3] =  0x00
400201f4      [0x1f4] =  0x00
400201f5      [0x1f5] =  0x00
400201f6      [0x1f6] =  0x00
400201f7      [0x1f7] =  0x00
400201f8      [0x1f8] =  0x00
400201f9      [0x1f9] =  0x00
400201fa      [0x1fa] =  0x00
400201fb      [0x1fb] =  0x00
400201fc      [0x1fc] =  0x00
400201fd      [0x1fd] =  0x00
400201fe      [0x1fe] =  0x00
400201ff      [0x1ff] =  0x00
40020200      [0x200] =  0x00
40020201      [0x201] =  0x00
40020202      [0x202] =  0x00
40020203      [0x203] =  0x00
40020204      [0x204] =  0x00
40020205      [0x205] =  0x00
40020206      [0x206] =  0x00
40020207      [0x207] =  0x00
40020208      [0x208] =  0x00
40020209      [0x209] =  0x00
4002020a      [0x20a] =  0x00
4002020b      [0x20b] =  0x00
4002020c      [0x20c] =  0x00
4002020d      [0x20d] =  0x00
4002020e      [0x20e] =  0x00
4002020f      [0x20f] =  0x00
40020210      [0x210] =  0x00
40020211      [0x211] =  0x00
40020212      [0x212] =  0x00
40020213      [0x213] =  0x00
40020214      [0x214] =  0x00
40020215      [0x215] =  0x00
40020216      [0x216] =  0x00
40020217      [0x217] =  0x00
40020218      [0x218] =  0x00
40020219      [0x219] =  0x00
4002021a      [0x21a] =  0x00
4002021b      [0x21b] =  0x00
4002021c      [0x21c] =  0x00
4002021d      [0x21d] =  0x00
4002021e      [0x21e] =  0x00
4002021f      [0x21f] =  0x00
40020220      [0x220] =  0x00
40020221      [0x221] =  0x00
40020222      [0x222] =  0x00
40020223      [0x223] =  0x00
40020224      [0x224] =  0x00
40020225      [0x225] =  0x00
40020226      [0x226] =  0x00
40020227      [0x227] =  0x00
40020228      [0x228] =  0x00
40020229      [0x229] =  0x00
4002022a      [0x22a] =  0x00
4002022b      [0x22b] =  0x00
4002022c      [0x22c] =  0x00
4002022d      [0x22d] =  0x00
4002022e      [0x22e] =  0x00
4002022f      [0x22f] =  0x00
40020230      [0x230] =  0x00
40020231      [0x231] =  0x00
40020232      [0x232] =  0x00
40020233      [0x233] =  0x00
40020234      [0x234] =  0x00
40020235      [0x235] =  0x00
40020236      [0x236] =  0x00
40020237      [0x237] =  0x00
40020238      [0x238] =  0x00
40020239      [0x239] =  0x00
4002023a      [0x23a] =  0x00
4002023b      [0x23b] =  0x00
4002023c      [0x23c] =  0x00
4002023d      [0x23d] =  0x00
4002023e      [0x23e] =  0x00
4002023f      [0x23f] =  0x00
40020240      [0x240] =  0x00
40020241      [0x241] =  0x00
40020242      [0x242] =  0x00
40020243      [0x243] =  0x00
40020244      [0x244] =  0x00
40020245      [0x245] =  0x00
40020246      [0x246] =  0x00
40020247      [0x247] =  0x00
40020248      [0x248] =  0x00
40020249      [0x249] =  0x00
4002024a      [0x24a] =  0x00
4002024b      [0x24b] =  0x00
4002024c      [0x24c] =  0x00
4002024d      [0x24d] =  0x00
4002024e      [0x24e] =  0x00
4002024f      [0x24f] =  0x00
40020250      [0x250] =  0x00
40020251      [0x251] =  0x00
40020252      [0x252] =  0x00
40020253      [0x253] =  0x00
40020254      [0x254] =  0x00
40020255      [0x255] =  0x00
40020256      [0x256] =  0x00
40020257      [0x257] =  0x00
40020258      [0x258] =  0x00
40020259      [0x259] =  0x00
4002025a      [0x25a] =  0x00
4002025b      [0x25b] =  0x00
4002025c      [0x25c] =  0x00
4002025d      [0x25d] =  0x00
4002025e      [0x25e] =  0x00
4002025f      [0x25f] =  0x00
40020260      [0x260] =  0x00
40020261      [0x261] =  0x00
40020262      [0x262] =  0x00
40020263      [0x263] =  0x00
40020264      [0x264] =  0x00
40020265      [0x265] =  0x00
40020266      [0x266] =  0x00
40020267      [0x267] =  0x00
40020268      [0x268] =  0x00
40020269      [0x269] =  0x00
4002026a      [0x26a] =  0x00
4002026b      [0x26b] =  0x00
4002026c      [0x26c] =  0x00
4002026d      [0x26d] =  0x00
4002026e      [0x26e] =  0x00
4002026f      [0x26f] =  0x00
40020270      [0x270] =  0x00
40020271      [0x271] =  0x00
40020272      [0x272] =  0x00
40020273      [0x273] =  0x00
40020274      [0x274] =  0x00
40020275      [0x275] =  0x00
40020276      [0x276] =  0x00
40020277      [0x277] =  0x00
40020278      [0x278] =  0x00
40020279      [0x279] =  0x00
4002027a      [0x27a] =  0x00
4002027b      [0x27b] =  0x00
4002027c      [0x27c] =  0x00
4002027d      [0x27d] =  0x00
4002027e      [0x27e] =  0x00
4002027f      [0x27f] =  0x00
40020280      [0x280] =  0x00
40020281      [0x281] =  0x00
40020282      [0x282] =  0x00
40020283      [0x283] =  0x00
40020284      [0x284] =  0x00
40020285      [0x285] =  0x00
40020286      [0x286] =  0x00
40020287      [0x287] =  0x00
40020288      [0x288] =  0x00
40020289      [0x289] =  0x00
4002028a      [0x28a] =  0x00
4002028b      [0x28b] =  0x00
4002028c      [0x28c] =  0x00
4002028d      [0x28d] =  0x00
4002028e      [0x28e] =  0x00
4002028f      [0x28f] =  0x00
40020290      [0x290] =  0x00
40020291      [0x291] =  0x00
40020292      [0x292] =  0x00
40020293      [0x293] =  0x00
40020294      [0x294] =  0x00
40020295      [0x295] =  0x00
40020296      [0x296] =  0x00
40020297      [0x297] =  0x00
40020298      [0x298] =  0x00
40020299      [0x299] =  0x00
4002029a      [0x29a] =  0x00
4002029b      [0x29b] =  0x00
4002029c      [0x29c] =  0x00
4002029d      [0x29d] =  0x00
4002029e      [0x29e] =  0x00
4002029f      [0x29f] =  0x00
400202a0      [0x2a0] =  0x00
400202a1      [0x2a1] =  0x00
400202a2      [0x2a2] =  0x00
400202a3      [0x2a3] =  0x00
400202a4      [0x2a4] =  0x00
400202a5      [0x2a5] =  0x00
400202a6      [0x2a6] =  0x00
400202a7      [0x2a7] =  0x00
400202a8      [0x2a8] =  0x00
400202a9      [0x2a9] =  0x00
400202aa      [0x2aa] =  0x00
400202ab      [0x2ab] =  0x00
400202ac      [0x2ac] =  0x00
400202ad      [0x2ad] =  0x00
400202ae      [0x2ae] =  0x00
400202af      [0x2af] =  0x00
400202b0      [0x2b0] =  0x00
400202b1      [0x2b1] =  0x00
400202b2      [0x2b2] =  0x00
400202b3      [0x2b3] =  0x00
400202b4      [0x2b4] =  0x00
400202b5      [0x2b5] =  0x00
400202b6      [0x2b6] =  0x00
400202b7      [0x2b7] =  0x00
400202b8      [0x2b8] =  0x00
400202b9      [0x2b9] =  0x00
400202ba      [0x2ba] =  0x00
400202bb      [0x2bb] =  0x00
400202bc      [0x2bc] =  0x00
400202bd      [0x2bd] =  0x00
400202be      [0x2be] =  0x00
400202bf      [0x2bf] =  0x00
400202c0      [0x2c0] =  0x00
400202c1      [0x2c1] =  0x00
400202c2      [0x2c2] =  0x00
400202c3      [0x2c3] =  0x00
400202c4      [0x2c4] =  0x00
400202c5      [0x2c5] =  0x00
400202c6      [0x2c6] =  0x00
400202c7      [0x2c7] =  0x00
400202c8      [0x2c8] =  0x00
400202c9      [0x2c9] =  0x00
400202ca      [0x2ca] =  0x00
400202cb      [0x2cb] =  0x00
400202cc      [0x2cc] =  0x00
400202cd      [0x2cd] =  0x00
400202ce      [0x2ce] =  0x00
400202cf      [0x2cf] =  0x00
400202d0      [0x2d0] =  0x00
400202d1      [0x2d1] =  0x00
400202d2      [0x2d2] =  0x00
400202d3      [0x2d3] =  0x00
400202d4      [0x2d4] =  0x00
400202d5      [0x2d5] =  0x00
400202d6      [0x2d6] =  0x00
400202d7      [0x2d7] =  0x00
400202d8      [0x2d8] =  0x00
400202d9      [0x2d9] =  0x00
400202da      [0x2da] =  0x00
400202db      [0x2db] =  0x00
400202dc      [0x2dc] =  0x00
400202dd      [0x2dd] =  0x00
400202de      [0x2de] =  0x00
400202df      [0x2df] =  0x00
400202e0      [0x2e0] =  0x00
400202e1      [0x2e1] =  0x00
400202e2      [0x2e2] =  0x00
400202e3      [0x2e3] =  0x00
400202e4      [0x2e4] =  0x00
400202e5      [0x2e5] =  0x00
400202e6      [0x2e6] =  0x00
400202e7      [0x2e7] =  0x00
400202e8      [0x2e8] =  0x00
400202e9      [0x2e9] =  0x00
400202ea      [0x2ea] =  0x00
400202eb      [0x2eb] =  0x00
400202ec      [0x2ec] =  0x00
400202ed      [0x2ed] =  0x00
400202ee      [0x2ee] =  0x00
400202ef      [0x2ef] =  0x00
400202f0      [0x2f0] =  0x00
400202f1      [0x2f1] =  0x00
400202f2      [0x2f2] =  0x00
400202f3      [0x2f3] =  0x00
400202f4      [0x2f4] =  0x00
400202f5      [0x2f5] =  0x00
400202f6      [0x2f6] =  0x00
400202f7      [0x2f7] =  0x00
400202f8      [0x2f8] =  0x00
400202f9      [0x2f9] =  0x00
400202fa      [0x2fa] =  0x00
400202fb      [0x2fb] =  0x00
400202fc      [0x2fc] =  0x00
400202fd      [0x2fd] =  0x00
400202fe      [0x2fe] =  0x00
400202ff      [0x2ff] =  0x00
40020300      [0x300] =  0x00
40020301      [0x301] =  0x00
40020302      [0x302] =  0x00
40020303      [0x303] =  0x00
40020304      [0x304] =  0x00
40020305      [0x305] =  0x00
40020306      [0x306] =  0x00
40020307      [0x307] =  0x00
40020308      [0x308] =  0x00
40020309      [0x309] =  0x00
4002030a      [0x30a] =  0x00
4002030b      [0x30b] =  0x00
4002030c      [0x30c] =  0x00
4002030d      [0x30d] =  0x00
4002030e      [0x30e] =  0x00
4002030f      [0x30f] =  0x00
40020310      [0x310] =  0x00
40020311      [0x311] =  0x00
40020312      [0x312] =  0x00
40020313      [0x313] =  0x00
40020314      [0x314] =  0x00
40020315      [0x315] =  0x00
40020316      [0x316] =  0x00
40020317      [0x317] =  0x00
40020318      [0x318] =  0x00
40020319      [0x319] =  0x00
4002031a      [0x31a] =  0x00
4002031b      [0x31b] =  0x00
4002031c      [0x31c] =  0x00
4002031d      [0x31d] =  0x00
4002031e      [0x31e] =  0x00
4002031f      [0x31f] =  0x00
40020320      [0x320] =  0x00
40020321      [0x321] =  0x00
40020322      [0x322] =  0x00
40020323      [0x323] =  0x00
40020324      [0x324] =  0x00
40020325      [0x325] =  0x00
40020326      [0x326] =  0x00
40020327      [0x327] =  0x00
40020328      [0x328] =  0x00
40020329      [0x329] =  0x00
4002032a      [0x32a] =  0x00
4002032b      [0x32b] =  0x00
4002032c      [0x32c] =  0x00
4002032d      [0x32d] =  0x00
4002032e      [0x32e] =  0x00
4002032f      [0x32f] =  0x00
40020330      [0x330] =  0x00
40020331      [0x331] =  0x00
40020332      [0x332] =  0x00
40020333      [0x333] =  0x00
40020334      [0x334] =  0x00
40020335      [0x335] =  0x00
40020336      [0x336] =  0x00
40020337      [0x337] =  0x00
40020338      [0x338] =  0x00
40020339      [0x339] =  0x00
4002033a      [0x33a] =  0x00
4002033b      [0x33b] =  0x00
4002033c      [0x33c] =  0x00
4002033d      [0x33d] =  0x00
4002033e      [0x33e] =  0x00
4002033f      [0x33f] =  0x00
40020340      [0x340] =  0x00
40020341      [0x341] =  0x00
40020342      [0x342] =  0x00
40020343      [0x343] =  0x00
40020344      [0x344] =  0x00
40020345      [0x345] =  0x00
40020346      [0x346] =  0x00
40020347      [0x347] =  0x00
40020348      [0x348] =  0x00
40020349      [0x349] =  0x00
4002034a      [0x34a] =  0x00
4002034b      [0x34b] =  0x00
4002034c      [0x34c] =  0x00
4002034d      [0x34d] =  0x00
4002034e      [0x34e] =  0x00
4002034f      [0x34f] =  0x00
40020350      [0x350] =  0x00
40020351      [0x351] =  0x00
40020352      [0x352] =  0x00
40020353      [0x353] =  0x00
40020354      [0x354] =  0x00
40020355      [0x355] =  0x00
40020356      [0x356] =  0x00
40020357      [0x357] =  0x00
40020358      [0x358] =  0x00
40020359      [0x359] =  0x00
4002035a      [0x35a] =  0x00
4002035b      [0x35b] =  0x00
4002035c      [0x35c] =  0x00
4002035d      [0x35d] =  0x00
4002035e      [0x35e] =  0x00
4002035f      [0x35f] =  0x00
40020360      [0x360] =  0x00
40020361      [0x361] =  0x00
40020362      [0x362] =  0x00
40020363      [0x363] =  0x00
40020364      [0x364] =  0x00
40020365      [0x365] =  0x00
40020366      [0x366] =  0x00
40020367      [0x367] =  0x00
40020368      [0x368] =  0x00
40020369      [0x369] =  0x00
4002036a      [0x36a] =  0x00
4002036b      [0x36b] =  0x00
4002036c      [0x36c] =  0x00
4002036d      [0x36d] =  0x00
4002036e      [0x36e] =  0x00
4002036f      [0x36f] =  0x00
40020370      [0x370] =  0x00
40020371      [0x371] =  0x00
40020372      [0x372] =  0x00
40020373      [0x373] =  0x00
40020374      [0x374] =  0x00
40020375      [0x375] =  0x00
40020376      [0x376] =  0x00
40020377      [0x377] =  0x00
40020378      [0x378] =  0x00
40020379      [0x379] =  0x00
4002037a      [0x37a] =  0x00
4002037b      [0x37b] =  0x00
4002037c      [0x37c] =  0x00
4002037d      [0x37d] =  0x00
4002037e      [0x37e] =  0x00
4002037f      [0x37f] =  0x00
40020380      [0x380] =  0x00
40020381      [0x381] =  0x00
40020382      [0x382] =  0x00
40020383      [0x383] =  0x00
40020384      [0x384] =  0x00
40020385      [0x385] =  0x00
40020386      [0x386] =  0x00
40020387      [0x387] =  0x00
40020388      [0x388] =  0x00
40020389      [0x389] =  0x00
4002038a      [0x38a] =  0x00
4002038b      [0x38b] =  0x00
4002038c      [0x38c] =  0x00
4002038d      [0x38d] =  0x00
4002038e      [0x38e] =  0x00
4002038f      [0x38f] =  0x00
40020390      [0x390] =  0x00
40020391      [0x391] =  0x00
40020392      [0x392] =  0x00
40020393      [0x393] =  0x00
40020394      [0x394] =  0x00
40020395      [0x395] =  0x00
40020396      [0x396] =  0x00
40020397      [0x397] =  0x00
40020398      [0x398] =  0x00
40020399      [0x399] =  0x00
4002039a      [0x39a] =  0x00
4002039b      [0x39b] =  0x00
4002039c      [0x39c] =  0x00
4002039d      [0x39d] =  0x00
4002039e      [0x39e] =  0x00
4002039f      [0x39f] =  0x00
400203a0      [0x3a0] =  0x00
400203a1      [0x3a1] =  0x00
400203a2      [0x3a2] =  0x00
400203a3      [0x3a3] =  0x00
400203a4      [0x3a4] =  0x00
400203a5      [0x3a5] =  0x00
400203a6      [0x3a6] =  0x00
400203a7      [0x3a7] =  0x00
400203a8      [0x3a8] =  0x00
400203a9      [0x3a9] =  0x00
400203aa      [0x3aa] =  0x00
400203ab      [0x3ab] =  0x00
400203ac      [0x3ac] =  0x00
400203ad      [0x3ad] =  0x00
400203ae      [0x3ae] =  0x00
400203af      [0x3af] =  0x00
400203b0      [0x3b0] =  0x00
400203b1      [0x3b1] =  0x00
400203b2      [0x3b2] =  0x00
400203b3      [0x3b3] =  0x00
400203b4      [0x3b4] =  0x00
400203b5      [0x3b5] =  0x00
400203b6      [0x3b6] =  0x00
400203b7      [0x3b7] =  0x00
400203b8      [0x3b8] =  0x00
400203b9      [0x3b9] =  0x00
400203ba      [0x3ba] =  0x00
400203bb      [0x3bb] =  0x00
400203bc      [0x3bc] =  0x00
400203bd      [0x3bd] =  0x00
400203be      [0x3be] =  0x00
400203bf      [0x3bf] =  0x00
400203c0      [0x3c0] =  0x00
400203c1      [0x3c1] =  0x00
400203c2      [0x3c2] =  0x00
400203c3      [0x3c3] =  0x00
400203c4      [0x3c4] =  0x00
400203c5      [0x3c5] =  0x00
400203c6      [0x3c6] =  0x00
400203c7      [0x3c7] =  0x00
400203c8      [0x3c8] =  0x00
400203c9      [0x3c9] =  0x00
400203ca      [0x3ca] =  0x00
400203cb      [0x3cb] =  0x00
400203cc      [0x3cc] =  0x00
400203cd      [0x3cd] =  0x00
400203ce      [0x3ce] =  0x00
400203cf      [0x3cf] =  0x00
400203d0      [0x3d0] =  0x00
400203d1      [0x3d1] =  0x00
400203d2      [0x3d2] =  0x00
400203d3      [0x3d3] =  0x00
400203d4      [0x3d4] =  0x00
400203d5      [0x3d5] =  0x00
400203d6      [0x3d6] =  0x00
400203d7      [0x3d7] =  0x00
400203d8      [0x3d8] =  0x00
400203d9      [0x3d9] =  0x00
400203da      [0x3da] =  0x00
400203db      [0x3db] =  0x00
400203dc      [0x3dc] =  0x00
400203dd      [0x3dd] =  0x00
400203de      [0x3de] =  0x00
400203df      [0x3df] =  0x00
400203e0      [0x3e0] =  0x00
400203e1      [0x3e1] =  0x00
400203e2      [0x3e2] =  0x00
400203e3      [0x3e3] =  0x00
400203e4      [0x3e4] =  0x00
400203e5      [0x3e5] =  0x00
400203e6      [0x3e6] =  0x00
400203e7      [0x3e7] =  0x00
400203e8      [0x3e8] =  0x00
400203e9      [0x3e9] =  0x00
400203ea      [0x3ea] =  0x00
400203eb      [0x3eb] =  0x00
400203ec      [0x3ec] =  0x00
400203ed      [0x3ed] =  0x00
400203ee      [0x3ee] =  0x00
400203ef      [0x3ef] =  0x00
400203f0      [0x3f0] =  0x00
400203f1      [0x3f1] =  0x00
400203f2      [0x3f2] =  0x00
400203f3      [0x3f3] =  0x00
400203f4      [0x3f4] =  0x00
400203f5      [0x3f5] =  0x00
400203f6      [0x3f6] =  0x00
400203f7      [0x3f7] =  0x00
400203f8      [0x3f8] =  0x00
400203f9      [0x3f9] =  0x00
400203fa      [0x3fa] =  0x00
400203fb      [0x3fb] =  0x00
400203fc      [0x3fc] =  0x00
400203fd      [0x3fd] =  0x00
400203fe      [0x3fe] =  0x00
400203ff      [0x3ff] =  0x00
40020400  }
40020400  uint8_t GPIOB[0x400] = 
40020400  {
40020400      [0x000] =  0x00
40020401      [0x001] =  0x00
40020402      [0x002] =  0x00
40020403      [0x003] =  0x00
40020404      [0x004] =  0x00
40020405      [0x005] =  0x00
40020406      [0x006] =  0x00
40020407      [0x007] =  0x00
40020408      [0x008] =  0x00
40020409      [0x009] =  0x00
4002040a      [0x00a] =  0x00
4002040b      [0x00b] =  0x00
4002040c      [0x00c] =  0x00
4002040d      [0x00d] =  0x00
4002040e      [0x00e] =  0x00
4002040f      [0x00f] =  0x00
40020410      [0x010] =  0x00
40020411      [0x011] =  0x00
40020412      [0x012] =  0x00
40020413      [0x013] =  0x00
40020414      [0x014] =  0x00
40020415      [0x015] =  0x00
40020416      [0x016] =  0x00
40020417      [0x017] =  0x00
40020418      [0x018] =  0x00
40020419      [0x019] =  0x00
4002041a      [0x01a] =  0x00
4002041b      [0x01b] =  0x00
4002041c      [0x01c] =  0x00
4002041d      [0x01d] =  0x00
4002041e      [0x01e] =  0x00
4002041f      [0x01f] =  0x00
40020420      [0x020] =  0x00
40020421      [0x021] =  0x00
40020422      [0x022] =  0x00
40020423      [0x023] =  0x00
40020424      [0x024] =  0x00
40020425      [0x025] =  0x00
40020426      [0x026] =  0x00
40020427      [0x027] =  0x00
40020428      [0x028] =  0x00
40020429      [0x029] =  0x00
4002042a      [0x02a] =  0x00
4002042b      [0x02b] =  0x00
4002042c      [0x02c] =  0x00
4002042d      [0x02d] =  0x00
4002042e      [0x02e] =  0x00
4002042f      [0x02f] =  0x00
40020430      [0x030] =  0x00
40020431      [0x031] =  0x00
40020432      [0x032] =  0x00
40020433      [0x033] =  0x00
40020434      [0x034] =  0x00
40020435      [0x035] =  0x00
40020436      [0x036] =  0x00
40020437      [0x037] =  0x00
40020438      [0x038] =  0x00
40020439      [0x039] =  0x00
4002043a      [0x03a] =  0x00
4002043b      [0x03b] =  0x00
4002043c      [0x03c] =  0x00
4002043d      [0x03d] =  0x00
4002043e      [0x03e] =  0x00
4002043f      [0x03f] =  0x00
40020440      [0x040] =  0x00
40020441      [0x041] =  0x00
40020442      [0x042] =  0x00
40020443      [0x043] =  0x00
40020444      [0x044] =  0x00
40020445      [0x045] =  0x00
40020446      [0x046] =  0x00
40020447      [0x047] =  0x00
40020448      [0x048] =  0x00
40020449      [0x049] =  0x00
4002044a      [0x04a] =  0x00
4002044b      [0x04b] =  0x00
4002044c      [0x04c] =  0x00
4002044d      [0x04d] =  0x00
4002044e      [0x04e] =  0x00
4002044f      [0x04f] =  0x00
40020450      [0x050] =  0x00
40020451      [0x051] =  0x00
40020452      [0x052] =  0x00
40020453      [0x053] =  0x00
40020454      [0x054] =  0x00
40020455      [0x055] =  0x00
40020456      [0x056] =  0x00
40020457      [0x057] =  0x00
40020458      [0x058] =  0x00
40020459      [0x059] =  0x00
4002045a      [0x05a] =  0x00
4002045b      [0x05b] =  0x00
4002045c      [0x05c] =  0x00
4002045d      [0x05d] =  0x00
4002045e      [0x05e] =  0x00
4002045f      [0x05f] =  0x00
40020460      [0x060] =  0x00
40020461      [0x061] =  0x00
40020462      [0x062] =  0x00
40020463      [0x063] =  0x00
40020464      [0x064] =  0x00
40020465      [0x065] =  0x00
40020466      [0x066] =  0x00
40020467      [0x067] =  0x00
40020468      [0x068] =  0x00
40020469      [0x069] =  0x00
4002046a      [0x06a] =  0x00
4002046b      [0x06b] =  0x00
4002046c      [0x06c] =  0x00
4002046d      [0x06d] =  0x00
4002046e      [0x06e] =  0x00
4002046f      [0x06f] =  0x00
40020470      [0x070] =  0x00
40020471      [0x071] =  0x00
40020472      [0x072] =  0x00
40020473      [0x073] =  0x00
40020474      [0x074] =  0x00
40020475      [0x075] =  0x00
40020476      [0x076] =  0x00
40020477      [0x077] =  0x00
40020478      [0x078] =  0x00
40020479      [0x079] =  0x00
4002047a      [0x07a] =  0x00
4002047b      [0x07b] =  0x00
4002047c      [0x07c] =  0x00
4002047d      [0x07d] =  0x00
4002047e      [0x07e] =  0x00
4002047f      [0x07f] =  0x00
40020480      [0x080] =  0x00
40020481      [0x081] =  0x00
40020482      [0x082] =  0x00
40020483      [0x083] =  0x00
40020484      [0x084] =  0x00
40020485      [0x085] =  0x00
40020486      [0x086] =  0x00
40020487      [0x087] =  0x00
40020488      [0x088] =  0x00
40020489      [0x089] =  0x00
4002048a      [0x08a] =  0x00
4002048b      [0x08b] =  0x00
4002048c      [0x08c] =  0x00
4002048d      [0x08d] =  0x00
4002048e      [0x08e] =  0x00
4002048f      [0x08f] =  0x00
40020490      [0x090] =  0x00
40020491      [0x091] =  0x00
40020492      [0x092] =  0x00
40020493      [0x093] =  0x00
40020494      [0x094] =  0x00
40020495      [0x095] =  0x00
40020496      [0x096] =  0x00
40020497      [0x097] =  0x00
40020498      [0x098] =  0x00
40020499      [0x099] =  0x00
4002049a      [0x09a] =  0x00
4002049b      [0x09b] =  0x00
4002049c      [0x09c] =  0x00
4002049d      [0x09d] =  0x00
4002049e      [0x09e] =  0x00
4002049f      [0x09f] =  0x00
400204a0      [0x0a0] =  0x00
400204a1      [0x0a1] =  0x00
400204a2      [0x0a2] =  0x00
400204a3      [0x0a3] =  0x00
400204a4      [0x0a4] =  0x00
400204a5      [0x0a5] =  0x00
400204a6      [0x0a6] =  0x00
400204a7      [0x0a7] =  0x00
400204a8      [0x0a8] =  0x00
400204a9      [0x0a9] =  0x00
400204aa      [0x0aa] =  0x00
400204ab      [0x0ab] =  0x00
400204ac      [0x0ac] =  0x00
400204ad      [0x0ad] =  0x00
400204ae      [0x0ae] =  0x00
400204af      [0x0af] =  0x00
400204b0      [0x0b0] =  0x00
400204b1      [0x0b1] =  0x00
400204b2      [0x0b2] =  0x00
400204b3      [0x0b3] =  0x00
400204b4      [0x0b4] =  0x00
400204b5      [0x0b5] =  0x00
400204b6      [0x0b6] =  0x00
400204b7      [0x0b7] =  0x00
400204b8      [0x0b8] =  0x00
400204b9      [0x0b9] =  0x00
400204ba      [0x0ba] =  0x00
400204bb      [0x0bb] =  0x00
400204bc      [0x0bc] =  0x00
400204bd      [0x0bd] =  0x00
400204be      [0x0be] =  0x00
400204bf      [0x0bf] =  0x00
400204c0      [0x0c0] =  0x00
400204c1      [0x0c1] =  0x00
400204c2      [0x0c2] =  0x00
400204c3      [0x0c3] =  0x00
400204c4      [0x0c4] =  0x00
400204c5      [0x0c5] =  0x00
400204c6      [0x0c6] =  0x00
400204c7      [0x0c7] =  0x00
400204c8      [0x0c8] =  0x00
400204c9      [0x0c9] =  0x00
400204ca      [0x0ca] =  0x00
400204cb      [0x0cb] =  0x00
400204cc      [0x0cc] =  0x00
400204cd      [0x0cd] =  0x00
400204ce      [0x0ce] =  0x00
400204cf      [0x0cf] =  0x00
400204d0      [0x0d0] =  0x00
400204d1      [0x0d1] =  0x00
400204d2      [0x0d2] =  0x00
400204d3      [0x0d3] =  0x00
400204d4      [0x0d4] =  0x00
400204d5      [0x0d5] =  0x00
400204d6      [0x0d6] =  0x00
400204d7      [0x0d7] =  0x00
400204d8      [0x0d8] =  0x00
400204d9      [0x0d9] =  0x00
400204da      [0x0da] =  0x00
400204db      [0x0db] =  0x00
400204dc      [0x0dc] =  0x00
400204dd      [0x0dd] =  0x00
400204de      [0x0de] =  0x00
400204df      [0x0df] =  0x00
400204e0      [0x0e0] =  0x00
400204e1      [0x0e1] =  0x00
400204e2      [0x0e2] =  0x00
400204e3      [0x0e3] =  0x00
400204e4      [0x0e4] =  0x00
400204e5      [0x0e5] =  0x00
400204e6      [0x0e6] =  0x00
400204e7      [0x0e7] =  0x00
400204e8      [0x0e8] =  0x00
400204e9      [0x0e9] =  0x00
400204ea      [0x0ea] =  0x00
400204eb      [0x0eb] =  0x00
400204ec      [0x0ec] =  0x00
400204ed      [0x0ed] =  0x00
400204ee      [0x0ee] =  0x00
400204ef      [0x0ef] =  0x00
400204f0      [0x0f0] =  0x00
400204f1      [0x0f1] =  0x00
400204f2      [0x0f2] =  0x00
400204f3      [0x0f3] =  0x00
400204f4      [0x0f4] =  0x00
400204f5      [0x0f5] =  0x00
400204f6      [0x0f6] =  0x00
400204f7      [0x0f7] =  0x00
400204f8      [0x0f8] =  0x00
400204f9      [0x0f9] =  0x00
400204fa      [0x0fa] =  0x00
400204fb      [0x0fb] =  0x00
400204fc      [0x0fc] =  0x00
400204fd      [0x0fd] =  0x00
400204fe      [0x0fe] =  0x00
400204ff      [0x0ff] =  0x00
40020500      [0x100] =  0x00
40020501      [0x101] =  0x00
40020502      [0x102] =  0x00
40020503      [0x103] =  0x00
40020504      [0x104] =  0x00
40020505      [0x105] =  0x00
40020506      [0x106] =  0x00
40020507      [0x107] =  0x00
40020508      [0x108] =  0x00
40020509      [0x109] =  0x00
4002050a      [0x10a] =  0x00
4002050b      [0x10b] =  0x00
4002050c      [0x10c] =  0x00
4002050d      [0x10d] =  0x00
4002050e      [0x10e] =  0x00
4002050f      [0x10f] =  0x00
40020510      [0x110] =  0x00
40020511      [0x111] =  0x00
40020512      [0x112] =  0x00
40020513      [0x113] =  0x00
40020514      [0x114] =  0x00
40020515      [0x115] =  0x00
40020516      [0x116] =  0x00
40020517      [0x117] =  0x00
40020518      [0x118] =  0x00
40020519      [0x119] =  0x00
4002051a      [0x11a] =  0x00
4002051b      [0x11b] =  0x00
4002051c      [0x11c] =  0x00
4002051d      [0x11d] =  0x00
4002051e      [0x11e] =  0x00
4002051f      [0x11f] =  0x00
40020520      [0x120] =  0x00
40020521      [0x121] =  0x00
40020522      [0x122] =  0x00
40020523      [0x123] =  0x00
40020524      [0x124] =  0x00
40020525      [0x125] =  0x00
40020526      [0x126] =  0x00
40020527      [0x127] =  0x00
40020528      [0x128] =  0x00
40020529      [0x129] =  0x00
4002052a      [0x12a] =  0x00
4002052b      [0x12b] =  0x00
4002052c      [0x12c] =  0x00
4002052d      [0x12d] =  0x00
4002052e      [0x12e] =  0x00
4002052f      [0x12f] =  0x00
40020530      [0x130] =  0x00
40020531      [0x131] =  0x00
40020532      [0x132] =  0x00
40020533      [0x133] =  0x00
40020534      [0x134] =  0x00
40020535      [0x135] =  0x00
40020536      [0x136] =  0x00
40020537      [0x137] =  0x00
40020538      [0x138] =  0x00
40020539      [0x139] =  0x00
4002053a      [0x13a] =  0x00
4002053b      [0x13b] =  0x00
4002053c      [0x13c] =  0x00
4002053d      [0x13d] =  0x00
4002053e      [0x13e] =  0x00
4002053f      [0x13f] =  0x00
40020540      [0x140] =  0x00
40020541      [0x141] =  0x00
40020542      [0x142] =  0x00
40020543      [0x143] =  0x00
40020544      [0x144] =  0x00
40020545      [0x145] =  0x00
40020546      [0x146] =  0x00
40020547      [0x147] =  0x00
40020548      [0x148] =  0x00
40020549      [0x149] =  0x00
4002054a      [0x14a] =  0x00
4002054b      [0x14b] =  0x00
4002054c      [0x14c] =  0x00
4002054d      [0x14d] =  0x00
4002054e      [0x14e] =  0x00
4002054f      [0x14f] =  0x00
40020550      [0x150] =  0x00
40020551      [0x151] =  0x00
40020552      [0x152] =  0x00
40020553      [0x153] =  0x00
40020554      [0x154] =  0x00
40020555      [0x155] =  0x00
40020556      [0x156] =  0x00
40020557      [0x157] =  0x00
40020558      [0x158] =  0x00
40020559      [0x159] =  0x00
4002055a      [0x15a] =  0x00
4002055b      [0x15b] =  0x00
4002055c      [0x15c] =  0x00
4002055d      [0x15d] =  0x00
4002055e      [0x15e] =  0x00
4002055f      [0x15f] =  0x00
40020560      [0x160] =  0x00
40020561      [0x161] =  0x00
40020562      [0x162] =  0x00
40020563      [0x163] =  0x00
40020564      [0x164] =  0x00
40020565      [0x165] =  0x00
40020566      [0x166] =  0x00
40020567      [0x167] =  0x00
40020568      [0x168] =  0x00
40020569      [0x169] =  0x00
4002056a      [0x16a] =  0x00
4002056b      [0x16b] =  0x00
4002056c      [0x16c] =  0x00
4002056d      [0x16d] =  0x00
4002056e      [0x16e] =  0x00
4002056f      [0x16f] =  0x00
40020570      [0x170] =  0x00
40020571      [0x171] =  0x00
40020572      [0x172] =  0x00
40020573      [0x173] =  0x00
40020574      [0x174] =  0x00
40020575      [0x175] =  0x00
40020576      [0x176] =  0x00
40020577      [0x177] =  0x00
40020578      [0x178] =  0x00
40020579      [0x179] =  0x00
4002057a      [0x17a] =  0x00
4002057b      [0x17b] =  0x00
4002057c      [0x17c] =  0x00
4002057d      [0x17d] =  0x00
4002057e      [0x17e] =  0x00
4002057f      [0x17f] =  0x00
40020580      [0x180] =  0x00
40020581      [0x181] =  0x00
40020582      [0x182] =  0x00
40020583      [0x183] =  0x00
40020584      [0x184] =  0x00
40020585      [0x185] =  0x00
40020586      [0x186] =  0x00
40020587      [0x187] =  0x00
40020588      [0x188] =  0x00
40020589      [0x189] =  0x00
4002058a      [0x18a] =  0x00
4002058b      [0x18b] =  0x00
4002058c      [0x18c] =  0x00
4002058d      [0x18d] =  0x00
4002058e      [0x18e] =  0x00
4002058f      [0x18f] =  0x00
40020590      [0x190] =  0x00
40020591      [0x191] =  0x00
40020592      [0x192] =  0x00
40020593      [0x193] =  0x00
40020594      [0x194] =  0x00
40020595      [0x195] =  0x00
40020596      [0x196] =  0x00
40020597      [0x197] =  0x00
40020598      [0x198] =  0x00
40020599      [0x199] =  0x00
4002059a      [0x19a] =  0x00
4002059b      [0x19b] =  0x00
4002059c      [0x19c] =  0x00
4002059d      [0x19d] =  0x00
4002059e      [0x19e] =  0x00
4002059f      [0x19f] =  0x00
400205a0      [0x1a0] =  0x00
400205a1      [0x1a1] =  0x00
400205a2      [0x1a2] =  0x00
400205a3      [0x1a3] =  0x00
400205a4      [0x1a4] =  0x00
400205a5      [0x1a5] =  0x00
400205a6      [0x1a6] =  0x00
400205a7      [0x1a7] =  0x00
400205a8      [0x1a8] =  0x00
400205a9      [0x1a9] =  0x00
400205aa      [0x1aa] =  0x00
400205ab      [0x1ab] =  0x00
400205ac      [0x1ac] =  0x00
400205ad      [0x1ad] =  0x00
400205ae      [0x1ae] =  0x00
400205af      [0x1af] =  0x00
400205b0      [0x1b0] =  0x00
400205b1      [0x1b1] =  0x00
400205b2      [0x1b2] =  0x00
400205b3      [0x1b3] =  0x00
400205b4      [0x1b4] =  0x00
400205b5      [0x1b5] =  0x00
400205b6      [0x1b6] =  0x00
400205b7      [0x1b7] =  0x00
400205b8      [0x1b8] =  0x00
400205b9      [0x1b9] =  0x00
400205ba      [0x1ba] =  0x00
400205bb      [0x1bb] =  0x00
400205bc      [0x1bc] =  0x00
400205bd      [0x1bd] =  0x00
400205be      [0x1be] =  0x00
400205bf      [0x1bf] =  0x00
400205c0      [0x1c0] =  0x00
400205c1      [0x1c1] =  0x00
400205c2      [0x1c2] =  0x00
400205c3      [0x1c3] =  0x00
400205c4      [0x1c4] =  0x00
400205c5      [0x1c5] =  0x00
400205c6      [0x1c6] =  0x00
400205c7      [0x1c7] =  0x00
400205c8      [0x1c8] =  0x00
400205c9      [0x1c9] =  0x00
400205ca      [0x1ca] =  0x00
400205cb      [0x1cb] =  0x00
400205cc      [0x1cc] =  0x00
400205cd      [0x1cd] =  0x00
400205ce      [0x1ce] =  0x00
400205cf      [0x1cf] =  0x00
400205d0      [0x1d0] =  0x00
400205d1      [0x1d1] =  0x00
400205d2      [0x1d2] =  0x00
400205d3      [0x1d3] =  0x00
400205d4      [0x1d4] =  0x00
400205d5      [0x1d5] =  0x00
400205d6      [0x1d6] =  0x00
400205d7      [0x1d7] =  0x00
400205d8      [0x1d8] =  0x00
400205d9      [0x1d9] =  0x00
400205da      [0x1da] =  0x00
400205db      [0x1db] =  0x00
400205dc      [0x1dc] =  0x00
400205dd      [0x1dd] =  0x00
400205de      [0x1de] =  0x00
400205df      [0x1df] =  0x00
400205e0      [0x1e0] =  0x00
400205e1      [0x1e1] =  0x00
400205e2      [0x1e2] =  0x00
400205e3      [0x1e3] =  0x00
400205e4      [0x1e4] =  0x00
400205e5      [0x1e5] =  0x00
400205e6      [0x1e6] =  0x00
400205e7      [0x1e7] =  0x00
400205e8      [0x1e8] =  0x00
400205e9      [0x1e9] =  0x00
400205ea      [0x1ea] =  0x00
400205eb      [0x1eb] =  0x00
400205ec      [0x1ec] =  0x00
400205ed      [0x1ed] =  0x00
400205ee      [0x1ee] =  0x00
400205ef      [0x1ef] =  0x00
400205f0      [0x1f0] =  0x00
400205f1      [0x1f1] =  0x00
400205f2      [0x1f2] =  0x00
400205f3      [0x1f3] =  0x00
400205f4      [0x1f4] =  0x00
400205f5      [0x1f5] =  0x00
400205f6      [0x1f6] =  0x00
400205f7      [0x1f7] =  0x00
400205f8      [0x1f8] =  0x00
400205f9      [0x1f9] =  0x00
400205fa      [0x1fa] =  0x00
400205fb      [0x1fb] =  0x00
400205fc      [0x1fc] =  0x00
400205fd      [0x1fd] =  0x00
400205fe      [0x1fe] =  0x00
400205ff      [0x1ff] =  0x00
40020600      [0x200] =  0x00
40020601      [0x201] =  0x00
40020602      [0x202] =  0x00
40020603      [0x203] =  0x00
40020604      [0x204] =  0x00
40020605      [0x205] =  0x00
40020606      [0x206] =  0x00
40020607      [0x207] =  0x00
40020608      [0x208] =  0x00
40020609      [0x209] =  0x00
4002060a      [0x20a] =  0x00
4002060b      [0x20b] =  0x00
4002060c      [0x20c] =  0x00
4002060d      [0x20d] =  0x00
4002060e      [0x20e] =  0x00
4002060f      [0x20f] =  0x00
40020610      [0x210] =  0x00
40020611      [0x211] =  0x00
40020612      [0x212] =  0x00
40020613      [0x213] =  0x00
40020614      [0x214] =  0x00
40020615      [0x215] =  0x00
40020616      [0x216] =  0x00
40020617      [0x217] =  0x00
40020618      [0x218] =  0x00
40020619      [0x219] =  0x00
4002061a      [0x21a] =  0x00
4002061b      [0x21b] =  0x00
4002061c      [0x21c] =  0x00
4002061d      [0x21d] =  0x00
4002061e      [0x21e] =  0x00
4002061f      [0x21f] =  0x00
40020620      [0x220] =  0x00
40020621      [0x221] =  0x00
40020622      [0x222] =  0x00
40020623      [0x223] =  0x00
40020624      [0x224] =  0x00
40020625      [0x225] =  0x00
40020626      [0x226] =  0x00
40020627      [0x227] =  0x00
40020628      [0x228] =  0x00
40020629      [0x229] =  0x00
4002062a      [0x22a] =  0x00
4002062b      [0x22b] =  0x00
4002062c      [0x22c] =  0x00
4002062d      [0x22d] =  0x00
4002062e      [0x22e] =  0x00
4002062f      [0x22f] =  0x00
40020630      [0x230] =  0x00
40020631      [0x231] =  0x00
40020632      [0x232] =  0x00
40020633      [0x233] =  0x00
40020634      [0x234] =  0x00
40020635      [0x235] =  0x00
40020636      [0x236] =  0x00
40020637      [0x237] =  0x00
40020638      [0x238] =  0x00
40020639      [0x239] =  0x00
4002063a      [0x23a] =  0x00
4002063b      [0x23b] =  0x00
4002063c      [0x23c] =  0x00
4002063d      [0x23d] =  0x00
4002063e      [0x23e] =  0x00
4002063f      [0x23f] =  0x00
40020640      [0x240] =  0x00
40020641      [0x241] =  0x00
40020642      [0x242] =  0x00
40020643      [0x243] =  0x00
40020644      [0x244] =  0x00
40020645      [0x245] =  0x00
40020646      [0x246] =  0x00
40020647      [0x247] =  0x00
40020648      [0x248] =  0x00
40020649      [0x249] =  0x00
4002064a      [0x24a] =  0x00
4002064b      [0x24b] =  0x00
4002064c      [0x24c] =  0x00
4002064d      [0x24d] =  0x00
4002064e      [0x24e] =  0x00
4002064f      [0x24f] =  0x00
40020650      [0x250] =  0x00
40020651      [0x251] =  0x00
40020652      [0x252] =  0x00
40020653      [0x253] =  0x00
40020654      [0x254] =  0x00
40020655      [0x255] =  0x00
40020656      [0x256] =  0x00
40020657      [0x257] =  0x00
40020658      [0x258] =  0x00
40020659      [0x259] =  0x00
4002065a      [0x25a] =  0x00
4002065b      [0x25b] =  0x00
4002065c      [0x25c] =  0x00
4002065d      [0x25d] =  0x00
4002065e      [0x25e] =  0x00
4002065f      [0x25f] =  0x00
40020660      [0x260] =  0x00
40020661      [0x261] =  0x00
40020662      [0x262] =  0x00
40020663      [0x263] =  0x00
40020664      [0x264] =  0x00
40020665      [0x265] =  0x00
40020666      [0x266] =  0x00
40020667      [0x267] =  0x00
40020668      [0x268] =  0x00
40020669      [0x269] =  0x00
4002066a      [0x26a] =  0x00
4002066b      [0x26b] =  0x00
4002066c      [0x26c] =  0x00
4002066d      [0x26d] =  0x00
4002066e      [0x26e] =  0x00
4002066f      [0x26f] =  0x00
40020670      [0x270] =  0x00
40020671      [0x271] =  0x00
40020672      [0x272] =  0x00
40020673      [0x273] =  0x00
40020674      [0x274] =  0x00
40020675      [0x275] =  0x00
40020676      [0x276] =  0x00
40020677      [0x277] =  0x00
40020678      [0x278] =  0x00
40020679      [0x279] =  0x00
4002067a      [0x27a] =  0x00
4002067b      [0x27b] =  0x00
4002067c      [0x27c] =  0x00
4002067d      [0x27d] =  0x00
4002067e      [0x27e] =  0x00
4002067f      [0x27f] =  0x00
40020680      [0x280] =  0x00
40020681      [0x281] =  0x00
40020682      [0x282] =  0x00
40020683      [0x283] =  0x00
40020684      [0x284] =  0x00
40020685      [0x285] =  0x00
40020686      [0x286] =  0x00
40020687      [0x287] =  0x00
40020688      [0x288] =  0x00
40020689      [0x289] =  0x00
4002068a      [0x28a] =  0x00
4002068b      [0x28b] =  0x00
4002068c      [0x28c] =  0x00
4002068d      [0x28d] =  0x00
4002068e      [0x28e] =  0x00
4002068f      [0x28f] =  0x00
40020690      [0x290] =  0x00
40020691      [0x291] =  0x00
40020692      [0x292] =  0x00
40020693      [0x293] =  0x00
40020694      [0x294] =  0x00
40020695      [0x295] =  0x00
40020696      [0x296] =  0x00
40020697      [0x297] =  0x00
40020698      [0x298] =  0x00
40020699      [0x299] =  0x00
4002069a      [0x29a] =  0x00
4002069b      [0x29b] =  0x00
4002069c      [0x29c] =  0x00
4002069d      [0x29d] =  0x00
4002069e      [0x29e] =  0x00
4002069f      [0x29f] =  0x00
400206a0      [0x2a0] =  0x00
400206a1      [0x2a1] =  0x00
400206a2      [0x2a2] =  0x00
400206a3      [0x2a3] =  0x00
400206a4      [0x2a4] =  0x00
400206a5      [0x2a5] =  0x00
400206a6      [0x2a6] =  0x00
400206a7      [0x2a7] =  0x00
400206a8      [0x2a8] =  0x00
400206a9      [0x2a9] =  0x00
400206aa      [0x2aa] =  0x00
400206ab      [0x2ab] =  0x00
400206ac      [0x2ac] =  0x00
400206ad      [0x2ad] =  0x00
400206ae      [0x2ae] =  0x00
400206af      [0x2af] =  0x00
400206b0      [0x2b0] =  0x00
400206b1      [0x2b1] =  0x00
400206b2      [0x2b2] =  0x00
400206b3      [0x2b3] =  0x00
400206b4      [0x2b4] =  0x00
400206b5      [0x2b5] =  0x00
400206b6      [0x2b6] =  0x00
400206b7      [0x2b7] =  0x00
400206b8      [0x2b8] =  0x00
400206b9      [0x2b9] =  0x00
400206ba      [0x2ba] =  0x00
400206bb      [0x2bb] =  0x00
400206bc      [0x2bc] =  0x00
400206bd      [0x2bd] =  0x00
400206be      [0x2be] =  0x00
400206bf      [0x2bf] =  0x00
400206c0      [0x2c0] =  0x00
400206c1      [0x2c1] =  0x00
400206c2      [0x2c2] =  0x00
400206c3      [0x2c3] =  0x00
400206c4      [0x2c4] =  0x00
400206c5      [0x2c5] =  0x00
400206c6      [0x2c6] =  0x00
400206c7      [0x2c7] =  0x00
400206c8      [0x2c8] =  0x00
400206c9      [0x2c9] =  0x00
400206ca      [0x2ca] =  0x00
400206cb      [0x2cb] =  0x00
400206cc      [0x2cc] =  0x00
400206cd      [0x2cd] =  0x00
400206ce      [0x2ce] =  0x00
400206cf      [0x2cf] =  0x00
400206d0      [0x2d0] =  0x00
400206d1      [0x2d1] =  0x00
400206d2      [0x2d2] =  0x00
400206d3      [0x2d3] =  0x00
400206d4      [0x2d4] =  0x00
400206d5      [0x2d5] =  0x00
400206d6      [0x2d6] =  0x00
400206d7      [0x2d7] =  0x00
400206d8      [0x2d8] =  0x00
400206d9      [0x2d9] =  0x00
400206da      [0x2da] =  0x00
400206db      [0x2db] =  0x00
400206dc      [0x2dc] =  0x00
400206dd      [0x2dd] =  0x00
400206de      [0x2de] =  0x00
400206df      [0x2df] =  0x00
400206e0      [0x2e0] =  0x00
400206e1      [0x2e1] =  0x00
400206e2      [0x2e2] =  0x00
400206e3      [0x2e3] =  0x00
400206e4      [0x2e4] =  0x00
400206e5      [0x2e5] =  0x00
400206e6      [0x2e6] =  0x00
400206e7      [0x2e7] =  0x00
400206e8      [0x2e8] =  0x00
400206e9      [0x2e9] =  0x00
400206ea      [0x2ea] =  0x00
400206eb      [0x2eb] =  0x00
400206ec      [0x2ec] =  0x00
400206ed      [0x2ed] =  0x00
400206ee      [0x2ee] =  0x00
400206ef      [0x2ef] =  0x00
400206f0      [0x2f0] =  0x00
400206f1      [0x2f1] =  0x00
400206f2      [0x2f2] =  0x00
400206f3      [0x2f3] =  0x00
400206f4      [0x2f4] =  0x00
400206f5      [0x2f5] =  0x00
400206f6      [0x2f6] =  0x00
400206f7      [0x2f7] =  0x00
400206f8      [0x2f8] =  0x00
400206f9      [0x2f9] =  0x00
400206fa      [0x2fa] =  0x00
400206fb      [0x2fb] =  0x00
400206fc      [0x2fc] =  0x00
400206fd      [0x2fd] =  0x00
400206fe      [0x2fe] =  0x00
400206ff      [0x2ff] =  0x00
40020700      [0x300] =  0x00
40020701      [0x301] =  0x00
40020702      [0x302] =  0x00
40020703      [0x303] =  0x00
40020704      [0x304] =  0x00
40020705      [0x305] =  0x00
40020706      [0x306] =  0x00
40020707      [0x307] =  0x00
40020708      [0x308] =  0x00
40020709      [0x309] =  0x00
4002070a      [0x30a] =  0x00
4002070b      [0x30b] =  0x00
4002070c      [0x30c] =  0x00
4002070d      [0x30d] =  0x00
4002070e      [0x30e] =  0x00
4002070f      [0x30f] =  0x00
40020710      [0x310] =  0x00
40020711      [0x311] =  0x00
40020712      [0x312] =  0x00
40020713      [0x313] =  0x00
40020714      [0x314] =  0x00
40020715      [0x315] =  0x00
40020716      [0x316] =  0x00
40020717      [0x317] =  0x00
40020718      [0x318] =  0x00
40020719      [0x319] =  0x00
4002071a      [0x31a] =  0x00
4002071b      [0x31b] =  0x00
4002071c      [0x31c] =  0x00
4002071d      [0x31d] =  0x00
4002071e      [0x31e] =  0x00
4002071f      [0x31f] =  0x00
40020720      [0x320] =  0x00
40020721      [0x321] =  0x00
40020722      [0x322] =  0x00
40020723      [0x323] =  0x00
40020724      [0x324] =  0x00
40020725      [0x325] =  0x00
40020726      [0x326] =  0x00
40020727      [0x327] =  0x00
40020728      [0x328] =  0x00
40020729      [0x329] =  0x00
4002072a      [0x32a] =  0x00
4002072b      [0x32b] =  0x00
4002072c      [0x32c] =  0x00
4002072d      [0x32d] =  0x00
4002072e      [0x32e] =  0x00
4002072f      [0x32f] =  0x00
40020730      [0x330] =  0x00
40020731      [0x331] =  0x00
40020732      [0x332] =  0x00
40020733      [0x333] =  0x00
40020734      [0x334] =  0x00
40020735      [0x335] =  0x00
40020736      [0x336] =  0x00
40020737      [0x337] =  0x00
40020738      [0x338] =  0x00
40020739      [0x339] =  0x00
4002073a      [0x33a] =  0x00
4002073b      [0x33b] =  0x00
4002073c      [0x33c] =  0x00
4002073d      [0x33d] =  0x00
4002073e      [0x33e] =  0x00
4002073f      [0x33f] =  0x00
40020740      [0x340] =  0x00
40020741      [0x341] =  0x00
40020742      [0x342] =  0x00
40020743      [0x343] =  0x00
40020744      [0x344] =  0x00
40020745      [0x345] =  0x00
40020746      [0x346] =  0x00
40020747      [0x347] =  0x00
40020748      [0x348] =  0x00
40020749      [0x349] =  0x00
4002074a      [0x34a] =  0x00
4002074b      [0x34b] =  0x00
4002074c      [0x34c] =  0x00
4002074d      [0x34d] =  0x00
4002074e      [0x34e] =  0x00
4002074f      [0x34f] =  0x00
40020750      [0x350] =  0x00
40020751      [0x351] =  0x00
40020752      [0x352] =  0x00
40020753      [0x353] =  0x00
40020754      [0x354] =  0x00
40020755      [0x355] =  0x00
40020756      [0x356] =  0x00
40020757      [0x357] =  0x00
40020758      [0x358] =  0x00
40020759      [0x359] =  0x00
4002075a      [0x35a] =  0x00
4002075b      [0x35b] =  0x00
4002075c      [0x35c] =  0x00
4002075d      [0x35d] =  0x00
4002075e      [0x35e] =  0x00
4002075f      [0x35f] =  0x00
40020760      [0x360] =  0x00
40020761      [0x361] =  0x00
40020762      [0x362] =  0x00
40020763      [0x363] =  0x00
40020764      [0x364] =  0x00
40020765      [0x365] =  0x00
40020766      [0x366] =  0x00
40020767      [0x367] =  0x00
40020768      [0x368] =  0x00
40020769      [0x369] =  0x00
4002076a      [0x36a] =  0x00
4002076b      [0x36b] =  0x00
4002076c      [0x36c] =  0x00
4002076d      [0x36d] =  0x00
4002076e      [0x36e] =  0x00
4002076f      [0x36f] =  0x00
40020770      [0x370] =  0x00
40020771      [0x371] =  0x00
40020772      [0x372] =  0x00
40020773      [0x373] =  0x00
40020774      [0x374] =  0x00
40020775      [0x375] =  0x00
40020776      [0x376] =  0x00
40020777      [0x377] =  0x00
40020778      [0x378] =  0x00
40020779      [0x379] =  0x00
4002077a      [0x37a] =  0x00
4002077b      [0x37b] =  0x00
4002077c      [0x37c] =  0x00
4002077d      [0x37d] =  0x00
4002077e      [0x37e] =  0x00
4002077f      [0x37f] =  0x00
40020780      [0x380] =  0x00
40020781      [0x381] =  0x00
40020782      [0x382] =  0x00
40020783      [0x383] =  0x00
40020784      [0x384] =  0x00
40020785      [0x385] =  0x00
40020786      [0x386] =  0x00
40020787      [0x387] =  0x00
40020788      [0x388] =  0x00
40020789      [0x389] =  0x00
4002078a      [0x38a] =  0x00
4002078b      [0x38b] =  0x00
4002078c      [0x38c] =  0x00
4002078d      [0x38d] =  0x00
4002078e      [0x38e] =  0x00
4002078f      [0x38f] =  0x00
40020790      [0x390] =  0x00
40020791      [0x391] =  0x00
40020792      [0x392] =  0x00
40020793      [0x393] =  0x00
40020794      [0x394] =  0x00
40020795      [0x395] =  0x00
40020796      [0x396] =  0x00
40020797      [0x397] =  0x00
40020798      [0x398] =  0x00
40020799      [0x399] =  0x00
4002079a      [0x39a] =  0x00
4002079b      [0x39b] =  0x00
4002079c      [0x39c] =  0x00
4002079d      [0x39d] =  0x00
4002079e      [0x39e] =  0x00
4002079f      [0x39f] =  0x00
400207a0      [0x3a0] =  0x00
400207a1      [0x3a1] =  0x00
400207a2      [0x3a2] =  0x00
400207a3      [0x3a3] =  0x00
400207a4      [0x3a4] =  0x00
400207a5      [0x3a5] =  0x00
400207a6      [0x3a6] =  0x00
400207a7      [0x3a7] =  0x00
400207a8      [0x3a8] =  0x00
400207a9      [0x3a9] =  0x00
400207aa      [0x3aa] =  0x00
400207ab      [0x3ab] =  0x00
400207ac      [0x3ac] =  0x00
400207ad      [0x3ad] =  0x00
400207ae      [0x3ae] =  0x00
400207af      [0x3af] =  0x00
400207b0      [0x3b0] =  0x00
400207b1      [0x3b1] =  0x00
400207b2      [0x3b2] =  0x00
400207b3      [0x3b3] =  0x00
400207b4      [0x3b4] =  0x00
400207b5      [0x3b5] =  0x00
400207b6      [0x3b6] =  0x00
400207b7      [0x3b7] =  0x00
400207b8      [0x3b8] =  0x00
400207b9      [0x3b9] =  0x00
400207ba      [0x3ba] =  0x00
400207bb      [0x3bb] =  0x00
400207bc      [0x3bc] =  0x00
400207bd      [0x3bd] =  0x00
400207be      [0x3be] =  0x00
400207bf      [0x3bf] =  0x00
400207c0      [0x3c0] =  0x00
400207c1      [0x3c1] =  0x00
400207c2      [0x3c2] =  0x00
400207c3      [0x3c3] =  0x00
400207c4      [0x3c4] =  0x00
400207c5      [0x3c5] =  0x00
400207c6      [0x3c6] =  0x00
400207c7      [0x3c7] =  0x00
400207c8      [0x3c8] =  0x00
400207c9      [0x3c9] =  0x00
400207ca      [0x3ca] =  0x00
400207cb      [0x3cb] =  0x00
400207cc      [0x3cc] =  0x00
400207cd      [0x3cd] =  0x00
400207ce      [0x3ce] =  0x00
400207cf      [0x3cf] =  0x00
400207d0      [0x3d0] =  0x00
400207d1      [0x3d1] =  0x00
400207d2      [0x3d2] =  0x00
400207d3      [0x3d3] =  0x00
400207d4      [0x3d4] =  0x00
400207d5      [0x3d5] =  0x00
400207d6      [0x3d6] =  0x00
400207d7      [0x3d7] =  0x00
400207d8      [0x3d8] =  0x00
400207d9      [0x3d9] =  0x00
400207da      [0x3da] =  0x00
400207db      [0x3db] =  0x00
400207dc      [0x3dc] =  0x00
400207dd      [0x3dd] =  0x00
400207de      [0x3de] =  0x00
400207df      [0x3df] =  0x00
400207e0      [0x3e0] =  0x00
400207e1      [0x3e1] =  0x00
400207e2      [0x3e2] =  0x00
400207e3      [0x3e3] =  0x00
400207e4      [0x3e4] =  0x00
400207e5      [0x3e5] =  0x00
400207e6      [0x3e6] =  0x00
400207e7      [0x3e7] =  0x00
400207e8      [0x3e8] =  0x00
400207e9      [0x3e9] =  0x00
400207ea      [0x3ea] =  0x00
400207eb      [0x3eb] =  0x00
400207ec      [0x3ec] =  0x00
400207ed      [0x3ed] =  0x00
400207ee      [0x3ee] =  0x00
400207ef      [0x3ef] =  0x00
400207f0      [0x3f0] =  0x00
400207f1      [0x3f1] =  0x00
400207f2      [0x3f2] =  0x00
400207f3      [0x3f3] =  0x00
400207f4      [0x3f4] =  0x00
400207f5      [0x3f5] =  0x00
400207f6      [0x3f6] =  0x00
400207f7      [0x3f7] =  0x00
400207f8      [0x3f8] =  0x00
400207f9      [0x3f9] =  0x00
400207fa      [0x3fa] =  0x00
400207fb      [0x3fb] =  0x00
400207fc      [0x3fc] =  0x00
400207fd      [0x3fd] =  0x00
400207fe      [0x3fe] =  0x00
400207ff      [0x3ff] =  0x00
40020800  }
40020800  uint8_t GPIOC[0x400] = 
40020800  {
40020800      [0x000] =  0x00
40020801      [0x001] =  0x00
40020802      [0x002] =  0x00
40020803      [0x003] =  0x00
40020804      [0x004] =  0x00
40020805      [0x005] =  0x00
40020806      [0x006] =  0x00
40020807      [0x007] =  0x00
40020808      [0x008] =  0x00
40020809      [0x009] =  0x00
4002080a      [0x00a] =  0x00
4002080b      [0x00b] =  0x00
4002080c      [0x00c] =  0x00
4002080d      [0x00d] =  0x00
4002080e      [0x00e] =  0x00
4002080f      [0x00f] =  0x00
40020810      [0x010] =  0x00
40020811      [0x011] =  0x00
40020812      [0x012] =  0x00
40020813      [0x013] =  0x00
40020814      [0x014] =  0x00
40020815      [0x015] =  0x00
40020816      [0x016] =  0x00
40020817      [0x017] =  0x00
40020818      [0x018] =  0x00
40020819      [0x019] =  0x00
4002081a      [0x01a] =  0x00
4002081b      [0x01b] =  0x00
4002081c      [0x01c] =  0x00
4002081d      [0x01d] =  0x00
4002081e      [0x01e] =  0x00
4002081f      [0x01f] =  0x00
40020820      [0x020] =  0x00
40020821      [0x021] =  0x00
40020822      [0x022] =  0x00
40020823      [0x023] =  0x00
40020824      [0x024] =  0x00
40020825      [0x025] =  0x00
40020826      [0x026] =  0x00
40020827      [0x027] =  0x00
40020828      [0x028] =  0x00
40020829      [0x029] =  0x00
4002082a      [0x02a] =  0x00
4002082b      [0x02b] =  0x00
4002082c      [0x02c] =  0x00
4002082d      [0x02d] =  0x00
4002082e      [0x02e] =  0x00
4002082f      [0x02f] =  0x00
40020830      [0x030] =  0x00
40020831      [0x031] =  0x00
40020832      [0x032] =  0x00
40020833      [0x033] =  0x00
40020834      [0x034] =  0x00
40020835      [0x035] =  0x00
40020836      [0x036] =  0x00
40020837      [0x037] =  0x00
40020838      [0x038] =  0x00
40020839      [0x039] =  0x00
4002083a      [0x03a] =  0x00
4002083b      [0x03b] =  0x00
4002083c      [0x03c] =  0x00
4002083d      [0x03d] =  0x00
4002083e      [0x03e] =  0x00
4002083f      [0x03f] =  0x00
40020840      [0x040] =  0x00
40020841      [0x041] =  0x00
40020842      [0x042] =  0x00
40020843      [0x043] =  0x00
40020844      [0x044] =  0x00
40020845      [0x045] =  0x00
40020846      [0x046] =  0x00
40020847      [0x047] =  0x00
40020848      [0x048] =  0x00
40020849      [0x049] =  0x00
4002084a      [0x04a] =  0x00
4002084b      [0x04b] =  0x00
4002084c      [0x04c] =  0x00
4002084d      [0x04d] =  0x00
4002084e      [0x04e] =  0x00
4002084f      [0x04f] =  0x00
40020850      [0x050] =  0x00
40020851      [0x051] =  0x00
40020852      [0x052] =  0x00
40020853      [0x053] =  0x00
40020854      [0x054] =  0x00
40020855      [0x055] =  0x00
40020856      [0x056] =  0x00
40020857      [0x057] =  0x00
40020858      [0x058] =  0x00
40020859      [0x059] =  0x00
4002085a      [0x05a] =  0x00
4002085b      [0x05b] =  0x00
4002085c      [0x05c] =  0x00
4002085d      [0x05d] =  0x00
4002085e      [0x05e] =  0x00
4002085f      [0x05f] =  0x00
40020860      [0x060] =  0x00
40020861      [0x061] =  0x00
40020862      [0x062] =  0x00
40020863      [0x063] =  0x00
40020864      [0x064] =  0x00
40020865      [0x065] =  0x00
40020866      [0x066] =  0x00
40020867      [0x067] =  0x00
40020868      [0x068] =  0x00
40020869      [0x069] =  0x00
4002086a      [0x06a] =  0x00
4002086b      [0x06b] =  0x00
4002086c      [0x06c] =  0x00
4002086d      [0x06d] =  0x00
4002086e      [0x06e] =  0x00
4002086f      [0x06f] =  0x00
40020870      [0x070] =  0x00
40020871      [0x071] =  0x00
40020872      [0x072] =  0x00
40020873      [0x073] =  0x00
40020874      [0x074] =  0x00
40020875      [0x075] =  0x00
40020876      [0x076] =  0x00
40020877      [0x077] =  0x00
40020878      [0x078] =  0x00
40020879      [0x079] =  0x00
4002087a      [0x07a] =  0x00
4002087b      [0x07b] =  0x00
4002087c      [0x07c] =  0x00
4002087d      [0x07d] =  0x00
4002087e      [0x07e] =  0x00
4002087f      [0x07f] =  0x00
40020880      [0x080] =  0x00
40020881      [0x081] =  0x00
40020882      [0x082] =  0x00
40020883      [0x083] =  0x00
40020884      [0x084] =  0x00
40020885      [0x085] =  0x00
40020886      [0x086] =  0x00
40020887      [0x087] =  0x00
40020888      [0x088] =  0x00
40020889      [0x089] =  0x00
4002088a      [0x08a] =  0x00
4002088b      [0x08b] =  0x00
4002088c      [0x08c] =  0x00
4002088d      [0x08d] =  0x00
4002088e      [0x08e] =  0x00
4002088f      [0x08f] =  0x00
40020890      [0x090] =  0x00
40020891      [0x091] =  0x00
40020892      [0x092] =  0x00
40020893      [0x093] =  0x00
40020894      [0x094] =  0x00
40020895      [0x095] =  0x00
40020896      [0x096] =  0x00
40020897      [0x097] =  0x00
40020898      [0x098] =  0x00
40020899      [0x099] =  0x00
4002089a      [0x09a] =  0x00
4002089b      [0x09b] =  0x00
4002089c      [0x09c] =  0x00
4002089d      [0x09d] =  0x00
4002089e      [0x09e] =  0x00
4002089f      [0x09f] =  0x00
400208a0      [0x0a0] =  0x00
400208a1      [0x0a1] =  0x00
400208a2      [0x0a2] =  0x00
400208a3      [0x0a3] =  0x00
400208a4      [0x0a4] =  0x00
400208a5      [0x0a5] =  0x00
400208a6      [0x0a6] =  0x00
400208a7      [0x0a7] =  0x00
400208a8      [0x0a8] =  0x00
400208a9      [0x0a9] =  0x00
400208aa      [0x0aa] =  0x00
400208ab      [0x0ab] =  0x00
400208ac      [0x0ac] =  0x00
400208ad      [0x0ad] =  0x00
400208ae      [0x0ae] =  0x00
400208af      [0x0af] =  0x00
400208b0      [0x0b0] =  0x00
400208b1      [0x0b1] =  0x00
400208b2      [0x0b2] =  0x00
400208b3      [0x0b3] =  0x00
400208b4      [0x0b4] =  0x00
400208b5      [0x0b5] =  0x00
400208b6      [0x0b6] =  0x00
400208b7      [0x0b7] =  0x00
400208b8      [0x0b8] =  0x00
400208b9      [0x0b9] =  0x00
400208ba      [0x0ba] =  0x00
400208bb      [0x0bb] =  0x00
400208bc      [0x0bc] =  0x00
400208bd      [0x0bd] =  0x00
400208be      [0x0be] =  0x00
400208bf      [0x0bf] =  0x00
400208c0      [0x0c0] =  0x00
400208c1      [0x0c1] =  0x00
400208c2      [0x0c2] =  0x00
400208c3      [0x0c3] =  0x00
400208c4      [0x0c4] =  0x00
400208c5      [0x0c5] =  0x00
400208c6      [0x0c6] =  0x00
400208c7      [0x0c7] =  0x00
400208c8      [0x0c8] =  0x00
400208c9      [0x0c9] =  0x00
400208ca      [0x0ca] =  0x00
400208cb      [0x0cb] =  0x00
400208cc      [0x0cc] =  0x00
400208cd      [0x0cd] =  0x00
400208ce      [0x0ce] =  0x00
400208cf      [0x0cf] =  0x00
400208d0      [0x0d0] =  0x00
400208d1      [0x0d1] =  0x00
400208d2      [0x0d2] =  0x00
400208d3      [0x0d3] =  0x00
400208d4      [0x0d4] =  0x00
400208d5      [0x0d5] =  0x00
400208d6      [0x0d6] =  0x00
400208d7      [0x0d7] =  0x00
400208d8      [0x0d8] =  0x00
400208d9      [0x0d9] =  0x00
400208da      [0x0da] =  0x00
400208db      [0x0db] =  0x00
400208dc      [0x0dc] =  0x00
400208dd      [0x0dd] =  0x00
400208de      [0x0de] =  0x00
400208df      [0x0df] =  0x00
400208e0      [0x0e0] =  0x00
400208e1      [0x0e1] =  0x00
400208e2      [0x0e2] =  0x00
400208e3      [0x0e3] =  0x00
400208e4      [0x0e4] =  0x00
400208e5      [0x0e5] =  0x00
400208e6      [0x0e6] =  0x00
400208e7      [0x0e7] =  0x00
400208e8      [0x0e8] =  0x00
400208e9      [0x0e9] =  0x00
400208ea      [0x0ea] =  0x00
400208eb      [0x0eb] =  0x00
400208ec      [0x0ec] =  0x00
400208ed      [0x0ed] =  0x00
400208ee      [0x0ee] =  0x00
400208ef      [0x0ef] =  0x00
400208f0      [0x0f0] =  0x00
400208f1      [0x0f1] =  0x00
400208f2      [0x0f2] =  0x00
400208f3      [0x0f3] =  0x00
400208f4      [0x0f4] =  0x00
400208f5      [0x0f5] =  0x00
400208f6      [0x0f6] =  0x00
400208f7      [0x0f7] =  0x00
400208f8      [0x0f8] =  0x00
400208f9      [0x0f9] =  0x00
400208fa      [0x0fa] =  0x00
400208fb      [0x0fb] =  0x00
400208fc      [0x0fc] =  0x00
400208fd      [0x0fd] =  0x00
400208fe      [0x0fe] =  0x00
400208ff      [0x0ff] =  0x00
40020900      [0x100] =  0x00
40020901      [0x101] =  0x00
40020902      [0x102] =  0x00
40020903      [0x103] =  0x00
40020904      [0x104] =  0x00
40020905      [0x105] =  0x00
40020906      [0x106] =  0x00
40020907      [0x107] =  0x00
40020908      [0x108] =  0x00
40020909      [0x109] =  0x00
4002090a      [0x10a] =  0x00
4002090b      [0x10b] =  0x00
4002090c      [0x10c] =  0x00
4002090d      [0x10d] =  0x00
4002090e      [0x10e] =  0x00
4002090f      [0x10f] =  0x00
40020910      [0x110] =  0x00
40020911      [0x111] =  0x00
40020912      [0x112] =  0x00
40020913      [0x113] =  0x00
40020914      [0x114] =  0x00
40020915      [0x115] =  0x00
40020916      [0x116] =  0x00
40020917      [0x117] =  0x00
40020918      [0x118] =  0x00
40020919      [0x119] =  0x00
4002091a      [0x11a] =  0x00
4002091b      [0x11b] =  0x00
4002091c      [0x11c] =  0x00
4002091d      [0x11d] =  0x00
4002091e      [0x11e] =  0x00
4002091f      [0x11f] =  0x00
40020920      [0x120] =  0x00
40020921      [0x121] =  0x00
40020922      [0x122] =  0x00
40020923      [0x123] =  0x00
40020924      [0x124] =  0x00
40020925      [0x125] =  0x00
40020926      [0x126] =  0x00
40020927      [0x127] =  0x00
40020928      [0x128] =  0x00
40020929      [0x129] =  0x00
4002092a      [0x12a] =  0x00
4002092b      [0x12b] =  0x00
4002092c      [0x12c] =  0x00
4002092d      [0x12d] =  0x00
4002092e      [0x12e] =  0x00
4002092f      [0x12f] =  0x00
40020930      [0x130] =  0x00
40020931      [0x131] =  0x00
40020932      [0x132] =  0x00
40020933      [0x133] =  0x00
40020934      [0x134] =  0x00
40020935      [0x135] =  0x00
40020936      [0x136] =  0x00
40020937      [0x137] =  0x00
40020938      [0x138] =  0x00
40020939      [0x139] =  0x00
4002093a      [0x13a] =  0x00
4002093b      [0x13b] =  0x00
4002093c      [0x13c] =  0x00
4002093d      [0x13d] =  0x00
4002093e      [0x13e] =  0x00
4002093f      [0x13f] =  0x00
40020940      [0x140] =  0x00
40020941      [0x141] =  0x00
40020942      [0x142] =  0x00
40020943      [0x143] =  0x00
40020944      [0x144] =  0x00
40020945      [0x145] =  0x00
40020946      [0x146] =  0x00
40020947      [0x147] =  0x00
40020948      [0x148] =  0x00
40020949      [0x149] =  0x00
4002094a      [0x14a] =  0x00
4002094b      [0x14b] =  0x00
4002094c      [0x14c] =  0x00
4002094d      [0x14d] =  0x00
4002094e      [0x14e] =  0x00
4002094f      [0x14f] =  0x00
40020950      [0x150] =  0x00
40020951      [0x151] =  0x00
40020952      [0x152] =  0x00
40020953      [0x153] =  0x00
40020954      [0x154] =  0x00
40020955      [0x155] =  0x00
40020956      [0x156] =  0x00
40020957      [0x157] =  0x00
40020958      [0x158] =  0x00
40020959      [0x159] =  0x00
4002095a      [0x15a] =  0x00
4002095b      [0x15b] =  0x00
4002095c      [0x15c] =  0x00
4002095d      [0x15d] =  0x00
4002095e      [0x15e] =  0x00
4002095f      [0x15f] =  0x00
40020960      [0x160] =  0x00
40020961      [0x161] =  0x00
40020962      [0x162] =  0x00
40020963      [0x163] =  0x00
40020964      [0x164] =  0x00
40020965      [0x165] =  0x00
40020966      [0x166] =  0x00
40020967      [0x167] =  0x00
40020968      [0x168] =  0x00
40020969      [0x169] =  0x00
4002096a      [0x16a] =  0x00
4002096b      [0x16b] =  0x00
4002096c      [0x16c] =  0x00
4002096d      [0x16d] =  0x00
4002096e      [0x16e] =  0x00
4002096f      [0x16f] =  0x00
40020970      [0x170] =  0x00
40020971      [0x171] =  0x00
40020972      [0x172] =  0x00
40020973      [0x173] =  0x00
40020974      [0x174] =  0x00
40020975      [0x175] =  0x00
40020976      [0x176] =  0x00
40020977      [0x177] =  0x00
40020978      [0x178] =  0x00
40020979      [0x179] =  0x00
4002097a      [0x17a] =  0x00
4002097b      [0x17b] =  0x00
4002097c      [0x17c] =  0x00
4002097d      [0x17d] =  0x00
4002097e      [0x17e] =  0x00
4002097f      [0x17f] =  0x00
40020980      [0x180] =  0x00
40020981      [0x181] =  0x00
40020982      [0x182] =  0x00
40020983      [0x183] =  0x00
40020984      [0x184] =  0x00
40020985      [0x185] =  0x00
40020986      [0x186] =  0x00
40020987      [0x187] =  0x00
40020988      [0x188] =  0x00
40020989      [0x189] =  0x00
4002098a      [0x18a] =  0x00
4002098b      [0x18b] =  0x00
4002098c      [0x18c] =  0x00
4002098d      [0x18d] =  0x00
4002098e      [0x18e] =  0x00
4002098f      [0x18f] =  0x00
40020990      [0x190] =  0x00
40020991      [0x191] =  0x00
40020992      [0x192] =  0x00
40020993      [0x193] =  0x00
40020994      [0x194] =  0x00
40020995      [0x195] =  0x00
40020996      [0x196] =  0x00
40020997      [0x197] =  0x00
40020998      [0x198] =  0x00
40020999      [0x199] =  0x00
4002099a      [0x19a] =  0x00
4002099b      [0x19b] =  0x00
4002099c      [0x19c] =  0x00
4002099d      [0x19d] =  0x00
4002099e      [0x19e] =  0x00
4002099f      [0x19f] =  0x00
400209a0      [0x1a0] =  0x00
400209a1      [0x1a1] =  0x00
400209a2      [0x1a2] =  0x00
400209a3      [0x1a3] =  0x00
400209a4      [0x1a4] =  0x00
400209a5      [0x1a5] =  0x00
400209a6      [0x1a6] =  0x00
400209a7      [0x1a7] =  0x00
400209a8      [0x1a8] =  0x00
400209a9      [0x1a9] =  0x00
400209aa      [0x1aa] =  0x00
400209ab      [0x1ab] =  0x00
400209ac      [0x1ac] =  0x00
400209ad      [0x1ad] =  0x00
400209ae      [0x1ae] =  0x00
400209af      [0x1af] =  0x00
400209b0      [0x1b0] =  0x00
400209b1      [0x1b1] =  0x00
400209b2      [0x1b2] =  0x00
400209b3      [0x1b3] =  0x00
400209b4      [0x1b4] =  0x00
400209b5      [0x1b5] =  0x00
400209b6      [0x1b6] =  0x00
400209b7      [0x1b7] =  0x00
400209b8      [0x1b8] =  0x00
400209b9      [0x1b9] =  0x00
400209ba      [0x1ba] =  0x00
400209bb      [0x1bb] =  0x00
400209bc      [0x1bc] =  0x00
400209bd      [0x1bd] =  0x00
400209be      [0x1be] =  0x00
400209bf      [0x1bf] =  0x00
400209c0      [0x1c0] =  0x00
400209c1      [0x1c1] =  0x00
400209c2      [0x1c2] =  0x00
400209c3      [0x1c3] =  0x00
400209c4      [0x1c4] =  0x00
400209c5      [0x1c5] =  0x00
400209c6      [0x1c6] =  0x00
400209c7      [0x1c7] =  0x00
400209c8      [0x1c8] =  0x00
400209c9      [0x1c9] =  0x00
400209ca      [0x1ca] =  0x00
400209cb      [0x1cb] =  0x00
400209cc      [0x1cc] =  0x00
400209cd      [0x1cd] =  0x00
400209ce      [0x1ce] =  0x00
400209cf      [0x1cf] =  0x00
400209d0      [0x1d0] =  0x00
400209d1      [0x1d1] =  0x00
400209d2      [0x1d2] =  0x00
400209d3      [0x1d3] =  0x00
400209d4      [0x1d4] =  0x00
400209d5      [0x1d5] =  0x00
400209d6      [0x1d6] =  0x00
400209d7      [0x1d7] =  0x00
400209d8      [0x1d8] =  0x00
400209d9      [0x1d9] =  0x00
400209da      [0x1da] =  0x00
400209db      [0x1db] =  0x00
400209dc      [0x1dc] =  0x00
400209dd      [0x1dd] =  0x00
400209de      [0x1de] =  0x00
400209df      [0x1df] =  0x00
400209e0      [0x1e0] =  0x00
400209e1      [0x1e1] =  0x00
400209e2      [0x1e2] =  0x00
400209e3      [0x1e3] =  0x00
400209e4      [0x1e4] =  0x00
400209e5      [0x1e5] =  0x00
400209e6      [0x1e6] =  0x00
400209e7      [0x1e7] =  0x00
400209e8      [0x1e8] =  0x00
400209e9      [0x1e9] =  0x00
400209ea      [0x1ea] =  0x00
400209eb      [0x1eb] =  0x00
400209ec      [0x1ec] =  0x00
400209ed      [0x1ed] =  0x00
400209ee      [0x1ee] =  0x00
400209ef      [0x1ef] =  0x00
400209f0      [0x1f0] =  0x00
400209f1      [0x1f1] =  0x00
400209f2      [0x1f2] =  0x00
400209f3      [0x1f3] =  0x00
400209f4      [0x1f4] =  0x00
400209f5      [0x1f5] =  0x00
400209f6      [0x1f6] =  0x00
400209f7      [0x1f7] =  0x00
400209f8      [0x1f8] =  0x00
400209f9      [0x1f9] =  0x00
400209fa      [0x1fa] =  0x00
400209fb      [0x1fb] =  0x00
400209fc      [0x1fc] =  0x00
400209fd      [0x1fd] =  0x00
400209fe      [0x1fe] =  0x00
400209ff      [0x1ff] =  0x00
40020a00      [0x200] =  0x00
40020a01      [0x201] =  0x00
40020a02      [0x202] =  0x00
40020a03      [0x203] =  0x00
40020a04      [0x204] =  0x00
40020a05      [0x205] =  0x00
40020a06      [0x206] =  0x00
40020a07      [0x207] =  0x00
40020a08      [0x208] =  0x00
40020a09      [0x209] =  0x00
40020a0a      [0x20a] =  0x00
40020a0b      [0x20b] =  0x00
40020a0c      [0x20c] =  0x00
40020a0d      [0x20d] =  0x00
40020a0e      [0x20e] =  0x00
40020a0f      [0x20f] =  0x00
40020a10      [0x210] =  0x00
40020a11      [0x211] =  0x00
40020a12      [0x212] =  0x00
40020a13      [0x213] =  0x00
40020a14      [0x214] =  0x00
40020a15      [0x215] =  0x00
40020a16      [0x216] =  0x00
40020a17      [0x217] =  0x00
40020a18      [0x218] =  0x00
40020a19      [0x219] =  0x00
40020a1a      [0x21a] =  0x00
40020a1b      [0x21b] =  0x00
40020a1c      [0x21c] =  0x00
40020a1d      [0x21d] =  0x00
40020a1e      [0x21e] =  0x00
40020a1f      [0x21f] =  0x00
40020a20      [0x220] =  0x00
40020a21      [0x221] =  0x00
40020a22      [0x222] =  0x00
40020a23      [0x223] =  0x00
40020a24      [0x224] =  0x00
40020a25      [0x225] =  0x00
40020a26      [0x226] =  0x00
40020a27      [0x227] =  0x00
40020a28      [0x228] =  0x00
40020a29      [0x229] =  0x00
40020a2a      [0x22a] =  0x00
40020a2b      [0x22b] =  0x00
40020a2c      [0x22c] =  0x00
40020a2d      [0x22d] =  0x00
40020a2e      [0x22e] =  0x00
40020a2f      [0x22f] =  0x00
40020a30      [0x230] =  0x00
40020a31      [0x231] =  0x00
40020a32      [0x232] =  0x00
40020a33      [0x233] =  0x00
40020a34      [0x234] =  0x00
40020a35      [0x235] =  0x00
40020a36      [0x236] =  0x00
40020a37      [0x237] =  0x00
40020a38      [0x238] =  0x00
40020a39      [0x239] =  0x00
40020a3a      [0x23a] =  0x00
40020a3b      [0x23b] =  0x00
40020a3c      [0x23c] =  0x00
40020a3d      [0x23d] =  0x00
40020a3e      [0x23e] =  0x00
40020a3f      [0x23f] =  0x00
40020a40      [0x240] =  0x00
40020a41      [0x241] =  0x00
40020a42      [0x242] =  0x00
40020a43      [0x243] =  0x00
40020a44      [0x244] =  0x00
40020a45      [0x245] =  0x00
40020a46      [0x246] =  0x00
40020a47      [0x247] =  0x00
40020a48      [0x248] =  0x00
40020a49      [0x249] =  0x00
40020a4a      [0x24a] =  0x00
40020a4b      [0x24b] =  0x00
40020a4c      [0x24c] =  0x00
40020a4d      [0x24d] =  0x00
40020a4e      [0x24e] =  0x00
40020a4f      [0x24f] =  0x00
40020a50      [0x250] =  0x00
40020a51      [0x251] =  0x00
40020a52      [0x252] =  0x00
40020a53      [0x253] =  0x00
40020a54      [0x254] =  0x00
40020a55      [0x255] =  0x00
40020a56      [0x256] =  0x00
40020a57      [0x257] =  0x00
40020a58      [0x258] =  0x00
40020a59      [0x259] =  0x00
40020a5a      [0x25a] =  0x00
40020a5b      [0x25b] =  0x00
40020a5c      [0x25c] =  0x00
40020a5d      [0x25d] =  0x00
40020a5e      [0x25e] =  0x00
40020a5f      [0x25f] =  0x00
40020a60      [0x260] =  0x00
40020a61      [0x261] =  0x00
40020a62      [0x262] =  0x00
40020a63      [0x263] =  0x00
40020a64      [0x264] =  0x00
40020a65      [0x265] =  0x00
40020a66      [0x266] =  0x00
40020a67      [0x267] =  0x00
40020a68      [0x268] =  0x00
40020a69      [0x269] =  0x00
40020a6a      [0x26a] =  0x00
40020a6b      [0x26b] =  0x00
40020a6c      [0x26c] =  0x00
40020a6d      [0x26d] =  0x00
40020a6e      [0x26e] =  0x00
40020a6f      [0x26f] =  0x00
40020a70      [0x270] =  0x00
40020a71      [0x271] =  0x00
40020a72      [0x272] =  0x00
40020a73      [0x273] =  0x00
40020a74      [0x274] =  0x00
40020a75      [0x275] =  0x00
40020a76      [0x276] =  0x00
40020a77      [0x277] =  0x00
40020a78      [0x278] =  0x00
40020a79      [0x279] =  0x00
40020a7a      [0x27a] =  0x00
40020a7b      [0x27b] =  0x00
40020a7c      [0x27c] =  0x00
40020a7d      [0x27d] =  0x00
40020a7e      [0x27e] =  0x00
40020a7f      [0x27f] =  0x00
40020a80      [0x280] =  0x00
40020a81      [0x281] =  0x00
40020a82      [0x282] =  0x00
40020a83      [0x283] =  0x00
40020a84      [0x284] =  0x00
40020a85      [0x285] =  0x00
40020a86      [0x286] =  0x00
40020a87      [0x287] =  0x00
40020a88      [0x288] =  0x00
40020a89      [0x289] =  0x00
40020a8a      [0x28a] =  0x00
40020a8b      [0x28b] =  0x00
40020a8c      [0x28c] =  0x00
40020a8d      [0x28d] =  0x00
40020a8e      [0x28e] =  0x00
40020a8f      [0x28f] =  0x00
40020a90      [0x290] =  0x00
40020a91      [0x291] =  0x00
40020a92      [0x292] =  0x00
40020a93      [0x293] =  0x00
40020a94      [0x294] =  0x00
40020a95      [0x295] =  0x00
40020a96      [0x296] =  0x00
40020a97      [0x297] =  0x00
40020a98      [0x298] =  0x00
40020a99      [0x299] =  0x00
40020a9a      [0x29a] =  0x00
40020a9b      [0x29b] =  0x00
40020a9c      [0x29c] =  0x00
40020a9d      [0x29d] =  0x00
40020a9e      [0x29e] =  0x00
40020a9f      [0x29f] =  0x00
40020aa0      [0x2a0] =  0x00
40020aa1      [0x2a1] =  0x00
40020aa2      [0x2a2] =  0x00
40020aa3      [0x2a3] =  0x00
40020aa4      [0x2a4] =  0x00
40020aa5      [0x2a5] =  0x00
40020aa6      [0x2a6] =  0x00
40020aa7      [0x2a7] =  0x00
40020aa8      [0x2a8] =  0x00
40020aa9      [0x2a9] =  0x00
40020aaa      [0x2aa] =  0x00
40020aab      [0x2ab] =  0x00
40020aac      [0x2ac] =  0x00
40020aad      [0x2ad] =  0x00
40020aae      [0x2ae] =  0x00
40020aaf      [0x2af] =  0x00
40020ab0      [0x2b0] =  0x00
40020ab1      [0x2b1] =  0x00
40020ab2      [0x2b2] =  0x00
40020ab3      [0x2b3] =  0x00
40020ab4      [0x2b4] =  0x00
40020ab5      [0x2b5] =  0x00
40020ab6      [0x2b6] =  0x00
40020ab7      [0x2b7] =  0x00
40020ab8      [0x2b8] =  0x00
40020ab9      [0x2b9] =  0x00
40020aba      [0x2ba] =  0x00
40020abb      [0x2bb] =  0x00
40020abc      [0x2bc] =  0x00
40020abd      [0x2bd] =  0x00
40020abe      [0x2be] =  0x00
40020abf      [0x2bf] =  0x00
40020ac0      [0x2c0] =  0x00
40020ac1      [0x2c1] =  0x00
40020ac2      [0x2c2] =  0x00
40020ac3      [0x2c3] =  0x00
40020ac4      [0x2c4] =  0x00
40020ac5      [0x2c5] =  0x00
40020ac6      [0x2c6] =  0x00
40020ac7      [0x2c7] =  0x00
40020ac8      [0x2c8] =  0x00
40020ac9      [0x2c9] =  0x00
40020aca      [0x2ca] =  0x00
40020acb      [0x2cb] =  0x00
40020acc      [0x2cc] =  0x00
40020acd      [0x2cd] =  0x00
40020ace      [0x2ce] =  0x00
40020acf      [0x2cf] =  0x00
40020ad0      [0x2d0] =  0x00
40020ad1      [0x2d1] =  0x00
40020ad2      [0x2d2] =  0x00
40020ad3      [0x2d3] =  0x00
40020ad4      [0x2d4] =  0x00
40020ad5      [0x2d5] =  0x00
40020ad6      [0x2d6] =  0x00
40020ad7      [0x2d7] =  0x00
40020ad8      [0x2d8] =  0x00
40020ad9      [0x2d9] =  0x00
40020ada      [0x2da] =  0x00
40020adb      [0x2db] =  0x00
40020adc      [0x2dc] =  0x00
40020add      [0x2dd] =  0x00
40020ade      [0x2de] =  0x00
40020adf      [0x2df] =  0x00
40020ae0      [0x2e0] =  0x00
40020ae1      [0x2e1] =  0x00
40020ae2      [0x2e2] =  0x00
40020ae3      [0x2e3] =  0x00
40020ae4      [0x2e4] =  0x00
40020ae5      [0x2e5] =  0x00
40020ae6      [0x2e6] =  0x00
40020ae7      [0x2e7] =  0x00
40020ae8      [0x2e8] =  0x00
40020ae9      [0x2e9] =  0x00
40020aea      [0x2ea] =  0x00
40020aeb      [0x2eb] =  0x00
40020aec      [0x2ec] =  0x00
40020aed      [0x2ed] =  0x00
40020aee      [0x2ee] =  0x00
40020aef      [0x2ef] =  0x00
40020af0      [0x2f0] =  0x00
40020af1      [0x2f1] =  0x00
40020af2      [0x2f2] =  0x00
40020af3      [0x2f3] =  0x00
40020af4      [0x2f4] =  0x00
40020af5      [0x2f5] =  0x00
40020af6      [0x2f6] =  0x00
40020af7      [0x2f7] =  0x00
40020af8      [0x2f8] =  0x00
40020af9      [0x2f9] =  0x00
40020afa      [0x2fa] =  0x00
40020afb      [0x2fb] =  0x00
40020afc      [0x2fc] =  0x00
40020afd      [0x2fd] =  0x00
40020afe      [0x2fe] =  0x00
40020aff      [0x2ff] =  0x00
40020b00      [0x300] =  0x00
40020b01      [0x301] =  0x00
40020b02      [0x302] =  0x00
40020b03      [0x303] =  0x00
40020b04      [0x304] =  0x00
40020b05      [0x305] =  0x00
40020b06      [0x306] =  0x00
40020b07      [0x307] =  0x00
40020b08      [0x308] =  0x00
40020b09      [0x309] =  0x00
40020b0a      [0x30a] =  0x00
40020b0b      [0x30b] =  0x00
40020b0c      [0x30c] =  0x00
40020b0d      [0x30d] =  0x00
40020b0e      [0x30e] =  0x00
40020b0f      [0x30f] =  0x00
40020b10      [0x310] =  0x00
40020b11      [0x311] =  0x00
40020b12      [0x312] =  0x00
40020b13      [0x313] =  0x00
40020b14      [0x314] =  0x00
40020b15      [0x315] =  0x00
40020b16      [0x316] =  0x00
40020b17      [0x317] =  0x00
40020b18      [0x318] =  0x00
40020b19      [0x319] =  0x00
40020b1a      [0x31a] =  0x00
40020b1b      [0x31b] =  0x00
40020b1c      [0x31c] =  0x00
40020b1d      [0x31d] =  0x00
40020b1e      [0x31e] =  0x00
40020b1f      [0x31f] =  0x00
40020b20      [0x320] =  0x00
40020b21      [0x321] =  0x00
40020b22      [0x322] =  0x00
40020b23      [0x323] =  0x00
40020b24      [0x324] =  0x00
40020b25      [0x325] =  0x00
40020b26      [0x326] =  0x00
40020b27      [0x327] =  0x00
40020b28      [0x328] =  0x00
40020b29      [0x329] =  0x00
40020b2a      [0x32a] =  0x00
40020b2b      [0x32b] =  0x00
40020b2c      [0x32c] =  0x00
40020b2d      [0x32d] =  0x00
40020b2e      [0x32e] =  0x00
40020b2f      [0x32f] =  0x00
40020b30      [0x330] =  0x00
40020b31      [0x331] =  0x00
40020b32      [0x332] =  0x00
40020b33      [0x333] =  0x00
40020b34      [0x334] =  0x00
40020b35      [0x335] =  0x00
40020b36      [0x336] =  0x00
40020b37      [0x337] =  0x00
40020b38      [0x338] =  0x00
40020b39      [0x339] =  0x00
40020b3a      [0x33a] =  0x00
40020b3b      [0x33b] =  0x00
40020b3c      [0x33c] =  0x00
40020b3d      [0x33d] =  0x00
40020b3e      [0x33e] =  0x00
40020b3f      [0x33f] =  0x00
40020b40      [0x340] =  0x00
40020b41      [0x341] =  0x00
40020b42      [0x342] =  0x00
40020b43      [0x343] =  0x00
40020b44      [0x344] =  0x00
40020b45      [0x345] =  0x00
40020b46      [0x346] =  0x00
40020b47      [0x347] =  0x00
40020b48      [0x348] =  0x00
40020b49      [0x349] =  0x00
40020b4a      [0x34a] =  0x00
40020b4b      [0x34b] =  0x00
40020b4c      [0x34c] =  0x00
40020b4d      [0x34d] =  0x00
40020b4e      [0x34e] =  0x00
40020b4f      [0x34f] =  0x00
40020b50      [0x350] =  0x00
40020b51      [0x351] =  0x00
40020b52      [0x352] =  0x00
40020b53      [0x353] =  0x00
40020b54      [0x354] =  0x00
40020b55      [0x355] =  0x00
40020b56      [0x356] =  0x00
40020b57      [0x357] =  0x00
40020b58      [0x358] =  0x00
40020b59      [0x359] =  0x00
40020b5a      [0x35a] =  0x00
40020b5b      [0x35b] =  0x00
40020b5c      [0x35c] =  0x00
40020b5d      [0x35d] =  0x00
40020b5e      [0x35e] =  0x00
40020b5f      [0x35f] =  0x00
40020b60      [0x360] =  0x00
40020b61      [0x361] =  0x00
40020b62      [0x362] =  0x00
40020b63      [0x363] =  0x00
40020b64      [0x364] =  0x00
40020b65      [0x365] =  0x00
40020b66      [0x366] =  0x00
40020b67      [0x367] =  0x00
40020b68      [0x368] =  0x00
40020b69      [0x369] =  0x00
40020b6a      [0x36a] =  0x00
40020b6b      [0x36b] =  0x00
40020b6c      [0x36c] =  0x00
40020b6d      [0x36d] =  0x00
40020b6e      [0x36e] =  0x00
40020b6f      [0x36f] =  0x00
40020b70      [0x370] =  0x00
40020b71      [0x371] =  0x00
40020b72      [0x372] =  0x00
40020b73      [0x373] =  0x00
40020b74      [0x374] =  0x00
40020b75      [0x375] =  0x00
40020b76      [0x376] =  0x00
40020b77      [0x377] =  0x00
40020b78      [0x378] =  0x00
40020b79      [0x379] =  0x00
40020b7a      [0x37a] =  0x00
40020b7b      [0x37b] =  0x00
40020b7c      [0x37c] =  0x00
40020b7d      [0x37d] =  0x00
40020b7e      [0x37e] =  0x00
40020b7f      [0x37f] =  0x00
40020b80      [0x380] =  0x00
40020b81      [0x381] =  0x00
40020b82      [0x382] =  0x00
40020b83      [0x383] =  0x00
40020b84      [0x384] =  0x00
40020b85      [0x385] =  0x00
40020b86      [0x386] =  0x00
40020b87      [0x387] =  0x00
40020b88      [0x388] =  0x00
40020b89      [0x389] =  0x00
40020b8a      [0x38a] =  0x00
40020b8b      [0x38b] =  0x00
40020b8c      [0x38c] =  0x00
40020b8d      [0x38d] =  0x00
40020b8e      [0x38e] =  0x00
40020b8f      [0x38f] =  0x00
40020b90      [0x390] =  0x00
40020b91      [0x391] =  0x00
40020b92      [0x392] =  0x00
40020b93      [0x393] =  0x00
40020b94      [0x394] =  0x00
40020b95      [0x395] =  0x00
40020b96      [0x396] =  0x00
40020b97      [0x397] =  0x00
40020b98      [0x398] =  0x00
40020b99      [0x399] =  0x00
40020b9a      [0x39a] =  0x00
40020b9b      [0x39b] =  0x00
40020b9c      [0x39c] =  0x00
40020b9d      [0x39d] =  0x00
40020b9e      [0x39e] =  0x00
40020b9f      [0x39f] =  0x00
40020ba0      [0x3a0] =  0x00
40020ba1      [0x3a1] =  0x00
40020ba2      [0x3a2] =  0x00
40020ba3      [0x3a3] =  0x00
40020ba4      [0x3a4] =  0x00
40020ba5      [0x3a5] =  0x00
40020ba6      [0x3a6] =  0x00
40020ba7      [0x3a7] =  0x00
40020ba8      [0x3a8] =  0x00
40020ba9      [0x3a9] =  0x00
40020baa      [0x3aa] =  0x00
40020bab      [0x3ab] =  0x00
40020bac      [0x3ac] =  0x00
40020bad      [0x3ad] =  0x00
40020bae      [0x3ae] =  0x00
40020baf      [0x3af] =  0x00
40020bb0      [0x3b0] =  0x00
40020bb1      [0x3b1] =  0x00
40020bb2      [0x3b2] =  0x00
40020bb3      [0x3b3] =  0x00
40020bb4      [0x3b4] =  0x00
40020bb5      [0x3b5] =  0x00
40020bb6      [0x3b6] =  0x00
40020bb7      [0x3b7] =  0x00
40020bb8      [0x3b8] =  0x00
40020bb9      [0x3b9] =  0x00
40020bba      [0x3ba] =  0x00
40020bbb      [0x3bb] =  0x00
40020bbc      [0x3bc] =  0x00
40020bbd      [0x3bd] =  0x00
40020bbe      [0x3be] =  0x00
40020bbf      [0x3bf] =  0x00
40020bc0      [0x3c0] =  0x00
40020bc1      [0x3c1] =  0x00
40020bc2      [0x3c2] =  0x00
40020bc3      [0x3c3] =  0x00
40020bc4      [0x3c4] =  0x00
40020bc5      [0x3c5] =  0x00
40020bc6      [0x3c6] =  0x00
40020bc7      [0x3c7] =  0x00
40020bc8      [0x3c8] =  0x00
40020bc9      [0x3c9] =  0x00
40020bca      [0x3ca] =  0x00
40020bcb      [0x3cb] =  0x00
40020bcc      [0x3cc] =  0x00
40020bcd      [0x3cd] =  0x00
40020bce      [0x3ce] =  0x00
40020bcf      [0x3cf] =  0x00
40020bd0      [0x3d0] =  0x00
40020bd1      [0x3d1] =  0x00
40020bd2      [0x3d2] =  0x00
40020bd3      [0x3d3] =  0x00
40020bd4      [0x3d4] =  0x00
40020bd5      [0x3d5] =  0x00
40020bd6      [0x3d6] =  0x00
40020bd7      [0x3d7] =  0x00
40020bd8      [0x3d8] =  0x00
40020bd9      [0x3d9] =  0x00
40020bda      [0x3da] =  0x00
40020bdb      [0x3db] =  0x00
40020bdc      [0x3dc] =  0x00
40020bdd      [0x3dd] =  0x00
40020bde      [0x3de] =  0x00
40020bdf      [0x3df] =  0x00
40020be0      [0x3e0] =  0x00
40020be1      [0x3e1] =  0x00
40020be2      [0x3e2] =  0x00
40020be3      [0x3e3] =  0x00
40020be4      [0x3e4] =  0x00
40020be5      [0x3e5] =  0x00
40020be6      [0x3e6] =  0x00
40020be7      [0x3e7] =  0x00
40020be8      [0x3e8] =  0x00
40020be9      [0x3e9] =  0x00
40020bea      [0x3ea] =  0x00
40020beb      [0x3eb] =  0x00
40020bec      [0x3ec] =  0x00
40020bed      [0x3ed] =  0x00
40020bee      [0x3ee] =  0x00
40020bef      [0x3ef] =  0x00
40020bf0      [0x3f0] =  0x00
40020bf1      [0x3f1] =  0x00
40020bf2      [0x3f2] =  0x00
40020bf3      [0x3f3] =  0x00
40020bf4      [0x3f4] =  0x00
40020bf5      [0x3f5] =  0x00
40020bf6      [0x3f6] =  0x00
40020bf7      [0x3f7] =  0x00
40020bf8      [0x3f8] =  0x00
40020bf9      [0x3f9] =  0x00
40020bfa      [0x3fa] =  0x00
40020bfb      [0x3fb] =  0x00
40020bfc      [0x3fc] =  0x00
40020bfd      [0x3fd] =  0x00
40020bfe      [0x3fe] =  0x00
40020bff      [0x3ff] =  0x00
40020c00  }
40023800  RCC_TypeDef RCC = 
40023800  {
40023800      vu32 volatile CR = 0x0
40023804      vu32 volatile PLLCFGR = 0x0
40023808      vu32 volatile CFGR = 0x0
4002380c      vu32 volatile CIR = 0x0
40023810      vu32 volatile AHB1RSTR = 0x0
40023814      vu32 volatile AHB2RSTR = 0x0
40023818      vu32 volatile AHB3RSTR = 0x0
4002381c      vu32 volatile RESERVED0 = 0x0
40023820      vu32 volatile APB1RSTR = 0x0
40023824      vu32 volatile APB2RSTR = 0x0
40023828      vu32 volatile RESERVED1 = 0x0
4002382c      vu32 volatile RESERVED2 = 0x0
40023830      vu32 volatile AHB1ENR = 0x0
40023834      vu32 volatile AHB2ENR = 0x0
40023838      vu32 volatile AHB3ENR = 0x0
4002383c      vu32 volatile RESERVED3 = 0x0
40023840      vu32 volatile APB1ENR = 0x0
40023844      vu32 volatile APB2ENR = 0x0
40023848      vu32 volatile RESERVED4 = 0x0
4002384c      vu32 volatile RESERVED5 = 0x0
40023850      vu32 volatile AHB1LPENR = 0x0
40023854      vu32 volatile AHB2LPENR = 0x0
40023858      vu32 volatile AHB3LPENR = 0x0
4002385c      vu32 volatile RESERVED6 = 0x0
40023860      vu32 volatile BDCR = 0x0
40023864      vu32 volatile CSR = 0x0
40023868  }
40023868                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
40023880  00 00 00 00 00 00 00 00 00 00 00 00                                                              ............
4002388c  int32_t data_4002388c = 0x0
40023890                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
400238c0  int32_t data_400238c0 = 0x0
400238c4              00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00      ............................
